import java.lang
import java.util
import java.util.concurrent
import scala
import scala.collection.concurrent
import scala.collection.convert
import scala.collection.generic
import scala.collection.immutable
import scala.collection.mutable
import scala.collection.parallel
import scala.collection.script
import scala.math
import scala.reflect
import scala.runtime
import typing



class DebugUtils:
    _arrayString__T = typing.TypeVar('_arrayString__T')  # <T>
    @staticmethod
    def arrayString(array: typing.Any, from_: int, until: int) -> str: ...
    @staticmethod
    def buildString(closure: scala.Function1[scala.Function1[typing.Any, scala.runtime.BoxedUnit], scala.runtime.BoxedUnit]) -> str: ...
    @staticmethod
    def illegalArgument(msg: str) -> scala.runtime.Nothing.: ...
    @staticmethod
    def indexOutOfBounds(index: int) -> scala.runtime.Nothing.: ...
    @staticmethod
    def noSuchElement(msg: str) -> scala.runtime.Nothing.: ...
    @staticmethod
    def unsupported(msg: str) -> scala.runtime.Nothing.: ...

_GenTraversableOnce__A = typing.TypeVar('_GenTraversableOnce__A')  # <A>
class GenTraversableOnce(typing.Generic[_GenTraversableOnce__A]):
    _$colon$bslash__B = typing.TypeVar('_$colon$bslash__B')  # <B>
    def $colon$bslash(self, z: _.colon.bslash__B, op: scala.Function2[_GenTraversableOnce__A, _.colon.bslash__B, _.colon.bslash__B]) -> _.colon.bslash__B: ...
    _$div$colon__B = typing.TypeVar('_$div$colon__B')  # <B>
    def $div$colon(self, z: _.div.colon__B, op: scala.Function2[_.div.colon__B, _GenTraversableOnce__A, _.div.colon__B]) -> _.div.colon__B: ...
    @staticmethod
    def $init$($this: 'GenTraversableOnce') -> None: ...
    _aggregate__B = typing.TypeVar('_aggregate__B')  # <B>
    def aggregate(self, z: scala.Function0[_aggregate__B], seqop: scala.Function2[_aggregate__B, _GenTraversableOnce__A, _aggregate__B], combop: scala.Function2[_aggregate__B, _aggregate__B, _aggregate__B]) -> _aggregate__B: ...
    _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
    _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
    _copyToArray_2__B = typing.TypeVar('_copyToArray_2__B')  # <B>
    @typing.overload
    def copyToArray(self, xs: typing.Any) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
    def count(self, p: scala.Function1[_GenTraversableOnce__A, typing.Any]) -> int: ...
    def exists(self, p: scala.Function1[_GenTraversableOnce__A, typing.Any]) -> bool: ...
    def find(self, p: scala.Function1[_GenTraversableOnce__A, typing.Any]) -> scala.Option[_GenTraversableOnce__A]: ...
    _fold__A1 = typing.TypeVar('_fold__A1')  # <A1>
    def fold(self, z: _fold__A1, op: scala.Function2[_fold__A1, _fold__A1, _fold__A1]) -> _fold__A1: ...
    _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
    def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, _GenTraversableOnce__A, _foldLeft__B]) -> _foldLeft__B: ...
    _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
    def foldRight(self, z: _foldRight__B, op: scala.Function2[_GenTraversableOnce__A, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
    def forall(self, p: scala.Function1[_GenTraversableOnce__A, typing.Any]) -> bool: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_GenTraversableOnce__A, _foreach__U]) -> None: ...
    def hasDefiniteSize(self) -> bool: ...
    def isEmpty(self) -> bool: ...
    def isTraversableAgain(self) -> bool: ...
    _max__A1 = typing.TypeVar('_max__A1')  # <A1>
    def max(self, ord: scala.math.Ordering[_max__A1]) -> _GenTraversableOnce__A: ...
    _maxBy__B = typing.TypeVar('_maxBy__B')  # <B>
    def maxBy(self, f: scala.Function1[_GenTraversableOnce__A, _maxBy__B], cmp: scala.math.Ordering[_maxBy__B]) -> _GenTraversableOnce__A: ...
    _min__A1 = typing.TypeVar('_min__A1')  # <A1>
    def min(self, ord: scala.math.Ordering[_min__A1]) -> _GenTraversableOnce__A: ...
    _minBy__B = typing.TypeVar('_minBy__B')  # <B>
    def minBy(self, f: scala.Function1[_GenTraversableOnce__A, _minBy__B], cmp: scala.math.Ordering[_minBy__B]) -> _GenTraversableOnce__A: ...
    @typing.overload
    def mkString(self) -> str: ...
    @typing.overload
    def mkString(self, sep: str) -> str: ...
    @typing.overload
    def mkString(self, start: str, sep: str, end: str) -> str: ...
    def nonEmpty(self) -> bool: ...
    _product__A1 = typing.TypeVar('_product__A1')  # <A1>
    def product(self, num: scala.math.Numeric[_product__A1]) -> _product__A1: ...
    _reduce__A1 = typing.TypeVar('_reduce__A1')  # <A1>
    def reduce(self, op: scala.Function2[_reduce__A1, _reduce__A1, _reduce__A1]) -> _reduce__A1: ...
    _reduceLeftOption__B = typing.TypeVar('_reduceLeftOption__B')  # <B>
    def reduceLeftOption(self, op: scala.Function2[_reduceLeftOption__B, _GenTraversableOnce__A, _reduceLeftOption__B]) -> scala.Option[_reduceLeftOption__B]: ...
    _reduceOption__A1 = typing.TypeVar('_reduceOption__A1')  # <A1>
    def reduceOption(self, op: scala.Function2[_reduceOption__A1, _reduceOption__A1, _reduceOption__A1]) -> scala.Option[_reduceOption__A1]: ...
    _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
    def reduceRight(self, op: scala.Function2[_GenTraversableOnce__A, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
    _reduceRightOption__B = typing.TypeVar('_reduceRightOption__B')  # <B>
    def reduceRightOption(self, op: scala.Function2[_GenTraversableOnce__A, _reduceRightOption__B, _reduceRightOption__B]) -> scala.Option[_reduceRightOption__B]: ...
    def seq(self) -> 'TraversableOnce'[_GenTraversableOnce__A]: ...
    def size(self) -> int: ...
    def sizeHintIfCheap(self) -> int: ...
    _sum__A1 = typing.TypeVar('_sum__A1')  # <A1>
    def sum(self, num: scala.math.Numeric[_sum__A1]) -> _sum__A1: ...
    _to__Col = typing.TypeVar('_to__Col')  # <Col>
    def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., _GenTraversableOnce__A, _to__Col]) -> _to__Col: ...
    _toArray__A1 = typing.TypeVar('_toArray__A1')  # <A1>
    def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__A1]) -> typing.Any: ...
    _toBuffer__A1 = typing.TypeVar('_toBuffer__A1')  # <A1>
    def toBuffer(self) -> scala.collection.mutable.Buffer[_toBuffer__A1]: ...
    def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq[_GenTraversableOnce__A]: ...
    def toIterable(self) -> 'GenIterable'[_GenTraversableOnce__A]: ...
    def toIterator(self) -> 'Iterator'[_GenTraversableOnce__A]: ...
    def toList(self) -> scala.collection.immutable.List[_GenTraversableOnce__A]: ...
    _toMap__K = typing.TypeVar('_toMap__K')  # <K>
    _toMap__V = typing.TypeVar('_toMap__V')  # <V>
    def toMap(self, ev: scala.Predef..less.colon.less[_GenTraversableOnce__A, scala.Tuple2[_toMap__K, _toMap__V]]) -> 'GenMap'[_toMap__K, _toMap__V]: ...
    def toSeq(self) -> 'GenSeq'[_GenTraversableOnce__A]: ...
    _toSet__A1 = typing.TypeVar('_toSet__A1')  # <A1>
    def toSet(self) -> 'GenSet'[_toSet__A1]: ...
    def toStream(self) -> scala.collection.immutable.Stream[_GenTraversableOnce__A]: ...
    def toTraversable(self) -> 'GenTraversable'[_GenTraversableOnce__A]: ...
    def toVector(self) -> scala.collection.immutable.Vector[_GenTraversableOnce__A]: ...

class JavaConversions:
    _asJavaCollection__A = typing.TypeVar('_asJavaCollection__A')  # <A>
    @staticmethod
    def asJavaCollection(it: 'Iterable'[_asJavaCollection__A]) -> java.util.Collection[_asJavaCollection__A]: ...
    _asJavaDictionary__A = typing.TypeVar('_asJavaDictionary__A')  # <A>
    _asJavaDictionary__B = typing.TypeVar('_asJavaDictionary__B')  # <B>
    @staticmethod
    def asJavaDictionary(m: scala.collection.mutable.Map[_asJavaDictionary__A, _asJavaDictionary__B]) -> java.util.Dictionary[_asJavaDictionary__A, _asJavaDictionary__B]: ...
    _asJavaEnumeration__A = typing.TypeVar('_asJavaEnumeration__A')  # <A>
    @staticmethod
    def asJavaEnumeration(it: 'Iterator'[_asJavaEnumeration__A]) -> java.util.Enumeration[_asJavaEnumeration__A]: ...
    _asJavaIterable__A = typing.TypeVar('_asJavaIterable__A')  # <A>
    @staticmethod
    def asJavaIterable(i: 'Iterable'[_asJavaIterable__A]) -> java.lang.Iterable[_asJavaIterable__A]: ...
    _asJavaIterator__A = typing.TypeVar('_asJavaIterator__A')  # <A>
    @staticmethod
    def asJavaIterator(it: 'Iterator'[_asJavaIterator__A]) -> java.util.Iterator[_asJavaIterator__A]: ...
    _asScalaBuffer__A = typing.TypeVar('_asScalaBuffer__A')  # <A>
    @staticmethod
    def asScalaBuffer(l: java.util.List[_asScalaBuffer__A]) -> scala.collection.mutable.Buffer[_asScalaBuffer__A]: ...
    _asScalaIterator__A = typing.TypeVar('_asScalaIterator__A')  # <A>
    @staticmethod
    def asScalaIterator(it: java.util.Iterator[_asScalaIterator__A]) -> 'Iterator'[_asScalaIterator__A]: ...
    _asScalaSet__A = typing.TypeVar('_asScalaSet__A')  # <A>
    @staticmethod
    def asScalaSet(s: java.util.Set[_asScalaSet__A]) -> scala.collection.mutable.Set[_asScalaSet__A]: ...
    _bufferAsJavaList__A = typing.TypeVar('_bufferAsJavaList__A')  # <A>
    @staticmethod
    def bufferAsJavaList(b: scala.collection.mutable.Buffer[_bufferAsJavaList__A]) -> java.util.List[_bufferAsJavaList__A]: ...
    _collectionAsScalaIterable__A = typing.TypeVar('_collectionAsScalaIterable__A')  # <A>
    @staticmethod
    def collectionAsScalaIterable(i: typing.Union[java.util.Collection[_collectionAsScalaIterable__A], typing.Sequence[_collectionAsScalaIterable__A], typing.Set[_collectionAsScalaIterable__A]]) -> 'Iterable'[_collectionAsScalaIterable__A]: ...
    _deprecated$u0020asJavaCollection__A = typing.TypeVar('_deprecated$u0020asJavaCollection__A')  # <A>
    @staticmethod
    def deprecated$u0020asJavaCollection(it: 'Iterable'[_deprecated.u0020asJavaCollection__A]) -> java.util.Collection[_deprecated.u0020asJavaCollection__A]: ...
    _deprecated$u0020asJavaDictionary__A = typing.TypeVar('_deprecated$u0020asJavaDictionary__A')  # <A>
    _deprecated$u0020asJavaDictionary__B = typing.TypeVar('_deprecated$u0020asJavaDictionary__B')  # <B>
    @staticmethod
    def deprecated$u0020asJavaDictionary(m: scala.collection.mutable.Map[_deprecated.u0020asJavaDictionary__A, _deprecated.u0020asJavaDictionary__B]) -> java.util.Dictionary[_deprecated.u0020asJavaDictionary__A, _deprecated.u0020asJavaDictionary__B]: ...
    _deprecated$u0020asJavaEnumeration__A = typing.TypeVar('_deprecated$u0020asJavaEnumeration__A')  # <A>
    @staticmethod
    def deprecated$u0020asJavaEnumeration(it: 'Iterator'[_deprecated.u0020asJavaEnumeration__A]) -> java.util.Enumeration[_deprecated.u0020asJavaEnumeration__A]: ...
    _deprecated$u0020asJavaIterable__A = typing.TypeVar('_deprecated$u0020asJavaIterable__A')  # <A>
    @staticmethod
    def deprecated$u0020asJavaIterable(i: 'Iterable'[_deprecated.u0020asJavaIterable__A]) -> java.lang.Iterable[_deprecated.u0020asJavaIterable__A]: ...
    _deprecated$u0020asJavaIterator__A = typing.TypeVar('_deprecated$u0020asJavaIterator__A')  # <A>
    @staticmethod
    def deprecated$u0020asJavaIterator(it: 'Iterator'[_deprecated.u0020asJavaIterator__A]) -> java.util.Iterator[_deprecated.u0020asJavaIterator__A]: ...
    _deprecated$u0020asScalaBuffer__A = typing.TypeVar('_deprecated$u0020asScalaBuffer__A')  # <A>
    @staticmethod
    def deprecated$u0020asScalaBuffer(l: java.util.List[_deprecated.u0020asScalaBuffer__A]) -> scala.collection.mutable.Buffer[_deprecated.u0020asScalaBuffer__A]: ...
    _deprecated$u0020asScalaIterator__A = typing.TypeVar('_deprecated$u0020asScalaIterator__A')  # <A>
    @staticmethod
    def deprecated$u0020asScalaIterator(it: java.util.Iterator[_deprecated.u0020asScalaIterator__A]) -> 'Iterator'[_deprecated.u0020asScalaIterator__A]: ...
    _deprecated$u0020asScalaSet__A = typing.TypeVar('_deprecated$u0020asScalaSet__A')  # <A>
    @staticmethod
    def deprecated$u0020asScalaSet(s: java.util.Set[_deprecated.u0020asScalaSet__A]) -> scala.collection.mutable.Set[_deprecated.u0020asScalaSet__A]: ...
    _deprecated$u0020bufferAsJavaList__A = typing.TypeVar('_deprecated$u0020bufferAsJavaList__A')  # <A>
    @staticmethod
    def deprecated$u0020bufferAsJavaList(b: scala.collection.mutable.Buffer[_deprecated.u0020bufferAsJavaList__A]) -> java.util.List[_deprecated.u0020bufferAsJavaList__A]: ...
    _deprecated$u0020collectionAsScalaIterable__A = typing.TypeVar('_deprecated$u0020collectionAsScalaIterable__A')  # <A>
    @staticmethod
    def deprecated$u0020collectionAsScalaIterable(i: typing.Union[java.util.Collection[_deprecated.u0020collectionAsScalaIterable__A], typing.Sequence[_deprecated.u0020collectionAsScalaIterable__A], typing.Set[_deprecated.u0020collectionAsScalaIterable__A]]) -> 'Iterable'[_deprecated.u0020collectionAsScalaIterable__A]: ...
    _deprecated$u0020dictionaryAsScalaMap__A = typing.TypeVar('_deprecated$u0020dictionaryAsScalaMap__A')  # <A>
    _deprecated$u0020dictionaryAsScalaMap__B = typing.TypeVar('_deprecated$u0020dictionaryAsScalaMap__B')  # <B>
    @staticmethod
    def deprecated$u0020dictionaryAsScalaMap(p: java.util.Dictionary[_deprecated.u0020dictionaryAsScalaMap__A, _deprecated.u0020dictionaryAsScalaMap__B]) -> scala.collection.mutable.Map[_deprecated.u0020dictionaryAsScalaMap__A, _deprecated.u0020dictionaryAsScalaMap__B]: ...
    _deprecated$u0020enumerationAsScalaIterator__A = typing.TypeVar('_deprecated$u0020enumerationAsScalaIterator__A')  # <A>
    @staticmethod
    def deprecated$u0020enumerationAsScalaIterator(i: java.util.Enumeration[_deprecated.u0020enumerationAsScalaIterator__A]) -> 'Iterator'[_deprecated.u0020enumerationAsScalaIterator__A]: ...
    _deprecated$u0020iterableAsScalaIterable__A = typing.TypeVar('_deprecated$u0020iterableAsScalaIterable__A')  # <A>
    @staticmethod
    def deprecated$u0020iterableAsScalaIterable(i: typing.Union[java.lang.Iterable[_deprecated.u0020iterableAsScalaIterable__A], typing.Sequence[_deprecated.u0020iterableAsScalaIterable__A], typing.Set[_deprecated.u0020iterableAsScalaIterable__A]]) -> 'Iterable'[_deprecated.u0020iterableAsScalaIterable__A]: ...
    _deprecated$u0020mapAsJavaConcurrentMap__A = typing.TypeVar('_deprecated$u0020mapAsJavaConcurrentMap__A')  # <A>
    _deprecated$u0020mapAsJavaConcurrentMap__B = typing.TypeVar('_deprecated$u0020mapAsJavaConcurrentMap__B')  # <B>
    @staticmethod
    def deprecated$u0020mapAsJavaConcurrentMap(m: scala.collection.concurrent.Map[_deprecated.u0020mapAsJavaConcurrentMap__A, _deprecated.u0020mapAsJavaConcurrentMap__B]) -> java.util.concurrent.ConcurrentMap[_deprecated.u0020mapAsJavaConcurrentMap__A, _deprecated.u0020mapAsJavaConcurrentMap__B]: ...
    _deprecated$u0020mapAsJavaMap__A = typing.TypeVar('_deprecated$u0020mapAsJavaMap__A')  # <A>
    _deprecated$u0020mapAsJavaMap__B = typing.TypeVar('_deprecated$u0020mapAsJavaMap__B')  # <B>
    @staticmethod
    def deprecated$u0020mapAsJavaMap(m: 'Map'[_deprecated.u0020mapAsJavaMap__A, _deprecated.u0020mapAsJavaMap__B]) -> java.util.Map[_deprecated.u0020mapAsJavaMap__A, _deprecated.u0020mapAsJavaMap__B]: ...
    _deprecated$u0020mapAsScalaConcurrentMap__A = typing.TypeVar('_deprecated$u0020mapAsScalaConcurrentMap__A')  # <A>
    _deprecated$u0020mapAsScalaConcurrentMap__B = typing.TypeVar('_deprecated$u0020mapAsScalaConcurrentMap__B')  # <B>
    @staticmethod
    def deprecated$u0020mapAsScalaConcurrentMap(m: java.util.concurrent.ConcurrentMap[_deprecated.u0020mapAsScalaConcurrentMap__A, _deprecated.u0020mapAsScalaConcurrentMap__B]) -> scala.collection.concurrent.Map[_deprecated.u0020mapAsScalaConcurrentMap__A, _deprecated.u0020mapAsScalaConcurrentMap__B]: ...
    _deprecated$u0020mapAsScalaMap__A = typing.TypeVar('_deprecated$u0020mapAsScalaMap__A')  # <A>
    _deprecated$u0020mapAsScalaMap__B = typing.TypeVar('_deprecated$u0020mapAsScalaMap__B')  # <B>
    @staticmethod
    def deprecated$u0020mapAsScalaMap(m: typing.Union[java.util.Map[_deprecated.u0020mapAsScalaMap__A, _deprecated.u0020mapAsScalaMap__B], typing.Mapping[_deprecated.u0020mapAsScalaMap__A, _deprecated.u0020mapAsScalaMap__B]]) -> scala.collection.mutable.Map[_deprecated.u0020mapAsScalaMap__A, _deprecated.u0020mapAsScalaMap__B]: ...
    _deprecated$u0020mutableMapAsJavaMap__A = typing.TypeVar('_deprecated$u0020mutableMapAsJavaMap__A')  # <A>
    _deprecated$u0020mutableMapAsJavaMap__B = typing.TypeVar('_deprecated$u0020mutableMapAsJavaMap__B')  # <B>
    @staticmethod
    def deprecated$u0020mutableMapAsJavaMap(m: scala.collection.mutable.Map[_deprecated.u0020mutableMapAsJavaMap__A, _deprecated.u0020mutableMapAsJavaMap__B]) -> java.util.Map[_deprecated.u0020mutableMapAsJavaMap__A, _deprecated.u0020mutableMapAsJavaMap__B]: ...
    _deprecated$u0020mutableSeqAsJavaList__A = typing.TypeVar('_deprecated$u0020mutableSeqAsJavaList__A')  # <A>
    @staticmethod
    def deprecated$u0020mutableSeqAsJavaList(seq: scala.collection.mutable.Seq[_deprecated.u0020mutableSeqAsJavaList__A]) -> java.util.List[_deprecated.u0020mutableSeqAsJavaList__A]: ...
    _deprecated$u0020mutableSetAsJavaSet__A = typing.TypeVar('_deprecated$u0020mutableSetAsJavaSet__A')  # <A>
    @staticmethod
    def deprecated$u0020mutableSetAsJavaSet(s: scala.collection.mutable.Set[_deprecated.u0020mutableSetAsJavaSet__A]) -> java.util.Set[_deprecated.u0020mutableSetAsJavaSet__A]: ...
    @staticmethod
    def deprecated$u0020propertiesAsScalaMap(p: java.util.Properties) -> scala.collection.mutable.Map[str, str]: ...
    _deprecated$u0020seqAsJavaList__A = typing.TypeVar('_deprecated$u0020seqAsJavaList__A')  # <A>
    @staticmethod
    def deprecated$u0020seqAsJavaList(seq: 'Seq'[_deprecated.u0020seqAsJavaList__A]) -> java.util.List[_deprecated.u0020seqAsJavaList__A]: ...
    _deprecated$u0020setAsJavaSet__A = typing.TypeVar('_deprecated$u0020setAsJavaSet__A')  # <A>
    @staticmethod
    def deprecated$u0020setAsJavaSet(s: 'Set'[_deprecated.u0020setAsJavaSet__A]) -> java.util.Set[_deprecated.u0020setAsJavaSet__A]: ...
    _dictionaryAsScalaMap__A = typing.TypeVar('_dictionaryAsScalaMap__A')  # <A>
    _dictionaryAsScalaMap__B = typing.TypeVar('_dictionaryAsScalaMap__B')  # <B>
    @staticmethod
    def dictionaryAsScalaMap(p: java.util.Dictionary[_dictionaryAsScalaMap__A, _dictionaryAsScalaMap__B]) -> scala.collection.mutable.Map[_dictionaryAsScalaMap__A, _dictionaryAsScalaMap__B]: ...
    _enumerationAsScalaIterator__A = typing.TypeVar('_enumerationAsScalaIterator__A')  # <A>
    @staticmethod
    def enumerationAsScalaIterator(i: java.util.Enumeration[_enumerationAsScalaIterator__A]) -> 'Iterator'[_enumerationAsScalaIterator__A]: ...
    _iterableAsScalaIterable__A = typing.TypeVar('_iterableAsScalaIterable__A')  # <A>
    @staticmethod
    def iterableAsScalaIterable(i: typing.Union[java.lang.Iterable[_iterableAsScalaIterable__A], typing.Sequence[_iterableAsScalaIterable__A], typing.Set[_iterableAsScalaIterable__A]]) -> 'Iterable'[_iterableAsScalaIterable__A]: ...
    _mapAsJavaConcurrentMap__A = typing.TypeVar('_mapAsJavaConcurrentMap__A')  # <A>
    _mapAsJavaConcurrentMap__B = typing.TypeVar('_mapAsJavaConcurrentMap__B')  # <B>
    @staticmethod
    def mapAsJavaConcurrentMap(m: scala.collection.concurrent.Map[_mapAsJavaConcurrentMap__A, _mapAsJavaConcurrentMap__B]) -> java.util.concurrent.ConcurrentMap[_mapAsJavaConcurrentMap__A, _mapAsJavaConcurrentMap__B]: ...
    _mapAsJavaMap__A = typing.TypeVar('_mapAsJavaMap__A')  # <A>
    _mapAsJavaMap__B = typing.TypeVar('_mapAsJavaMap__B')  # <B>
    @staticmethod
    def mapAsJavaMap(m: 'Map'[_mapAsJavaMap__A, _mapAsJavaMap__B]) -> java.util.Map[_mapAsJavaMap__A, _mapAsJavaMap__B]: ...
    _mapAsScalaConcurrentMap__A = typing.TypeVar('_mapAsScalaConcurrentMap__A')  # <A>
    _mapAsScalaConcurrentMap__B = typing.TypeVar('_mapAsScalaConcurrentMap__B')  # <B>
    @staticmethod
    def mapAsScalaConcurrentMap(m: java.util.concurrent.ConcurrentMap[_mapAsScalaConcurrentMap__A, _mapAsScalaConcurrentMap__B]) -> scala.collection.concurrent.Map[_mapAsScalaConcurrentMap__A, _mapAsScalaConcurrentMap__B]: ...
    _mapAsScalaMap__A = typing.TypeVar('_mapAsScalaMap__A')  # <A>
    _mapAsScalaMap__B = typing.TypeVar('_mapAsScalaMap__B')  # <B>
    @staticmethod
    def mapAsScalaMap(m: typing.Union[java.util.Map[_mapAsScalaMap__A, _mapAsScalaMap__B], typing.Mapping[_mapAsScalaMap__A, _mapAsScalaMap__B]]) -> scala.collection.mutable.Map[_mapAsScalaMap__A, _mapAsScalaMap__B]: ...
    _mutableMapAsJavaMap__A = typing.TypeVar('_mutableMapAsJavaMap__A')  # <A>
    _mutableMapAsJavaMap__B = typing.TypeVar('_mutableMapAsJavaMap__B')  # <B>
    @staticmethod
    def mutableMapAsJavaMap(m: scala.collection.mutable.Map[_mutableMapAsJavaMap__A, _mutableMapAsJavaMap__B]) -> java.util.Map[_mutableMapAsJavaMap__A, _mutableMapAsJavaMap__B]: ...
    _mutableSeqAsJavaList__A = typing.TypeVar('_mutableSeqAsJavaList__A')  # <A>
    @staticmethod
    def mutableSeqAsJavaList(seq: scala.collection.mutable.Seq[_mutableSeqAsJavaList__A]) -> java.util.List[_mutableSeqAsJavaList__A]: ...
    _mutableSetAsJavaSet__A = typing.TypeVar('_mutableSetAsJavaSet__A')  # <A>
    @staticmethod
    def mutableSetAsJavaSet(s: scala.collection.mutable.Set[_mutableSetAsJavaSet__A]) -> java.util.Set[_mutableSetAsJavaSet__A]: ...
    @staticmethod
    def propertiesAsScalaMap(p: java.util.Properties) -> scala.collection.mutable.Map[str, str]: ...
    _seqAsJavaList__A = typing.TypeVar('_seqAsJavaList__A')  # <A>
    @staticmethod
    def seqAsJavaList(seq: 'Seq'[_seqAsJavaList__A]) -> java.util.List[_seqAsJavaList__A]: ...
    _setAsJavaSet__A = typing.TypeVar('_setAsJavaSet__A')  # <A>
    @staticmethod
    def setAsJavaSet(s: 'Set'[_setAsJavaSet__A]) -> java.util.Set[_setAsJavaSet__A]: ...

class JavaConverters:
    _asJavaCollection__A = typing.TypeVar('_asJavaCollection__A')  # <A>
    @staticmethod
    def asJavaCollection(i: 'Iterable'[_asJavaCollection__A]) -> java.util.Collection[_asJavaCollection__A]: ...
    _asJavaCollectionConverter__A = typing.TypeVar('_asJavaCollectionConverter__A')  # <A>
    @staticmethod
    def asJavaCollectionConverter(i: 'Iterable'[_asJavaCollectionConverter__A]) -> scala.collection.convert.Decorators.AsJavaCollection[_asJavaCollectionConverter__A]: ...
    _asJavaDictionary__A = typing.TypeVar('_asJavaDictionary__A')  # <A>
    _asJavaDictionary__B = typing.TypeVar('_asJavaDictionary__B')  # <B>
    @staticmethod
    def asJavaDictionary(m: scala.collection.mutable.Map[_asJavaDictionary__A, _asJavaDictionary__B]) -> java.util.Dictionary[_asJavaDictionary__A, _asJavaDictionary__B]: ...
    _asJavaDictionaryConverter__A = typing.TypeVar('_asJavaDictionaryConverter__A')  # <A>
    _asJavaDictionaryConverter__B = typing.TypeVar('_asJavaDictionaryConverter__B')  # <B>
    @staticmethod
    def asJavaDictionaryConverter(m: scala.collection.mutable.Map[_asJavaDictionaryConverter__A, _asJavaDictionaryConverter__B]) -> scala.collection.convert.Decorators.AsJavaDictionary[_asJavaDictionaryConverter__A, _asJavaDictionaryConverter__B]: ...
    _asJavaEnumeration__A = typing.TypeVar('_asJavaEnumeration__A')  # <A>
    @staticmethod
    def asJavaEnumeration(i: 'Iterator'[_asJavaEnumeration__A]) -> java.util.Enumeration[_asJavaEnumeration__A]: ...
    _asJavaEnumerationConverter__A = typing.TypeVar('_asJavaEnumerationConverter__A')  # <A>
    @staticmethod
    def asJavaEnumerationConverter(i: 'Iterator'[_asJavaEnumerationConverter__A]) -> scala.collection.convert.Decorators.AsJavaEnumeration[_asJavaEnumerationConverter__A]: ...
    _asJavaIterable__A = typing.TypeVar('_asJavaIterable__A')  # <A>
    @staticmethod
    def asJavaIterable(i: 'Iterable'[_asJavaIterable__A]) -> java.lang.Iterable[_asJavaIterable__A]: ...
    _asJavaIterableConverter__A = typing.TypeVar('_asJavaIterableConverter__A')  # <A>
    @staticmethod
    def asJavaIterableConverter(i: 'Iterable'[_asJavaIterableConverter__A]) -> scala.collection.convert.Decorators.AsJava[java.lang.Iterable[_asJavaIterableConverter__A]]: ...
    _asJavaIterator__A = typing.TypeVar('_asJavaIterator__A')  # <A>
    @staticmethod
    def asJavaIterator(i: 'Iterator'[_asJavaIterator__A]) -> java.util.Iterator[_asJavaIterator__A]: ...
    _asJavaIteratorConverter__A = typing.TypeVar('_asJavaIteratorConverter__A')  # <A>
    @staticmethod
    def asJavaIteratorConverter(i: 'Iterator'[_asJavaIteratorConverter__A]) -> scala.collection.convert.Decorators.AsJava[java.util.Iterator[_asJavaIteratorConverter__A]]: ...
    _asScalaBuffer__A = typing.TypeVar('_asScalaBuffer__A')  # <A>
    @staticmethod
    def asScalaBuffer(l: java.util.List[_asScalaBuffer__A]) -> scala.collection.mutable.Buffer[_asScalaBuffer__A]: ...
    _asScalaBufferConverter__A = typing.TypeVar('_asScalaBufferConverter__A')  # <A>
    @staticmethod
    def asScalaBufferConverter(l: java.util.List[_asScalaBufferConverter__A]) -> scala.collection.convert.Decorators.AsScala[scala.collection.mutable.Buffer[_asScalaBufferConverter__A]]: ...
    _asScalaIterator__A = typing.TypeVar('_asScalaIterator__A')  # <A>
    @staticmethod
    def asScalaIterator(i: java.util.Iterator[_asScalaIterator__A]) -> 'Iterator'[_asScalaIterator__A]: ...
    _asScalaIteratorConverter__A = typing.TypeVar('_asScalaIteratorConverter__A')  # <A>
    @staticmethod
    def asScalaIteratorConverter(i: java.util.Iterator[_asScalaIteratorConverter__A]) -> scala.collection.convert.Decorators.AsScala['Iterator'[_asScalaIteratorConverter__A]]: ...
    _asScalaSet__A = typing.TypeVar('_asScalaSet__A')  # <A>
    @staticmethod
    def asScalaSet(s: java.util.Set[_asScalaSet__A]) -> scala.collection.mutable.Set[_asScalaSet__A]: ...
    _asScalaSetConverter__A = typing.TypeVar('_asScalaSetConverter__A')  # <A>
    @staticmethod
    def asScalaSetConverter(s: java.util.Set[_asScalaSetConverter__A]) -> scala.collection.convert.Decorators.AsScala[scala.collection.mutable.Set[_asScalaSetConverter__A]]: ...
    _bufferAsJavaList__A = typing.TypeVar('_bufferAsJavaList__A')  # <A>
    @staticmethod
    def bufferAsJavaList(b: scala.collection.mutable.Buffer[_bufferAsJavaList__A]) -> java.util.List[_bufferAsJavaList__A]: ...
    _bufferAsJavaListConverter__A = typing.TypeVar('_bufferAsJavaListConverter__A')  # <A>
    @staticmethod
    def bufferAsJavaListConverter(b: scala.collection.mutable.Buffer[_bufferAsJavaListConverter__A]) -> scala.collection.convert.Decorators.AsJava[java.util.List[_bufferAsJavaListConverter__A]]: ...
    _collectionAsScalaIterable__A = typing.TypeVar('_collectionAsScalaIterable__A')  # <A>
    @staticmethod
    def collectionAsScalaIterable(i: typing.Union[java.util.Collection[_collectionAsScalaIterable__A], typing.Sequence[_collectionAsScalaIterable__A], typing.Set[_collectionAsScalaIterable__A]]) -> 'Iterable'[_collectionAsScalaIterable__A]: ...
    _collectionAsScalaIterableConverter__A = typing.TypeVar('_collectionAsScalaIterableConverter__A')  # <A>
    @staticmethod
    def collectionAsScalaIterableConverter(i: typing.Union[java.util.Collection[_collectionAsScalaIterableConverter__A], typing.Sequence[_collectionAsScalaIterableConverter__A], typing.Set[_collectionAsScalaIterableConverter__A]]) -> scala.collection.convert.Decorators.AsScala['Iterable'[_collectionAsScalaIterableConverter__A]]: ...
    _dictionaryAsScalaMap__A = typing.TypeVar('_dictionaryAsScalaMap__A')  # <A>
    _dictionaryAsScalaMap__B = typing.TypeVar('_dictionaryAsScalaMap__B')  # <B>
    @staticmethod
    def dictionaryAsScalaMap(p: java.util.Dictionary[_dictionaryAsScalaMap__A, _dictionaryAsScalaMap__B]) -> scala.collection.mutable.Map[_dictionaryAsScalaMap__A, _dictionaryAsScalaMap__B]: ...
    _dictionaryAsScalaMapConverter__A = typing.TypeVar('_dictionaryAsScalaMapConverter__A')  # <A>
    _dictionaryAsScalaMapConverter__B = typing.TypeVar('_dictionaryAsScalaMapConverter__B')  # <B>
    @staticmethod
    def dictionaryAsScalaMapConverter(p: java.util.Dictionary[_dictionaryAsScalaMapConverter__A, _dictionaryAsScalaMapConverter__B]) -> scala.collection.convert.Decorators.AsScala[scala.collection.mutable.Map[_dictionaryAsScalaMapConverter__A, _dictionaryAsScalaMapConverter__B]]: ...
    _enumerationAsScalaIterator__A = typing.TypeVar('_enumerationAsScalaIterator__A')  # <A>
    @staticmethod
    def enumerationAsScalaIterator(i: java.util.Enumeration[_enumerationAsScalaIterator__A]) -> 'Iterator'[_enumerationAsScalaIterator__A]: ...
    _enumerationAsScalaIteratorConverter__A = typing.TypeVar('_enumerationAsScalaIteratorConverter__A')  # <A>
    @staticmethod
    def enumerationAsScalaIteratorConverter(i: java.util.Enumeration[_enumerationAsScalaIteratorConverter__A]) -> scala.collection.convert.Decorators.AsScala['Iterator'[_enumerationAsScalaIteratorConverter__A]]: ...
    _iterableAsScalaIterable__A = typing.TypeVar('_iterableAsScalaIterable__A')  # <A>
    @staticmethod
    def iterableAsScalaIterable(i: typing.Union[java.lang.Iterable[_iterableAsScalaIterable__A], typing.Sequence[_iterableAsScalaIterable__A], typing.Set[_iterableAsScalaIterable__A]]) -> 'Iterable'[_iterableAsScalaIterable__A]: ...
    _iterableAsScalaIterableConverter__A = typing.TypeVar('_iterableAsScalaIterableConverter__A')  # <A>
    @staticmethod
    def iterableAsScalaIterableConverter(i: typing.Union[java.lang.Iterable[_iterableAsScalaIterableConverter__A], typing.Sequence[_iterableAsScalaIterableConverter__A], typing.Set[_iterableAsScalaIterableConverter__A]]) -> scala.collection.convert.Decorators.AsScala['Iterable'[_iterableAsScalaIterableConverter__A]]: ...
    _mapAsJavaConcurrentMap__A = typing.TypeVar('_mapAsJavaConcurrentMap__A')  # <A>
    _mapAsJavaConcurrentMap__B = typing.TypeVar('_mapAsJavaConcurrentMap__B')  # <B>
    @staticmethod
    def mapAsJavaConcurrentMap(m: scala.collection.concurrent.Map[_mapAsJavaConcurrentMap__A, _mapAsJavaConcurrentMap__B]) -> java.util.concurrent.ConcurrentMap[_mapAsJavaConcurrentMap__A, _mapAsJavaConcurrentMap__B]: ...
    _mapAsJavaConcurrentMapConverter__A = typing.TypeVar('_mapAsJavaConcurrentMapConverter__A')  # <A>
    _mapAsJavaConcurrentMapConverter__B = typing.TypeVar('_mapAsJavaConcurrentMapConverter__B')  # <B>
    @staticmethod
    def mapAsJavaConcurrentMapConverter(m: scala.collection.concurrent.Map[_mapAsJavaConcurrentMapConverter__A, _mapAsJavaConcurrentMapConverter__B]) -> scala.collection.convert.Decorators.AsJava[java.util.concurrent.ConcurrentMap[_mapAsJavaConcurrentMapConverter__A, _mapAsJavaConcurrentMapConverter__B]]: ...
    _mapAsJavaMap__A = typing.TypeVar('_mapAsJavaMap__A')  # <A>
    _mapAsJavaMap__B = typing.TypeVar('_mapAsJavaMap__B')  # <B>
    @staticmethod
    def mapAsJavaMap(m: 'Map'[_mapAsJavaMap__A, _mapAsJavaMap__B]) -> java.util.Map[_mapAsJavaMap__A, _mapAsJavaMap__B]: ...
    _mapAsJavaMapConverter__A = typing.TypeVar('_mapAsJavaMapConverter__A')  # <A>
    _mapAsJavaMapConverter__B = typing.TypeVar('_mapAsJavaMapConverter__B')  # <B>
    @staticmethod
    def mapAsJavaMapConverter(m: 'Map'[_mapAsJavaMapConverter__A, _mapAsJavaMapConverter__B]) -> scala.collection.convert.Decorators.AsJava[java.util.Map[_mapAsJavaMapConverter__A, _mapAsJavaMapConverter__B]]: ...
    _mapAsScalaConcurrentMap__A = typing.TypeVar('_mapAsScalaConcurrentMap__A')  # <A>
    _mapAsScalaConcurrentMap__B = typing.TypeVar('_mapAsScalaConcurrentMap__B')  # <B>
    @staticmethod
    def mapAsScalaConcurrentMap(m: java.util.concurrent.ConcurrentMap[_mapAsScalaConcurrentMap__A, _mapAsScalaConcurrentMap__B]) -> scala.collection.concurrent.Map[_mapAsScalaConcurrentMap__A, _mapAsScalaConcurrentMap__B]: ...
    _mapAsScalaConcurrentMapConverter__A = typing.TypeVar('_mapAsScalaConcurrentMapConverter__A')  # <A>
    _mapAsScalaConcurrentMapConverter__B = typing.TypeVar('_mapAsScalaConcurrentMapConverter__B')  # <B>
    @staticmethod
    def mapAsScalaConcurrentMapConverter(m: java.util.concurrent.ConcurrentMap[_mapAsScalaConcurrentMapConverter__A, _mapAsScalaConcurrentMapConverter__B]) -> scala.collection.convert.Decorators.AsScala[scala.collection.concurrent.Map[_mapAsScalaConcurrentMapConverter__A, _mapAsScalaConcurrentMapConverter__B]]: ...
    _mapAsScalaMap__A = typing.TypeVar('_mapAsScalaMap__A')  # <A>
    _mapAsScalaMap__B = typing.TypeVar('_mapAsScalaMap__B')  # <B>
    @staticmethod
    def mapAsScalaMap(m: typing.Union[java.util.Map[_mapAsScalaMap__A, _mapAsScalaMap__B], typing.Mapping[_mapAsScalaMap__A, _mapAsScalaMap__B]]) -> scala.collection.mutable.Map[_mapAsScalaMap__A, _mapAsScalaMap__B]: ...
    _mapAsScalaMapConverter__A = typing.TypeVar('_mapAsScalaMapConverter__A')  # <A>
    _mapAsScalaMapConverter__B = typing.TypeVar('_mapAsScalaMapConverter__B')  # <B>
    @staticmethod
    def mapAsScalaMapConverter(m: typing.Union[java.util.Map[_mapAsScalaMapConverter__A, _mapAsScalaMapConverter__B], typing.Mapping[_mapAsScalaMapConverter__A, _mapAsScalaMapConverter__B]]) -> scala.collection.convert.Decorators.AsScala[scala.collection.mutable.Map[_mapAsScalaMapConverter__A, _mapAsScalaMapConverter__B]]: ...
    _mutableMapAsJavaMap__A = typing.TypeVar('_mutableMapAsJavaMap__A')  # <A>
    _mutableMapAsJavaMap__B = typing.TypeVar('_mutableMapAsJavaMap__B')  # <B>
    @staticmethod
    def mutableMapAsJavaMap(m: scala.collection.mutable.Map[_mutableMapAsJavaMap__A, _mutableMapAsJavaMap__B]) -> java.util.Map[_mutableMapAsJavaMap__A, _mutableMapAsJavaMap__B]: ...
    _mutableMapAsJavaMapConverter__A = typing.TypeVar('_mutableMapAsJavaMapConverter__A')  # <A>
    _mutableMapAsJavaMapConverter__B = typing.TypeVar('_mutableMapAsJavaMapConverter__B')  # <B>
    @staticmethod
    def mutableMapAsJavaMapConverter(m: scala.collection.mutable.Map[_mutableMapAsJavaMapConverter__A, _mutableMapAsJavaMapConverter__B]) -> scala.collection.convert.Decorators.AsJava[java.util.Map[_mutableMapAsJavaMapConverter__A, _mutableMapAsJavaMapConverter__B]]: ...
    _mutableSeqAsJavaList__A = typing.TypeVar('_mutableSeqAsJavaList__A')  # <A>
    @staticmethod
    def mutableSeqAsJavaList(s: scala.collection.mutable.Seq[_mutableSeqAsJavaList__A]) -> java.util.List[_mutableSeqAsJavaList__A]: ...
    _mutableSeqAsJavaListConverter__A = typing.TypeVar('_mutableSeqAsJavaListConverter__A')  # <A>
    @staticmethod
    def mutableSeqAsJavaListConverter(b: scala.collection.mutable.Seq[_mutableSeqAsJavaListConverter__A]) -> scala.collection.convert.Decorators.AsJava[java.util.List[_mutableSeqAsJavaListConverter__A]]: ...
    _mutableSetAsJavaSet__A = typing.TypeVar('_mutableSetAsJavaSet__A')  # <A>
    @staticmethod
    def mutableSetAsJavaSet(s: scala.collection.mutable.Set[_mutableSetAsJavaSet__A]) -> java.util.Set[_mutableSetAsJavaSet__A]: ...
    _mutableSetAsJavaSetConverter__A = typing.TypeVar('_mutableSetAsJavaSetConverter__A')  # <A>
    @staticmethod
    def mutableSetAsJavaSetConverter(s: scala.collection.mutable.Set[_mutableSetAsJavaSetConverter__A]) -> scala.collection.convert.Decorators.AsJava[java.util.Set[_mutableSetAsJavaSetConverter__A]]: ...
    @staticmethod
    def propertiesAsScalaMap(p: java.util.Properties) -> scala.collection.mutable.Map[str, str]: ...
    @staticmethod
    def propertiesAsScalaMapConverter(p: java.util.Properties) -> scala.collection.convert.Decorators.AsScala[scala.collection.mutable.Map[str, str]]: ...
    _seqAsJavaList__A = typing.TypeVar('_seqAsJavaList__A')  # <A>
    @staticmethod
    def seqAsJavaList(s: 'Seq'[_seqAsJavaList__A]) -> java.util.List[_seqAsJavaList__A]: ...
    _seqAsJavaListConverter__A = typing.TypeVar('_seqAsJavaListConverter__A')  # <A>
    @staticmethod
    def seqAsJavaListConverter(b: 'Seq'[_seqAsJavaListConverter__A]) -> scala.collection.convert.Decorators.AsJava[java.util.List[_seqAsJavaListConverter__A]]: ...
    _setAsJavaSet__A = typing.TypeVar('_setAsJavaSet__A')  # <A>
    @staticmethod
    def setAsJavaSet(s: 'Set'[_setAsJavaSet__A]) -> java.util.Set[_setAsJavaSet__A]: ...
    _setAsJavaSetConverter__A = typing.TypeVar('_setAsJavaSetConverter__A')  # <A>
    @staticmethod
    def setAsJavaSetConverter(s: 'Set'[_setAsJavaSetConverter__A]) -> scala.collection.convert.Decorators.AsJava[java.util.Set[_setAsJavaSetConverter__A]]: ...

class Parallel: ...

_Parallelizable__A = typing.TypeVar('_Parallelizable__A')  # <A>
_Parallelizable__ParRepr = typing.TypeVar('_Parallelizable__ParRepr', bound=Parallel)  # <ParRepr>
class Parallelizable(typing.Generic[_Parallelizable__A, _Parallelizable__ParRepr]):
    @staticmethod
    def $init$($this: 'Parallelizable') -> None: ...
    def par(self) -> _Parallelizable__ParRepr: ...
    def parCombiner(self) -> scala.collection.parallel.Combiner[_Parallelizable__A, _Parallelizable__ParRepr]: ...
    def seq(self) -> 'TraversableOnce'[_Parallelizable__A]: ...

class SeqExtractors:
    def __init__(self): ...

_ViewMkString__A = typing.TypeVar('_ViewMkString__A')  # <A>
class ViewMkString(typing.Generic[_ViewMkString__A]):
    @staticmethod
    def $init$($this: 'ViewMkString') -> None: ...
    def addString(self, b: scala.collection.mutable.StringBuilder, start: str, sep: str, end: str) -> scala.collection.mutable.StringBuilder: ...
    @typing.overload
    def mkString(self) -> str: ...
    @typing.overload
    def mkString(self, sep: str) -> str: ...
    @typing.overload
    def mkString(self, start: str, sep: str, end: str) -> str: ...
    def thisSeq(self) -> 'Seq'[_ViewMkString__A]: ...

class package:
    _breakOut__From = typing.TypeVar('_breakOut__From')  # <From>
    _breakOut__T = typing.TypeVar('_breakOut__T')  # <T>
    _breakOut__To = typing.TypeVar('_breakOut__To')  # <To>
    @staticmethod
    def breakOut(b: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., _breakOut__T, _breakOut__To]) -> scala.collection.generic.CanBuildFrom[_breakOut__From, _breakOut__T, _breakOut__To]: ...

_CustomParallelizable__A = typing.TypeVar('_CustomParallelizable__A')  # <A>
_CustomParallelizable__ParRepr = typing.TypeVar('_CustomParallelizable__ParRepr', bound=Parallel)  # <ParRepr>
class CustomParallelizable(Parallelizable[_CustomParallelizable__A, _CustomParallelizable__ParRepr], typing.Generic[_CustomParallelizable__A, _CustomParallelizable__ParRepr]):
    @staticmethod
    def $init$($this: 'CustomParallelizable') -> None: ...
    def par(self) -> _CustomParallelizable__ParRepr: ...
    def parCombiner(self) -> scala.collection.parallel.Combiner[_CustomParallelizable__A, _CustomParallelizable__ParRepr]: ...

_GenTraversableLike__A = typing.TypeVar('_GenTraversableLike__A')  # <A>
_GenTraversableLike__Repr = typing.TypeVar('_GenTraversableLike__Repr')  # <Repr>
class GenTraversableLike(GenTraversableOnce[_GenTraversableLike__A], Parallelizable[_GenTraversableLike__A, scala.collection.parallel.ParIterable[_GenTraversableLike__A]], typing.Generic[_GenTraversableLike__A, _GenTraversableLike__Repr]):
    _$plus$plus__B = typing.TypeVar('_$plus$plus__B')  # <B>
    _$plus$plus__That = typing.TypeVar('_$plus$plus__That')  # <That>
    def $plus$plus(self, that: GenTraversableOnce[_.plus.plus__B], bf: scala.collection.generic.CanBuildFrom[_GenTraversableLike__Repr, _.plus.plus__B, _.plus.plus__That]) -> _.plus.plus__That: ...
    _collect__B = typing.TypeVar('_collect__B')  # <B>
    _collect__That = typing.TypeVar('_collect__That')  # <That>
    def collect(self, pf: scala.PartialFunction[_GenTraversableLike__A, _collect__B], bf: scala.collection.generic.CanBuildFrom[_GenTraversableLike__Repr, _collect__B, _collect__That]) -> _collect__That: ...
    def drop(self, n: int) -> _GenTraversableLike__Repr: ...
    def dropWhile(self, pred: scala.Function1[_GenTraversableLike__A, typing.Any]) -> _GenTraversableLike__Repr: ...
    def filter(self, pred: scala.Function1[_GenTraversableLike__A, typing.Any]) -> _GenTraversableLike__Repr: ...
    def filterNot(self, pred: scala.Function1[_GenTraversableLike__A, typing.Any]) -> _GenTraversableLike__Repr: ...
    _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
    _flatMap__That = typing.TypeVar('_flatMap__That')  # <That>
    def flatMap(self, f: scala.Function1[_GenTraversableLike__A, GenTraversableOnce[_flatMap__B]], bf: scala.collection.generic.CanBuildFrom[_GenTraversableLike__Repr, _flatMap__B, _flatMap__That]) -> _flatMap__That: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_GenTraversableLike__A, _foreach__U]) -> None: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[_GenTraversableLike__A, _groupBy__K]) -> 'GenMap'[_groupBy__K, _GenTraversableLike__Repr]: ...
    def head(self) -> _GenTraversableLike__A: ...
    def headOption(self) -> scala.Option[_GenTraversableLike__A]: ...
    def init(self) -> _GenTraversableLike__Repr: ...
    def isTraversableAgain(self) -> bool: ...
    def last(self) -> _GenTraversableLike__A: ...
    def lastOption(self) -> scala.Option[_GenTraversableLike__A]: ...
    _map__B = typing.TypeVar('_map__B')  # <B>
    _map__That = typing.TypeVar('_map__That')  # <That>
    def map(self, f: scala.Function1[_GenTraversableLike__A, _map__B], bf: scala.collection.generic.CanBuildFrom[_GenTraversableLike__Repr, _map__B, _map__That]) -> _map__That: ...
    def partition(self, pred: scala.Function1[_GenTraversableLike__A, typing.Any]) -> scala.Tuple2[_GenTraversableLike__Repr, _GenTraversableLike__Repr]: ...
    def repr(self) -> _GenTraversableLike__Repr: ...
    _scan__B = typing.TypeVar('_scan__B')  # <B>
    _scan__That = typing.TypeVar('_scan__That')  # <That>
    def scan(self, z: _scan__B, op: scala.Function2[_scan__B, _scan__B, _scan__B], cbf: scala.collection.generic.CanBuildFrom[_GenTraversableLike__Repr, _scan__B, _scan__That]) -> _scan__That: ...
    _scanLeft__B = typing.TypeVar('_scanLeft__B')  # <B>
    _scanLeft__That = typing.TypeVar('_scanLeft__That')  # <That>
    def scanLeft(self, z: _scanLeft__B, op: scala.Function2[_scanLeft__B, _GenTraversableLike__A, _scanLeft__B], bf: scala.collection.generic.CanBuildFrom[_GenTraversableLike__Repr, _scanLeft__B, _scanLeft__That]) -> _scanLeft__That: ...
    _scanRight__B = typing.TypeVar('_scanRight__B')  # <B>
    _scanRight__That = typing.TypeVar('_scanRight__That')  # <That>
    def scanRight(self, z: _scanRight__B, op: scala.Function2[_GenTraversableLike__A, _scanRight__B, _scanRight__B], bf: scala.collection.generic.CanBuildFrom[_GenTraversableLike__Repr, _scanRight__B, _scanRight__That]) -> _scanRight__That: ...
    def size(self) -> int: ...
    def slice(self, unc_from: int, unc_until: int) -> _GenTraversableLike__Repr: ...
    def span(self, pred: scala.Function1[_GenTraversableLike__A, typing.Any]) -> scala.Tuple2[_GenTraversableLike__Repr, _GenTraversableLike__Repr]: ...
    def splitAt(self, n: int) -> scala.Tuple2[_GenTraversableLike__Repr, _GenTraversableLike__Repr]: ...
    def stringPrefix(self) -> str: ...
    def tail(self) -> _GenTraversableLike__Repr: ...
    def take(self, n: int) -> _GenTraversableLike__Repr: ...
    def takeWhile(self, pred: scala.Function1[_GenTraversableLike__A, typing.Any]) -> _GenTraversableLike__Repr: ...

_GenIterableLike__A = typing.TypeVar('_GenIterableLike__A')  # <A>
_GenIterableLike__Repr = typing.TypeVar('_GenIterableLike__Repr')  # <Repr>
class GenIterableLike(GenTraversableLike[_GenIterableLike__A, _GenIterableLike__Repr], typing.Generic[_GenIterableLike__A, _GenIterableLike__Repr]):
    def iterator(self) -> 'Iterator'[_GenIterableLike__A]: ...
    _sameElements__A1 = typing.TypeVar('_sameElements__A1')  # <A1>
    def sameElements(self, that: 'GenIterable'[_sameElements__A1]) -> bool: ...
    _zip__A1 = typing.TypeVar('_zip__A1')  # <A1>
    _zip__B = typing.TypeVar('_zip__B')  # <B>
    _zip__That = typing.TypeVar('_zip__That')  # <That>
    def zip(self, that: 'GenIterable'[_zip__B], bf: scala.collection.generic.CanBuildFrom[_GenIterableLike__Repr, scala.Tuple2[_zip__A1, _zip__B], _zip__That]) -> _zip__That: ...
    _zipAll__B = typing.TypeVar('_zipAll__B')  # <B>
    _zipAll__A1 = typing.TypeVar('_zipAll__A1')  # <A1>
    _zipAll__That = typing.TypeVar('_zipAll__That')  # <That>
    def zipAll(self, that: 'GenIterable'[_zipAll__B], thisElem: _zipAll__A1, thatElem: _zipAll__B, bf: scala.collection.generic.CanBuildFrom[_GenIterableLike__Repr, scala.Tuple2[_zipAll__A1, _zipAll__B], _zipAll__That]) -> _zipAll__That: ...
    _zipWithIndex__A1 = typing.TypeVar('_zipWithIndex__A1')  # <A1>
    _zipWithIndex__That = typing.TypeVar('_zipWithIndex__That')  # <That>
    def zipWithIndex(self, bf: scala.collection.generic.CanBuildFrom[_GenIterableLike__Repr, scala.Tuple2[_zipWithIndex__A1, typing.Any], _zipWithIndex__That]) -> _zipWithIndex__That: ...

_GenTraversable__A = typing.TypeVar('_GenTraversable__A')  # <A>
class GenTraversable(GenTraversableLike[_GenTraversable__A, 'GenTraversable'[_GenTraversable__A]], scala.collection.generic.GenericTraversableTemplate[_GenTraversable__A, 'GenTraversable'], typing.Generic[_GenTraversable__A]):
    @staticmethod
    def $init$($this: 'GenTraversable') -> None: ...
    @staticmethod
    def ReusableCBF() -> scala.collection.generic.GenTraversableFactory.GenericCanBuildFrom[scala.runtime.Nothing.]: ...
    _apply__A = typing.TypeVar('_apply__A')  # <A>
    @staticmethod
    def apply(elems: 'Seq'[_apply__A]) -> 'GenTraversable'[_apply__A]: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.GenTraversableFactory.GenericCanBuildFrom[_canBuildFrom__A]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['GenTraversable']: ...
    _concat__A = typing.TypeVar('_concat__A')  # <A>
    @staticmethod
    def concat(xss: 'Seq'['Traversable'[_concat__A]]) -> 'GenTraversable'[_concat__A]: ...
    _empty__A = typing.TypeVar('_empty__A')  # <A>
    @staticmethod
    def empty() -> 'GenTraversable'[_empty__A]: ...
    _fill_0__A = typing.TypeVar('_fill_0__A')  # <A>
    _fill_1__A = typing.TypeVar('_fill_1__A')  # <A>
    _fill_2__A = typing.TypeVar('_fill_2__A')  # <A>
    _fill_3__A = typing.TypeVar('_fill_3__A')  # <A>
    _fill_4__A = typing.TypeVar('_fill_4__A')  # <A>
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, n5: int, elem: scala.Function0[_fill_0__A]) -> 'GenTraversable'['GenTraversable'['GenTraversable'['GenTraversable'['GenTraversable'[_fill_0__A]]]]]: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, elem: scala.Function0[_fill_1__A]) -> 'GenTraversable'['GenTraversable'['GenTraversable'['GenTraversable'[_fill_1__A]]]]: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, elem: scala.Function0[_fill_2__A]) -> 'GenTraversable'['GenTraversable'['GenTraversable'[_fill_2__A]]]: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, elem: scala.Function0[_fill_3__A]) -> 'GenTraversable'['GenTraversable'[_fill_3__A]]: ...
    @typing.overload
    @staticmethod
    def fill(n: int, elem: scala.Function0[_fill_4__A]) -> 'GenTraversable'[_fill_4__A]: ...
    _iterate__A = typing.TypeVar('_iterate__A')  # <A>
    @staticmethod
    def iterate(start: _iterate__A, len: int, f: scala.Function1[_iterate__A, _iterate__A]) -> 'GenTraversable'[_iterate__A]: ...
    _range_0__T = typing.TypeVar('_range_0__T')  # <T>
    _range_1__T = typing.TypeVar('_range_1__T')  # <T>
    @typing.overload
    @staticmethod
    def range(start: _range_0__T, end: _range_0__T, step: _range_0__T, evidence$2: scala.math.Integral[_range_0__T]) -> 'GenTraversable'[_range_0__T]: ...
    @typing.overload
    @staticmethod
    def range(start: _range_1__T, end: _range_1__T, evidence$1: scala.math.Integral[_range_1__T]) -> 'GenTraversable'[_range_1__T]: ...
    @typing.overload
    def seq(self) -> 'Traversable'[_GenTraversable__A]: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[_GenTraversable__A]: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[_GenTraversable__A]: ...
    _tabulate_0__A = typing.TypeVar('_tabulate_0__A')  # <A>
    _tabulate_1__A = typing.TypeVar('_tabulate_1__A')  # <A>
    _tabulate_2__A = typing.TypeVar('_tabulate_2__A')  # <A>
    _tabulate_3__A = typing.TypeVar('_tabulate_3__A')  # <A>
    _tabulate_4__A = typing.TypeVar('_tabulate_4__A')  # <A>
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, n5: int, f: scala.Function5[typing.Any, typing.Any, typing.Any, typing.Any, typing.Any, _tabulate_0__A]) -> 'GenTraversable'['GenTraversable'['GenTraversable'['GenTraversable'['GenTraversable'[_tabulate_0__A]]]]]: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, f: scala.Function4[typing.Any, typing.Any, typing.Any, typing.Any, _tabulate_1__A]) -> 'GenTraversable'['GenTraversable'['GenTraversable'['GenTraversable'[_tabulate_1__A]]]]: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, f: scala.Function3[typing.Any, typing.Any, typing.Any, _tabulate_2__A]) -> 'GenTraversable'['GenTraversable'['GenTraversable'[_tabulate_2__A]]]: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, f: scala.Function2[typing.Any, typing.Any, _tabulate_3__A]) -> 'GenTraversable'['GenTraversable'[_tabulate_3__A]]: ...
    @typing.overload
    @staticmethod
    def tabulate(n: int, f: scala.Function1[typing.Any, _tabulate_4__A]) -> 'GenTraversable'[_tabulate_4__A]: ...

_GenIterable__A = typing.TypeVar('_GenIterable__A')  # <A>
class GenIterable(GenIterableLike[_GenIterable__A, 'GenIterable'[_GenIterable__A]], GenTraversable[_GenIterable__A], typing.Generic[_GenIterable__A]):
    @staticmethod
    def $init$($this: 'GenIterable') -> None: ...
    @staticmethod
    def ReusableCBF() -> scala.collection.generic.GenTraversableFactory.GenericCanBuildFrom[scala.runtime.Nothing.]: ...
    @staticmethod
    def apply(elems: 'Seq') -> GenTraversable: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.GenTraversableFactory.GenericCanBuildFrom[_canBuildFrom__A]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['GenIterable']: ...
    @staticmethod
    def concat(xss: 'Seq') -> GenTraversable: ...
    @staticmethod
    def empty() -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, n5: int, elem: scala.Function0) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, elem: scala.Function0) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, elem: scala.Function0) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, elem: scala.Function0) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n: int, elem: scala.Function0) -> GenTraversable: ...
    @staticmethod
    def iterate(start: typing.Any, len: int, f: scala.Function1) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, step: typing.Any, evidence$2: scala.math.Integral) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, evidence$1: scala.math.Integral) -> GenTraversable: ...
    @typing.overload
    def seq(self) -> 'Iterable'[_GenIterable__A]: ...
    @typing.overload
    def seq(self) -> 'Traversable'[_GenIterable__A]: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[_GenIterable__A]: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[_GenIterable__A]: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, n5: int, f: scala.Function5) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, f: scala.Function4) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, f: scala.Function3) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, f: scala.Function2) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n: int, f: scala.Function1) -> GenTraversable: ...

_GenMapLike__K = typing.TypeVar('_GenMapLike__K')  # <K>
_GenMapLike__V = typing.TypeVar('_GenMapLike__V')  # <V>
_GenMapLike__Repr = typing.TypeVar('_GenMapLike__Repr')  # <Repr>
class GenMapLike(GenIterableLike[scala.Tuple2[_GenMapLike__K, _GenMapLike__V], _GenMapLike__Repr], scala.Equals, typing.Generic[_GenMapLike__K, _GenMapLike__V, _GenMapLike__Repr]):
    @staticmethod
    def $init$($this: 'GenMapLike') -> None: ...
    def $minus(self, key: _GenMapLike__K) -> _GenMapLike__Repr: ...
    _$plus__V1 = typing.TypeVar('_$plus__V1')  # <V1>
    def $plus(self, kv: scala.Tuple2[_GenMapLike__K, _.plus__V1]) -> 'GenMap'[_GenMapLike__K, _.plus__V1]: ...
    def apply(self, key: _GenMapLike__K) -> _GenMapLike__V: ...
    def contains(self, key: _GenMapLike__K) -> bool: ...
    def default(self, key: _GenMapLike__K) -> _GenMapLike__V: ...
    def equals(self, that: typing.Any) -> bool: ...
    def filterKeys(self, p: scala.Function1[_GenMapLike__K, typing.Any]) -> 'GenMap'[_GenMapLike__K, _GenMapLike__V]: ...
    def get(self, key: _GenMapLike__K) -> scala.Option[_GenMapLike__V]: ...
    _getOrElse__V1 = typing.TypeVar('_getOrElse__V1')  # <V1>
    def getOrElse(self, key: _GenMapLike__K, default: scala.Function0[_getOrElse__V1]) -> _getOrElse__V1: ...
    def hashCode(self) -> int: ...
    def isDefinedAt(self, key: _GenMapLike__K) -> bool: ...
    def keySet(self) -> 'GenSet'[_GenMapLike__K]: ...
    def keys(self) -> GenIterable[_GenMapLike__K]: ...
    def keysIterator(self) -> 'Iterator'[_GenMapLike__K]: ...
    _mapValues__W = typing.TypeVar('_mapValues__W')  # <W>
    def mapValues(self, f: scala.Function1[_GenMapLike__V, _mapValues__W]) -> 'GenMap'[_GenMapLike__K, _mapValues__W]: ...
    @typing.overload
    def seq(self) -> 'Map'[_GenMapLike__K, _GenMapLike__V]: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[typing.Any]: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[typing.Any]: ...
    def values(self) -> GenIterable[_GenMapLike__V]: ...
    def valuesIterator(self) -> 'Iterator'[_GenMapLike__V]: ...

_GenSeqLike__A = typing.TypeVar('_GenSeqLike__A')  # <A>
_GenSeqLike__Repr = typing.TypeVar('_GenSeqLike__Repr')  # <Repr>
class GenSeqLike(GenIterableLike[_GenSeqLike__A, _GenSeqLike__Repr], scala.Equals, typing.Generic[_GenSeqLike__A, _GenSeqLike__Repr]):
    _$colon$plus__B = typing.TypeVar('_$colon$plus__B')  # <B>
    _$colon$plus__That = typing.TypeVar('_$colon$plus__That')  # <That>
    def $colon$plus(self, elem: _.colon.plus__B, bf: scala.collection.generic.CanBuildFrom[_GenSeqLike__Repr, _.colon.plus__B, _.colon.plus__That]) -> _.colon.plus__That: ...
    @staticmethod
    def $init$($this: 'GenSeqLike') -> None: ...
    _$plus$colon__B = typing.TypeVar('_$plus$colon__B')  # <B>
    _$plus$colon__That = typing.TypeVar('_$plus$colon__That')  # <That>
    def $plus$colon(self, elem: _.plus.colon__B, bf: scala.collection.generic.CanBuildFrom[_GenSeqLike__Repr, _.plus.colon__B, _.plus.colon__That]) -> _.plus.colon__That: ...
    def apply(self, idx: int) -> _GenSeqLike__A: ...
    _corresponds__B = typing.TypeVar('_corresponds__B')  # <B>
    def corresponds(self, that: 'GenSeq'[_corresponds__B], p: scala.Function2[_GenSeqLike__A, _corresponds__B, typing.Any]) -> bool: ...
    _diff__B = typing.TypeVar('_diff__B')  # <B>
    def diff(self, that: 'GenSeq'[_diff__B]) -> _GenSeqLike__Repr: ...
    def distinct(self) -> _GenSeqLike__Repr: ...
    _endsWith__B = typing.TypeVar('_endsWith__B')  # <B>
    def endsWith(self, that: 'GenSeq'[_endsWith__B]) -> bool: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    _indexOf_0__B = typing.TypeVar('_indexOf_0__B')  # <B>
    _indexOf_1__B = typing.TypeVar('_indexOf_1__B')  # <B>
    @typing.overload
    def indexOf(self, elem: _indexOf_0__B) -> int: ...
    @typing.overload
    def indexOf(self, elem: _indexOf_1__B, from_: int) -> int: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[_GenSeqLike__A, typing.Any], from_: int) -> int: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[_GenSeqLike__A, typing.Any]) -> int: ...
    _intersect__B = typing.TypeVar('_intersect__B')  # <B>
    def intersect(self, that: 'GenSeq'[_intersect__B]) -> _GenSeqLike__Repr: ...
    def isDefinedAt(self, idx: int) -> bool: ...
    _lastIndexOf_0__B = typing.TypeVar('_lastIndexOf_0__B')  # <B>
    _lastIndexOf_1__B = typing.TypeVar('_lastIndexOf_1__B')  # <B>
    @typing.overload
    def lastIndexOf(self, elem: _lastIndexOf_0__B) -> int: ...
    @typing.overload
    def lastIndexOf(self, elem: _lastIndexOf_1__B, end: int) -> int: ...
    @typing.overload
    def lastIndexWhere(self, p: scala.Function1[_GenSeqLike__A, typing.Any], end: int) -> int: ...
    @typing.overload
    def lastIndexWhere(self, p: scala.Function1[_GenSeqLike__A, typing.Any]) -> int: ...
    def length(self) -> int: ...
    _padTo__B = typing.TypeVar('_padTo__B')  # <B>
    _padTo__That = typing.TypeVar('_padTo__That')  # <That>
    def padTo(self, len: int, elem: _padTo__B, bf: scala.collection.generic.CanBuildFrom[_GenSeqLike__Repr, _padTo__B, _padTo__That]) -> _padTo__That: ...
    _patch__B = typing.TypeVar('_patch__B')  # <B>
    _patch__That = typing.TypeVar('_patch__That')  # <That>
    def patch(self, from_: int, patch: 'GenSeq'[_patch__B], replaced: int, bf: scala.collection.generic.CanBuildFrom[_GenSeqLike__Repr, _patch__B, _patch__That]) -> _patch__That: ...
    def prefixLength(self, p: scala.Function1[_GenSeqLike__A, typing.Any]) -> int: ...
    def reverse(self) -> _GenSeqLike__Repr: ...
    _reverseMap__B = typing.TypeVar('_reverseMap__B')  # <B>
    _reverseMap__That = typing.TypeVar('_reverseMap__That')  # <That>
    def reverseMap(self, f: scala.Function1[_GenSeqLike__A, _reverseMap__B], bf: scala.collection.generic.CanBuildFrom[_GenSeqLike__Repr, _reverseMap__B, _reverseMap__That]) -> _reverseMap__That: ...
    def segmentLength(self, p: scala.Function1[_GenSeqLike__A, typing.Any], from_: int) -> int: ...
    @typing.overload
    def seq(self) -> 'Seq'[_GenSeqLike__A]: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[_GenSeqLike__A]: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[_GenSeqLike__A]: ...
    _startsWith_0__B = typing.TypeVar('_startsWith_0__B')  # <B>
    _startsWith_1__B = typing.TypeVar('_startsWith_1__B')  # <B>
    @typing.overload
    def startsWith(self, that: 'GenSeq'[_startsWith_0__B], offset: int) -> bool: ...
    @typing.overload
    def startsWith(self, that: 'GenSeq'[_startsWith_1__B]) -> bool: ...
    def toSeq(self) -> 'GenSeq'[_GenSeqLike__A]: ...
    _union__B = typing.TypeVar('_union__B')  # <B>
    _union__That = typing.TypeVar('_union__That')  # <That>
    def union(self, that: 'GenSeq'[_union__B], bf: scala.collection.generic.CanBuildFrom[_GenSeqLike__Repr, _union__B, _union__That]) -> _union__That: ...
    _updated__B = typing.TypeVar('_updated__B')  # <B>
    _updated__That = typing.TypeVar('_updated__That')  # <That>
    def updated(self, index: int, elem: _updated__B, bf: scala.collection.generic.CanBuildFrom[_GenSeqLike__Repr, _updated__B, _updated__That]) -> _updated__That: ...

_GenSetLike__A = typing.TypeVar('_GenSetLike__A')  # <A>
_GenSetLike__Repr = typing.TypeVar('_GenSetLike__Repr')  # <Repr>
class GenSetLike(GenIterableLike[_GenSetLike__A, _GenSetLike__Repr], scala.Function1[_GenSetLike__A, typing.Any], scala.Equals, typing.Generic[_GenSetLike__A, _GenSetLike__Repr]):
    def $amp(self, that: 'GenSet'[_GenSetLike__A]) -> _GenSetLike__Repr: ...
    def $amp$tilde(self, that: 'GenSet'[_GenSetLike__A]) -> _GenSetLike__Repr: ...
    def $bar(self, that: 'GenSet'[_GenSetLike__A]) -> _GenSetLike__Repr: ...
    @staticmethod
    def $init$($this: 'GenSetLike') -> None: ...
    def $minus(self, elem: _GenSetLike__A) -> _GenSetLike__Repr: ...
    def $plus(self, elem: _GenSetLike__A) -> _GenSetLike__Repr: ...
    @typing.overload
    def apply(self, v1: typing.Any) -> typing.Any: ...
    @typing.overload
    def apply(self, elem: _GenSetLike__A) -> bool: ...
    def contains(self, elem: _GenSetLike__A) -> bool: ...
    def diff(self, that: 'GenSet'[_GenSetLike__A]) -> _GenSetLike__Repr: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def intersect(self, that: 'GenSet'[_GenSetLike__A]) -> _GenSetLike__Repr: ...
    def iterator(self) -> 'Iterator'[_GenSetLike__A]: ...
    @typing.overload
    def seq(self) -> 'Set'[_GenSetLike__A]: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[_GenSetLike__A]: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[_GenSetLike__A]: ...
    def subsetOf(self, that: 'GenSet'[_GenSetLike__A]) -> bool: ...
    def toString(self) -> str: ...
    def union(self, that: 'GenSet'[_GenSetLike__A]) -> _GenSetLike__Repr: ...

_GenMap__K = typing.TypeVar('_GenMap__K')  # <K>
_GenMap__V = typing.TypeVar('_GenMap__V')  # <V>
class GenMap(GenMapLike[_GenMap__K, _GenMap__V, 'GenMap'[_GenMap__K, _GenMap__V]], GenIterable[scala.Tuple2[_GenMap__K, _GenMap__V]], typing.Generic[_GenMap__K, _GenMap__V]):
    _canBuildFrom__K = typing.TypeVar('_canBuildFrom__K')  # <K>
    _canBuildFrom__V = typing.TypeVar('_canBuildFrom__V')  # <V>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['GenMap'[typing.Any, typing.Any], scala.Tuple2[_canBuildFrom__K, _canBuildFrom__V], 'GenMap'[_canBuildFrom__K, _canBuildFrom__V]]: ...
    _empty__K = typing.TypeVar('_empty__K')  # <K>
    _empty__V = typing.TypeVar('_empty__V')  # <V>
    @staticmethod
    def empty() -> scala.collection.immutable.Map[_empty__K, _empty__V]: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def seq(self) -> 'Iterable'[typing.Any]: ...
    @typing.overload
    def seq(self) -> 'Map'[_GenMap__K, _GenMap__V]: ...
    @typing.overload
    def seq(self) -> 'Traversable'[typing.Any]: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[typing.Any]: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[typing.Any]: ...
    _updated__V1 = typing.TypeVar('_updated__V1')  # <V1>
    def updated(self, key: _GenMap__K, value: _updated__V1) -> 'GenMap'[_GenMap__K, _updated__V1]: ...

_GenSeq__A = typing.TypeVar('_GenSeq__A')  # <A>
class GenSeq(GenSeqLike[_GenSeq__A, 'GenSeq'[_GenSeq__A]], GenIterable[_GenSeq__A], typing.Generic[_GenSeq__A]):
    @staticmethod
    def $init$($this: 'GenSeq') -> None: ...
    @staticmethod
    def ReusableCBF() -> scala.collection.generic.GenTraversableFactory.GenericCanBuildFrom[scala.runtime.Nothing.]: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.GenTraversableFactory.GenericCanBuildFrom[_canBuildFrom__A]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['GenSeq']: ...
    @staticmethod
    def concat(xss: 'Seq') -> GenTraversable: ...
    @staticmethod
    def empty() -> GenTraversable: ...
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, n5: int, elem: scala.Function0) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, elem: scala.Function0) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, elem: scala.Function0) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, elem: scala.Function0) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n: int, elem: scala.Function0) -> GenTraversable: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def iterate(start: typing.Any, len: int, f: scala.Function1) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, step: typing.Any, evidence$2: scala.math.Integral) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, evidence$1: scala.math.Integral) -> GenTraversable: ...
    @typing.overload
    def seq(self) -> 'Iterable'[_GenSeq__A]: ...
    @typing.overload
    def seq(self) -> 'Seq'[_GenSeq__A]: ...
    @typing.overload
    def seq(self) -> 'Traversable'[_GenSeq__A]: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[_GenSeq__A]: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[_GenSeq__A]: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, n5: int, f: scala.Function5) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, f: scala.Function4) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, f: scala.Function3) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, f: scala.Function2) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n: int, f: scala.Function1) -> GenTraversable: ...

_GenSet__A = typing.TypeVar('_GenSet__A')  # <A>
class GenSet(GenSetLike[_GenSet__A, 'GenSet'[_GenSet__A]], GenIterable[_GenSet__A], scala.collection.generic.GenericSetTemplate[_GenSet__A, 'GenSet'], typing.Generic[_GenSet__A]):
    @staticmethod
    def $init$($this: 'GenSet') -> None: ...
    @staticmethod
    def ReusableCBF() -> scala.collection.generic.GenTraversableFactory.GenericCanBuildFrom[scala.runtime.Nothing.]: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.GenTraversableFactory.GenericCanBuildFrom[_canBuildFrom__A]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['GenSet']: ...
    @staticmethod
    def concat(xss: 'Seq') -> GenTraversable: ...
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, n5: int, elem: scala.Function0) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, elem: scala.Function0) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, elem: scala.Function0) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, elem: scala.Function0) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n: int, elem: scala.Function0) -> GenTraversable: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def iterate(start: typing.Any, len: int, f: scala.Function1) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, step: typing.Any, evidence$2: scala.math.Integral) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, evidence$1: scala.math.Integral) -> GenTraversable: ...
    @typing.overload
    def seq(self) -> 'Iterable'[_GenSet__A]: ...
    @typing.overload
    def seq(self) -> 'Set'[_GenSet__A]: ...
    @typing.overload
    def seq(self) -> 'Traversable'[_GenSet__A]: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[_GenSet__A]: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[_GenSet__A]: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, n5: int, f: scala.Function5) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, f: scala.Function4) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, f: scala.Function3) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, f: scala.Function2) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n: int, f: scala.Function1) -> GenTraversable: ...
    def toString(self) -> str: ...

_AbstractIterable__A = typing.TypeVar('_AbstractIterable__A')  # <A>
class AbstractIterable(scala.collection.AbstractTraversable[_AbstractIterable__A], scala.collection.Iterable[_AbstractIterable__A], typing.Generic[_AbstractIterable__A]):
    def __init__(self): ...
    def canEqual(self, that: typing.Any) -> bool: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['Iterable']: ...
    _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
    _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
    _copyToArray_2__B = typing.TypeVar('_copyToArray_2__B')  # <B>
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int) -> None: ...
    def drop(self, n: int) -> typing.Any: ...
    def dropRight(self, n: int) -> typing.Any: ...
    def exists(self, p: scala.Function1[_AbstractIterable__A, typing.Any]) -> bool: ...
    def find(self, p: scala.Function1[_AbstractIterable__A, typing.Any]) -> scala.Option[_AbstractIterable__A]: ...
    _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
    def foldRight(self, z: _foldRight__B, op: scala.Function2[_AbstractIterable__A, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
    def forall(self, p: scala.Function1[_AbstractIterable__A, typing.Any]) -> bool: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_AbstractIterable__A, _foreach__U]) -> None: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[_AbstractIterable__A, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, 'Traversable'[_AbstractIterable__A]]: ...
    def grouped(self, size: int) -> 'Iterator'['Iterable'[_AbstractIterable__A]]: ...
    def head(self) -> _AbstractIterable__A: ...
    def isEmpty(self) -> bool: ...
    _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
    def reduceRight(self, op: scala.Function2[_AbstractIterable__A, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
    _sameElements__B = typing.TypeVar('_sameElements__B')  # <B>
    def sameElements(self, that: GenIterable[_sameElements__B]) -> bool: ...
    def seq(self) -> 'Iterable'[_AbstractIterable__A]: ...
    def slice(self, from_: int, until: int) -> typing.Any: ...
    @typing.overload
    def sliding(self, size: int) -> 'Iterator'['Iterable'[_AbstractIterable__A]]: ...
    @typing.overload
    def sliding(self, size: int, step: int) -> 'Iterator'['Iterable'[_AbstractIterable__A]]: ...
    def take(self, n: int) -> typing.Any: ...
    def takeRight(self, n: int) -> typing.Any: ...
    def takeWhile(self, p: scala.Function1) -> typing.Any: ...
    def thisCollection(self) -> 'Iterable'[_AbstractIterable__A]: ...
    def toCollection(self, repr: typing.Any) -> 'Iterable': ...
    def toIterable(self) -> 'Iterable'[_AbstractIterable__A]: ...
    def toIterator(self) -> 'Iterator'[_AbstractIterable__A]: ...
    def toStream(self) -> scala.collection.immutable.Stream[_AbstractIterable__A]: ...
    def toTraversable(self) -> 'Traversable'[_AbstractIterable__A]: ...
    @typing.overload
    def view(self) -> 'IterableView'[_AbstractIterable__A, 'Iterable'[_AbstractIterable__A]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> 'IterableView'[_AbstractIterable__A, 'Iterable'[_AbstractIterable__A]]: ...
    _zip__A1 = typing.TypeVar('_zip__A1')  # <A1>
    _zip__B = typing.TypeVar('_zip__B')  # <B>
    _zip__That = typing.TypeVar('_zip__That')  # <That>
    def zip(self, that: GenIterable[_zip__B], bf: scala.collection.generic.CanBuildFrom['Iterable'[_AbstractIterable__A], scala.Tuple2[_zip__A1, _zip__B], _zip__That]) -> _zip__That: ...
    _zipAll__B = typing.TypeVar('_zipAll__B')  # <B>
    _zipAll__A1 = typing.TypeVar('_zipAll__A1')  # <A1>
    _zipAll__That = typing.TypeVar('_zipAll__That')  # <That>
    def zipAll(self, that: GenIterable[_zipAll__B], thisElem: _zipAll__A1, thatElem: _zipAll__B, bf: scala.collection.generic.CanBuildFrom['Iterable'[_AbstractIterable__A], scala.Tuple2[_zipAll__A1, _zipAll__B], _zipAll__That]) -> _zipAll__That: ...
    _zipWithIndex__A1 = typing.TypeVar('_zipWithIndex__A1')  # <A1>
    _zipWithIndex__That = typing.TypeVar('_zipWithIndex__That')  # <That>
    def zipWithIndex(self, bf: scala.collection.generic.CanBuildFrom['Iterable'[_AbstractIterable__A], scala.Tuple2[_zipWithIndex__A1, typing.Any], _zipWithIndex__That]) -> _zipWithIndex__That: ...

_AbstractIterator__A = typing.TypeVar('_AbstractIterator__A')  # <A>
class AbstractIterator(scala.collection.Iterator[_AbstractIterator__A], typing.Generic[_AbstractIterator__A]):
    def __init__(self): ...
    _$colon$bslash__B = typing.TypeVar('_$colon$bslash__B')  # <B>
    def $colon$bslash(self, z: _.colon.bslash__B, op: scala.Function2[_AbstractIterator__A, _.colon.bslash__B, _.colon.bslash__B]) -> _.colon.bslash__B: ...
    _$div$colon__B = typing.TypeVar('_$div$colon__B')  # <B>
    def $div$colon(self, z: _.div.colon__B, op: scala.Function2[_.div.colon__B, _AbstractIterator__A, _.div.colon__B]) -> _.div.colon__B: ...
    _$plus$plus__B = typing.TypeVar('_$plus$plus__B')  # <B>
    def $plus$plus(self, that: scala.Function0[GenTraversableOnce[_.plus.plus__B]]) -> 'Iterator'[_.plus.plus__B]: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder) -> scala.collection.mutable.StringBuilder: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder, sep: str) -> scala.collection.mutable.StringBuilder: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder, start: str, sep: str, end: str) -> scala.collection.mutable.StringBuilder: ...
    _aggregate__B = typing.TypeVar('_aggregate__B')  # <B>
    def aggregate(self, z: scala.Function0[_aggregate__B], seqop: scala.Function2[_aggregate__B, _AbstractIterator__A, _aggregate__B], combop: scala.Function2[_aggregate__B, _aggregate__B, _aggregate__B]) -> _aggregate__B: ...
    def buffered(self) -> 'BufferedIterator'[_AbstractIterator__A]: ...
    _collect__B = typing.TypeVar('_collect__B')  # <B>
    def collect(self, pf: scala.PartialFunction[_AbstractIterator__A, _collect__B]) -> 'Iterator'[_collect__B]: ...
    _collectFirst__B = typing.TypeVar('_collectFirst__B')  # <B>
    def collectFirst(self, pf: scala.PartialFunction[_AbstractIterator__A, _collectFirst__B]) -> scala.Option[_collectFirst__B]: ...
    def contains(self, elem: typing.Any) -> bool: ...
    _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
    _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
    _copyToArray_2__B = typing.TypeVar('_copyToArray_2__B')  # <B>
    @typing.overload
    def copyToArray(self, xs: typing.Any) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
    _copyToBuffer__B = typing.TypeVar('_copyToBuffer__B')  # <B>
    def copyToBuffer(self, dest: scala.collection.mutable.Buffer[_copyToBuffer__B]) -> None: ...
    _corresponds__B = typing.TypeVar('_corresponds__B')  # <B>
    def corresponds(self, that: GenTraversableOnce[_corresponds__B], p: scala.Function2[_AbstractIterator__A, _corresponds__B, typing.Any]) -> bool: ...
    def count(self, p: scala.Function1[_AbstractIterator__A, typing.Any]) -> int: ...
    def drop(self, n: int) -> 'Iterator'[_AbstractIterator__A]: ...
    def dropWhile(self, p: scala.Function1[_AbstractIterator__A, typing.Any]) -> 'Iterator'[_AbstractIterator__A]: ...
    def duplicate(self) -> scala.Tuple2['Iterator'[_AbstractIterator__A], 'Iterator'[_AbstractIterator__A]]: ...
    def exists(self, p: scala.Function1[_AbstractIterator__A, typing.Any]) -> bool: ...
    def filter(self, p: scala.Function1[_AbstractIterator__A, typing.Any]) -> 'Iterator'[_AbstractIterator__A]: ...
    def filterNot(self, p: scala.Function1[_AbstractIterator__A, typing.Any]) -> 'Iterator'[_AbstractIterator__A]: ...
    def find(self, p: scala.Function1[_AbstractIterator__A, typing.Any]) -> scala.Option[_AbstractIterator__A]: ...
    _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
    def flatMap(self, f: scala.Function1[_AbstractIterator__A, GenTraversableOnce[_flatMap__B]]) -> 'Iterator'[_flatMap__B]: ...
    _fold__A1 = typing.TypeVar('_fold__A1')  # <A1>
    def fold(self, z: _fold__A1, op: scala.Function2[_fold__A1, _fold__A1, _fold__A1]) -> _fold__A1: ...
    _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
    def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, _AbstractIterator__A, _foldLeft__B]) -> _foldLeft__B: ...
    _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
    def foldRight(self, z: _foldRight__B, op: scala.Function2[_AbstractIterator__A, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
    def forall(self, p: scala.Function1[_AbstractIterator__A, typing.Any]) -> bool: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_AbstractIterator__A, _foreach__U]) -> None: ...
    _grouped__B = typing.TypeVar('_grouped__B')  # <B>
    def grouped(self, size: int) -> 'Iterator.GroupedIterator'[_grouped__B]: ...
    def hasDefiniteSize(self) -> bool: ...
    _indexOf_0__B = typing.TypeVar('_indexOf_0__B')  # <B>
    _indexOf_1__B = typing.TypeVar('_indexOf_1__B')  # <B>
    @typing.overload
    def indexOf(self, elem: _indexOf_0__B) -> int: ...
    @typing.overload
    def indexOf(self, elem: _indexOf_1__B, from_: int) -> int: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[_AbstractIterator__A, typing.Any]) -> int: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[_AbstractIterator__A, typing.Any], from_: int) -> int: ...
    def isEmpty(self) -> bool: ...
    def isTraversableAgain(self) -> bool: ...
    def length(self) -> int: ...
    _map__B = typing.TypeVar('_map__B')  # <B>
    def map(self, f: scala.Function1[_AbstractIterator__A, _map__B]) -> 'Iterator'[_map__B]: ...
    _max__B = typing.TypeVar('_max__B')  # <B>
    def max(self, cmp: scala.math.Ordering[_max__B]) -> _AbstractIterator__A: ...
    _maxBy__B = typing.TypeVar('_maxBy__B')  # <B>
    def maxBy(self, f: scala.Function1[_AbstractIterator__A, _maxBy__B], cmp: scala.math.Ordering[_maxBy__B]) -> _AbstractIterator__A: ...
    _min__B = typing.TypeVar('_min__B')  # <B>
    def min(self, cmp: scala.math.Ordering[_min__B]) -> _AbstractIterator__A: ...
    _minBy__B = typing.TypeVar('_minBy__B')  # <B>
    def minBy(self, f: scala.Function1[_AbstractIterator__A, _minBy__B], cmp: scala.math.Ordering[_minBy__B]) -> _AbstractIterator__A: ...
    @typing.overload
    def mkString(self) -> str: ...
    @typing.overload
    def mkString(self, sep: str) -> str: ...
    @typing.overload
    def mkString(self, start: str, sep: str, end: str) -> str: ...
    def nonEmpty(self) -> bool: ...
    _padTo__A1 = typing.TypeVar('_padTo__A1')  # <A1>
    def padTo(self, len: int, elem: _padTo__A1) -> 'Iterator'[_padTo__A1]: ...
    def partition(self, p: scala.Function1[_AbstractIterator__A, typing.Any]) -> scala.Tuple2['Iterator'[_AbstractIterator__A], 'Iterator'[_AbstractIterator__A]]: ...
    _patch__B = typing.TypeVar('_patch__B')  # <B>
    def patch(self, from_: int, patchElems: 'Iterator'[_patch__B], replaced: int) -> 'Iterator'[_patch__B]: ...
    _product__B = typing.TypeVar('_product__B')  # <B>
    def product(self, num: scala.math.Numeric[_product__B]) -> _product__B: ...
    _reduce__A1 = typing.TypeVar('_reduce__A1')  # <A1>
    def reduce(self, op: scala.Function2[_reduce__A1, _reduce__A1, _reduce__A1]) -> _reduce__A1: ...
    _reduceLeft__B = typing.TypeVar('_reduceLeft__B')  # <B>
    def reduceLeft(self, op: scala.Function2[_reduceLeft__B, _AbstractIterator__A, _reduceLeft__B]) -> _reduceLeft__B: ...
    _reduceLeftOption__B = typing.TypeVar('_reduceLeftOption__B')  # <B>
    def reduceLeftOption(self, op: scala.Function2[_reduceLeftOption__B, _AbstractIterator__A, _reduceLeftOption__B]) -> scala.Option[_reduceLeftOption__B]: ...
    _reduceOption__A1 = typing.TypeVar('_reduceOption__A1')  # <A1>
    def reduceOption(self, op: scala.Function2[_reduceOption__A1, _reduceOption__A1, _reduceOption__A1]) -> scala.Option[_reduceOption__A1]: ...
    _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
    def reduceRight(self, op: scala.Function2[_AbstractIterator__A, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
    _reduceRightOption__B = typing.TypeVar('_reduceRightOption__B')  # <B>
    def reduceRightOption(self, op: scala.Function2[_AbstractIterator__A, _reduceRightOption__B, _reduceRightOption__B]) -> scala.Option[_reduceRightOption__B]: ...
    def reversed(self) -> scala.collection.immutable.List[_AbstractIterator__A]: ...
    def sameElements(self, that: 'Iterator'[typing.Any]) -> bool: ...
    _scanLeft__B = typing.TypeVar('_scanLeft__B')  # <B>
    def scanLeft(self, z: _scanLeft__B, op: scala.Function2[_scanLeft__B, _AbstractIterator__A, _scanLeft__B]) -> 'Iterator'[_scanLeft__B]: ...
    _scanRight__B = typing.TypeVar('_scanRight__B')  # <B>
    def scanRight(self, z: _scanRight__B, op: scala.Function2[_AbstractIterator__A, _scanRight__B, _scanRight__B]) -> 'Iterator'[_scanRight__B]: ...
    def seq(self) -> 'Iterator'[_AbstractIterator__A]: ...
    def size(self) -> int: ...
    def sizeHintIfCheap(self) -> int: ...
    def slice(self, from_: int, until: int) -> 'Iterator'[_AbstractIterator__A]: ...
    def sliceIterator(self, from_: int, until: int) -> 'Iterator'[_AbstractIterator__A]: ...
    _sliding__B = typing.TypeVar('_sliding__B')  # <B>
    def sliding(self, size: int, step: int) -> 'Iterator.GroupedIterator'[_sliding__B]: ...
    _sliding$default$2__B = typing.TypeVar('_sliding$default$2__B')  # <B>
    def sliding$default$2(self) -> int: ...
    def span(self, p: scala.Function1[_AbstractIterator__A, typing.Any]) -> scala.Tuple2['Iterator'[_AbstractIterator__A], 'Iterator'[_AbstractIterator__A]]: ...
    _sum__B = typing.TypeVar('_sum__B')  # <B>
    def sum(self, num: scala.math.Numeric[_sum__B]) -> _sum__B: ...
    def take(self, n: int) -> 'Iterator'[_AbstractIterator__A]: ...
    def takeWhile(self, p: scala.Function1[_AbstractIterator__A, typing.Any]) -> 'Iterator'[_AbstractIterator__A]: ...
    _to__Col = typing.TypeVar('_to__Col')  # <Col>
    def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., _AbstractIterator__A, _to__Col]) -> _to__Col: ...
    _toArray__B = typing.TypeVar('_toArray__B')  # <B>
    def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__B]) -> typing.Any: ...
    _toBuffer__B = typing.TypeVar('_toBuffer__B')  # <B>
    def toBuffer(self) -> scala.collection.mutable.Buffer[_toBuffer__B]: ...
    def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq[_AbstractIterator__A]: ...
    def toIterable(self) -> 'Iterable'[_AbstractIterator__A]: ...
    def toIterator(self) -> 'Iterator'[_AbstractIterator__A]: ...
    def toList(self) -> scala.collection.immutable.List[_AbstractIterator__A]: ...
    _toMap__T = typing.TypeVar('_toMap__T')  # <T>
    _toMap__U = typing.TypeVar('_toMap__U')  # <U>
    def toMap(self, ev: scala.Predef..less.colon.less[_AbstractIterator__A, scala.Tuple2[_toMap__T, _toMap__U]]) -> scala.collection.immutable.Map[_toMap__T, _toMap__U]: ...
    def toSeq(self) -> 'Seq'[_AbstractIterator__A]: ...
    _toSet__B = typing.TypeVar('_toSet__B')  # <B>
    def toSet(self) -> scala.collection.immutable.Set[_toSet__B]: ...
    def toStream(self) -> scala.collection.immutable.Stream[_AbstractIterator__A]: ...
    def toString(self) -> str: ...
    def toTraversable(self) -> 'Traversable'[_AbstractIterator__A]: ...
    def toVector(self) -> scala.collection.immutable.Vector[_AbstractIterator__A]: ...
    def withFilter(self, p: scala.Function1[_AbstractIterator__A, typing.Any]) -> 'Iterator'[_AbstractIterator__A]: ...
    _zip__B = typing.TypeVar('_zip__B')  # <B>
    def zip(self, that: 'Iterator'[_zip__B]) -> 'Iterator'[scala.Tuple2[_AbstractIterator__A, _zip__B]]: ...
    _zipAll__B = typing.TypeVar('_zipAll__B')  # <B>
    _zipAll__A1 = typing.TypeVar('_zipAll__A1')  # <A1>
    _zipAll__B1 = typing.TypeVar('_zipAll__B1')  # <B1>
    def zipAll(self, that: 'Iterator'[_zipAll__B], thisElem: _zipAll__A1, thatElem: _zipAll__B1) -> 'Iterator'[scala.Tuple2[_zipAll__A1, _zipAll__B1]]: ...
    def zipWithIndex(self) -> 'Iterator'[scala.Tuple2[_AbstractIterator__A, typing.Any]]: ...

_AbstractMap__K = typing.TypeVar('_AbstractMap__K')  # <K>
_AbstractMap__V = typing.TypeVar('_AbstractMap__V')  # <V>
class AbstractMap(AbstractIterable[scala.Tuple2[_AbstractMap__K, _AbstractMap__V]], scala.collection.Map[_AbstractMap__K, _AbstractMap__V], typing.Generic[_AbstractMap__K, _AbstractMap__V]):
    def __init__(self): ...
    @typing.overload
    def $minus(self, key: _AbstractMap__K) -> typing.Any: ...
    @typing.overload
    def $minus(self, key: _AbstractMap__K) -> 'MapLike': ...
    @typing.overload
    def $minus(self, elem: typing.Any) -> scala.collection.generic.Subtractable: ...
    @typing.overload
    def $minus(self, elem1: typing.Any, elem2: typing.Any, elems: 'Seq') -> scala.collection.generic.Subtractable: ...
    def $minus$minus(self, xs: GenTraversableOnce) -> scala.collection.generic.Subtractable: ...
    _$plus_0__V1 = typing.TypeVar('_$plus_0__V1')  # <V1>
    _$plus_1__V1 = typing.TypeVar('_$plus_1__V1')  # <V1>
    _$plus_2__V1 = typing.TypeVar('_$plus_2__V1')  # <V1>
    @typing.overload
    def $plus(self, kv: scala.Tuple2[_AbstractMap__K, _.plus_0__V1]) -> GenMap[_AbstractMap__K, _.plus_0__V1]: ...
    @typing.overload
    def $plus(self, kv: scala.Tuple2[_AbstractMap__K, _.plus_1__V1]) -> 'Map'[_AbstractMap__K, _.plus_1__V1]: ...
    @typing.overload
    def $plus(self, kv1: scala.Tuple2[_AbstractMap__K, _.plus_2__V1], kv2: scala.Tuple2[_AbstractMap__K, _.plus_2__V1], kvs: 'Seq'[scala.Tuple2[_AbstractMap__K, _.plus_2__V1]]) -> 'Map'[_AbstractMap__K, _.plus_2__V1]: ...
    _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
    _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
    _$plus$plus_1__V1 = typing.TypeVar('_$plus$plus_1__V1')  # <V1>
    @typing.overload
    def $plus$plus(self, that: GenTraversableOnce[_.plus.plus_0__B], bf: scala.collection.generic.CanBuildFrom['Traversable'[typing.Any], _.plus.plus_0__B, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
    @typing.overload
    def $plus$plus(self, xs: GenTraversableOnce[scala.Tuple2[_AbstractMap__K, _.plus.plus_1__V1]]) -> 'Map'[_AbstractMap__K, _.plus.plus_1__V1]: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder, start: str, sep: str, end: str) -> scala.collection.mutable.StringBuilder: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder) -> scala.collection.mutable.StringBuilder: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder, sep: str) -> scala.collection.mutable.StringBuilder: ...
    _andThen__C = typing.TypeVar('_andThen__C')  # <C>
    def andThen(self, k: scala.Function1[_AbstractMap__V, _andThen__C]) -> scala.PartialFunction[_AbstractMap__K, _andThen__C]: ...
    def apply(self, key: _AbstractMap__K) -> _AbstractMap__V: ...
    def apply$mcDD$sp(self, v1: float) -> float: ...
    def apply$mcDF$sp(self, v1: float) -> float: ...
    def apply$mcDI$sp(self, v1: int) -> float: ...
    def apply$mcDJ$sp(self, v1: int) -> float: ...
    def apply$mcFD$sp(self, v1: float) -> float: ...
    def apply$mcFF$sp(self, v1: float) -> float: ...
    def apply$mcFI$sp(self, v1: int) -> float: ...
    def apply$mcFJ$sp(self, v1: int) -> float: ...
    def apply$mcID$sp(self, v1: float) -> int: ...
    def apply$mcIF$sp(self, v1: float) -> int: ...
    def apply$mcII$sp(self, v1: int) -> int: ...
    def apply$mcIJ$sp(self, v1: int) -> int: ...
    def apply$mcJD$sp(self, v1: float) -> int: ...
    def apply$mcJF$sp(self, v1: float) -> int: ...
    def apply$mcJI$sp(self, v1: int) -> int: ...
    def apply$mcJJ$sp(self, v1: int) -> int: ...
    def apply$mcVD$sp(self, v1: float) -> None: ...
    def apply$mcVF$sp(self, v1: float) -> None: ...
    def apply$mcVI$sp(self, v1: int) -> None: ...
    def apply$mcVJ$sp(self, v1: int) -> None: ...
    def apply$mcZD$sp(self, v1: float) -> bool: ...
    def apply$mcZF$sp(self, v1: float) -> bool: ...
    def apply$mcZI$sp(self, v1: int) -> bool: ...
    def apply$mcZJ$sp(self, v1: int) -> bool: ...
    _applyOrElse__K1 = typing.TypeVar('_applyOrElse__K1')  # <K1>
    _applyOrElse__V1 = typing.TypeVar('_applyOrElse__V1')  # <V1>
    def applyOrElse(self, x: _applyOrElse__K1, default: scala.Function1[_applyOrElse__K1, _applyOrElse__V1]) -> _applyOrElse__V1: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    def compose(self, g: scala.Function1[_compose__A, _AbstractMap__K]) -> scala.Function1[_compose__A, _AbstractMap__V]: ...
    def contains(self, key: _AbstractMap__K) -> bool: ...
    def default(self, key: _AbstractMap__K) -> _AbstractMap__V: ...
    def empty(self) -> 'Map'[_AbstractMap__K, _AbstractMap__V]: ...
    def equals(self, that: typing.Any) -> bool: ...
    def filterKeys(self, p: scala.Function1[_AbstractMap__K, typing.Any]) -> 'Map'[_AbstractMap__K, _AbstractMap__V]: ...
    def filterNot(self, p: scala.Function1[scala.Tuple2[_AbstractMap__K, _AbstractMap__V], typing.Any]) -> 'Map'[_AbstractMap__K, _AbstractMap__V]: ...
    _getOrElse__V1 = typing.TypeVar('_getOrElse__V1')  # <V1>
    def getOrElse(self, key: _AbstractMap__K, default: scala.Function0[_getOrElse__V1]) -> _getOrElse__V1: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[typing.Any, typing.Any]) -> scala.collection.immutable.Map[typing.Any, 'Traversable'[typing.Any]]: ...
    def hashCode(self) -> int: ...
    def isDefinedAt(self, key: _AbstractMap__K) -> bool: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> 'Set'[_AbstractMap__K]: ...
    def keys(self) -> 'Iterable'[_AbstractMap__K]: ...
    def keysIterator(self) -> 'Iterator'[_AbstractMap__K]: ...
    def lift(self) -> scala.Function1[_AbstractMap__K, scala.Option[_AbstractMap__V]]: ...
    _mapValues__W = typing.TypeVar('_mapValues__W')  # <W>
    def mapValues(self, f: scala.Function1[_AbstractMap__V, _mapValues__W]) -> 'Map'[_AbstractMap__K, _mapValues__W]: ...
    def newBuilder(self) -> scala.collection.mutable.Builder[scala.Tuple2[_AbstractMap__K, _AbstractMap__V], 'Map'[_AbstractMap__K, _AbstractMap__V]]: ...
    _orElse__A1 = typing.TypeVar('_orElse__A1')  # <A1>
    _orElse__B1 = typing.TypeVar('_orElse__B1')  # <B1>
    def orElse(self, that: scala.PartialFunction[_orElse__A1, _orElse__B1]) -> scala.PartialFunction[_orElse__A1, _orElse__B1]: ...
    def parCombiner(self) -> scala.collection.parallel.Combiner[scala.Tuple2[_AbstractMap__K, _AbstractMap__V], scala.collection.parallel.ParMap[_AbstractMap__K, _AbstractMap__V]]: ...
    def repr(self) -> typing.Any: ...
    _runWith__U = typing.TypeVar('_runWith__U')  # <U>
    def runWith(self, action: scala.Function1[_AbstractMap__V, _runWith__U]) -> scala.Function1[_AbstractMap__K, typing.Any]: ...
    def seq(self) -> 'Map'[_AbstractMap__K, _AbstractMap__V]: ...
    def stringPrefix(self) -> str: ...
    def thisCollection(self) -> 'Iterable'[typing.Any]: ...
    _toBuffer__E = typing.TypeVar('_toBuffer__E')  # <E>
    def toBuffer(self) -> scala.collection.mutable.Buffer[_toBuffer__E]: ...
    def toCollection(self, repr: typing.Any) -> 'Iterable': ...
    def toIterable(self) -> 'Iterable'[typing.Any]: ...
    def toSeq(self) -> 'Seq'[scala.Tuple2[_AbstractMap__K, _AbstractMap__V]]: ...
    def toString(self) -> str: ...
    def toTraversable(self) -> 'Traversable'[typing.Any]: ...
    _updated__V1 = typing.TypeVar('_updated__V1')  # <V1>
    def updated(self, key: _AbstractMap__K, value: _updated__V1) -> 'Map'[_AbstractMap__K, _updated__V1]: ...
    def values(self) -> 'Iterable'[_AbstractMap__V]: ...
    def valuesIterator(self) -> 'Iterator'[_AbstractMap__V]: ...
    @typing.overload
    def view(self) -> 'IterableView'[typing.Any, 'Iterable'[typing.Any]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> 'IterableView'[typing.Any, 'Iterable'[typing.Any]]: ...

_AbstractSeq__A = typing.TypeVar('_AbstractSeq__A')  # <A>
class AbstractSeq(AbstractIterable[_AbstractSeq__A], scala.collection.Seq[_AbstractSeq__A], typing.Generic[_AbstractSeq__A]):
    def __init__(self): ...
    _$colon$plus__B = typing.TypeVar('_$colon$plus__B')  # <B>
    _$colon$plus__That = typing.TypeVar('_$colon$plus__That')  # <That>
    def $colon$plus(self, elem: _.colon.plus__B, bf: scala.collection.generic.CanBuildFrom['Seq'[_AbstractSeq__A], _.colon.plus__B, _.colon.plus__That]) -> _.colon.plus__That: ...
    _$plus$colon__B = typing.TypeVar('_$plus$colon__B')  # <B>
    _$plus$colon__That = typing.TypeVar('_$plus$colon__That')  # <That>
    def $plus$colon(self, elem: _.plus.colon__B, bf: scala.collection.generic.CanBuildFrom['Seq'[_AbstractSeq__A], _.plus.colon__B, _.plus.colon__That]) -> _.plus.colon__That: ...
    _andThen__C = typing.TypeVar('_andThen__C')  # <C>
    def andThen(self, k: scala.Function1[_AbstractSeq__A, _andThen__C]) -> scala.PartialFunction[typing.Any, _andThen__C]: ...
    def apply$mcDD$sp(self, v1: float) -> float: ...
    def apply$mcDF$sp(self, v1: float) -> float: ...
    def apply$mcDI$sp(self, v1: int) -> float: ...
    def apply$mcDJ$sp(self, v1: int) -> float: ...
    def apply$mcFD$sp(self, v1: float) -> float: ...
    def apply$mcFF$sp(self, v1: float) -> float: ...
    def apply$mcFI$sp(self, v1: int) -> float: ...
    def apply$mcFJ$sp(self, v1: int) -> float: ...
    def apply$mcID$sp(self, v1: float) -> int: ...
    def apply$mcIF$sp(self, v1: float) -> int: ...
    def apply$mcII$sp(self, v1: int) -> int: ...
    def apply$mcIJ$sp(self, v1: int) -> int: ...
    def apply$mcJD$sp(self, v1: float) -> int: ...
    def apply$mcJF$sp(self, v1: float) -> int: ...
    def apply$mcJI$sp(self, v1: int) -> int: ...
    def apply$mcJJ$sp(self, v1: int) -> int: ...
    def apply$mcVD$sp(self, v1: float) -> None: ...
    def apply$mcVF$sp(self, v1: float) -> None: ...
    def apply$mcVI$sp(self, v1: int) -> None: ...
    def apply$mcVJ$sp(self, v1: int) -> None: ...
    def apply$mcZD$sp(self, v1: float) -> bool: ...
    def apply$mcZF$sp(self, v1: float) -> bool: ...
    def apply$mcZI$sp(self, v1: int) -> bool: ...
    def apply$mcZJ$sp(self, v1: int) -> bool: ...
    def applyOrElse(self, x: typing.Any, default: scala.Function1) -> typing.Any: ...
    def combinations(self, n: int) -> 'Iterator'['Seq'[_AbstractSeq__A]]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['Seq']: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    def compose(self, g: scala.Function1[typing.Any, typing.Any]) -> scala.Function1[typing.Any, typing.Any]: ...
    _contains__A1 = typing.TypeVar('_contains__A1')  # <A1>
    def contains(self, elem: _contains__A1) -> bool: ...
    _containsSlice__B = typing.TypeVar('_containsSlice__B')  # <B>
    def containsSlice(self, that: GenSeq[_containsSlice__B]) -> bool: ...
    _corresponds__B = typing.TypeVar('_corresponds__B')  # <B>
    def corresponds(self, that: GenSeq[_corresponds__B], p: scala.Function2[_AbstractSeq__A, _corresponds__B, typing.Any]) -> bool: ...
    def diff(self, that: GenSeq) -> typing.Any: ...
    def distinct(self) -> typing.Any: ...
    _endsWith__B = typing.TypeVar('_endsWith__B')  # <B>
    def endsWith(self, that: GenSeq[_endsWith__B]) -> bool: ...
    def equals(self, that: typing.Any) -> bool: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[_AbstractSeq__A, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, 'Traversable'[_AbstractSeq__A]]: ...
    def hashCode(self) -> int: ...
    _indexOf_0__B = typing.TypeVar('_indexOf_0__B')  # <B>
    _indexOf_1__B = typing.TypeVar('_indexOf_1__B')  # <B>
    @typing.overload
    def indexOf(self, elem: _indexOf_0__B) -> int: ...
    @typing.overload
    def indexOf(self, elem: _indexOf_1__B, from_: int) -> int: ...
    _indexOfSlice_0__B = typing.TypeVar('_indexOfSlice_0__B')  # <B>
    _indexOfSlice_1__B = typing.TypeVar('_indexOfSlice_1__B')  # <B>
    @typing.overload
    def indexOfSlice(self, that: GenSeq[_indexOfSlice_0__B]) -> int: ...
    @typing.overload
    def indexOfSlice(self, that: GenSeq[_indexOfSlice_1__B], from_: int) -> int: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[_AbstractSeq__A, typing.Any]) -> int: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[_AbstractSeq__A, typing.Any], from_: int) -> int: ...
    def indices(self) -> scala.collection.immutable.Range: ...
    def intersect(self, that: GenSeq) -> typing.Any: ...
    def isDefinedAt(self, idx: int) -> bool: ...
    def isEmpty(self) -> bool: ...
    _lastIndexOf_0__B = typing.TypeVar('_lastIndexOf_0__B')  # <B>
    _lastIndexOf_1__B = typing.TypeVar('_lastIndexOf_1__B')  # <B>
    @typing.overload
    def lastIndexOf(self, elem: _lastIndexOf_0__B) -> int: ...
    @typing.overload
    def lastIndexOf(self, elem: _lastIndexOf_1__B, end: int) -> int: ...
    _lastIndexOfSlice_0__B = typing.TypeVar('_lastIndexOfSlice_0__B')  # <B>
    _lastIndexOfSlice_1__B = typing.TypeVar('_lastIndexOfSlice_1__B')  # <B>
    @typing.overload
    def lastIndexOfSlice(self, that: GenSeq[_lastIndexOfSlice_0__B]) -> int: ...
    @typing.overload
    def lastIndexOfSlice(self, that: GenSeq[_lastIndexOfSlice_1__B], end: int) -> int: ...
    @typing.overload
    def lastIndexWhere(self, p: scala.Function1[_AbstractSeq__A, typing.Any]) -> int: ...
    @typing.overload
    def lastIndexWhere(self, p: scala.Function1[_AbstractSeq__A, typing.Any], end: int) -> int: ...
    def lengthCompare(self, len: int) -> int: ...
    def lift(self) -> scala.Function1[typing.Any, scala.Option[_AbstractSeq__A]]: ...
    _orElse__A1 = typing.TypeVar('_orElse__A1')  # <A1>
    _orElse__B1 = typing.TypeVar('_orElse__B1')  # <B1>
    def orElse(self, that: scala.PartialFunction[_orElse__A1, _orElse__B1]) -> scala.PartialFunction[_orElse__A1, _orElse__B1]: ...
    _padTo__B = typing.TypeVar('_padTo__B')  # <B>
    _padTo__That = typing.TypeVar('_padTo__That')  # <That>
    def padTo(self, len: int, elem: _padTo__B, bf: scala.collection.generic.CanBuildFrom['Seq'[_AbstractSeq__A], _padTo__B, _padTo__That]) -> _padTo__That: ...
    def parCombiner(self) -> scala.collection.parallel.Combiner[_AbstractSeq__A, scala.collection.parallel.ParSeq[_AbstractSeq__A]]: ...
    _patch__B = typing.TypeVar('_patch__B')  # <B>
    _patch__That = typing.TypeVar('_patch__That')  # <That>
    def patch(self, from_: int, patch: GenSeq[_patch__B], replaced: int, bf: scala.collection.generic.CanBuildFrom['Seq'[_AbstractSeq__A], _patch__B, _patch__That]) -> _patch__That: ...
    def permutations(self) -> 'Iterator'['Seq'[_AbstractSeq__A]]: ...
    def prefixLength(self, p: scala.Function1[_AbstractSeq__A, typing.Any]) -> int: ...
    def reverse(self) -> typing.Any: ...
    def reverseIterator(self) -> 'Iterator'[_AbstractSeq__A]: ...
    _reverseMap__B = typing.TypeVar('_reverseMap__B')  # <B>
    _reverseMap__That = typing.TypeVar('_reverseMap__That')  # <That>
    def reverseMap(self, f: scala.Function1[_AbstractSeq__A, _reverseMap__B], bf: scala.collection.generic.CanBuildFrom['Seq'[_AbstractSeq__A], _reverseMap__B, _reverseMap__That]) -> _reverseMap__That: ...
    _runWith__U = typing.TypeVar('_runWith__U')  # <U>
    def runWith(self, action: scala.Function1[_AbstractSeq__A, _runWith__U]) -> scala.Function1[typing.Any, typing.Any]: ...
    def segmentLength(self, p: scala.Function1[_AbstractSeq__A, typing.Any], from_: int) -> int: ...
    def seq(self) -> 'Seq'[_AbstractSeq__A]: ...
    def size(self) -> int: ...
    def sortBy(self, f: scala.Function1, ord: scala.math.Ordering) -> typing.Any: ...
    def sortWith(self, lt: scala.Function2) -> typing.Any: ...
    def sorted(self, ord: scala.math.Ordering) -> typing.Any: ...
    _startsWith_0__B = typing.TypeVar('_startsWith_0__B')  # <B>
    _startsWith_1__B = typing.TypeVar('_startsWith_1__B')  # <B>
    @typing.overload
    def startsWith(self, that: GenSeq[_startsWith_0__B]) -> bool: ...
    @typing.overload
    def startsWith(self, that: GenSeq[_startsWith_1__B], offset: int) -> bool: ...
    def thisCollection(self) -> 'Seq'[_AbstractSeq__A]: ...
    def toCollection(self, repr: typing.Any) -> 'Seq': ...
    def toIterable(self) -> 'Iterable'[_AbstractSeq__A]: ...
    def toSeq(self) -> 'Seq'[_AbstractSeq__A]: ...
    def toString(self) -> str: ...
    def toTraversable(self) -> 'Traversable'[_AbstractSeq__A]: ...
    _union__B = typing.TypeVar('_union__B')  # <B>
    _union__That = typing.TypeVar('_union__That')  # <That>
    def union(self, that: GenSeq[_union__B], bf: scala.collection.generic.CanBuildFrom['Seq'[_AbstractSeq__A], _union__B, _union__That]) -> _union__That: ...
    _updated__B = typing.TypeVar('_updated__B')  # <B>
    _updated__That = typing.TypeVar('_updated__That')  # <That>
    def updated(self, index: int, elem: _updated__B, bf: scala.collection.generic.CanBuildFrom['Seq'[_AbstractSeq__A], _updated__B, _updated__That]) -> _updated__That: ...
    @typing.overload
    def view(self) -> 'SeqView'[_AbstractSeq__A, 'Seq'[_AbstractSeq__A]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> 'SeqView'[_AbstractSeq__A, 'Seq'[_AbstractSeq__A]]: ...

_AbstractSet__A = typing.TypeVar('_AbstractSet__A')  # <A>
class AbstractSet(AbstractIterable[_AbstractSet__A], scala.collection.Set[_AbstractSet__A], typing.Generic[_AbstractSet__A]):
    def __init__(self): ...
    def $amp(self, that: GenSet) -> typing.Any: ...
    def $amp$tilde(self, that: GenSet) -> typing.Any: ...
    def $bar(self, that: GenSet) -> typing.Any: ...
    @typing.overload
    def $minus(self, elem: _AbstractSet__A) -> typing.Any: ...
    @typing.overload
    def $minus(self, elem: _AbstractSet__A) -> 'SetLike': ...
    @typing.overload
    def $minus(self, elem: _AbstractSet__A) -> scala.collection.generic.Subtractable: ...
    @typing.overload
    def $minus(self, elem1: typing.Any, elem2: typing.Any, elems: 'Seq') -> scala.collection.generic.Subtractable: ...
    def $minus$minus(self, xs: GenTraversableOnce) -> scala.collection.generic.Subtractable: ...
    @typing.overload
    def $plus(self, elem: _AbstractSet__A) -> typing.Any: ...
    @typing.overload
    def $plus(self, elem: _AbstractSet__A) -> 'SetLike': ...
    @typing.overload
    def $plus(self, elem1: _AbstractSet__A, elem2: _AbstractSet__A, elems: 'Seq'[_AbstractSet__A]) -> 'Set'[_AbstractSet__A]: ...
    _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
    _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
    @typing.overload
    def $plus$plus(self, that: GenTraversableOnce[_.plus.plus_0__B], bf: scala.collection.generic.CanBuildFrom['Traversable'[_AbstractSet__A], _.plus.plus_0__B, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
    @typing.overload
    def $plus$plus(self, elems: GenTraversableOnce[_AbstractSet__A]) -> 'Set'[_AbstractSet__A]: ...
    _andThen__A = typing.TypeVar('_andThen__A')  # <A>
    def andThen(self, g: scala.Function1[typing.Any, typing.Any]) -> scala.Function1[typing.Any, typing.Any]: ...
    def apply(self, elem: _AbstractSet__A) -> bool: ...
    def apply$mcDD$sp(self, v1: float) -> float: ...
    def apply$mcDF$sp(self, v1: float) -> float: ...
    def apply$mcDI$sp(self, v1: int) -> float: ...
    def apply$mcDJ$sp(self, v1: int) -> float: ...
    def apply$mcFD$sp(self, v1: float) -> float: ...
    def apply$mcFF$sp(self, v1: float) -> float: ...
    def apply$mcFI$sp(self, v1: int) -> float: ...
    def apply$mcFJ$sp(self, v1: int) -> float: ...
    def apply$mcID$sp(self, v1: float) -> int: ...
    def apply$mcIF$sp(self, v1: float) -> int: ...
    def apply$mcII$sp(self, v1: int) -> int: ...
    def apply$mcIJ$sp(self, v1: int) -> int: ...
    def apply$mcJD$sp(self, v1: float) -> int: ...
    def apply$mcJF$sp(self, v1: float) -> int: ...
    def apply$mcJI$sp(self, v1: int) -> int: ...
    def apply$mcJJ$sp(self, v1: int) -> int: ...
    def apply$mcVD$sp(self, v1: float) -> None: ...
    def apply$mcVF$sp(self, v1: float) -> None: ...
    def apply$mcVI$sp(self, v1: int) -> None: ...
    def apply$mcVJ$sp(self, v1: int) -> None: ...
    def apply$mcZD$sp(self, v1: float) -> bool: ...
    def apply$mcZF$sp(self, v1: float) -> bool: ...
    def apply$mcZI$sp(self, v1: int) -> bool: ...
    def apply$mcZJ$sp(self, v1: int) -> bool: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['Set']: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    def compose(self, g: scala.Function1[typing.Any, typing.Any]) -> scala.Function1[typing.Any, typing.Any]: ...
    def diff(self, that: GenSet[_AbstractSet__A]) -> 'Set'[_AbstractSet__A]: ...
    def empty(self) -> GenSet: ...
    def equals(self, that: typing.Any) -> bool: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[_AbstractSet__A, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, 'Traversable'[_AbstractSet__A]]: ...
    def hashCode(self) -> int: ...
    def intersect(self, that: GenSet) -> typing.Any: ...
    def isEmpty(self) -> bool: ...
    _map__B = typing.TypeVar('_map__B')  # <B>
    _map__That = typing.TypeVar('_map__That')  # <That>
    def map(self, f: scala.Function1[_AbstractSet__A, _map__B], bf: scala.collection.generic.CanBuildFrom['Set'[_AbstractSet__A], _map__B, _map__That]) -> _map__That: ...
    def newBuilder(self) -> scala.collection.mutable.Builder[_AbstractSet__A, 'Set'[_AbstractSet__A]]: ...
    def parCombiner(self) -> scala.collection.parallel.Combiner[_AbstractSet__A, scala.collection.parallel.ParSet[_AbstractSet__A]]: ...
    def repr(self) -> typing.Any: ...
    def seq(self) -> 'Set'[_AbstractSet__A]: ...
    def stringPrefix(self) -> str: ...
    def subsetOf(self, that: GenSet[_AbstractSet__A]) -> bool: ...
    @typing.overload
    def subsets(self) -> 'Iterator'['Set'[_AbstractSet__A]]: ...
    @typing.overload
    def subsets(self, len: int) -> 'Iterator'['Set'[_AbstractSet__A]]: ...
    def thisCollection(self) -> 'Iterable'[_AbstractSet__A]: ...
    _toBuffer__A1 = typing.TypeVar('_toBuffer__A1')  # <A1>
    def toBuffer(self) -> scala.collection.mutable.Buffer[_toBuffer__A1]: ...
    def toCollection(self, repr: typing.Any) -> 'Iterable': ...
    def toIterable(self) -> 'Iterable'[_AbstractSet__A]: ...
    def toSeq(self) -> 'Seq'[_AbstractSet__A]: ...
    def toString(self) -> str: ...
    def toTraversable(self) -> 'Traversable'[_AbstractSet__A]: ...
    def union(self, that: GenSet[_AbstractSet__A]) -> 'Set'[_AbstractSet__A]: ...
    @typing.overload
    def view(self) -> 'IterableView'[_AbstractSet__A, 'Iterable'[_AbstractSet__A]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> 'IterableView'[_AbstractSet__A, 'Iterable'[_AbstractSet__A]]: ...

_AbstractTraversable__A = typing.TypeVar('_AbstractTraversable__A')  # <A>
class AbstractTraversable(scala.collection.Traversable[_AbstractTraversable__A], typing.Generic[_AbstractTraversable__A]):
    def __init__(self): ...
    _$colon$bslash__B = typing.TypeVar('_$colon$bslash__B')  # <B>
    def $colon$bslash(self, z: _.colon.bslash__B, op: scala.Function2[_AbstractTraversable__A, _.colon.bslash__B, _.colon.bslash__B]) -> _.colon.bslash__B: ...
    _$div$colon__B = typing.TypeVar('_$div$colon__B')  # <B>
    def $div$colon(self, z: _.div.colon__B, op: scala.Function2[_.div.colon__B, _AbstractTraversable__A, _.div.colon__B]) -> _.div.colon__B: ...
    _$plus$plus__B = typing.TypeVar('_$plus$plus__B')  # <B>
    _$plus$plus__That = typing.TypeVar('_$plus$plus__That')  # <That>
    def $plus$plus(self, that: GenTraversableOnce[_.plus.plus__B], bf: scala.collection.generic.CanBuildFrom['Traversable'[_AbstractTraversable__A], _.plus.plus__B, _.plus.plus__That]) -> _.plus.plus__That: ...
    _$plus$plus$colon_0__B = typing.TypeVar('_$plus$plus$colon_0__B')  # <B>
    _$plus$plus$colon_0__That = typing.TypeVar('_$plus$plus$colon_0__That')  # <That>
    _$plus$plus$colon_1__B = typing.TypeVar('_$plus$plus$colon_1__B')  # <B>
    _$plus$plus$colon_1__That = typing.TypeVar('_$plus$plus$colon_1__That')  # <That>
    @typing.overload
    def $plus$plus$colon(self, that: 'Traversable'[_.plus.plus.colon_0__B], bf: scala.collection.generic.CanBuildFrom['Traversable'[_AbstractTraversable__A], _.plus.plus.colon_0__B, _.plus.plus.colon_0__That]) -> _.plus.plus.colon_0__That: ...
    @typing.overload
    def $plus$plus$colon(self, that: 'TraversableOnce'[_.plus.plus.colon_1__B], bf: scala.collection.generic.CanBuildFrom['Traversable'[_AbstractTraversable__A], _.plus.plus.colon_1__B, _.plus.plus.colon_1__That]) -> _.plus.plus.colon_1__That: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder) -> scala.collection.mutable.StringBuilder: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder, sep: str) -> scala.collection.mutable.StringBuilder: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder, start: str, sep: str, end: str) -> scala.collection.mutable.StringBuilder: ...
    _aggregate__B = typing.TypeVar('_aggregate__B')  # <B>
    def aggregate(self, z: scala.Function0[_aggregate__B], seqop: scala.Function2[_aggregate__B, _AbstractTraversable__A, _aggregate__B], combop: scala.Function2[_aggregate__B, _aggregate__B, _aggregate__B]) -> _aggregate__B: ...
    _collect__B = typing.TypeVar('_collect__B')  # <B>
    _collect__That = typing.TypeVar('_collect__That')  # <That>
    def collect(self, pf: scala.PartialFunction[_AbstractTraversable__A, _collect__B], bf: scala.collection.generic.CanBuildFrom['Traversable'[_AbstractTraversable__A], _collect__B, _collect__That]) -> _collect__That: ...
    _collectFirst__B = typing.TypeVar('_collectFirst__B')  # <B>
    def collectFirst(self, pf: scala.PartialFunction[_AbstractTraversable__A, _collectFirst__B]) -> scala.Option[_collectFirst__B]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['Traversable']: ...
    _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
    _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
    _copyToArray_2__B = typing.TypeVar('_copyToArray_2__B')  # <B>
    @typing.overload
    def copyToArray(self, xs: typing.Any) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
    _copyToBuffer__B = typing.TypeVar('_copyToBuffer__B')  # <B>
    def copyToBuffer(self, dest: scala.collection.mutable.Buffer[_copyToBuffer__B]) -> None: ...
    def count(self, p: scala.Function1[_AbstractTraversable__A, typing.Any]) -> int: ...
    def drop(self, n: int) -> typing.Any: ...
    def dropWhile(self, p: scala.Function1) -> typing.Any: ...
    def exists(self, p: scala.Function1[_AbstractTraversable__A, typing.Any]) -> bool: ...
    def filter(self, p: scala.Function1) -> typing.Any: ...
    def filterImpl(self, p: scala.Function1, isFlipped: bool) -> typing.Any: ...
    def filterNot(self, p: scala.Function1) -> typing.Any: ...
    def find(self, p: scala.Function1[_AbstractTraversable__A, typing.Any]) -> scala.Option[_AbstractTraversable__A]: ...
    _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
    _flatMap__That = typing.TypeVar('_flatMap__That')  # <That>
    def flatMap(self, f: scala.Function1[_AbstractTraversable__A, GenTraversableOnce[_flatMap__B]], bf: scala.collection.generic.CanBuildFrom['Traversable'[_AbstractTraversable__A], _flatMap__B, _flatMap__That]) -> _flatMap__That: ...
    def flatten(self, asTraversable: scala.Function1) -> GenTraversable: ...
    _fold__A1 = typing.TypeVar('_fold__A1')  # <A1>
    def fold(self, z: _fold__A1, op: scala.Function2[_fold__A1, _fold__A1, _fold__A1]) -> _fold__A1: ...
    _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
    def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, _AbstractTraversable__A, _foldLeft__B]) -> _foldLeft__B: ...
    _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
    def foldRight(self, z: _foldRight__B, op: scala.Function2[_AbstractTraversable__A, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
    def forall(self, p: scala.Function1[_AbstractTraversable__A, typing.Any]) -> bool: ...
    _genericBuilder__B = typing.TypeVar('_genericBuilder__B')  # <B>
    def genericBuilder(self) -> scala.collection.mutable.Builder[_genericBuilder__B, 'Traversable'[_genericBuilder__B]]: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[_AbstractTraversable__A, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, 'Traversable'[_AbstractTraversable__A]]: ...
    def hasDefiniteSize(self) -> bool: ...
    def head(self) -> _AbstractTraversable__A: ...
    def headOption(self) -> scala.Option[_AbstractTraversable__A]: ...
    def init(self) -> typing.Any: ...
    def inits(self) -> 'Iterator'['Traversable'[_AbstractTraversable__A]]: ...
    def isEmpty(self) -> bool: ...
    def isTraversableAgain(self) -> bool: ...
    def last(self) -> _AbstractTraversable__A: ...
    def lastOption(self) -> scala.Option[_AbstractTraversable__A]: ...
    _map__B = typing.TypeVar('_map__B')  # <B>
    _map__That = typing.TypeVar('_map__That')  # <That>
    def map(self, f: scala.Function1[_AbstractTraversable__A, _map__B], bf: scala.collection.generic.CanBuildFrom['Traversable'[_AbstractTraversable__A], _map__B, _map__That]) -> _map__That: ...
    _max__B = typing.TypeVar('_max__B')  # <B>
    def max(self, cmp: scala.math.Ordering[_max__B]) -> _AbstractTraversable__A: ...
    _maxBy__B = typing.TypeVar('_maxBy__B')  # <B>
    def maxBy(self, f: scala.Function1[_AbstractTraversable__A, _maxBy__B], cmp: scala.math.Ordering[_maxBy__B]) -> _AbstractTraversable__A: ...
    _min__B = typing.TypeVar('_min__B')  # <B>
    def min(self, cmp: scala.math.Ordering[_min__B]) -> _AbstractTraversable__A: ...
    _minBy__B = typing.TypeVar('_minBy__B')  # <B>
    def minBy(self, f: scala.Function1[_AbstractTraversable__A, _minBy__B], cmp: scala.math.Ordering[_minBy__B]) -> _AbstractTraversable__A: ...
    @typing.overload
    def mkString(self) -> str: ...
    @typing.overload
    def mkString(self, sep: str) -> str: ...
    @typing.overload
    def mkString(self, start: str, sep: str, end: str) -> str: ...
    def newBuilder(self) -> scala.collection.mutable.Builder[_AbstractTraversable__A, 'Traversable'[_AbstractTraversable__A]]: ...
    def nonEmpty(self) -> bool: ...
    def par(self) -> Parallel: ...
    def parCombiner(self) -> scala.collection.parallel.Combiner[_AbstractTraversable__A, scala.collection.parallel.ParIterable[_AbstractTraversable__A]]: ...
    def partition(self, p: scala.Function1[_AbstractTraversable__A, typing.Any]) -> scala.Tuple2['Traversable'[_AbstractTraversable__A], 'Traversable'[_AbstractTraversable__A]]: ...
    _product__B = typing.TypeVar('_product__B')  # <B>
    def product(self, num: scala.math.Numeric[_product__B]) -> _product__B: ...
    _reduce__A1 = typing.TypeVar('_reduce__A1')  # <A1>
    def reduce(self, op: scala.Function2[_reduce__A1, _reduce__A1, _reduce__A1]) -> _reduce__A1: ...
    _reduceLeft__B = typing.TypeVar('_reduceLeft__B')  # <B>
    def reduceLeft(self, op: scala.Function2[_reduceLeft__B, _AbstractTraversable__A, _reduceLeft__B]) -> _reduceLeft__B: ...
    _reduceLeftOption__B = typing.TypeVar('_reduceLeftOption__B')  # <B>
    def reduceLeftOption(self, op: scala.Function2[_reduceLeftOption__B, _AbstractTraversable__A, _reduceLeftOption__B]) -> scala.Option[_reduceLeftOption__B]: ...
    _reduceOption__A1 = typing.TypeVar('_reduceOption__A1')  # <A1>
    def reduceOption(self, op: scala.Function2[_reduceOption__A1, _reduceOption__A1, _reduceOption__A1]) -> scala.Option[_reduceOption__A1]: ...
    _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
    def reduceRight(self, op: scala.Function2[_AbstractTraversable__A, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
    _reduceRightOption__B = typing.TypeVar('_reduceRightOption__B')  # <B>
    def reduceRightOption(self, op: scala.Function2[_AbstractTraversable__A, _reduceRightOption__B, _reduceRightOption__B]) -> scala.Option[_reduceRightOption__B]: ...
    def repr(self) -> typing.Any: ...
    def reversed(self) -> scala.collection.immutable.List[_AbstractTraversable__A]: ...
    _scan__B = typing.TypeVar('_scan__B')  # <B>
    _scan__That = typing.TypeVar('_scan__That')  # <That>
    def scan(self, z: _scan__B, op: scala.Function2[_scan__B, _scan__B, _scan__B], cbf: scala.collection.generic.CanBuildFrom['Traversable'[_AbstractTraversable__A], _scan__B, _scan__That]) -> _scan__That: ...
    _scanLeft__B = typing.TypeVar('_scanLeft__B')  # <B>
    _scanLeft__That = typing.TypeVar('_scanLeft__That')  # <That>
    def scanLeft(self, z: _scanLeft__B, op: scala.Function2[_scanLeft__B, _AbstractTraversable__A, _scanLeft__B], bf: scala.collection.generic.CanBuildFrom['Traversable'[_AbstractTraversable__A], _scanLeft__B, _scanLeft__That]) -> _scanLeft__That: ...
    _scanRight__B = typing.TypeVar('_scanRight__B')  # <B>
    _scanRight__That = typing.TypeVar('_scanRight__That')  # <That>
    def scanRight(self, z: _scanRight__B, op: scala.Function2[_AbstractTraversable__A, _scanRight__B, _scanRight__B], bf: scala.collection.generic.CanBuildFrom['Traversable'[_AbstractTraversable__A], _scanRight__B, _scanRight__That]) -> _scanRight__That: ...
    def seq(self) -> 'Traversable'[_AbstractTraversable__A]: ...
    def size(self) -> int: ...
    def sizeHintIfCheap(self) -> int: ...
    def slice(self, from_: int, until: int) -> typing.Any: ...
    def sliceWithKnownBound(self, from_: int, until: int) -> typing.Any: ...
    def sliceWithKnownDelta(self, from_: int, until: int, delta: int) -> typing.Any: ...
    def span(self, p: scala.Function1[_AbstractTraversable__A, typing.Any]) -> scala.Tuple2['Traversable'[_AbstractTraversable__A], 'Traversable'[_AbstractTraversable__A]]: ...
    def splitAt(self, n: int) -> scala.Tuple2['Traversable'[_AbstractTraversable__A], 'Traversable'[_AbstractTraversable__A]]: ...
    def stringPrefix(self) -> str: ...
    _sum__B = typing.TypeVar('_sum__B')  # <B>
    def sum(self, num: scala.math.Numeric[_sum__B]) -> _sum__B: ...
    def tail(self) -> typing.Any: ...
    def tails(self) -> 'Iterator'['Traversable'[_AbstractTraversable__A]]: ...
    def take(self, n: int) -> typing.Any: ...
    def takeWhile(self, p: scala.Function1) -> typing.Any: ...
    def thisCollection(self) -> 'Traversable'[_AbstractTraversable__A]: ...
    _to__Col = typing.TypeVar('_to__Col')  # <Col>
    def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., _AbstractTraversable__A, _to__Col]) -> _to__Col: ...
    _toArray__B = typing.TypeVar('_toArray__B')  # <B>
    def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__B]) -> typing.Any: ...
    _toBuffer__B = typing.TypeVar('_toBuffer__B')  # <B>
    def toBuffer(self) -> scala.collection.mutable.Buffer[_toBuffer__B]: ...
    def toCollection(self, repr: typing.Any) -> 'Traversable': ...
    def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq[_AbstractTraversable__A]: ...
    def toIterable(self) -> 'Iterable'[_AbstractTraversable__A]: ...
    def toIterator(self) -> 'Iterator'[_AbstractTraversable__A]: ...
    def toList(self) -> scala.collection.immutable.List[_AbstractTraversable__A]: ...
    _toMap__T = typing.TypeVar('_toMap__T')  # <T>
    _toMap__U = typing.TypeVar('_toMap__U')  # <U>
    def toMap(self, ev: scala.Predef..less.colon.less[_AbstractTraversable__A, scala.Tuple2[_toMap__T, _toMap__U]]) -> scala.collection.immutable.Map[_toMap__T, _toMap__U]: ...
    def toSeq(self) -> 'Seq'[_AbstractTraversable__A]: ...
    _toSet__B = typing.TypeVar('_toSet__B')  # <B>
    def toSet(self) -> scala.collection.immutable.Set[_toSet__B]: ...
    def toStream(self) -> scala.collection.immutable.Stream[_AbstractTraversable__A]: ...
    def toString(self) -> str: ...
    def toTraversable(self) -> 'Traversable'[_AbstractTraversable__A]: ...
    def toVector(self) -> scala.collection.immutable.Vector[_AbstractTraversable__A]: ...
    def transpose(self, asTraversable: scala.Function1) -> GenTraversable: ...
    _unzip__A1 = typing.TypeVar('_unzip__A1')  # <A1>
    _unzip__A2 = typing.TypeVar('_unzip__A2')  # <A2>
    def unzip(self, asPair: scala.Function1[_AbstractTraversable__A, scala.Tuple2[_unzip__A1, _unzip__A2]]) -> scala.Tuple2['Traversable'[_unzip__A1], 'Traversable'[_unzip__A2]]: ...
    _unzip3__A1 = typing.TypeVar('_unzip3__A1')  # <A1>
    _unzip3__A2 = typing.TypeVar('_unzip3__A2')  # <A2>
    _unzip3__A3 = typing.TypeVar('_unzip3__A3')  # <A3>
    def unzip3(self, asTriple: scala.Function1[_AbstractTraversable__A, scala.Tuple3[_unzip3__A1, _unzip3__A2, _unzip3__A3]]) -> scala.Tuple3['Traversable'[_unzip3__A1], 'Traversable'[_unzip3__A2], 'Traversable'[_unzip3__A3]]: ...
    @typing.overload
    def view(self) -> 'TraversableView'[_AbstractTraversable__A, 'Traversable'[_AbstractTraversable__A]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> 'TraversableView'[_AbstractTraversable__A, 'Traversable'[_AbstractTraversable__A]]: ...
    def withFilter(self, p: scala.Function1[_AbstractTraversable__A, typing.Any]) -> scala.collection.generic.FilterMonadic[_AbstractTraversable__A, 'Traversable'[_AbstractTraversable__A]]: ...

class BitSet(scala.collection.SortedSet[typing.Any], scala.collection.BitSetLike['BitSet']):
    @staticmethod
    def $init$($this: 'BitSet') -> None: ...
    @staticmethod
    def bitsetCanBuildFrom() -> scala.collection.generic.CanBuildFrom['BitSet', typing.Any, 'BitSet']: ...
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['BitSet', typing.Any, 'BitSet']: ...
    @typing.overload
    def empty(self) -> 'BitSetLike': ...
    @typing.overload
    def empty(self) -> 'SetLike': ...
    @typing.overload
    def empty(self) -> 'BitSet': ...
    @typing.overload
    def empty(self) -> GenSet: ...
    @typing.overload
    def empty(self) -> 'SortedSet'[typing.Any]: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...

_BitSetLike__This = typing.TypeVar('_BitSetLike__This', bound='BitSetLike')  # <This>
class BitSetLike(scala.collection.SortedSetLike[typing.Any, _BitSetLike__This], typing.Generic[_BitSetLike__This]):
    @typing.overload
    def $amp(self, that: GenSet[typing.Any]) -> typing.Any: ...
    @typing.overload
    def $amp(self, other: BitSet) -> _BitSetLike__This: ...
    @typing.overload
    def $amp$tilde(self, that: GenSet[typing.Any]) -> typing.Any: ...
    @typing.overload
    def $amp$tilde(self, other: BitSet) -> _BitSetLike__This: ...
    @typing.overload
    def $bar(self, that: GenSet[typing.Any]) -> typing.Any: ...
    @typing.overload
    def $bar(self, other: BitSet) -> _BitSetLike__This: ...
    @staticmethod
    def $init$($this: 'BitSetLike') -> None: ...
    def $up(self, other: BitSet) -> _BitSetLike__This: ...
    @typing.overload
    def addString(self, sb: scala.collection.mutable.StringBuilder, start: str, sep: str, end: str) -> scala.collection.mutable.StringBuilder: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder) -> scala.collection.mutable.StringBuilder: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder, sep: str) -> scala.collection.mutable.StringBuilder: ...
    @typing.overload
    def contains(self, elem: typing.Any) -> bool: ...
    @typing.overload
    def contains(self, elem: int) -> bool: ...
    @typing.overload
    def empty(self) -> _BitSetLike__This: ...
    @typing.overload
    def empty(self) -> _BitSetLike__This: ...
    def equals(self, that: typing.Any) -> bool: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[typing.Any, _foreach__U]) -> None: ...
    def fromBitMaskNoCopy(self, elems: typing.List[int]) -> _BitSetLike__This: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def head(self) -> int: ...
    @typing.overload
    def head(self) -> typing.Any: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> 'Iterator'[typing.Any]: ...
    @typing.overload
    def keysIteratorFrom(self, start: typing.Any) -> 'Iterator'[typing.Any]: ...
    @typing.overload
    def keysIteratorFrom(self, start: int) -> AbstractIterator[typing.Any]: ...
    @typing.overload
    def last(self) -> int: ...
    @typing.overload
    def last(self) -> typing.Any: ...
    def nwords(self) -> int: ...
    def ordering(self) -> scala.math.Ordering[typing.Any]: ...
    @typing.overload
    def rangeImpl(self, from_: scala.Option[typing.Any], until: scala.Option[typing.Any]) -> _BitSetLike__This: ...
    @typing.overload
    def rangeImpl(self, from_: scala.Option[typing.Any], until: scala.Option[typing.Any]) -> _BitSetLike__This: ...
    @typing.overload
    def rangeImpl(self, from_: scala.Option[typing.Any], until: scala.Option[typing.Any]) -> _BitSetLike__This: ...
    def size(self) -> int: ...
    def stringPrefix(self) -> str: ...
    @typing.overload
    def subsetOf(self, other: BitSet) -> bool: ...
    @typing.overload
    def subsetOf(self, that: GenSet[typing.Any]) -> bool: ...
    def toBitMask(self) -> typing.List[int]: ...
    def toString(self) -> str: ...
    def word(self, idx: int) -> int: ...

_BufferedIterator__A = typing.TypeVar('_BufferedIterator__A')  # <A>
class BufferedIterator(scala.collection.Iterator[_BufferedIterator__A], typing.Generic[_BufferedIterator__A]):
    @staticmethod
    def $init$($this: 'BufferedIterator') -> None: ...
    def buffered(self) -> 'BufferedIterator'[_BufferedIterator__A]: ...
    def head(self) -> _BufferedIterator__A: ...
    def headOption(self) -> scala.Option[_BufferedIterator__A]: ...
    def toString(self) -> str: ...

_DefaultMap__A = typing.TypeVar('_DefaultMap__A')  # <A>
_DefaultMap__B = typing.TypeVar('_DefaultMap__B')  # <B>
class DefaultMap(scala.collection.Map[_DefaultMap__A, _DefaultMap__B], typing.Generic[_DefaultMap__A, _DefaultMap__B]):
    @staticmethod
    def $init$($this: 'DefaultMap') -> None: ...
    @typing.overload
    def $minus(self, key: typing.Any) -> typing.Any: ...
    @typing.overload
    def $minus(self, elem: _DefaultMap__A) -> scala.collection.generic.Subtractable: ...
    @typing.overload
    def $minus(self, key: _DefaultMap__A) -> 'Map'[_DefaultMap__A, _DefaultMap__B]: ...
    @typing.overload
    def $minus(self, elem1: _DefaultMap__A, elem2: _DefaultMap__A, elems: 'Seq'[_DefaultMap__A]) -> scala.collection.generic.Subtractable: ...
    _$plus_0__V1 = typing.TypeVar('_$plus_0__V1')  # <V1>
    _$plus_1__B1 = typing.TypeVar('_$plus_1__B1')  # <B1>
    _$plus_2__V1 = typing.TypeVar('_$plus_2__V1')  # <V1>
    @typing.overload
    def $plus(self, kv: scala.Tuple2[typing.Any, _.plus_0__V1]) -> GenMap[typing.Any, _.plus_0__V1]: ...
    @typing.overload
    def $plus(self, kv: scala.Tuple2[_DefaultMap__A, _.plus_1__B1]) -> 'Map'[_DefaultMap__A, _.plus_1__B1]: ...
    @typing.overload
    def $plus(self, kv1: scala.Tuple2[typing.Any, _.plus_2__V1], kv2: scala.Tuple2[typing.Any, _.plus_2__V1], kvs: 'Seq'[scala.Tuple2[typing.Any, _.plus_2__V1]]) -> 'Map'[typing.Any, _.plus_2__V1]: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...

_IndexedSeq__A = typing.TypeVar('_IndexedSeq__A')  # <A>
class IndexedSeq(scala.collection.Seq[_IndexedSeq__A], scala.collection.IndexedSeqLike[_IndexedSeq__A, 'IndexedSeq'[_IndexedSeq__A]], typing.Generic[_IndexedSeq__A]):
    @staticmethod
    def $init$($this: 'IndexedSeq') -> None: ...
    @staticmethod
    def ReusableCBF() -> scala.collection.generic.GenTraversableFactory.GenericCanBuildFrom[scala.runtime.Nothing.]: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['IndexedSeq'[typing.Any], _canBuildFrom__A, 'IndexedSeq'[_canBuildFrom__A]]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['IndexedSeq']: ...
    @staticmethod
    def concat(xss: 'Seq') -> GenTraversable: ...
    @staticmethod
    def empty() -> GenTraversable: ...
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, n5: int, elem: scala.Function0) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, elem: scala.Function0) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, elem: scala.Function0) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, elem: scala.Function0) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n: int, elem: scala.Function0) -> GenTraversable: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def iterate(start: typing.Any, len: int, f: scala.Function1) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, step: typing.Any, evidence$2: scala.math.Integral) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, evidence$1: scala.math.Integral) -> GenTraversable: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[_IndexedSeq__A]: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[_IndexedSeq__A]: ...
    @typing.overload
    def seq(self) -> 'IndexedSeq'[_IndexedSeq__A]: ...
    @typing.overload
    def seq(self) -> 'Iterable'[_IndexedSeq__A]: ...
    @typing.overload
    def seq(self) -> 'Seq'[_IndexedSeq__A]: ...
    @typing.overload
    def seq(self) -> 'Traversable'[_IndexedSeq__A]: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, n5: int, f: scala.Function5) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, f: scala.Function4) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, f: scala.Function3) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, f: scala.Function2) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n: int, f: scala.Function1) -> GenTraversable: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self) -> str: ...
    @staticmethod
    def unapplySeq(x: 'Seq') -> scala.Some: ...

_IndexedSeqLike__A = typing.TypeVar('_IndexedSeqLike__A')  # <A>
_IndexedSeqLike__Repr = typing.TypeVar('_IndexedSeqLike__Repr')  # <Repr>
class IndexedSeqLike(scala.collection.SeqLike[_IndexedSeqLike__A, _IndexedSeqLike__Repr], typing.Generic[_IndexedSeqLike__A, _IndexedSeqLike__Repr]):
    @staticmethod
    def $init$($this: 'IndexedSeqLike') -> None: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def iterator(self) -> 'Iterator'[_IndexedSeqLike__A]: ...
    @typing.overload
    def seq(self) -> IndexedSeq[_IndexedSeqLike__A]: ...
    @typing.overload
    def seq(self) -> 'Seq'[_IndexedSeqLike__A]: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[_IndexedSeqLike__A]: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[_IndexedSeqLike__A]: ...
    def sizeHintIfCheap(self) -> int: ...
    @typing.overload
    def thisCollection(self) -> IndexedSeq[_IndexedSeqLike__A]: ...
    @typing.overload
    def thisCollection(self) -> 'Iterable'[_IndexedSeqLike__A]: ...
    @typing.overload
    def thisCollection(self) -> 'Seq'[_IndexedSeqLike__A]: ...
    @typing.overload
    def thisCollection(self) -> 'Traversable'[_IndexedSeqLike__A]: ...
    _toBuffer__A1 = typing.TypeVar('_toBuffer__A1')  # <A1>
    def toBuffer(self) -> scala.collection.mutable.Buffer[_toBuffer__A1]: ...
    @typing.overload
    def toCollection(self, repr: _IndexedSeqLike__Repr) -> IndexedSeq[_IndexedSeqLike__A]: ...
    @typing.overload
    def toCollection(self, repr: _IndexedSeqLike__Repr) -> 'Iterable'[_IndexedSeqLike__A]: ...
    @typing.overload
    def toCollection(self, repr: _IndexedSeqLike__Repr) -> 'Seq'[_IndexedSeqLike__A]: ...
    @typing.overload
    def toCollection(self, repr: _IndexedSeqLike__Repr) -> 'Traversable'[_IndexedSeqLike__A]: ...
    def toString(self) -> str: ...
    class Elements(AbstractIterator[_IndexedSeqLike__A], BufferedIterator[_IndexedSeqLike__A], scala.Serializable):
        serialVersionUID: typing.ClassVar[int] = ...
        $outer: 'IndexedSeqLike' = ...
        def __init__(self, $outer: 'IndexedSeqLike', start: int, end: int): ...
        def buffered(self) -> BufferedIterator[_IndexedSeqLike__A]: ...
        def drop(self, n: int) -> 'Iterator'[_IndexedSeqLike__A]: ...
        def hasNext(self) -> bool: ...
        def head(self) -> _IndexedSeqLike__A: ...
        def headOption(self) -> scala.Option[_IndexedSeqLike__A]: ...
        def next(self) -> _IndexedSeqLike__A: ...
        def slice(self, from_: int, until: int) -> 'Iterator'[_IndexedSeqLike__A]: ...
        def take(self, n: int) -> 'Iterator'[_IndexedSeqLike__A]: ...

_IndexedSeqOptimized__A = typing.TypeVar('_IndexedSeqOptimized__A')  # <A>
_IndexedSeqOptimized__Repr = typing.TypeVar('_IndexedSeqOptimized__Repr')  # <Repr>
class IndexedSeqOptimized(IndexedSeqLike[_IndexedSeqOptimized__A, _IndexedSeqOptimized__Repr], typing.Generic[_IndexedSeqOptimized__A, _IndexedSeqOptimized__Repr]):
    @staticmethod
    def $init$($this: 'IndexedSeqOptimized') -> None: ...
    _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
    _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
    _copyToArray_2__B = typing.TypeVar('_copyToArray_2__B')  # <B>
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int) -> None: ...
    def drop(self, n: int) -> _IndexedSeqOptimized__Repr: ...
    def dropRight(self, n: int) -> _IndexedSeqOptimized__Repr: ...
    def dropWhile(self, p: scala.Function1[_IndexedSeqOptimized__A, typing.Any]) -> _IndexedSeqOptimized__Repr: ...
    _endsWith__B = typing.TypeVar('_endsWith__B')  # <B>
    def endsWith(self, that: GenSeq[_endsWith__B]) -> bool: ...
    def equals(self, that: typing.Any) -> bool: ...
    def exists(self, p: scala.Function1[_IndexedSeqOptimized__A, typing.Any]) -> bool: ...
    def find(self, p: scala.Function1[_IndexedSeqOptimized__A, typing.Any]) -> scala.Option[_IndexedSeqOptimized__A]: ...
    _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
    def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, _IndexedSeqOptimized__A, _foldLeft__B]) -> _foldLeft__B: ...
    _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
    def foldRight(self, z: _foldRight__B, op: scala.Function2[_IndexedSeqOptimized__A, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
    def forall(self, p: scala.Function1[_IndexedSeqOptimized__A, typing.Any]) -> bool: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_IndexedSeqOptimized__A, _foreach__U]) -> None: ...
    def hashCode(self) -> int: ...
    def head(self) -> _IndexedSeqOptimized__A: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[_IndexedSeqOptimized__A, typing.Any]) -> int: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[_IndexedSeqOptimized__A, typing.Any], from_: int) -> int: ...
    def init(self) -> _IndexedSeqOptimized__Repr: ...
    def isEmpty(self) -> bool: ...
    def last(self) -> _IndexedSeqOptimized__A: ...
    @typing.overload
    def lastIndexWhere(self, p: scala.Function1[_IndexedSeqOptimized__A, typing.Any]) -> int: ...
    @typing.overload
    def lastIndexWhere(self, p: scala.Function1[_IndexedSeqOptimized__A, typing.Any], end: int) -> int: ...
    def lengthCompare(self, len: int) -> int: ...
    _reduceLeft__B = typing.TypeVar('_reduceLeft__B')  # <B>
    def reduceLeft(self, op: scala.Function2[_reduceLeft__B, _IndexedSeqOptimized__A, _reduceLeft__B]) -> _reduceLeft__B: ...
    _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
    def reduceRight(self, op: scala.Function2[_IndexedSeqOptimized__A, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
    def reverse(self) -> _IndexedSeqOptimized__Repr: ...
    def reverseIterator(self) -> 'Iterator'[_IndexedSeqOptimized__A]: ...
    _sameElements__B = typing.TypeVar('_sameElements__B')  # <B>
    def sameElements(self, that: GenIterable[_sameElements__B]) -> bool: ...
    def segmentLength(self, p: scala.Function1[_IndexedSeqOptimized__A, typing.Any], from_: int) -> int: ...
    def slice(self, from_: int, until: int) -> _IndexedSeqOptimized__Repr: ...
    def span(self, p: scala.Function1[_IndexedSeqOptimized__A, typing.Any]) -> scala.Tuple2[_IndexedSeqOptimized__Repr, _IndexedSeqOptimized__Repr]: ...
    def splitAt(self, n: int) -> scala.Tuple2[_IndexedSeqOptimized__Repr, _IndexedSeqOptimized__Repr]: ...
    _startsWith_0__B = typing.TypeVar('_startsWith_0__B')  # <B>
    _startsWith_1__B = typing.TypeVar('_startsWith_1__B')  # <B>
    @typing.overload
    def startsWith(self, that: GenSeq[_startsWith_0__B]) -> bool: ...
    @typing.overload
    def startsWith(self, that: GenSeq[_startsWith_1__B], offset: int) -> bool: ...
    def tail(self) -> _IndexedSeqOptimized__Repr: ...
    def take(self, n: int) -> _IndexedSeqOptimized__Repr: ...
    def takeRight(self, n: int) -> _IndexedSeqOptimized__Repr: ...
    def takeWhile(self, p: scala.Function1[_IndexedSeqOptimized__A, typing.Any]) -> _IndexedSeqOptimized__Repr: ...
    def toList(self) -> scala.collection.immutable.List[_IndexedSeqOptimized__A]: ...
    def toString(self) -> str: ...
    _zip__A1 = typing.TypeVar('_zip__A1')  # <A1>
    _zip__B = typing.TypeVar('_zip__B')  # <B>
    _zip__That = typing.TypeVar('_zip__That')  # <That>
    def zip(self, that: GenIterable[_zip__B], bf: scala.collection.generic.CanBuildFrom[_IndexedSeqOptimized__Repr, scala.Tuple2[_zip__A1, _zip__B], _zip__That]) -> _zip__That: ...
    _zipWithIndex__A1 = typing.TypeVar('_zipWithIndex__A1')  # <A1>
    _zipWithIndex__That = typing.TypeVar('_zipWithIndex__That')  # <That>
    def zipWithIndex(self, bf: scala.collection.generic.CanBuildFrom[_IndexedSeqOptimized__Repr, scala.Tuple2[_zipWithIndex__A1, typing.Any], _zipWithIndex__That]) -> _zipWithIndex__That: ...

_Iterable__A = typing.TypeVar('_Iterable__A')  # <A>
class Iterable(scala.collection.Traversable[_Iterable__A], GenIterable[_Iterable__A], scala.collection.IterableLike[_Iterable__A, 'Iterable'[_Iterable__A]], typing.Generic[_Iterable__A]):
    @staticmethod
    def $init$($this: 'Iterable') -> None: ...
    @staticmethod
    def ReusableCBF() -> scala.collection.generic.GenTraversableFactory.GenericCanBuildFrom[scala.runtime.Nothing.]: ...
    @staticmethod
    def apply(elems: 'Seq') -> GenTraversable: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['Iterable'[typing.Any], _canBuildFrom__A, 'Iterable'[_canBuildFrom__A]]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['Iterable']: ...
    @staticmethod
    def concat(xss: 'Seq') -> GenTraversable: ...
    @staticmethod
    def empty() -> GenTraversable: ...
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, n5: int, elem: scala.Function0) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, elem: scala.Function0) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, elem: scala.Function0) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, elem: scala.Function0) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n: int, elem: scala.Function0) -> GenTraversable: ...
    @staticmethod
    def iterate(start: typing.Any, len: int, f: scala.Function1) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, step: typing.Any, evidence$2: scala.math.Integral) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, evidence$1: scala.math.Integral) -> GenTraversable: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[_Iterable__A]: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[_Iterable__A]: ...
    @typing.overload
    def seq(self) -> 'Iterable'[_Iterable__A]: ...
    @typing.overload
    def seq(self) -> 'Traversable'[_Iterable__A]: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, n5: int, f: scala.Function5) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, f: scala.Function4) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, f: scala.Function3) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, f: scala.Function2) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n: int, f: scala.Function1) -> GenTraversable: ...
    def toString(self) -> str: ...

_IterableLike__A = typing.TypeVar('_IterableLike__A')  # <A>
_IterableLike__Repr = typing.TypeVar('_IterableLike__Repr')  # <Repr>
class IterableLike(scala.Equals, scala.collection.TraversableLike[_IterableLike__A, _IterableLike__Repr], GenIterableLike[_IterableLike__A, _IterableLike__Repr], typing.Generic[_IterableLike__A, _IterableLike__Repr]):
    @staticmethod
    def $init$($this: 'IterableLike') -> None: ...
    def canEqual(self, that: typing.Any) -> bool: ...
    _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
    _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
    _copyToArray_2__B = typing.TypeVar('_copyToArray_2__B')  # <B>
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int) -> None: ...
    def drop(self, n: int) -> _IterableLike__Repr: ...
    def dropRight(self, n: int) -> _IterableLike__Repr: ...
    def equals(self, that: typing.Any) -> bool: ...
    def exists(self, p: scala.Function1[_IterableLike__A, typing.Any]) -> bool: ...
    def find(self, p: scala.Function1[_IterableLike__A, typing.Any]) -> scala.Option[_IterableLike__A]: ...
    _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
    def foldRight(self, z: _foldRight__B, op: scala.Function2[_IterableLike__A, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
    def forall(self, p: scala.Function1[_IterableLike__A, typing.Any]) -> bool: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_IterableLike__A, _foreach__U]) -> None: ...
    def grouped(self, size: int) -> 'Iterator'[_IterableLike__Repr]: ...
    def head(self) -> _IterableLike__A: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> 'Iterator'[_IterableLike__A]: ...
    _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
    def reduceRight(self, op: scala.Function2[_IterableLike__A, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
    _sameElements__B = typing.TypeVar('_sameElements__B')  # <B>
    def sameElements(self, that: GenIterable[_sameElements__B]) -> bool: ...
    def slice(self, from_: int, until: int) -> _IterableLike__Repr: ...
    @typing.overload
    def sliding(self, size: int) -> 'Iterator'[_IterableLike__Repr]: ...
    @typing.overload
    def sliding(self, size: int, step: int) -> 'Iterator'[_IterableLike__Repr]: ...
    def take(self, n: int) -> _IterableLike__Repr: ...
    def takeRight(self, n: int) -> _IterableLike__Repr: ...
    def takeWhile(self, p: scala.Function1[_IterableLike__A, typing.Any]) -> _IterableLike__Repr: ...
    @typing.overload
    def thisCollection(self) -> Iterable[_IterableLike__A]: ...
    @typing.overload
    def thisCollection(self) -> 'Traversable'[_IterableLike__A]: ...
    @typing.overload
    def toCollection(self, repr: _IterableLike__Repr) -> Iterable[_IterableLike__A]: ...
    @typing.overload
    def toCollection(self, repr: _IterableLike__Repr) -> 'Traversable'[_IterableLike__A]: ...
    @typing.overload
    def toIterable(self) -> GenIterable[_IterableLike__A]: ...
    @typing.overload
    def toIterable(self) -> Iterable[_IterableLike__A]: ...
    def toIterator(self) -> 'Iterator'[_IterableLike__A]: ...
    def toStream(self) -> scala.collection.immutable.Stream[_IterableLike__A]: ...
    def toString(self) -> str: ...
    @typing.overload
    def view(self) -> 'IterableView'[_IterableLike__A, _IterableLike__Repr]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> 'IterableView'[_IterableLike__A, _IterableLike__Repr]: ...
    @typing.overload
    def view(self) -> 'TraversableView'[_IterableLike__A, _IterableLike__Repr]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> 'TraversableView'[_IterableLike__A, _IterableLike__Repr]: ...
    _zip__A1 = typing.TypeVar('_zip__A1')  # <A1>
    _zip__B = typing.TypeVar('_zip__B')  # <B>
    _zip__That = typing.TypeVar('_zip__That')  # <That>
    def zip(self, that: GenIterable[_zip__B], bf: scala.collection.generic.CanBuildFrom[_IterableLike__Repr, scala.Tuple2[_zip__A1, _zip__B], _zip__That]) -> _zip__That: ...
    _zipAll__B = typing.TypeVar('_zipAll__B')  # <B>
    _zipAll__A1 = typing.TypeVar('_zipAll__A1')  # <A1>
    _zipAll__That = typing.TypeVar('_zipAll__That')  # <That>
    def zipAll(self, that: GenIterable[_zipAll__B], thisElem: _zipAll__A1, thatElem: _zipAll__B, bf: scala.collection.generic.CanBuildFrom[_IterableLike__Repr, scala.Tuple2[_zipAll__A1, _zipAll__B], _zipAll__That]) -> _zipAll__That: ...
    _zipWithIndex__A1 = typing.TypeVar('_zipWithIndex__A1')  # <A1>
    _zipWithIndex__That = typing.TypeVar('_zipWithIndex__That')  # <That>
    def zipWithIndex(self, bf: scala.collection.generic.CanBuildFrom[_IterableLike__Repr, scala.Tuple2[_zipWithIndex__A1, typing.Any], _zipWithIndex__That]) -> _zipWithIndex__That: ...

_IterableProxy__A = typing.TypeVar('_IterableProxy__A')  # <A>
class IterableProxy(Iterable[_IterableProxy__A], scala.collection.IterableProxyLike[_IterableProxy__A, Iterable[_IterableProxy__A]], typing.Generic[_IterableProxy__A]):
    @typing.overload
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self) -> str: ...

_IterableProxyLike__A = typing.TypeVar('_IterableProxyLike__A')  # <A>
_IterableProxyLike__Repr = typing.TypeVar('_IterableProxyLike__Repr', bound=IterableLike)  # <Repr>
class IterableProxyLike(IterableLike[_IterableProxyLike__A, _IterableProxyLike__Repr], scala.collection.TraversableProxyLike[_IterableProxyLike__A, _IterableProxyLike__Repr], typing.Generic[_IterableProxyLike__A, _IterableProxyLike__Repr]):
    @staticmethod
    def $init$($this: 'IterableProxyLike') -> None: ...
    @typing.overload
    def dropRight(self, n: int) -> _IterableProxyLike__Repr: ...
    @typing.overload
    def dropRight(self, n: int) -> _IterableProxyLike__Repr: ...
    @typing.overload
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    def equals(self, that: typing.Any) -> bool: ...
    def grouped(self, size: int) -> 'Iterator'[_IterableProxyLike__Repr]: ...
    def hashCode(self) -> int: ...
    def iterator(self) -> 'Iterator'[_IterableProxyLike__A]: ...
    _sameElements__B = typing.TypeVar('_sameElements__B')  # <B>
    def sameElements(self, that: GenIterable[_sameElements__B]) -> bool: ...
    @typing.overload
    def sliding(self, size: int) -> 'Iterator'[_IterableProxyLike__Repr]: ...
    @typing.overload
    def sliding(self, size: int, step: int) -> 'Iterator'[_IterableProxyLike__Repr]: ...
    @typing.overload
    def takeRight(self, n: int) -> _IterableProxyLike__Repr: ...
    @typing.overload
    def takeRight(self, n: int) -> _IterableProxyLike__Repr: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def view(self) -> 'IterableView'[_IterableProxyLike__A, _IterableProxyLike__Repr]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> 'IterableView'[_IterableProxyLike__A, _IterableProxyLike__Repr]: ...
    @typing.overload
    def view(self) -> 'TraversableView'[_IterableProxyLike__A, _IterableProxyLike__Repr]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> 'TraversableView'[_IterableProxyLike__A, _IterableProxyLike__Repr]: ...
    _zip__A1 = typing.TypeVar('_zip__A1')  # <A1>
    _zip__B = typing.TypeVar('_zip__B')  # <B>
    _zip__That = typing.TypeVar('_zip__That')  # <That>
    def zip(self, that: GenIterable[_zip__B], bf: scala.collection.generic.CanBuildFrom[_IterableProxyLike__Repr, scala.Tuple2[_zip__A1, _zip__B], _zip__That]) -> _zip__That: ...
    _zipAll__B = typing.TypeVar('_zipAll__B')  # <B>
    _zipAll__A1 = typing.TypeVar('_zipAll__A1')  # <A1>
    _zipAll__That = typing.TypeVar('_zipAll__That')  # <That>
    def zipAll(self, that: GenIterable[_zipAll__B], thisElem: _zipAll__A1, thatElem: _zipAll__B, bf: scala.collection.generic.CanBuildFrom[_IterableProxyLike__Repr, scala.Tuple2[_zipAll__A1, _zipAll__B], _zipAll__That]) -> _zipAll__That: ...
    _zipWithIndex__A1 = typing.TypeVar('_zipWithIndex__A1')  # <A1>
    _zipWithIndex__That = typing.TypeVar('_zipWithIndex__That')  # <That>
    def zipWithIndex(self, bf: scala.collection.generic.CanBuildFrom[_IterableProxyLike__Repr, scala.Tuple2[_zipWithIndex__A1, typing.Any], _zipWithIndex__That]) -> _zipWithIndex__That: ...

_IterableView__A = typing.TypeVar('_IterableView__A')  # <A>
_IterableView__Coll = typing.TypeVar('_IterableView__Coll')  # <Coll>
class IterableView(scala.collection.IterableViewLike[_IterableView__A, _IterableView__Coll, 'IterableView'[_IterableView__A, _IterableView__Coll]], typing.Generic[_IterableView__A, _IterableView__Coll]):
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['TraversableView'[typing.Any, 'Traversable'[typing.Any]], _canBuildFrom__A, 'IterableView'[_canBuildFrom__A, Iterable[typing.Any]]]: ...
    def equals(self, that: typing.Any) -> bool: ...
    def toString(self) -> str: ...

_Iterator__ConcatIterator__A = typing.TypeVar('_Iterator__ConcatIterator__A')  # <A>
_Iterator__ConcatIteratorCell__A = typing.TypeVar('_Iterator__ConcatIteratorCell__A')  # <A>
_Iterator__GroupedIterator__B = typing.TypeVar('_Iterator__GroupedIterator__B')  # <B>
_Iterator__SliceIterator__A = typing.TypeVar('_Iterator__SliceIterator__A')  # <A>
_Iterator__A = typing.TypeVar('_Iterator__A')  # <A>
class Iterator(scala.collection.TraversableOnce[_Iterator__A], typing.Generic[_Iterator__A]):
    @staticmethod
    def $init$($this: 'Iterator') -> None: ...
    _$plus$plus__B = typing.TypeVar('_$plus$plus__B')  # <B>
    def $plus$plus(self, that: scala.Function0[GenTraversableOnce[_.plus.plus__B]]) -> 'Iterator'[_.plus.plus__B]: ...
    _IteratorCanBuildFrom__A = typing.TypeVar('_IteratorCanBuildFrom__A')  # <A>
    @staticmethod
    def IteratorCanBuildFrom() -> 'TraversableOnce.BufferedCanBuildFrom'[_IteratorCanBuildFrom__A, 'Iterator']: ...
    _apply__A = typing.TypeVar('_apply__A')  # <A>
    @staticmethod
    def apply(elems: 'Seq'[_apply__A]) -> 'Iterator'[_apply__A]: ...
    def buffered(self) -> BufferedIterator[_Iterator__A]: ...
    _collect__B = typing.TypeVar('_collect__B')  # <B>
    def collect(self, pf: scala.PartialFunction[_Iterator__A, _collect__B]) -> 'Iterator'[_collect__B]: ...
    def contains(self, elem: typing.Any) -> bool: ...
    _continually__A = typing.TypeVar('_continually__A')  # <A>
    @staticmethod
    def continually(elem: scala.Function0[_continually__A]) -> 'Iterator'[_continually__A]: ...
    _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
    _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
    _copyToArray_2__B = typing.TypeVar('_copyToArray_2__B')  # <B>
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int) -> None: ...
    _corresponds__B = typing.TypeVar('_corresponds__B')  # <B>
    def corresponds(self, that: GenTraversableOnce[_corresponds__B], p: scala.Function2[_Iterator__A, _corresponds__B, typing.Any]) -> bool: ...
    def drop(self, n: int) -> 'Iterator'[_Iterator__A]: ...
    def dropWhile(self, p: scala.Function1[_Iterator__A, typing.Any]) -> 'Iterator'[_Iterator__A]: ...
    def duplicate(self) -> scala.Tuple2['Iterator'[_Iterator__A], 'Iterator'[_Iterator__A]]: ...
    @staticmethod
    def empty() -> 'Iterator'[scala.runtime.Nothing.]: ...
    def exists(self, p: scala.Function1[_Iterator__A, typing.Any]) -> bool: ...
    _fill__A = typing.TypeVar('_fill__A')  # <A>
    @staticmethod
    def fill(len: int, elem: scala.Function0[_fill__A]) -> 'Iterator'[_fill__A]: ...
    def filter(self, p: scala.Function1[_Iterator__A, typing.Any]) -> 'Iterator'[_Iterator__A]: ...
    def filterNot(self, p: scala.Function1[_Iterator__A, typing.Any]) -> 'Iterator'[_Iterator__A]: ...
    def find(self, p: scala.Function1[_Iterator__A, typing.Any]) -> scala.Option[_Iterator__A]: ...
    _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
    def flatMap(self, f: scala.Function1[_Iterator__A, GenTraversableOnce[_flatMap__B]]) -> 'Iterator'[_flatMap__B]: ...
    def forall(self, p: scala.Function1[_Iterator__A, typing.Any]) -> bool: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_Iterator__A, _foreach__U]) -> None: ...
    _grouped__B = typing.TypeVar('_grouped__B')  # <B>
    def grouped(self, size: int) -> 'Iterator.GroupedIterator'[_grouped__B]: ...
    def hasDefiniteSize(self) -> bool: ...
    def hasNext(self) -> bool: ...
    _indexOf_0__B = typing.TypeVar('_indexOf_0__B')  # <B>
    _indexOf_1__B = typing.TypeVar('_indexOf_1__B')  # <B>
    @typing.overload
    def indexOf(self, elem: _indexOf_0__B) -> int: ...
    @typing.overload
    def indexOf(self, elem: _indexOf_1__B, from_: int) -> int: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[_Iterator__A, typing.Any]) -> int: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[_Iterator__A, typing.Any], from_: int) -> int: ...
    def isEmpty(self) -> bool: ...
    def isTraversableAgain(self) -> bool: ...
    _iterate__T = typing.TypeVar('_iterate__T')  # <T>
    @staticmethod
    def iterate(start: _iterate__T, f: scala.Function1[_iterate__T, _iterate__T]) -> 'Iterator'[_iterate__T]: ...
    def length(self) -> int: ...
    _map__B = typing.TypeVar('_map__B')  # <B>
    def map(self, f: scala.Function1[_Iterator__A, _map__B]) -> 'Iterator'[_map__B]: ...
    def next(self) -> _Iterator__A: ...
    _padTo__A1 = typing.TypeVar('_padTo__A1')  # <A1>
    def padTo(self, len: int, elem: _padTo__A1) -> 'Iterator'[_padTo__A1]: ...
    def partition(self, p: scala.Function1[_Iterator__A, typing.Any]) -> scala.Tuple2['Iterator'[_Iterator__A], 'Iterator'[_Iterator__A]]: ...
    _patch__B = typing.TypeVar('_patch__B')  # <B>
    def patch(self, from_: int, patchElems: 'Iterator'[_patch__B], replaced: int) -> 'Iterator'[_patch__B]: ...
    @typing.overload
    @staticmethod
    def range(start: int, end: int) -> 'Iterator'[typing.Any]: ...
    @typing.overload
    @staticmethod
    def range(start: int, end: int, step: int) -> 'Iterator'[typing.Any]: ...
    def sameElements(self, that: 'Iterator'[typing.Any]) -> bool: ...
    _scanLeft__B = typing.TypeVar('_scanLeft__B')  # <B>
    def scanLeft(self, z: _scanLeft__B, op: scala.Function2[_scanLeft__B, _Iterator__A, _scanLeft__B]) -> 'Iterator'[_scanLeft__B]: ...
    _scanRight__B = typing.TypeVar('_scanRight__B')  # <B>
    def scanRight(self, z: _scanRight__B, op: scala.Function2[_Iterator__A, _scanRight__B, _scanRight__B]) -> 'Iterator'[_scanRight__B]: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[_Iterator__A]: ...
    @typing.overload
    def seq(self) -> 'Iterator'[_Iterator__A]: ...
    _single__A = typing.TypeVar('_single__A')  # <A>
    @staticmethod
    def single(elem: _single__A) -> 'Iterator'[_single__A]: ...
    def slice(self, from_: int, until: int) -> 'Iterator'[_Iterator__A]: ...
    def sliceIterator(self, from_: int, until: int) -> 'Iterator'[_Iterator__A]: ...
    _sliding__B = typing.TypeVar('_sliding__B')  # <B>
    def sliding(self, size: int, step: int) -> 'Iterator.GroupedIterator'[_sliding__B]: ...
    _sliding$default$2__B = typing.TypeVar('_sliding$default$2__B')  # <B>
    def sliding$default$2(self) -> int: ...
    def span(self, p: scala.Function1[_Iterator__A, typing.Any]) -> scala.Tuple2['Iterator'[_Iterator__A], 'Iterator'[_Iterator__A]]: ...
    _tabulate__A = typing.TypeVar('_tabulate__A')  # <A>
    @staticmethod
    def tabulate(end: int, f: scala.Function1[typing.Any, _tabulate__A]) -> 'Iterator'[_tabulate__A]: ...
    def take(self, n: int) -> 'Iterator'[_Iterator__A]: ...
    def takeWhile(self, p: scala.Function1[_Iterator__A, typing.Any]) -> 'Iterator'[_Iterator__A]: ...
    def toIterator(self) -> 'Iterator'[_Iterator__A]: ...
    def toStream(self) -> scala.collection.immutable.Stream[_Iterator__A]: ...
    def toString(self) -> str: ...
    @typing.overload
    def toTraversable(self) -> GenTraversable[_Iterator__A]: ...
    @typing.overload
    def toTraversable(self) -> 'Traversable'[_Iterator__A]: ...
    def withFilter(self, p: scala.Function1[_Iterator__A, typing.Any]) -> 'Iterator'[_Iterator__A]: ...
    _zip__B = typing.TypeVar('_zip__B')  # <B>
    def zip(self, that: 'Iterator'[_zip__B]) -> 'Iterator'[scala.Tuple2[_Iterator__A, _zip__B]]: ...
    _zipAll__B = typing.TypeVar('_zipAll__B')  # <B>
    _zipAll__A1 = typing.TypeVar('_zipAll__A1')  # <A1>
    _zipAll__B1 = typing.TypeVar('_zipAll__B1')  # <B1>
    def zipAll(self, that: 'Iterator'[_zipAll__B], thisElem: _zipAll__A1, thatElem: _zipAll__B1) -> 'Iterator'[scala.Tuple2[_zipAll__A1, _zipAll__B1]]: ...
    def zipWithIndex(self) -> 'Iterator'[scala.Tuple2[_Iterator__A, typing.Any]]: ...
    class ConcatIterator(scala.collection.Iterator[_Iterator__ConcatIterator__A], typing.Generic[_Iterator__ConcatIterator__A]):
        def __init__(self, current: 'Iterator'[_Iterator__ConcatIterator__A]): ...
        _$colon$bslash__B = typing.TypeVar('_$colon$bslash__B')  # <B>
        def $colon$bslash(self, z: _.colon.bslash__B, op: scala.Function2[_Iterator__ConcatIterator__A, _.colon.bslash__B, _.colon.bslash__B]) -> _.colon.bslash__B: ...
        _$div$colon__B = typing.TypeVar('_$div$colon__B')  # <B>
        def $div$colon(self, z: _.div.colon__B, op: scala.Function2[_.div.colon__B, _Iterator__ConcatIterator__A, _.div.colon__B]) -> _.div.colon__B: ...
        _$plus$plus__B = typing.TypeVar('_$plus$plus__B')  # <B>
        def $plus$plus(self, that: scala.Function0[GenTraversableOnce[_.plus.plus__B]]) -> 'Iterator'[_.plus.plus__B]: ...
        @typing.overload
        def addString(self, b: scala.collection.mutable.StringBuilder) -> scala.collection.mutable.StringBuilder: ...
        @typing.overload
        def addString(self, b: scala.collection.mutable.StringBuilder, sep: str) -> scala.collection.mutable.StringBuilder: ...
        @typing.overload
        def addString(self, b: scala.collection.mutable.StringBuilder, start: str, sep: str, end: str) -> scala.collection.mutable.StringBuilder: ...
        _aggregate__B = typing.TypeVar('_aggregate__B')  # <B>
        def aggregate(self, z: scala.Function0[_aggregate__B], seqop: scala.Function2[_aggregate__B, _Iterator__ConcatIterator__A, _aggregate__B], combop: scala.Function2[_aggregate__B, _aggregate__B, _aggregate__B]) -> _aggregate__B: ...
        def buffered(self) -> BufferedIterator[_Iterator__ConcatIterator__A]: ...
        _collect__B = typing.TypeVar('_collect__B')  # <B>
        def collect(self, pf: scala.PartialFunction[_Iterator__ConcatIterator__A, _collect__B]) -> 'Iterator'[_collect__B]: ...
        _collectFirst__B = typing.TypeVar('_collectFirst__B')  # <B>
        def collectFirst(self, pf: scala.PartialFunction[_Iterator__ConcatIterator__A, _collectFirst__B]) -> scala.Option[_collectFirst__B]: ...
        def contains(self, elem: typing.Any) -> bool: ...
        _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
        _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
        _copyToArray_2__B = typing.TypeVar('_copyToArray_2__B')  # <B>
        @typing.overload
        def copyToArray(self, xs: typing.Any) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
        _copyToBuffer__B = typing.TypeVar('_copyToBuffer__B')  # <B>
        def copyToBuffer(self, dest: scala.collection.mutable.Buffer[_copyToBuffer__B]) -> None: ...
        _corresponds__B = typing.TypeVar('_corresponds__B')  # <B>
        def corresponds(self, that: GenTraversableOnce[_corresponds__B], p: scala.Function2[_Iterator__ConcatIterator__A, _corresponds__B, typing.Any]) -> bool: ...
        def count(self, p: scala.Function1[_Iterator__ConcatIterator__A, typing.Any]) -> int: ...
        def drop(self, n: int) -> 'Iterator'[_Iterator__ConcatIterator__A]: ...
        def dropWhile(self, p: scala.Function1[_Iterator__ConcatIterator__A, typing.Any]) -> 'Iterator'[_Iterator__ConcatIterator__A]: ...
        def duplicate(self) -> scala.Tuple2['Iterator'[_Iterator__ConcatIterator__A], 'Iterator'[_Iterator__ConcatIterator__A]]: ...
        def exists(self, p: scala.Function1[_Iterator__ConcatIterator__A, typing.Any]) -> bool: ...
        def filter(self, p: scala.Function1[_Iterator__ConcatIterator__A, typing.Any]) -> 'Iterator'[_Iterator__ConcatIterator__A]: ...
        def filterNot(self, p: scala.Function1[_Iterator__ConcatIterator__A, typing.Any]) -> 'Iterator'[_Iterator__ConcatIterator__A]: ...
        def find(self, p: scala.Function1[_Iterator__ConcatIterator__A, typing.Any]) -> scala.Option[_Iterator__ConcatIterator__A]: ...
        _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
        def flatMap(self, f: scala.Function1[_Iterator__ConcatIterator__A, GenTraversableOnce[_flatMap__B]]) -> 'Iterator'[_flatMap__B]: ...
        _fold__A1 = typing.TypeVar('_fold__A1')  # <A1>
        def fold(self, z: _fold__A1, op: scala.Function2[_fold__A1, _fold__A1, _fold__A1]) -> _fold__A1: ...
        _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
        def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, _Iterator__ConcatIterator__A, _foldLeft__B]) -> _foldLeft__B: ...
        _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
        def foldRight(self, z: _foldRight__B, op: scala.Function2[_Iterator__ConcatIterator__A, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
        def forall(self, p: scala.Function1[_Iterator__ConcatIterator__A, typing.Any]) -> bool: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[_Iterator__ConcatIterator__A, _foreach__U]) -> None: ...
        _grouped__B = typing.TypeVar('_grouped__B')  # <B>
        def grouped(self, size: int) -> 'Iterator.GroupedIterator'[_grouped__B]: ...
        def hasDefiniteSize(self) -> bool: ...
        def hasNext(self) -> bool: ...
        _indexOf_0__B = typing.TypeVar('_indexOf_0__B')  # <B>
        _indexOf_1__B = typing.TypeVar('_indexOf_1__B')  # <B>
        @typing.overload
        def indexOf(self, elem: _indexOf_0__B) -> int: ...
        @typing.overload
        def indexOf(self, elem: _indexOf_1__B, from_: int) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[_Iterator__ConcatIterator__A, typing.Any]) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[_Iterator__ConcatIterator__A, typing.Any], from_: int) -> int: ...
        def isEmpty(self) -> bool: ...
        def isTraversableAgain(self) -> bool: ...
        def length(self) -> int: ...
        _map__B = typing.TypeVar('_map__B')  # <B>
        def map(self, f: scala.Function1[_Iterator__ConcatIterator__A, _map__B]) -> 'Iterator'[_map__B]: ...
        _max__B = typing.TypeVar('_max__B')  # <B>
        def max(self, cmp: scala.math.Ordering[_max__B]) -> _Iterator__ConcatIterator__A: ...
        _maxBy__B = typing.TypeVar('_maxBy__B')  # <B>
        def maxBy(self, f: scala.Function1[_Iterator__ConcatIterator__A, _maxBy__B], cmp: scala.math.Ordering[_maxBy__B]) -> _Iterator__ConcatIterator__A: ...
        _min__B = typing.TypeVar('_min__B')  # <B>
        def min(self, cmp: scala.math.Ordering[_min__B]) -> _Iterator__ConcatIterator__A: ...
        _minBy__B = typing.TypeVar('_minBy__B')  # <B>
        def minBy(self, f: scala.Function1[_Iterator__ConcatIterator__A, _minBy__B], cmp: scala.math.Ordering[_minBy__B]) -> _Iterator__ConcatIterator__A: ...
        @typing.overload
        def mkString(self) -> str: ...
        @typing.overload
        def mkString(self, sep: str) -> str: ...
        @typing.overload
        def mkString(self, start: str, sep: str, end: str) -> str: ...
        def next(self) -> _Iterator__ConcatIterator__A: ...
        def nonEmpty(self) -> bool: ...
        _padTo__A1 = typing.TypeVar('_padTo__A1')  # <A1>
        def padTo(self, len: int, elem: _padTo__A1) -> 'Iterator'[_padTo__A1]: ...
        def partition(self, p: scala.Function1[_Iterator__ConcatIterator__A, typing.Any]) -> scala.Tuple2['Iterator'[_Iterator__ConcatIterator__A], 'Iterator'[_Iterator__ConcatIterator__A]]: ...
        _patch__B = typing.TypeVar('_patch__B')  # <B>
        def patch(self, from_: int, patchElems: 'Iterator'[_patch__B], replaced: int) -> 'Iterator'[_patch__B]: ...
        _product__B = typing.TypeVar('_product__B')  # <B>
        def product(self, num: scala.math.Numeric[_product__B]) -> _product__B: ...
        _reduce__A1 = typing.TypeVar('_reduce__A1')  # <A1>
        def reduce(self, op: scala.Function2[_reduce__A1, _reduce__A1, _reduce__A1]) -> _reduce__A1: ...
        _reduceLeft__B = typing.TypeVar('_reduceLeft__B')  # <B>
        def reduceLeft(self, op: scala.Function2[_reduceLeft__B, _Iterator__ConcatIterator__A, _reduceLeft__B]) -> _reduceLeft__B: ...
        _reduceLeftOption__B = typing.TypeVar('_reduceLeftOption__B')  # <B>
        def reduceLeftOption(self, op: scala.Function2[_reduceLeftOption__B, _Iterator__ConcatIterator__A, _reduceLeftOption__B]) -> scala.Option[_reduceLeftOption__B]: ...
        _reduceOption__A1 = typing.TypeVar('_reduceOption__A1')  # <A1>
        def reduceOption(self, op: scala.Function2[_reduceOption__A1, _reduceOption__A1, _reduceOption__A1]) -> scala.Option[_reduceOption__A1]: ...
        _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
        def reduceRight(self, op: scala.Function2[_Iterator__ConcatIterator__A, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
        _reduceRightOption__B = typing.TypeVar('_reduceRightOption__B')  # <B>
        def reduceRightOption(self, op: scala.Function2[_Iterator__ConcatIterator__A, _reduceRightOption__B, _reduceRightOption__B]) -> scala.Option[_reduceRightOption__B]: ...
        def reversed(self) -> scala.collection.immutable.List[_Iterator__ConcatIterator__A]: ...
        def sameElements(self, that: 'Iterator'[typing.Any]) -> bool: ...
        _scanLeft__B = typing.TypeVar('_scanLeft__B')  # <B>
        def scanLeft(self, z: _scanLeft__B, op: scala.Function2[_scanLeft__B, _Iterator__ConcatIterator__A, _scanLeft__B]) -> 'Iterator'[_scanLeft__B]: ...
        _scanRight__B = typing.TypeVar('_scanRight__B')  # <B>
        def scanRight(self, z: _scanRight__B, op: scala.Function2[_Iterator__ConcatIterator__A, _scanRight__B, _scanRight__B]) -> 'Iterator'[_scanRight__B]: ...
        def seq(self) -> 'Iterator'[_Iterator__ConcatIterator__A]: ...
        def size(self) -> int: ...
        def sizeHintIfCheap(self) -> int: ...
        def slice(self, from_: int, until: int) -> 'Iterator'[_Iterator__ConcatIterator__A]: ...
        def sliceIterator(self, from_: int, until: int) -> 'Iterator'[_Iterator__ConcatIterator__A]: ...
        _sliding__B = typing.TypeVar('_sliding__B')  # <B>
        def sliding(self, size: int, step: int) -> 'Iterator.GroupedIterator'[_sliding__B]: ...
        _sliding$default$2__B = typing.TypeVar('_sliding$default$2__B')  # <B>
        def sliding$default$2(self) -> int: ...
        def span(self, p: scala.Function1[_Iterator__ConcatIterator__A, typing.Any]) -> scala.Tuple2['Iterator'[_Iterator__ConcatIterator__A], 'Iterator'[_Iterator__ConcatIterator__A]]: ...
        _sum__B = typing.TypeVar('_sum__B')  # <B>
        def sum(self, num: scala.math.Numeric[_sum__B]) -> _sum__B: ...
        def take(self, n: int) -> 'Iterator'[_Iterator__ConcatIterator__A]: ...
        def takeWhile(self, p: scala.Function1[_Iterator__ConcatIterator__A, typing.Any]) -> 'Iterator'[_Iterator__ConcatIterator__A]: ...
        _to__Col = typing.TypeVar('_to__Col')  # <Col>
        def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., _Iterator__ConcatIterator__A, _to__Col]) -> _to__Col: ...
        _toArray__B = typing.TypeVar('_toArray__B')  # <B>
        def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__B]) -> typing.Any: ...
        _toBuffer__B = typing.TypeVar('_toBuffer__B')  # <B>
        def toBuffer(self) -> scala.collection.mutable.Buffer[_toBuffer__B]: ...
        def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq[_Iterator__ConcatIterator__A]: ...
        def toIterable(self) -> Iterable[_Iterator__ConcatIterator__A]: ...
        def toIterator(self) -> 'Iterator'[_Iterator__ConcatIterator__A]: ...
        def toList(self) -> scala.collection.immutable.List[_Iterator__ConcatIterator__A]: ...
        _toMap__T = typing.TypeVar('_toMap__T')  # <T>
        _toMap__U = typing.TypeVar('_toMap__U')  # <U>
        def toMap(self, ev: scala.Predef..less.colon.less[_Iterator__ConcatIterator__A, scala.Tuple2[_toMap__T, _toMap__U]]) -> scala.collection.immutable.Map[_toMap__T, _toMap__U]: ...
        def toSeq(self) -> 'Seq'[_Iterator__ConcatIterator__A]: ...
        _toSet__B = typing.TypeVar('_toSet__B')  # <B>
        def toSet(self) -> scala.collection.immutable.Set[_toSet__B]: ...
        def toStream(self) -> scala.collection.immutable.Stream[_Iterator__ConcatIterator__A]: ...
        def toString(self) -> str: ...
        def toTraversable(self) -> 'Traversable'[_Iterator__ConcatIterator__A]: ...
        def toVector(self) -> scala.collection.immutable.Vector[_Iterator__ConcatIterator__A]: ...
        def withFilter(self, p: scala.Function1[_Iterator__ConcatIterator__A, typing.Any]) -> 'Iterator'[_Iterator__ConcatIterator__A]: ...
        _zip__B = typing.TypeVar('_zip__B')  # <B>
        def zip(self, that: 'Iterator'[_zip__B]) -> 'Iterator'[scala.Tuple2[_Iterator__ConcatIterator__A, _zip__B]]: ...
        _zipAll__B = typing.TypeVar('_zipAll__B')  # <B>
        _zipAll__A1 = typing.TypeVar('_zipAll__A1')  # <A1>
        _zipAll__B1 = typing.TypeVar('_zipAll__B1')  # <B1>
        def zipAll(self, that: 'Iterator'[_zipAll__B], thisElem: _zipAll__A1, thatElem: _zipAll__B1) -> 'Iterator'[scala.Tuple2[_zipAll__A1, _zipAll__B1]]: ...
        def zipWithIndex(self) -> 'Iterator'[scala.Tuple2[_Iterator__ConcatIterator__A, typing.Any]]: ...
    class ConcatIteratorCell(typing.Generic[_Iterator__ConcatIteratorCell__A]):
        def __init__(self, head: scala.Function0[GenTraversableOnce[_Iterator__ConcatIteratorCell__A]], tail: 'Iterator.ConcatIteratorCell'[_Iterator__ConcatIteratorCell__A]): ...
        def headIterator(self) -> 'Iterator'[_Iterator__ConcatIteratorCell__A]: ...
        def tail(self) -> 'Iterator.ConcatIteratorCell'[_Iterator__ConcatIteratorCell__A]: ...
        def tail_$eq(self, x$1: 'Iterator.ConcatIteratorCell'[_Iterator__ConcatIteratorCell__A]) -> None: ...
    class GroupedIterator(AbstractIterator['Seq'[_Iterator__GroupedIterator__B]], typing.Generic[_Iterator__GroupedIterator__B]):
        $outer: 'Iterator' = ...
        def __init__(self, $outer: 'Iterator', self, size: int, step: int): ...
        def hasNext(self) -> bool: ...
        def next(self) -> scala.collection.immutable.List[_Iterator__GroupedIterator__B]: ...
        def withPadding(self, x: scala.Function0[_Iterator__GroupedIterator__B]) -> 'Iterator.GroupedIterator'[_Iterator__GroupedIterator__B]: ...
        def withPartial(self, x: bool) -> 'Iterator.GroupedIterator'[_Iterator__GroupedIterator__B]: ...
    class SliceIterator(AbstractIterator[_Iterator__SliceIterator__A], typing.Generic[_Iterator__SliceIterator__A]):
        def __init__(self, underlying: 'Iterator'[_Iterator__SliceIterator__A], start: int, limit: int): ...
        def hasNext(self) -> bool: ...
        def next(self) -> _Iterator__SliceIterator__A: ...
        def scala$collection$Iterator$SliceIterator$$remaining(self) -> int: ...
        def sliceIterator(self, from_: int, until: int) -> 'Iterator'[_Iterator__SliceIterator__A]: ...
        def underlying(self) -> 'Iterator'[_Iterator__SliceIterator__A]: ...

_LinearSeq__A = typing.TypeVar('_LinearSeq__A')  # <A>
class LinearSeq(scala.collection.Seq[_LinearSeq__A], scala.collection.LinearSeqLike[_LinearSeq__A, 'LinearSeq'[_LinearSeq__A]], typing.Generic[_LinearSeq__A]):
    @staticmethod
    def $init$($this: 'LinearSeq') -> None: ...
    @staticmethod
    def ReusableCBF() -> scala.collection.generic.GenTraversableFactory.GenericCanBuildFrom[scala.runtime.Nothing.]: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['LinearSeq'[typing.Any], _canBuildFrom__A, 'LinearSeq'[_canBuildFrom__A]]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['LinearSeq']: ...
    @staticmethod
    def concat(xss: 'Seq') -> GenTraversable: ...
    @staticmethod
    def empty() -> GenTraversable: ...
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, n5: int, elem: scala.Function0) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, elem: scala.Function0) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, elem: scala.Function0) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, elem: scala.Function0) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n: int, elem: scala.Function0) -> GenTraversable: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def iterate(start: typing.Any, len: int, f: scala.Function1) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, step: typing.Any, evidence$2: scala.math.Integral) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, evidence$1: scala.math.Integral) -> GenTraversable: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[_LinearSeq__A]: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[_LinearSeq__A]: ...
    @typing.overload
    def seq(self) -> Iterable[_LinearSeq__A]: ...
    @typing.overload
    def seq(self) -> 'LinearSeq'[_LinearSeq__A]: ...
    @typing.overload
    def seq(self) -> 'Seq'[_LinearSeq__A]: ...
    @typing.overload
    def seq(self) -> 'Traversable'[_LinearSeq__A]: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, n5: int, f: scala.Function5) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, f: scala.Function4) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, f: scala.Function3) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, f: scala.Function2) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n: int, f: scala.Function1) -> GenTraversable: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self) -> str: ...
    @staticmethod
    def unapplySeq(x: 'Seq') -> scala.Some: ...

_LinearSeqLike__A = typing.TypeVar('_LinearSeqLike__A')  # <A>
_LinearSeqLike__Repr = typing.TypeVar('_LinearSeqLike__Repr', bound='LinearSeqLike')  # <Repr>
class LinearSeqLike(scala.collection.SeqLike[_LinearSeqLike__A, _LinearSeqLike__Repr], typing.Generic[_LinearSeqLike__A, _LinearSeqLike__Repr]):
    @staticmethod
    def $init$($this: 'LinearSeqLike') -> None: ...
    _corresponds__B = typing.TypeVar('_corresponds__B')  # <B>
    def corresponds(self, that: GenSeq[_corresponds__B], p: scala.Function2[_LinearSeqLike__A, _corresponds__B, typing.Any]) -> bool: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def iterator(self) -> Iterator[_LinearSeqLike__A]: ...
    @typing.overload
    def seq(self) -> LinearSeq[_LinearSeqLike__A]: ...
    @typing.overload
    def seq(self) -> 'Seq'[_LinearSeqLike__A]: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[_LinearSeqLike__A]: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[_LinearSeqLike__A]: ...
    @typing.overload
    def thisCollection(self) -> Iterable[_LinearSeqLike__A]: ...
    @typing.overload
    def thisCollection(self) -> LinearSeq[_LinearSeqLike__A]: ...
    @typing.overload
    def thisCollection(self) -> 'Seq'[_LinearSeqLike__A]: ...
    @typing.overload
    def thisCollection(self) -> 'Traversable'[_LinearSeqLike__A]: ...
    @typing.overload
    def toCollection(self, repr: _LinearSeqLike__Repr) -> Iterable[_LinearSeqLike__A]: ...
    @typing.overload
    def toCollection(self, repr: _LinearSeqLike__Repr) -> LinearSeq[_LinearSeqLike__A]: ...
    @typing.overload
    def toCollection(self, repr: _LinearSeqLike__Repr) -> 'Seq'[_LinearSeqLike__A]: ...
    @typing.overload
    def toCollection(self, repr: _LinearSeqLike__Repr) -> 'Traversable'[_LinearSeqLike__A]: ...
    def toString(self) -> str: ...

_LinearSeqOptimized__A = typing.TypeVar('_LinearSeqOptimized__A')  # <A>
_LinearSeqOptimized__Repr = typing.TypeVar('_LinearSeqOptimized__Repr', bound='LinearSeqOptimized')  # <Repr>
class LinearSeqOptimized(LinearSeqLike[_LinearSeqOptimized__A, _LinearSeqOptimized__Repr], typing.Generic[_LinearSeqOptimized__A, _LinearSeqOptimized__Repr]):
    @staticmethod
    def $init$($this: 'LinearSeqOptimized') -> None: ...
    def apply(self, n: int) -> _LinearSeqOptimized__A: ...
    _contains__A1 = typing.TypeVar('_contains__A1')  # <A1>
    def contains(self, elem: _contains__A1) -> bool: ...
    @typing.overload
    def drop(self, n: int) -> _LinearSeqOptimized__Repr: ...
    @typing.overload
    def drop(self, n: int) -> _LinearSeqOptimized__Repr: ...
    @typing.overload
    def dropRight(self, n: int) -> _LinearSeqOptimized__Repr: ...
    @typing.overload
    def dropRight(self, n: int) -> _LinearSeqOptimized__Repr: ...
    def equals(self, that: typing.Any) -> bool: ...
    def exists(self, p: scala.Function1[_LinearSeqOptimized__A, typing.Any]) -> bool: ...
    def find(self, p: scala.Function1[_LinearSeqOptimized__A, typing.Any]) -> scala.Option[_LinearSeqOptimized__A]: ...
    _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
    def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, _LinearSeqOptimized__A, _foldLeft__B]) -> _foldLeft__B: ...
    _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
    def foldRight(self, z: _foldRight__B, op: scala.Function2[_LinearSeqOptimized__A, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
    def forall(self, p: scala.Function1[_LinearSeqOptimized__A, typing.Any]) -> bool: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_LinearSeqOptimized__A, _foreach__U]) -> None: ...
    def hashCode(self) -> int: ...
    def head(self) -> _LinearSeqOptimized__A: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[_LinearSeqOptimized__A, typing.Any]) -> int: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[_LinearSeqOptimized__A, typing.Any], from_: int) -> int: ...
    def isDefinedAt(self, x: int) -> bool: ...
    def isEmpty(self) -> bool: ...
    def last(self) -> _LinearSeqOptimized__A: ...
    @typing.overload
    def lastIndexWhere(self, p: scala.Function1[_LinearSeqOptimized__A, typing.Any]) -> int: ...
    @typing.overload
    def lastIndexWhere(self, p: scala.Function1[_LinearSeqOptimized__A, typing.Any], end: int) -> int: ...
    def length(self) -> int: ...
    def lengthCompare(self, len: int) -> int: ...
    _reduceLeft__B = typing.TypeVar('_reduceLeft__B')  # <B>
    def reduceLeft(self, op: scala.Function2[_reduceLeft__B, _LinearSeqOptimized__A, _reduceLeft__B]) -> _reduceLeft__B: ...
    _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
    def reduceRight(self, op: scala.Function2[_LinearSeqOptimized__A, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
    _sameElements__B = typing.TypeVar('_sameElements__B')  # <B>
    def sameElements(self, that: GenIterable[_sameElements__B]) -> bool: ...
    def segmentLength(self, p: scala.Function1[_LinearSeqOptimized__A, typing.Any], from_: int) -> int: ...
    @typing.overload
    def slice(self, from_: int, until: int) -> _LinearSeqOptimized__Repr: ...
    @typing.overload
    def slice(self, from_: int, until: int) -> _LinearSeqOptimized__Repr: ...
    def span(self, p: scala.Function1[_LinearSeqOptimized__A, typing.Any]) -> scala.Tuple2[_LinearSeqOptimized__Repr, _LinearSeqOptimized__Repr]: ...
    @typing.overload
    def tail(self) -> _LinearSeqOptimized__Repr: ...
    @typing.overload
    def tail(self) -> _LinearSeqOptimized__Repr: ...
    def tails(self) -> Iterator[_LinearSeqOptimized__Repr]: ...
    @typing.overload
    def take(self, n: int) -> _LinearSeqOptimized__Repr: ...
    @typing.overload
    def take(self, n: int) -> _LinearSeqOptimized__Repr: ...
    @typing.overload
    def takeWhile(self, p: scala.Function1[_LinearSeqOptimized__A, typing.Any]) -> _LinearSeqOptimized__Repr: ...
    @typing.overload
    def takeWhile(self, p: scala.Function1[_LinearSeqOptimized__A, typing.Any]) -> _LinearSeqOptimized__Repr: ...
    def toString(self) -> str: ...

_Map__WithDefault__K = typing.TypeVar('_Map__WithDefault__K')  # <K>
_Map__WithDefault__V = typing.TypeVar('_Map__WithDefault__V')  # <V>
_Map__K = typing.TypeVar('_Map__K')  # <K>
_Map__V = typing.TypeVar('_Map__V')  # <V>
class Map(Iterable[scala.Tuple2[_Map__K, _Map__V]], GenMap[_Map__K, _Map__V], scala.collection.MapLike[_Map__K, _Map__V, 'Map'[_Map__K, _Map__V]], typing.Generic[_Map__K, _Map__V]):
    @staticmethod
    def $init$($this: 'Map') -> None: ...
    _canBuildFrom__K = typing.TypeVar('_canBuildFrom__K')  # <K>
    _canBuildFrom__V = typing.TypeVar('_canBuildFrom__V')  # <V>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['Map'[typing.Any, typing.Any], scala.Tuple2[_canBuildFrom__K, _canBuildFrom__V], 'Map'[_canBuildFrom__K, _canBuildFrom__V]]: ...
    def empty(self) -> 'Map'[_Map__K, _Map__V]: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[typing.Any]: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[typing.Any]: ...
    @typing.overload
    def seq(self) -> Iterable[typing.Any]: ...
    @typing.overload
    def seq(self) -> 'Map'[_Map__K, _Map__V]: ...
    @typing.overload
    def seq(self) -> 'Traversable'[typing.Any]: ...
    def toString(self) -> str: ...
    class WithDefault(AbstractMap[_Map__WithDefault__K, _Map__WithDefault__V], scala.Serializable, typing.Generic[_Map__WithDefault__K, _Map__WithDefault__V]):
        def __init__(self, underlying: 'Map'[_Map__WithDefault__K, _Map__WithDefault__V], d: scala.Function1[_Map__WithDefault__K, _Map__WithDefault__V]): ...
        def default(self, key: _Map__WithDefault__K) -> _Map__WithDefault__V: ...
        def get(self, key: _Map__WithDefault__K) -> scala.Option[_Map__WithDefault__V]: ...
        def iterator(self) -> Iterator[scala.Tuple2[_Map__WithDefault__K, _Map__WithDefault__V]]: ...
        def size(self) -> int: ...

_MapLike__MappedValues__W = typing.TypeVar('_MapLike__MappedValues__W')  # <W>
_MapLike__K = typing.TypeVar('_MapLike__K')  # <K>
_MapLike__V = typing.TypeVar('_MapLike__V')  # <V>
_MapLike__This = typing.TypeVar('_MapLike__This', bound='MapLike')  # <This>
class MapLike(scala.PartialFunction[_MapLike__K, _MapLike__V], IterableLike[scala.Tuple2[_MapLike__K, _MapLike__V], _MapLike__This], GenMapLike[_MapLike__K, _MapLike__V, _MapLike__This], scala.collection.generic.Subtractable[_MapLike__K, _MapLike__This], typing.Generic[_MapLike__K, _MapLike__V, _MapLike__This]):
    @staticmethod
    def $init$($this: 'MapLike') -> None: ...
    @typing.overload
    def $minus(self, key: _MapLike__K) -> typing.Any: ...
    @typing.overload
    def $minus(self, key: _MapLike__K) -> _MapLike__This: ...
    @typing.overload
    def $minus(self, elem: typing.Any) -> scala.collection.generic.Subtractable: ...
    @typing.overload
    def $minus(self, elem1: typing.Any, elem2: typing.Any, elems: 'Seq'[typing.Any]) -> scala.collection.generic.Subtractable: ...
    _$plus_0__V1 = typing.TypeVar('_$plus_0__V1')  # <V1>
    _$plus_1__V1 = typing.TypeVar('_$plus_1__V1')  # <V1>
    _$plus_2__V1 = typing.TypeVar('_$plus_2__V1')  # <V1>
    @typing.overload
    def $plus(self, kv: scala.Tuple2[_MapLike__K, _.plus_0__V1]) -> GenMap[_MapLike__K, _.plus_0__V1]: ...
    @typing.overload
    def $plus(self, kv: scala.Tuple2[_MapLike__K, _.plus_1__V1]) -> Map[_MapLike__K, _.plus_1__V1]: ...
    @typing.overload
    def $plus(self, kv1: scala.Tuple2[_MapLike__K, _.plus_2__V1], kv2: scala.Tuple2[_MapLike__K, _.plus_2__V1], kvs: 'Seq'[scala.Tuple2[_MapLike__K, _.plus_2__V1]]) -> Map[_MapLike__K, _.plus_2__V1]: ...
    _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
    _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
    _$plus$plus_1__V1 = typing.TypeVar('_$plus$plus_1__V1')  # <V1>
    @typing.overload
    def $plus$plus(self, that: GenTraversableOnce[_.plus.plus_0__B], bf: scala.collection.generic.CanBuildFrom[typing.Any, _.plus.plus_0__B, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
    @typing.overload
    def $plus$plus(self, xs: GenTraversableOnce[scala.Tuple2[_MapLike__K, _.plus.plus_1__V1]]) -> Map[_MapLike__K, _.plus.plus_1__V1]: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder, start: str, sep: str, end: str) -> scala.collection.mutable.StringBuilder: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder) -> scala.collection.mutable.StringBuilder: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder, sep: str) -> scala.collection.mutable.StringBuilder: ...
    def apply(self, key: _MapLike__K) -> _MapLike__V: ...
    _applyOrElse__K1 = typing.TypeVar('_applyOrElse__K1')  # <K1>
    _applyOrElse__V1 = typing.TypeVar('_applyOrElse__V1')  # <V1>
    def applyOrElse(self, x: _applyOrElse__K1, default: scala.Function1[_applyOrElse__K1, _applyOrElse__V1]) -> _applyOrElse__V1: ...
    def contains(self, key: _MapLike__K) -> bool: ...
    def default(self, key: _MapLike__K) -> _MapLike__V: ...
    def empty(self) -> _MapLike__This: ...
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    def filterKeys(self, p: scala.Function1[_MapLike__K, typing.Any]) -> GenMap[_MapLike__K, _MapLike__V]: ...
    @typing.overload
    def filterKeys(self, p: scala.Function1[_MapLike__K, typing.Any]) -> Map[_MapLike__K, _MapLike__V]: ...
    @typing.overload
    def filterNot(self, p: scala.Function1[typing.Any, typing.Any]) -> typing.Any: ...
    @typing.overload
    def filterNot(self, p: scala.Function1[scala.Tuple2[_MapLike__K, _MapLike__V], typing.Any]) -> _MapLike__This: ...
    def get(self, key: _MapLike__K) -> scala.Option[_MapLike__V]: ...
    _getOrElse__V1 = typing.TypeVar('_getOrElse__V1')  # <V1>
    def getOrElse(self, key: _MapLike__K, default: scala.Function0[_getOrElse__V1]) -> _getOrElse__V1: ...
    def hashCode(self) -> int: ...
    def isDefinedAt(self, key: _MapLike__K) -> bool: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[scala.Tuple2[_MapLike__K, _MapLike__V]]: ...
    @typing.overload
    def keySet(self) -> GenSet[_MapLike__K]: ...
    @typing.overload
    def keySet(self) -> 'Set'[_MapLike__K]: ...
    @typing.overload
    def keys(self) -> GenIterable[_MapLike__K]: ...
    @typing.overload
    def keys(self) -> Iterable[_MapLike__K]: ...
    def keysIterator(self) -> Iterator[_MapLike__K]: ...
    _mapValues_0__W = typing.TypeVar('_mapValues_0__W')  # <W>
    _mapValues_1__W = typing.TypeVar('_mapValues_1__W')  # <W>
    @typing.overload
    def mapValues(self, f: scala.Function1[_MapLike__V, _mapValues_0__W]) -> GenMap[_MapLike__K, _mapValues_0__W]: ...
    @typing.overload
    def mapValues(self, f: scala.Function1[_MapLike__V, _mapValues_1__W]) -> Map[_MapLike__K, _mapValues_1__W]: ...
    def newBuilder(self) -> scala.collection.mutable.Builder[scala.Tuple2[_MapLike__K, _MapLike__V], _MapLike__This]: ...
    def parCombiner(self) -> scala.collection.parallel.Combiner[scala.Tuple2[_MapLike__K, _MapLike__V], scala.collection.parallel.ParMap[_MapLike__K, _MapLike__V]]: ...
    def stringPrefix(self) -> str: ...
    _toBuffer__E = typing.TypeVar('_toBuffer__E')  # <E>
    def toBuffer(self) -> scala.collection.mutable.Buffer[_toBuffer__E]: ...
    @typing.overload
    def toSeq(self) -> GenSeq[typing.Any]: ...
    @typing.overload
    def toSeq(self) -> 'Seq'[scala.Tuple2[_MapLike__K, _MapLike__V]]: ...
    def toString(self) -> str: ...
    _updated__V1 = typing.TypeVar('_updated__V1')  # <V1>
    def updated(self, key: _MapLike__K, value: _updated__V1) -> Map[_MapLike__K, _updated__V1]: ...
    @typing.overload
    def values(self) -> GenIterable[_MapLike__V]: ...
    @typing.overload
    def values(self) -> Iterable[_MapLike__V]: ...
    def valuesIterator(self) -> Iterator[_MapLike__V]: ...
    class DefaultKeySet(AbstractSet[_MapLike__K], scala.Serializable):
        $outer: 'MapLike' = ...
        def __init__(self, $outer: 'MapLike'): ...
        @typing.overload
        def $minus(self, elem: _MapLike__K) -> 'Set'[_MapLike__K]: ...
        @typing.overload
        def $minus(self, elem1: typing.Any, elem2: typing.Any, elems: 'Seq') -> scala.collection.generic.Subtractable: ...
        @typing.overload
        def $plus(self, elem1: typing.Any, elem2: typing.Any, elems: 'Seq'[typing.Any]) -> 'Set'[typing.Any]: ...
        @typing.overload
        def $plus(self, elem: _MapLike__K) -> 'Set'[_MapLike__K]: ...
        def contains(self, key: _MapLike__K) -> bool: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[_MapLike__K, _foreach__U]) -> None: ...
        def iterator(self) -> Iterator[_MapLike__K]: ...
        def size(self) -> int: ...
    class DefaultValuesIterable(AbstractIterable[_MapLike__V], scala.Serializable):
        $outer: 'MapLike' = ...
        def __init__(self, $outer: 'MapLike'): ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[_MapLike__V, _foreach__U]) -> None: ...
        def iterator(self) -> Iterator[_MapLike__V]: ...
        def size(self) -> int: ...
    class FilteredKeys(AbstractMap[_MapLike__K, _MapLike__V], DefaultMap[_MapLike__K, _MapLike__V]):
        $outer: 'MapLike' = ...
        def __init__(self, $outer: 'MapLike', p: scala.Function1[_MapLike__K, typing.Any]): ...
        @typing.overload
        def $minus(self, key: _MapLike__K) -> Map[_MapLike__K, _MapLike__V]: ...
        @typing.overload
        def $minus(self, elem1: typing.Any, elem2: typing.Any, elems: 'Seq') -> scala.collection.generic.Subtractable: ...
        _$plus_0__V1 = typing.TypeVar('_$plus_0__V1')  # <V1>
        _$plus_1__B1 = typing.TypeVar('_$plus_1__B1')  # <B1>
        @typing.overload
        def $plus(self, kv1: scala.Tuple2[_MapLike__K, _.plus_0__V1], kv2: scala.Tuple2[_MapLike__K, _.plus_0__V1], kvs: 'Seq'[scala.Tuple2[_MapLike__K, _.plus_0__V1]]) -> Map[_MapLike__K, _.plus_0__V1]: ...
        @typing.overload
        def $plus(self, kv: scala.Tuple2[_MapLike__K, _.plus_1__B1]) -> Map[_MapLike__K, _.plus_1__B1]: ...
        def contains(self, key: _MapLike__K) -> bool: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[scala.Tuple2[_MapLike__K, _MapLike__V], _foreach__U]) -> None: ...
        def get(self, key: _MapLike__K) -> scala.Option[_MapLike__V]: ...
        def iterator(self) -> Iterator[scala.Tuple2[_MapLike__K, _MapLike__V]]: ...
    class MappedValues(AbstractMap[_MapLike__K, _MapLike__MappedValues__W], DefaultMap[_MapLike__K, _MapLike__MappedValues__W], typing.Generic[_MapLike__MappedValues__W]):
        $outer: 'MapLike' = ...
        def __init__(self, $outer: 'MapLike', f: scala.Function1[_MapLike__V, _MapLike__MappedValues__W]): ...
        @typing.overload
        def $minus(self, key: _MapLike__K) -> Map[_MapLike__K, _MapLike__MappedValues__W]: ...
        @typing.overload
        def $minus(self, elem1: typing.Any, elem2: typing.Any, elems: 'Seq') -> scala.collection.generic.Subtractable: ...
        _$plus_0__V1 = typing.TypeVar('_$plus_0__V1')  # <V1>
        _$plus_1__B1 = typing.TypeVar('_$plus_1__B1')  # <B1>
        @typing.overload
        def $plus(self, kv1: scala.Tuple2[_MapLike__K, _.plus_0__V1], kv2: scala.Tuple2[_MapLike__K, _.plus_0__V1], kvs: 'Seq'[scala.Tuple2[_MapLike__K, _.plus_0__V1]]) -> Map[_MapLike__K, _.plus_0__V1]: ...
        @typing.overload
        def $plus(self, kv: scala.Tuple2[_MapLike__K, _.plus_1__B1]) -> Map[_MapLike__K, _.plus_1__B1]: ...
        def contains(self, key: _MapLike__K) -> bool: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, g: scala.Function1[scala.Tuple2[_MapLike__K, _MapLike__MappedValues__W], _foreach__U]) -> None: ...
        def get(self, key: _MapLike__K) -> scala.Option[_MapLike__MappedValues__W]: ...
        def iterator(self) -> Iterator[scala.Tuple2[_MapLike__K, _MapLike__MappedValues__W]]: ...
        def size(self) -> int: ...

_MapProxy__A = typing.TypeVar('_MapProxy__A')  # <A>
_MapProxy__B = typing.TypeVar('_MapProxy__B')  # <B>
class MapProxy(Map[_MapProxy__A, _MapProxy__B], scala.collection.MapProxyLike[_MapProxy__A, _MapProxy__B, Map[_MapProxy__A, _MapProxy__B]], typing.Generic[_MapProxy__A, _MapProxy__B]):
    @typing.overload
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self) -> str: ...

_MapProxyLike__A = typing.TypeVar('_MapProxyLike__A')  # <A>
_MapProxyLike__B = typing.TypeVar('_MapProxyLike__B')  # <B>
_MapProxyLike__This = typing.TypeVar('_MapProxyLike__This', bound=MapLike)  # <This>
class MapProxyLike(MapLike[_MapProxyLike__A, _MapProxyLike__B, _MapProxyLike__This], IterableProxyLike[scala.Tuple2[_MapProxyLike__A, _MapProxyLike__B], _MapProxyLike__This], typing.Generic[_MapProxyLike__A, _MapProxyLike__B, _MapProxyLike__This]):
    @staticmethod
    def $init$($this: 'MapProxyLike') -> None: ...
    @typing.overload
    def $minus(self, key: typing.Any) -> typing.Any: ...
    @typing.overload
    def $minus(self, elem: _MapProxyLike__A) -> scala.collection.generic.Subtractable: ...
    @typing.overload
    def $minus(self, key: _MapProxyLike__A) -> _MapProxyLike__This: ...
    @typing.overload
    def $minus(self, elem1: _MapProxyLike__A, elem2: _MapProxyLike__A, elems: 'Seq'[_MapProxyLike__A]) -> scala.collection.generic.Subtractable: ...
    _$plus_0__V1 = typing.TypeVar('_$plus_0__V1')  # <V1>
    _$plus_1__B1 = typing.TypeVar('_$plus_1__B1')  # <B1>
    _$plus_2__B1 = typing.TypeVar('_$plus_2__B1')  # <B1>
    @typing.overload
    def $plus(self, kv: scala.Tuple2[typing.Any, _.plus_0__V1]) -> GenMap[typing.Any, _.plus_0__V1]: ...
    @typing.overload
    def $plus(self, kv: scala.Tuple2[_MapProxyLike__A, _.plus_1__B1]) -> Map[_MapProxyLike__A, _.plus_1__B1]: ...
    @typing.overload
    def $plus(self, kv1: scala.Tuple2[_MapProxyLike__A, _.plus_2__B1], kv2: scala.Tuple2[_MapProxyLike__A, _.plus_2__B1], kvs: 'Seq'[scala.Tuple2[_MapProxyLike__A, _.plus_2__B1]]) -> Map[_MapProxyLike__A, _.plus_2__B1]: ...
    _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
    _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
    _$plus$plus_1__B1 = typing.TypeVar('_$plus$plus_1__B1')  # <B1>
    @typing.overload
    def $plus$plus(self, xs: GenTraversableOnce[typing.Any], bf: scala.collection.generic.CanBuildFrom['TraversableLike', typing.Any, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
    @typing.overload
    def $plus$plus(self, xs: GenTraversableOnce[scala.Tuple2[_MapProxyLike__A, _.plus.plus_1__B1]]) -> Map[_MapProxyLike__A, _.plus.plus_1__B1]: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder, start: str, sep: str, end: str) -> scala.collection.mutable.StringBuilder: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder) -> scala.collection.mutable.StringBuilder: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder, sep: str) -> scala.collection.mutable.StringBuilder: ...
    def apply(self, key: _MapProxyLike__A) -> _MapProxyLike__B: ...
    def contains(self, key: _MapProxyLike__A) -> bool: ...
    def default(self, key: _MapProxyLike__A) -> _MapProxyLike__B: ...
    @typing.overload
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    def filterKeys(self, p: scala.Function1[typing.Any, typing.Any]) -> GenMap[typing.Any, typing.Any]: ...
    @typing.overload
    def filterKeys(self, p: scala.Function1[_MapProxyLike__A, typing.Any]) -> Map[_MapProxyLike__A, _MapProxyLike__B]: ...
    @typing.overload
    def filterNot(self, p: scala.Function1[_MapProxyLike__A, typing.Any]) -> typing.Any: ...
    @typing.overload
    def filterNot(self, p: scala.Function1[scala.Tuple2[_MapProxyLike__A, _MapProxyLike__B], typing.Any]) -> _MapProxyLike__This: ...
    @typing.overload
    def filterNot(self, p: scala.Function1[_MapProxyLike__A, typing.Any]) -> 'TraversableLike': ...
    def get(self, key: _MapProxyLike__A) -> scala.Option[_MapProxyLike__B]: ...
    _getOrElse__B1 = typing.TypeVar('_getOrElse__B1')  # <B1>
    def getOrElse(self, key: _MapProxyLike__A, default: scala.Function0[_getOrElse__B1]) -> _getOrElse__B1: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @typing.overload
    def hashCode(self) -> int: ...
    def isDefinedAt(self, key: _MapProxyLike__A) -> bool: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[scala.Tuple2[_MapProxyLike__A, _MapProxyLike__B]]: ...
    @typing.overload
    def keySet(self) -> GenSet[typing.Any]: ...
    @typing.overload
    def keySet(self) -> 'Set'[_MapProxyLike__A]: ...
    @typing.overload
    def keys(self) -> GenIterable[typing.Any]: ...
    @typing.overload
    def keys(self) -> Iterable[_MapProxyLike__A]: ...
    def keysIterator(self) -> Iterator[_MapProxyLike__A]: ...
    _mapValues_0__W = typing.TypeVar('_mapValues_0__W')  # <W>
    _mapValues_1__C = typing.TypeVar('_mapValues_1__C')  # <C>
    @typing.overload
    def mapValues(self, f: scala.Function1[typing.Any, _mapValues_0__W]) -> GenMap[typing.Any, _mapValues_0__W]: ...
    @typing.overload
    def mapValues(self, f: scala.Function1[_MapProxyLike__B, _mapValues_1__C]) -> Map[_MapProxyLike__A, _mapValues_1__C]: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self) -> str: ...
    _updated__B1 = typing.TypeVar('_updated__B1')  # <B1>
    def updated(self, key: _MapProxyLike__A, value: _updated__B1) -> Map[_MapProxyLike__A, _updated__B1]: ...
    @typing.overload
    def values(self) -> GenIterable[typing.Any]: ...
    @typing.overload
    def values(self) -> Iterable[_MapProxyLike__B]: ...
    def valuesIterator(self) -> Iterator[_MapProxyLike__B]: ...

_Searching__SearchImpl__A = typing.TypeVar('_Searching__SearchImpl__A')  # <A>
_Searching__SearchImpl__Repr = typing.TypeVar('_Searching__SearchImpl__Repr')  # <Repr>
class Searching:
    _search__Repr = typing.TypeVar('_search__Repr')  # <Repr>
    _search__A = typing.TypeVar('_search__A')  # <A>
    @staticmethod
    def search(coll: _search__Repr, fr: scala.collection.generic.IsSeqLike[_search__Repr]) -> 'Searching.SearchImpl'[typing.Any, _search__Repr]: ...
    class Found(scala.collection.Searching.SearchResult, scala.Product, scala.Serializable):
        def __init__(self, foundIndex: int): ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        def copy(self, foundIndex: int) -> 'Searching.Found': ...
        def copy$default$1(self) -> int: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def foundIndex(self) -> int: ...
        def hashCode(self) -> int: ...
        def insertionPoint(self) -> int: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> Iterator[typing.Any]: ...
        def productPrefix(self) -> str: ...
        def toString(self) -> str: ...
    class Found$(scala.runtime.AbstractFunction1[typing.Any, 'Searching.Found'], scala.Serializable):
        MODULE$: typing.ClassVar['Searching.Found.'] = ...
        def __init__(self): ...
        def apply(self, foundIndex: int) -> 'Searching.Found': ...
        def toString(self) -> str: ...
        def unapply(self, x$0: 'Searching.Found') -> scala.Option[typing.Any]: ...
    class InsertionPoint(scala.collection.Searching.SearchResult, scala.Product, scala.Serializable):
        def __init__(self, insertionPoint: int): ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        def copy(self, insertionPoint: int) -> 'Searching.InsertionPoint': ...
        def copy$default$1(self) -> int: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def insertionPoint(self) -> int: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> Iterator[typing.Any]: ...
        def productPrefix(self) -> str: ...
        def toString(self) -> str: ...
    class InsertionPoint$(scala.runtime.AbstractFunction1[typing.Any, 'Searching.InsertionPoint'], scala.Serializable):
        MODULE$: typing.ClassVar['Searching.InsertionPoint.'] = ...
        def __init__(self): ...
        def apply(self, insertionPoint: int) -> 'Searching.InsertionPoint': ...
        def toString(self) -> str: ...
        def unapply(self, x$0: 'Searching.InsertionPoint') -> scala.Option[typing.Any]: ...
    class SearchImpl(typing.Generic[_Searching__SearchImpl__A, _Searching__SearchImpl__Repr]):
        def __init__(self, coll: 'SeqLike'[_Searching__SearchImpl__A, _Searching__SearchImpl__Repr]): ...
        def coll(self) -> 'SeqLike'[_Searching__SearchImpl__A, _Searching__SearchImpl__Repr]: ...
        _search_0__B = typing.TypeVar('_search_0__B')  # <B>
        _search_1__B = typing.TypeVar('_search_1__B')  # <B>
        @typing.overload
        def search(self, elem: _search_0__B, from_: int, to: int, ord: scala.math.Ordering[_search_0__B]) -> 'Searching.SearchResult': ...
        @typing.overload
        def search(self, elem: _search_1__B, ord: scala.math.Ordering[_search_1__B]) -> 'Searching.SearchResult': ...
    class SearchResult:
        def __init__(self): ...
        def insertionPoint(self) -> int: ...

_Seq__A = typing.TypeVar('_Seq__A')  # <A>
class Seq(scala.PartialFunction[typing.Any, _Seq__A], Iterable[_Seq__A], GenSeq[_Seq__A], scala.collection.SeqLike[_Seq__A, 'Seq'[_Seq__A]], typing.Generic[_Seq__A]):
    @staticmethod
    def $init$($this: 'Seq') -> None: ...
    @staticmethod
    def ReusableCBF() -> scala.collection.generic.GenTraversableFactory.GenericCanBuildFrom[scala.runtime.Nothing.]: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['Seq'[typing.Any], _canBuildFrom__A, 'Seq'[_canBuildFrom__A]]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['Seq']: ...
    @staticmethod
    def concat(xss: 'Seq') -> GenTraversable: ...
    @staticmethod
    def empty() -> GenTraversable: ...
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, n5: int, elem: scala.Function0) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, elem: scala.Function0) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, elem: scala.Function0) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, elem: scala.Function0) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n: int, elem: scala.Function0) -> GenTraversable: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def iterate(start: typing.Any, len: int, f: scala.Function1) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, step: typing.Any, evidence$2: scala.math.Integral) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, evidence$1: scala.math.Integral) -> GenTraversable: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[_Seq__A]: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[_Seq__A]: ...
    @typing.overload
    def seq(self) -> Iterable[_Seq__A]: ...
    @typing.overload
    def seq(self) -> 'Seq'[_Seq__A]: ...
    @typing.overload
    def seq(self) -> 'Traversable'[_Seq__A]: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, n5: int, f: scala.Function5) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, f: scala.Function4) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, f: scala.Function3) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, f: scala.Function2) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n: int, f: scala.Function1) -> GenTraversable: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self) -> str: ...
    _unapplySeq__A = typing.TypeVar('_unapplySeq__A')  # <A>
    @staticmethod
    def unapplySeq(x: 'Seq'[_unapplySeq__A]) -> scala.Some['Seq'[_unapplySeq__A]]: ...

_SeqLike__A = typing.TypeVar('_SeqLike__A')  # <A>
_SeqLike__Repr = typing.TypeVar('_SeqLike__Repr')  # <Repr>
class SeqLike(IterableLike[_SeqLike__A, _SeqLike__Repr], GenSeqLike[_SeqLike__A, _SeqLike__Repr], typing.Generic[_SeqLike__A, _SeqLike__Repr]):
    _$colon$plus__B = typing.TypeVar('_$colon$plus__B')  # <B>
    _$colon$plus__That = typing.TypeVar('_$colon$plus__That')  # <That>
    def $colon$plus(self, elem: _.colon.plus__B, bf: scala.collection.generic.CanBuildFrom[_SeqLike__Repr, _.colon.plus__B, _.colon.plus__That]) -> _.colon.plus__That: ...
    @staticmethod
    def $init$($this: 'SeqLike') -> None: ...
    _$plus$colon__B = typing.TypeVar('_$plus$colon__B')  # <B>
    _$plus$colon__That = typing.TypeVar('_$plus$colon__That')  # <That>
    def $plus$colon(self, elem: _.plus.colon__B, bf: scala.collection.generic.CanBuildFrom[_SeqLike__Repr, _.plus.colon__B, _.plus.colon__That]) -> _.plus.colon__That: ...
    def apply(self, idx: int) -> _SeqLike__A: ...
    def combinations(self, n: int) -> Iterator[_SeqLike__Repr]: ...
    _contains__A1 = typing.TypeVar('_contains__A1')  # <A1>
    def contains(self, elem: _contains__A1) -> bool: ...
    _containsSlice__B = typing.TypeVar('_containsSlice__B')  # <B>
    def containsSlice(self, that: GenSeq[_containsSlice__B]) -> bool: ...
    _corresponds__B = typing.TypeVar('_corresponds__B')  # <B>
    def corresponds(self, that: GenSeq[_corresponds__B], p: scala.Function2[_SeqLike__A, _corresponds__B, typing.Any]) -> bool: ...
    _diff__B = typing.TypeVar('_diff__B')  # <B>
    def diff(self, that: GenSeq[_diff__B]) -> _SeqLike__Repr: ...
    def distinct(self) -> _SeqLike__Repr: ...
    _endsWith__B = typing.TypeVar('_endsWith__B')  # <B>
    def endsWith(self, that: GenSeq[_endsWith__B]) -> bool: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    _indexOfSlice_0__B = typing.TypeVar('_indexOfSlice_0__B')  # <B>
    _indexOfSlice_1__B = typing.TypeVar('_indexOfSlice_1__B')  # <B>
    @typing.overload
    def indexOfSlice(self, that: GenSeq[_indexOfSlice_0__B]) -> int: ...
    @typing.overload
    def indexOfSlice(self, that: GenSeq[_indexOfSlice_1__B], from_: int) -> int: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[_SeqLike__A, typing.Any]) -> int: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[_SeqLike__A, typing.Any], from_: int) -> int: ...
    def indices(self) -> scala.collection.immutable.Range: ...
    _intersect__B = typing.TypeVar('_intersect__B')  # <B>
    def intersect(self, that: GenSeq[_intersect__B]) -> _SeqLike__Repr: ...
    def isEmpty(self) -> bool: ...
    _lastIndexOfSlice_0__B = typing.TypeVar('_lastIndexOfSlice_0__B')  # <B>
    _lastIndexOfSlice_1__B = typing.TypeVar('_lastIndexOfSlice_1__B')  # <B>
    @typing.overload
    def lastIndexOfSlice(self, that: GenSeq[_lastIndexOfSlice_0__B]) -> int: ...
    @typing.overload
    def lastIndexOfSlice(self, that: GenSeq[_lastIndexOfSlice_1__B], end: int) -> int: ...
    @typing.overload
    def lastIndexWhere(self, p: scala.Function1[_SeqLike__A, typing.Any]) -> int: ...
    @typing.overload
    def lastIndexWhere(self, p: scala.Function1[_SeqLike__A, typing.Any], end: int) -> int: ...
    def length(self) -> int: ...
    def lengthCompare(self, len: int) -> int: ...
    _padTo__B = typing.TypeVar('_padTo__B')  # <B>
    _padTo__That = typing.TypeVar('_padTo__That')  # <That>
    def padTo(self, len: int, elem: _padTo__B, bf: scala.collection.generic.CanBuildFrom[_SeqLike__Repr, _padTo__B, _padTo__That]) -> _padTo__That: ...
    def parCombiner(self) -> scala.collection.parallel.Combiner[_SeqLike__A, scala.collection.parallel.ParSeq[_SeqLike__A]]: ...
    _patch__B = typing.TypeVar('_patch__B')  # <B>
    _patch__That = typing.TypeVar('_patch__That')  # <That>
    def patch(self, from_: int, patch: GenSeq[_patch__B], replaced: int, bf: scala.collection.generic.CanBuildFrom[_SeqLike__Repr, _patch__B, _patch__That]) -> _patch__That: ...
    def permutations(self) -> Iterator[_SeqLike__Repr]: ...
    def reverse(self) -> _SeqLike__Repr: ...
    def reverseIterator(self) -> Iterator[_SeqLike__A]: ...
    _reverseMap__B = typing.TypeVar('_reverseMap__B')  # <B>
    _reverseMap__That = typing.TypeVar('_reverseMap__That')  # <That>
    def reverseMap(self, f: scala.Function1[_SeqLike__A, _reverseMap__B], bf: scala.collection.generic.CanBuildFrom[_SeqLike__Repr, _reverseMap__B, _reverseMap__That]) -> _reverseMap__That: ...
    def segmentLength(self, p: scala.Function1[_SeqLike__A, typing.Any], from_: int) -> int: ...
    def size(self) -> int: ...
    _sortBy__B = typing.TypeVar('_sortBy__B')  # <B>
    def sortBy(self, f: scala.Function1[_SeqLike__A, _sortBy__B], ord: scala.math.Ordering[_sortBy__B]) -> _SeqLike__Repr: ...
    def sortWith(self, lt: scala.Function2[_SeqLike__A, _SeqLike__A, typing.Any]) -> _SeqLike__Repr: ...
    _sorted__B = typing.TypeVar('_sorted__B')  # <B>
    def sorted(self, ord: scala.math.Ordering[_sorted__B]) -> _SeqLike__Repr: ...
    _startsWith_0__B = typing.TypeVar('_startsWith_0__B')  # <B>
    _startsWith_1__B = typing.TypeVar('_startsWith_1__B')  # <B>
    @typing.overload
    def startsWith(self, that: GenSeq[_startsWith_0__B]) -> bool: ...
    @typing.overload
    def startsWith(self, that: GenSeq[_startsWith_1__B], offset: int) -> bool: ...
    @typing.overload
    def thisCollection(self) -> Iterable[_SeqLike__A]: ...
    @typing.overload
    def thisCollection(self) -> Seq[_SeqLike__A]: ...
    @typing.overload
    def thisCollection(self) -> 'Traversable'[_SeqLike__A]: ...
    @typing.overload
    def toCollection(self, repr: _SeqLike__Repr) -> Iterable[_SeqLike__A]: ...
    @typing.overload
    def toCollection(self, repr: _SeqLike__Repr) -> Seq[_SeqLike__A]: ...
    @typing.overload
    def toCollection(self, repr: _SeqLike__Repr) -> 'Traversable'[_SeqLike__A]: ...
    @typing.overload
    def toSeq(self) -> GenSeq[_SeqLike__A]: ...
    @typing.overload
    def toSeq(self) -> Seq[_SeqLike__A]: ...
    def toString(self) -> str: ...
    _union__B = typing.TypeVar('_union__B')  # <B>
    _union__That = typing.TypeVar('_union__That')  # <That>
    def union(self, that: GenSeq[_union__B], bf: scala.collection.generic.CanBuildFrom[_SeqLike__Repr, _union__B, _union__That]) -> _union__That: ...
    _updated__B = typing.TypeVar('_updated__B')  # <B>
    _updated__That = typing.TypeVar('_updated__That')  # <That>
    def updated(self, index: int, elem: _updated__B, bf: scala.collection.generic.CanBuildFrom[_SeqLike__Repr, _updated__B, _updated__That]) -> _updated__That: ...
    @typing.overload
    def view(self) -> IterableView[_SeqLike__A, _SeqLike__Repr]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> IterableView[_SeqLike__A, _SeqLike__Repr]: ...
    @typing.overload
    def view(self) -> 'SeqView'[_SeqLike__A, _SeqLike__Repr]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> 'SeqView'[_SeqLike__A, _SeqLike__Repr]: ...
    @typing.overload
    def view(self) -> 'TraversableView'[_SeqLike__A, _SeqLike__Repr]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> 'TraversableView'[_SeqLike__A, _SeqLike__Repr]: ...
    class CombinationsItr(AbstractIterator[_SeqLike__Repr]):
        $outer: 'SeqLike' = ...
        def __init__(self, $outer: 'SeqLike', n: int): ...
        def hasNext(self) -> bool: ...
        def next(self) -> _SeqLike__Repr: ...
    class PermutationsItr(AbstractIterator[_SeqLike__Repr]):
        $outer: 'SeqLike' = ...
        def __init__(self, $outer: 'SeqLike'): ...
        def hasNext(self) -> bool: ...
        def next(self) -> _SeqLike__Repr: ...

_SeqProxy__A = typing.TypeVar('_SeqProxy__A')  # <A>
class SeqProxy(Seq[_SeqProxy__A], scala.collection.SeqProxyLike[_SeqProxy__A, Seq[_SeqProxy__A]], typing.Generic[_SeqProxy__A]):
    @typing.overload
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self) -> str: ...

_SeqProxyLike__A = typing.TypeVar('_SeqProxyLike__A')  # <A>
_SeqProxyLike__Repr = typing.TypeVar('_SeqProxyLike__Repr', bound=SeqLike)  # <Repr>
class SeqProxyLike(SeqLike[_SeqProxyLike__A, _SeqProxyLike__Repr], IterableProxyLike[_SeqProxyLike__A, _SeqProxyLike__Repr], typing.Generic[_SeqProxyLike__A, _SeqProxyLike__Repr]):
    _$colon$plus__B = typing.TypeVar('_$colon$plus__B')  # <B>
    _$colon$plus__That = typing.TypeVar('_$colon$plus__That')  # <That>
    def $colon$plus(self, elem: _.colon.plus__B, bf: scala.collection.generic.CanBuildFrom[_SeqProxyLike__Repr, _.colon.plus__B, _.colon.plus__That]) -> _.colon.plus__That: ...
    @staticmethod
    def $init$($this: 'SeqProxyLike') -> None: ...
    _$plus$colon__B = typing.TypeVar('_$plus$colon__B')  # <B>
    _$plus$colon__That = typing.TypeVar('_$plus$colon__That')  # <That>
    def $plus$colon(self, elem: _.plus.colon__B, bf: scala.collection.generic.CanBuildFrom[_SeqProxyLike__Repr, _.plus.colon__B, _.plus.colon__That]) -> _.plus.colon__That: ...
    def apply(self, idx: int) -> _SeqProxyLike__A: ...
    _contains__A1 = typing.TypeVar('_contains__A1')  # <A1>
    def contains(self, elem: _contains__A1) -> bool: ...
    _containsSlice__B = typing.TypeVar('_containsSlice__B')  # <B>
    def containsSlice(self, that: GenSeq[_containsSlice__B]) -> bool: ...
    _corresponds__B = typing.TypeVar('_corresponds__B')  # <B>
    def corresponds(self, that: GenSeq[_corresponds__B], p: scala.Function2[_SeqProxyLike__A, _corresponds__B, typing.Any]) -> bool: ...
    _diff_0__B = typing.TypeVar('_diff_0__B')  # <B>
    _diff_1__B = typing.TypeVar('_diff_1__B')  # <B>
    @typing.overload
    def diff(self, that: GenSeq[_diff_0__B]) -> _SeqProxyLike__Repr: ...
    @typing.overload
    def diff(self, that: GenSeq[_diff_1__B]) -> _SeqProxyLike__Repr: ...
    @typing.overload
    def distinct(self) -> _SeqProxyLike__Repr: ...
    @typing.overload
    def distinct(self) -> _SeqProxyLike__Repr: ...
    _endsWith__B = typing.TypeVar('_endsWith__B')  # <B>
    def endsWith(self, that: GenSeq[_endsWith__B]) -> bool: ...
    @typing.overload
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @typing.overload
    def hashCode(self) -> int: ...
    _indexOf_0__B = typing.TypeVar('_indexOf_0__B')  # <B>
    _indexOf_1__B = typing.TypeVar('_indexOf_1__B')  # <B>
    @typing.overload
    def indexOf(self, elem: _indexOf_0__B) -> int: ...
    @typing.overload
    def indexOf(self, elem: _indexOf_1__B, from_: int) -> int: ...
    _indexOfSlice_0__B = typing.TypeVar('_indexOfSlice_0__B')  # <B>
    _indexOfSlice_1__B = typing.TypeVar('_indexOfSlice_1__B')  # <B>
    @typing.overload
    def indexOfSlice(self, that: GenSeq[_indexOfSlice_0__B]) -> int: ...
    @typing.overload
    def indexOfSlice(self, that: GenSeq[_indexOfSlice_1__B], from_: int) -> int: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[_SeqProxyLike__A, typing.Any]) -> int: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[_SeqProxyLike__A, typing.Any], from_: int) -> int: ...
    def indices(self) -> scala.collection.immutable.Range: ...
    _intersect_0__B = typing.TypeVar('_intersect_0__B')  # <B>
    _intersect_1__B = typing.TypeVar('_intersect_1__B')  # <B>
    @typing.overload
    def intersect(self, that: GenSeq[_intersect_0__B]) -> _SeqProxyLike__Repr: ...
    @typing.overload
    def intersect(self, that: GenSeq[_intersect_1__B]) -> _SeqProxyLike__Repr: ...
    def isDefinedAt(self, x: int) -> bool: ...
    _lastIndexOf_0__B = typing.TypeVar('_lastIndexOf_0__B')  # <B>
    _lastIndexOf_1__B = typing.TypeVar('_lastIndexOf_1__B')  # <B>
    @typing.overload
    def lastIndexOf(self, elem: _lastIndexOf_0__B) -> int: ...
    @typing.overload
    def lastIndexOf(self, elem: _lastIndexOf_1__B, end: int) -> int: ...
    _lastIndexOfSlice_0__B = typing.TypeVar('_lastIndexOfSlice_0__B')  # <B>
    _lastIndexOfSlice_1__B = typing.TypeVar('_lastIndexOfSlice_1__B')  # <B>
    @typing.overload
    def lastIndexOfSlice(self, that: GenSeq[_lastIndexOfSlice_0__B]) -> int: ...
    @typing.overload
    def lastIndexOfSlice(self, that: GenSeq[_lastIndexOfSlice_1__B], end: int) -> int: ...
    @typing.overload
    def lastIndexWhere(self, p: scala.Function1[_SeqProxyLike__A, typing.Any]) -> int: ...
    @typing.overload
    def lastIndexWhere(self, p: scala.Function1[_SeqProxyLike__A, typing.Any], end: int) -> int: ...
    def length(self) -> int: ...
    def lengthCompare(self, len: int) -> int: ...
    _padTo__B = typing.TypeVar('_padTo__B')  # <B>
    _padTo__That = typing.TypeVar('_padTo__That')  # <That>
    def padTo(self, len: int, elem: _padTo__B, bf: scala.collection.generic.CanBuildFrom[_SeqProxyLike__Repr, _padTo__B, _padTo__That]) -> _padTo__That: ...
    _patch__B = typing.TypeVar('_patch__B')  # <B>
    _patch__That = typing.TypeVar('_patch__That')  # <That>
    def patch(self, from_: int, patch: GenSeq[_patch__B], replaced: int, bf: scala.collection.generic.CanBuildFrom[_SeqProxyLike__Repr, _patch__B, _patch__That]) -> _patch__That: ...
    def prefixLength(self, p: scala.Function1[_SeqProxyLike__A, typing.Any]) -> int: ...
    @typing.overload
    def reverse(self) -> _SeqProxyLike__Repr: ...
    @typing.overload
    def reverse(self) -> _SeqProxyLike__Repr: ...
    def reverseIterator(self) -> Iterator[_SeqProxyLike__A]: ...
    _reverseMap__B = typing.TypeVar('_reverseMap__B')  # <B>
    _reverseMap__That = typing.TypeVar('_reverseMap__That')  # <That>
    def reverseMap(self, f: scala.Function1[_SeqProxyLike__A, _reverseMap__B], bf: scala.collection.generic.CanBuildFrom[_SeqProxyLike__Repr, _reverseMap__B, _reverseMap__That]) -> _reverseMap__That: ...
    def segmentLength(self, p: scala.Function1[_SeqProxyLike__A, typing.Any], from_: int) -> int: ...
    def size(self) -> int: ...
    _sortBy_0__B = typing.TypeVar('_sortBy_0__B')  # <B>
    _sortBy_1__B = typing.TypeVar('_sortBy_1__B')  # <B>
    @typing.overload
    def sortBy(self, f: scala.Function1[_SeqProxyLike__A, _sortBy_0__B], ord: scala.math.Ordering[_sortBy_0__B]) -> _SeqProxyLike__Repr: ...
    @typing.overload
    def sortBy(self, f: scala.Function1[_SeqProxyLike__A, _sortBy_1__B], ord: scala.math.Ordering[_sortBy_1__B]) -> _SeqProxyLike__Repr: ...
    @typing.overload
    def sortWith(self, lt: scala.Function2[_SeqProxyLike__A, _SeqProxyLike__A, typing.Any]) -> _SeqProxyLike__Repr: ...
    @typing.overload
    def sortWith(self, lt: scala.Function2[_SeqProxyLike__A, _SeqProxyLike__A, typing.Any]) -> _SeqProxyLike__Repr: ...
    _sorted_0__B = typing.TypeVar('_sorted_0__B')  # <B>
    _sorted_1__B = typing.TypeVar('_sorted_1__B')  # <B>
    @typing.overload
    def sorted(self, ord: scala.math.Ordering[_sorted_0__B]) -> _SeqProxyLike__Repr: ...
    @typing.overload
    def sorted(self, ord: scala.math.Ordering[_sorted_1__B]) -> _SeqProxyLike__Repr: ...
    _startsWith_0__B = typing.TypeVar('_startsWith_0__B')  # <B>
    _startsWith_1__B = typing.TypeVar('_startsWith_1__B')  # <B>
    @typing.overload
    def startsWith(self, that: GenSeq[_startsWith_0__B]) -> bool: ...
    @typing.overload
    def startsWith(self, that: GenSeq[_startsWith_1__B], offset: int) -> bool: ...
    @typing.overload
    def toSeq(self) -> GenSeq[_SeqProxyLike__A]: ...
    @typing.overload
    def toSeq(self) -> Seq[_SeqProxyLike__A]: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self) -> str: ...
    _union__B = typing.TypeVar('_union__B')  # <B>
    _union__That = typing.TypeVar('_union__That')  # <That>
    def union(self, that: GenSeq[_union__B], bf: scala.collection.generic.CanBuildFrom[_SeqProxyLike__Repr, _union__B, _union__That]) -> _union__That: ...
    _updated__B = typing.TypeVar('_updated__B')  # <B>
    _updated__That = typing.TypeVar('_updated__That')  # <That>
    def updated(self, index: int, elem: _updated__B, bf: scala.collection.generic.CanBuildFrom[_SeqProxyLike__Repr, _updated__B, _updated__That]) -> _updated__That: ...
    @typing.overload
    def view(self) -> IterableView[_SeqProxyLike__A, _SeqProxyLike__Repr]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> IterableView[_SeqProxyLike__A, _SeqProxyLike__Repr]: ...
    @typing.overload
    def view(self) -> 'SeqView'[_SeqProxyLike__A, _SeqProxyLike__Repr]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> 'SeqView'[_SeqProxyLike__A, _SeqProxyLike__Repr]: ...
    @typing.overload
    def view(self) -> 'TraversableView'[_SeqProxyLike__A, _SeqProxyLike__Repr]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> 'TraversableView'[_SeqProxyLike__A, _SeqProxyLike__Repr]: ...

_SeqView__A = typing.TypeVar('_SeqView__A')  # <A>
_SeqView__Coll = typing.TypeVar('_SeqView__Coll')  # <Coll>
class SeqView(scala.collection.SeqViewLike[_SeqView__A, _SeqView__Coll, 'SeqView'[_SeqView__A, _SeqView__Coll]], typing.Generic[_SeqView__A, _SeqView__Coll]):
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['TraversableView'[typing.Any, 'Traversable'[typing.Any]], _canBuildFrom__A, 'SeqView'[_canBuildFrom__A, Seq[typing.Any]]]: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self) -> str: ...

_Set__A = typing.TypeVar('_Set__A')  # <A>
class Set(Iterable[_Set__A], GenSet[_Set__A], scala.collection.SetLike[_Set__A, 'Set'[_Set__A]], typing.Generic[_Set__A]):
    @staticmethod
    def $init$($this: 'Set') -> None: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['Set'[typing.Any], _canBuildFrom__A, 'Set'[_canBuildFrom__A]]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['Set']: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[_Set__A]: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[_Set__A]: ...
    @typing.overload
    def seq(self) -> Iterable[_Set__A]: ...
    @typing.overload
    def seq(self) -> 'Set'[_Set__A]: ...
    @typing.overload
    def seq(self) -> 'Traversable'[_Set__A]: ...
    _setCanBuildFrom__A = typing.TypeVar('_setCanBuildFrom__A')  # <A>
    @staticmethod
    def setCanBuildFrom() -> scala.collection.generic.CanBuildFrom['Set'[typing.Any], _setCanBuildFrom__A, 'Set'[_setCanBuildFrom__A]]: ...
    def toString(self) -> str: ...

_SetLike__A = typing.TypeVar('_SetLike__A')  # <A>
_SetLike__This = typing.TypeVar('_SetLike__This', bound='SetLike')  # <This>
class SetLike(IterableLike[_SetLike__A, _SetLike__This], GenSetLike[_SetLike__A, _SetLike__This], scala.collection.generic.Subtractable[_SetLike__A, _SetLike__This], typing.Generic[_SetLike__A, _SetLike__This]):
    @staticmethod
    def $init$($this: 'SetLike') -> None: ...
    @typing.overload
    def $minus(self, elem: _SetLike__A) -> typing.Any: ...
    @typing.overload
    def $minus(self, elem: _SetLike__A) -> _SetLike__This: ...
    @typing.overload
    def $minus(self, elem: _SetLike__A) -> scala.collection.generic.Subtractable: ...
    @typing.overload
    def $minus(self, elem1: _SetLike__A, elem2: _SetLike__A, elems: Seq[_SetLike__A]) -> scala.collection.generic.Subtractable: ...
    @typing.overload
    def $plus(self, elem: _SetLike__A) -> typing.Any: ...
    @typing.overload
    def $plus(self, elem: _SetLike__A) -> _SetLike__This: ...
    @typing.overload
    def $plus(self, elem1: _SetLike__A, elem2: _SetLike__A, elems: Seq[_SetLike__A]) -> _SetLike__This: ...
    _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
    _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
    @typing.overload
    def $plus$plus(self, that: GenTraversableOnce[_.plus.plus_0__B], bf: scala.collection.generic.CanBuildFrom[typing.Any, _.plus.plus_0__B, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
    @typing.overload
    def $plus$plus(self, elems: GenTraversableOnce[_SetLike__A]) -> _SetLike__This: ...
    def contains(self, elem: _SetLike__A) -> bool: ...
    @typing.overload
    def diff(self, that: GenSet[_SetLike__A]) -> typing.Any: ...
    @typing.overload
    def diff(self, that: GenSet[_SetLike__A]) -> _SetLike__This: ...
    def empty(self) -> _SetLike__This: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    _map__B = typing.TypeVar('_map__B')  # <B>
    _map__That = typing.TypeVar('_map__That')  # <That>
    def map(self, f: scala.Function1[_SetLike__A, _map__B], bf: scala.collection.generic.CanBuildFrom[_SetLike__This, _map__B, _map__That]) -> _map__That: ...
    def newBuilder(self) -> scala.collection.mutable.Builder[_SetLike__A, _SetLike__This]: ...
    def parCombiner(self) -> scala.collection.parallel.Combiner[_SetLike__A, scala.collection.parallel.ParSet[_SetLike__A]]: ...
    def stringPrefix(self) -> str: ...
    @typing.overload
    def subsets(self) -> Iterator[_SetLike__This]: ...
    @typing.overload
    def subsets(self, len: int) -> Iterator[_SetLike__This]: ...
    _toBuffer__A1 = typing.TypeVar('_toBuffer__A1')  # <A1>
    def toBuffer(self) -> scala.collection.mutable.Buffer[_toBuffer__A1]: ...
    @typing.overload
    def toSeq(self) -> GenSeq[_SetLike__A]: ...
    @typing.overload
    def toSeq(self) -> Seq[_SetLike__A]: ...
    def toString(self) -> str: ...
    @typing.overload
    def union(self, that: GenSet[_SetLike__A]) -> typing.Any: ...
    @typing.overload
    def union(self, that: GenSet[_SetLike__A]) -> _SetLike__This: ...
    class SubsetsItr(AbstractIterator[_SetLike__This]):
        $outer: 'SetLike' = ...
        def __init__(self, $outer: 'SetLike', elms: IndexedSeq[_SetLike__A], len: int): ...
        def hasNext(self) -> bool: ...
        def next(self) -> _SetLike__This: ...

_SetProxy__A = typing.TypeVar('_SetProxy__A')  # <A>
class SetProxy(Set[_SetProxy__A], scala.collection.SetProxyLike[_SetProxy__A, Set[_SetProxy__A]], typing.Generic[_SetProxy__A]):
    @typing.overload
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self) -> str: ...

_SetProxyLike__A = typing.TypeVar('_SetProxyLike__A')  # <A>
_SetProxyLike__This = typing.TypeVar('_SetProxyLike__This', bound=SetLike)  # <This>
class SetProxyLike(SetLike[_SetProxyLike__A, _SetProxyLike__This], IterableProxyLike[_SetProxyLike__A, _SetProxyLike__This], typing.Generic[_SetProxyLike__A, _SetProxyLike__This]):
    @typing.overload
    def $amp(self, that: GenSet[_SetProxyLike__A]) -> typing.Any: ...
    @typing.overload
    def $amp(self, that: GenSet[_SetProxyLike__A]) -> _SetProxyLike__This: ...
    @typing.overload
    def $amp$tilde(self, that: GenSet[_SetProxyLike__A]) -> typing.Any: ...
    @typing.overload
    def $amp$tilde(self, that: GenSet[_SetProxyLike__A]) -> _SetProxyLike__This: ...
    @typing.overload
    def $bar(self, that: GenSet[_SetProxyLike__A]) -> typing.Any: ...
    @typing.overload
    def $bar(self, that: GenSet[_SetProxyLike__A]) -> _SetProxyLike__This: ...
    @staticmethod
    def $init$($this: 'SetProxyLike') -> None: ...
    @typing.overload
    def $minus(self, elem: _SetProxyLike__A) -> typing.Any: ...
    @typing.overload
    def $minus(self, elem: _SetProxyLike__A) -> scala.collection.generic.Subtractable: ...
    @typing.overload
    def $minus(self, elem: _SetProxyLike__A) -> _SetProxyLike__This: ...
    @typing.overload
    def $minus(self, elem1: _SetProxyLike__A, elem2: _SetProxyLike__A, elems: Seq[_SetProxyLike__A]) -> scala.collection.generic.Subtractable: ...
    @typing.overload
    def $plus(self, elem: _SetProxyLike__A) -> typing.Any: ...
    @typing.overload
    def $plus(self, elem1: _SetProxyLike__A, elem2: _SetProxyLike__A, elems: Seq[_SetProxyLike__A]) -> _SetProxyLike__This: ...
    @typing.overload
    def $plus(self, elem: _SetProxyLike__A) -> _SetProxyLike__This: ...
    @typing.overload
    def apply(self, v1: typing.Any) -> typing.Any: ...
    @typing.overload
    def apply(self, elem: _SetProxyLike__A) -> bool: ...
    def contains(self, elem: _SetProxyLike__A) -> bool: ...
    @typing.overload
    def diff(self, that: GenSet[_SetProxyLike__A]) -> typing.Any: ...
    @typing.overload
    def diff(self, that: GenSet[_SetProxyLike__A]) -> _SetProxyLike__This: ...
    def empty(self) -> _SetProxyLike__This: ...
    @typing.overload
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @typing.overload
    def intersect(self, that: GenSet[_SetProxyLike__A]) -> typing.Any: ...
    @typing.overload
    def intersect(self, that: GenSet[_SetProxyLike__A]) -> _SetProxyLike__This: ...
    def isEmpty(self) -> bool: ...
    def subsetOf(self, that: GenSet[_SetProxyLike__A]) -> bool: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def union(self, that: GenSet[_SetProxyLike__A]) -> typing.Any: ...
    @typing.overload
    def union(self, that: GenSet[_SetProxyLike__A]) -> _SetProxyLike__This: ...

_SortedMap__Default__A = typing.TypeVar('_SortedMap__Default__A')  # <A>
_SortedMap__Default__B = typing.TypeVar('_SortedMap__Default__B')  # <B>
_SortedMap__A = typing.TypeVar('_SortedMap__A')  # <A>
_SortedMap__B = typing.TypeVar('_SortedMap__B')  # <B>
class SortedMap(Map[_SortedMap__A, _SortedMap__B], scala.collection.SortedMapLike[_SortedMap__A, _SortedMap__B, 'SortedMap'[_SortedMap__A, _SortedMap__B]], typing.Generic[_SortedMap__A, _SortedMap__B]):
    @staticmethod
    def $init$($this: 'SortedMap') -> None: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    _canBuildFrom__B = typing.TypeVar('_canBuildFrom__B')  # <B>
    @staticmethod
    def canBuildFrom(ord: scala.math.Ordering[_canBuildFrom__A]) -> scala.collection.generic.CanBuildFrom['SortedMap'[typing.Any, typing.Any], scala.Tuple2[_canBuildFrom__A, _canBuildFrom__B], 'SortedMap'[_canBuildFrom__A, _canBuildFrom__B]]: ...
    @typing.overload
    def empty(self) -> Map[typing.Any, typing.Any]: ...
    @typing.overload
    def empty(self) -> 'SortedMap'[_SortedMap__A, _SortedMap__B]: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def newBuilder(self) -> scala.collection.mutable.Builder[scala.Tuple2[_SortedMap__A, _SortedMap__B], 'SortedMap'[_SortedMap__A, _SortedMap__B]]: ...
    def toString(self) -> str: ...
    class Default(scala.collection.SortedMap[_SortedMap__Default__A, _SortedMap__Default__B], typing.Generic[_SortedMap__Default__A, _SortedMap__Default__B]):
        @staticmethod
        def $init$($this: 'SortedMap.Default') -> None: ...
        @typing.overload
        def $minus(self, key: typing.Any) -> typing.Any: ...
        @typing.overload
        def $minus(self, key: typing.Any) -> MapLike: ...
        @typing.overload
        def $minus(self, elem: _SortedMap__Default__A) -> scala.collection.generic.Subtractable: ...
        @typing.overload
        def $minus(self, key: _SortedMap__Default__A) -> 'SortedMap'[_SortedMap__Default__A, _SortedMap__Default__B]: ...
        @typing.overload
        def $minus(self, elem1: _SortedMap__Default__A, elem2: _SortedMap__Default__A, elems: Seq[_SortedMap__Default__A]) -> scala.collection.generic.Subtractable: ...
        _$plus_0__V1 = typing.TypeVar('_$plus_0__V1')  # <V1>
        _$plus_1__V1 = typing.TypeVar('_$plus_1__V1')  # <V1>
        _$plus_2__V1 = typing.TypeVar('_$plus_2__V1')  # <V1>
        _$plus_3__B1 = typing.TypeVar('_$plus_3__B1')  # <B1>
        _$plus_4__B1 = typing.TypeVar('_$plus_4__B1')  # <B1>
        @typing.overload
        def $plus(self, kv: scala.Tuple2[typing.Any, _.plus_0__V1]) -> GenMap[typing.Any, _.plus_0__V1]: ...
        @typing.overload
        def $plus(self, kv: scala.Tuple2[typing.Any, _.plus_1__V1]) -> Map[typing.Any, _.plus_1__V1]: ...
        @typing.overload
        def $plus(self, kv1: scala.Tuple2[typing.Any, _.plus_2__V1], kv2: scala.Tuple2[typing.Any, _.plus_2__V1], kvs: Seq[scala.Tuple2[typing.Any, _.plus_2__V1]]) -> Map[typing.Any, _.plus_2__V1]: ...
        @typing.overload
        def $plus(self, kv: scala.Tuple2[_SortedMap__Default__A, _.plus_3__B1]) -> 'SortedMap'[_SortedMap__Default__A, _.plus_3__B1]: ...
        @typing.overload
        def $plus(self, elem1: scala.Tuple2[_SortedMap__Default__A, _.plus_4__B1], elem2: scala.Tuple2[_SortedMap__Default__A, _.plus_4__B1], elems: Seq[scala.Tuple2[_SortedMap__Default__A, _.plus_4__B1]]) -> 'SortedMap'[_SortedMap__Default__A, _.plus_4__B1]: ...
        def equals(self, that: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def toString(self) -> str: ...

_SortedMapLike__A = typing.TypeVar('_SortedMapLike__A')  # <A>
_SortedMapLike__B = typing.TypeVar('_SortedMapLike__B')  # <B>
_SortedMapLike__This = typing.TypeVar('_SortedMapLike__This', bound='SortedMapLike')  # <This>
class SortedMapLike(scala.collection.generic.Sorted[_SortedMapLike__A, _SortedMapLike__This], MapLike[_SortedMapLike__A, _SortedMapLike__B, _SortedMapLike__This], typing.Generic[_SortedMapLike__A, _SortedMapLike__B, _SortedMapLike__This]):
    @staticmethod
    def $init$($this: 'SortedMapLike') -> None: ...
    _$plus_0__V1 = typing.TypeVar('_$plus_0__V1')  # <V1>
    _$plus_1__V1 = typing.TypeVar('_$plus_1__V1')  # <V1>
    _$plus_2__B1 = typing.TypeVar('_$plus_2__B1')  # <B1>
    _$plus_3__V1 = typing.TypeVar('_$plus_3__V1')  # <V1>
    _$plus_4__B1 = typing.TypeVar('_$plus_4__B1')  # <B1>
    @typing.overload
    def $plus(self, kv: scala.Tuple2[typing.Any, _.plus_0__V1]) -> GenMap[typing.Any, _.plus_0__V1]: ...
    @typing.overload
    def $plus(self, kv: scala.Tuple2[typing.Any, _.plus_1__V1]) -> Map[typing.Any, _.plus_1__V1]: ...
    @typing.overload
    def $plus(self, kv: scala.Tuple2[_SortedMapLike__A, _.plus_2__B1]) -> SortedMap[_SortedMapLike__A, _.plus_2__B1]: ...
    @typing.overload
    def $plus(self, kv1: scala.Tuple2[typing.Any, _.plus_3__V1], kv2: scala.Tuple2[typing.Any, _.plus_3__V1], kvs: Seq[scala.Tuple2[typing.Any, _.plus_3__V1]]) -> Map[typing.Any, _.plus_3__V1]: ...
    @typing.overload
    def $plus(self, elem1: scala.Tuple2[_SortedMapLike__A, _.plus_4__B1], elem2: scala.Tuple2[_SortedMapLike__A, _.plus_4__B1], elems: Seq[scala.Tuple2[_SortedMapLike__A, _.plus_4__B1]]) -> SortedMap[_SortedMapLike__A, _.plus_4__B1]: ...
    _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
    _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
    _$plus$plus_1__V1 = typing.TypeVar('_$plus$plus_1__V1')  # <V1>
    _$plus$plus_2__B1 = typing.TypeVar('_$plus$plus_2__B1')  # <B1>
    @typing.overload
    def $plus$plus(self, that: GenTraversableOnce[typing.Any], bf: scala.collection.generic.CanBuildFrom[typing.Any, typing.Any, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
    @typing.overload
    def $plus$plus(self, xs: GenTraversableOnce[scala.Tuple2[typing.Any, _.plus.plus_1__V1]]) -> Map[typing.Any, _.plus.plus_1__V1]: ...
    @typing.overload
    def $plus$plus(self, xs: GenTraversableOnce[scala.Tuple2[_SortedMapLike__A, _.plus.plus_2__B1]]) -> SortedMap[_SortedMapLike__A, _.plus.plus_2__B1]: ...
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    def filterKeys(self, p: scala.Function1[typing.Any, typing.Any]) -> GenMap[typing.Any, typing.Any]: ...
    @typing.overload
    def filterKeys(self, p: scala.Function1[typing.Any, typing.Any]) -> Map[typing.Any, typing.Any]: ...
    @typing.overload
    def filterKeys(self, p: scala.Function1[_SortedMapLike__A, typing.Any]) -> SortedMap[_SortedMapLike__A, _SortedMapLike__B]: ...
    def firstKey(self) -> _SortedMapLike__A: ...
    def hashCode(self) -> int: ...
    def iteratorFrom(self, start: _SortedMapLike__A) -> Iterator[scala.Tuple2[_SortedMapLike__A, _SortedMapLike__B]]: ...
    @typing.overload
    def keySet(self) -> GenSet[typing.Any]: ...
    @typing.overload
    def keySet(self) -> Set[typing.Any]: ...
    @typing.overload
    def keySet(self) -> 'SortedSet'[_SortedMapLike__A]: ...
    def lastKey(self) -> _SortedMapLike__A: ...
    _mapValues_0__W = typing.TypeVar('_mapValues_0__W')  # <W>
    _mapValues_1__W = typing.TypeVar('_mapValues_1__W')  # <W>
    _mapValues_2__C = typing.TypeVar('_mapValues_2__C')  # <C>
    @typing.overload
    def mapValues(self, f: scala.Function1[typing.Any, _mapValues_0__W]) -> GenMap[typing.Any, _mapValues_0__W]: ...
    @typing.overload
    def mapValues(self, f: scala.Function1[typing.Any, _mapValues_1__W]) -> Map[typing.Any, _mapValues_1__W]: ...
    @typing.overload
    def mapValues(self, f: scala.Function1[_SortedMapLike__B, _mapValues_2__C]) -> SortedMap[_SortedMapLike__A, _mapValues_2__C]: ...
    def ordering(self) -> scala.math.Ordering[_SortedMapLike__A]: ...
    @typing.overload
    def rangeImpl(self, from_: scala.Option[_SortedMapLike__A], until: scala.Option[_SortedMapLike__A]) -> _SortedMapLike__This: ...
    @typing.overload
    def rangeImpl(self, from_: scala.Option[typing.Any], until: scala.Option[typing.Any]) -> _SortedMapLike__This: ...
    def toString(self) -> str: ...
    _updated_0__V1 = typing.TypeVar('_updated_0__V1')  # <V1>
    _updated_1__B1 = typing.TypeVar('_updated_1__B1')  # <B1>
    @typing.overload
    def updated(self, key: typing.Any, value: _updated_0__V1) -> Map[typing.Any, _updated_0__V1]: ...
    @typing.overload
    def updated(self, key: _SortedMapLike__A, value: _updated_1__B1) -> SortedMap[_SortedMapLike__A, _updated_1__B1]: ...
    def valuesIteratorFrom(self, start: _SortedMapLike__A) -> Iterator[_SortedMapLike__B]: ...
    class DefaultKeySortedSet(MapLike.DefaultKeySet, scala.collection.SortedSet[_SortedMapLike__A]):
        def __init__(self, $outer: 'SortedMapLike'): ...
        @typing.overload
        def $minus(self, elem: _SortedMapLike__A) -> 'SortedSet'[_SortedMapLike__A]: ...
        @typing.overload
        def $minus(self, elem1: typing.Any, elem2: typing.Any, elems: Seq) -> scala.collection.generic.Subtractable: ...
        @typing.overload
        def $plus(self, elem1: _SortedMapLike__A, elem2: _SortedMapLike__A, elems: Seq[_SortedMapLike__A]) -> Set[_SortedMapLike__A]: ...
        @typing.overload
        def $plus(self, elem: _SortedMapLike__A) -> 'SortedSet'[_SortedMapLike__A]: ...
        def apply(self, elem: _SortedMapLike__A) -> bool: ...
        def compare(self, k0: _SortedMapLike__A, k1: _SortedMapLike__A) -> int: ...
        def diff(self, that: GenSet[_SortedMapLike__A]) -> Set[_SortedMapLike__A]: ...
        def empty(self) -> 'SortedSet'[_SortedMapLike__A]: ...
        def firstKey(self) -> _SortedMapLike__A: ...
        _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
        def groupBy(self, f: scala.Function1[_SortedMapLike__A, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, 'Traversable'[_SortedMapLike__A]]: ...
        def hasAll(self, j: Iterator[_SortedMapLike__A]) -> bool: ...
        def iteratorFrom(self, start: _SortedMapLike__A) -> Iterator[_SortedMapLike__A]: ...
        def keySet(self) -> 'SortedSet'[_SortedMapLike__A]: ...
        def keysIteratorFrom(self, start: _SortedMapLike__A) -> Iterator[_SortedMapLike__A]: ...
        def lastKey(self) -> _SortedMapLike__A: ...
        def ordering(self) -> scala.math.Ordering[_SortedMapLike__A]: ...
        def range(self, from_: _SortedMapLike__A, until: _SortedMapLike__A) -> 'SortedSet'[_SortedMapLike__A]: ...
        def rangeImpl(self, from_: scala.Option[_SortedMapLike__A], until: scala.Option[_SortedMapLike__A]) -> 'SortedSet'[_SortedMapLike__A]: ...
        def repr(self) -> typing.Any: ...
        def subsetOf(self, that: GenSet[_SortedMapLike__A]) -> bool: ...
        def thisCollection(self) -> Iterable[_SortedMapLike__A]: ...
        _to_0__Col = typing.TypeVar('_to_0__Col')  # <Col>
        @typing.overload
        def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., _SortedMapLike__A, _to_0__Col]) -> _to_0__Col: ...
        @typing.overload
        def to(self, to: typing.Any) -> scala.collection.generic.Sorted: ...
        def toCollection(self, repr: typing.Any) -> Iterable: ...
        def toIterable(self) -> Iterable[_SortedMapLike__A]: ...
        def toSeq(self) -> Seq[_SortedMapLike__A]: ...
        def toTraversable(self) -> 'Traversable'[_SortedMapLike__A]: ...
        def union(self, that: GenSet[_SortedMapLike__A]) -> Set[_SortedMapLike__A]: ...
        def until(self, until: _SortedMapLike__A) -> 'SortedSet'[_SortedMapLike__A]: ...
        @typing.overload
        def view(self) -> IterableView[_SortedMapLike__A, Iterable[_SortedMapLike__A]]: ...
        @typing.overload
        def view(self, from_: int, until: int) -> IterableView[_SortedMapLike__A, Iterable[_SortedMapLike__A]]: ...

_SortedSet__A = typing.TypeVar('_SortedSet__A')  # <A>
class SortedSet(Set[_SortedSet__A], scala.collection.SortedSetLike[_SortedSet__A, 'SortedSet'[_SortedSet__A]], typing.Generic[_SortedSet__A]):
    @staticmethod
    def $init$($this: 'SortedSet') -> None: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom(ord: scala.math.Ordering[_canBuildFrom__A]) -> scala.collection.generic.CanBuildFrom['SortedSet'[typing.Any], _canBuildFrom__A, 'SortedSet'[_canBuildFrom__A]]: ...
    @typing.overload
    def empty(self) -> SetLike: ...
    @typing.overload
    def empty(self) -> GenSet: ...
    @typing.overload
    def empty(self) -> 'SortedSet'[_SortedSet__A]: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    _newCanBuildFrom__A = typing.TypeVar('_newCanBuildFrom__A')  # <A>
    @staticmethod
    def newCanBuildFrom(ord: scala.math.Ordering[_newCanBuildFrom__A]) -> scala.collection.generic.CanBuildFrom['SortedSet'[typing.Any], _newCanBuildFrom__A, 'SortedSet'[_newCanBuildFrom__A]]: ...
    def toString(self) -> str: ...

_SortedSetLike__A = typing.TypeVar('_SortedSetLike__A')  # <A>
_SortedSetLike__This = typing.TypeVar('_SortedSetLike__This', bound=SortedSet)  # <This>
class SortedSetLike(scala.collection.generic.Sorted[_SortedSetLike__A, _SortedSetLike__This], SetLike[_SortedSetLike__A, _SortedSetLike__This], typing.Generic[_SortedSetLike__A, _SortedSetLike__This]):
    @staticmethod
    def $init$($this: 'SortedSetLike') -> None: ...
    def equals(self, that: typing.Any) -> bool: ...
    def firstKey(self) -> _SortedSetLike__A: ...
    def hashCode(self) -> int: ...
    def iteratorFrom(self, start: _SortedSetLike__A) -> Iterator[_SortedSetLike__A]: ...
    def keySet(self) -> _SortedSetLike__This: ...
    def lastKey(self) -> _SortedSetLike__A: ...
    def ordering(self) -> scala.math.Ordering[_SortedSetLike__A]: ...
    @typing.overload
    def range(self, from_: _SortedSetLike__A, until: _SortedSetLike__A) -> _SortedSetLike__This: ...
    @typing.overload
    def range(self, from_: typing.Any, until: typing.Any) -> _SortedSetLike__This: ...
    @typing.overload
    def rangeImpl(self, from_: scala.Option[_SortedSetLike__A], until: scala.Option[_SortedSetLike__A]) -> _SortedSetLike__This: ...
    @typing.overload
    def rangeImpl(self, from_: scala.Option[typing.Any], until: scala.Option[typing.Any]) -> _SortedSetLike__This: ...
    def subsetOf(self, that: GenSet[_SortedSetLike__A]) -> bool: ...
    def toString(self) -> str: ...
    @typing.overload
    def until(self, until: _SortedSetLike__A) -> _SortedSetLike__This: ...
    @typing.overload
    def until(self, until: typing.Any) -> _SortedSetLike__This: ...

_Traversable__A = typing.TypeVar('_Traversable__A')  # <A>
class Traversable(scala.collection.TraversableLike[_Traversable__A, 'Traversable'[_Traversable__A]], GenTraversable[_Traversable__A], typing.Generic[_Traversable__A]):
    @staticmethod
    def $init$($this: 'Traversable') -> None: ...
    @staticmethod
    def ReusableCBF() -> scala.collection.generic.GenTraversableFactory.GenericCanBuildFrom[scala.runtime.Nothing.]: ...
    @staticmethod
    def apply(elems: Seq) -> GenTraversable: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['Traversable'[typing.Any], _canBuildFrom__A, 'Traversable'[_canBuildFrom__A]]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['Traversable']: ...
    @staticmethod
    def concat(xss: Seq) -> GenTraversable: ...
    @staticmethod
    def empty() -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, n5: int, elem: scala.Function0) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, elem: scala.Function0) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, elem: scala.Function0) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, elem: scala.Function0) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n: int, elem: scala.Function0) -> GenTraversable: ...
    @staticmethod
    def iterate(start: typing.Any, len: int, f: scala.Function1) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, step: typing.Any, evidence$2: scala.math.Integral) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, evidence$1: scala.math.Integral) -> GenTraversable: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[_Traversable__A]: ...
    @typing.overload
    def seq(self) -> 'TraversableOnce'[_Traversable__A]: ...
    @typing.overload
    def seq(self) -> 'Traversable'[_Traversable__A]: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, n5: int, f: scala.Function5) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, f: scala.Function4) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, f: scala.Function3) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, f: scala.Function2) -> GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n: int, f: scala.Function1) -> GenTraversable: ...
    def toString(self) -> str: ...

_TraversableLike__A = typing.TypeVar('_TraversableLike__A')  # <A>
_TraversableLike__Repr = typing.TypeVar('_TraversableLike__Repr')  # <Repr>
class TraversableLike(scala.collection.generic.HasNewBuilder[_TraversableLike__A, _TraversableLike__Repr], scala.collection.generic.FilterMonadic[_TraversableLike__A, _TraversableLike__Repr], scala.collection.TraversableOnce[_TraversableLike__A], GenTraversableLike[_TraversableLike__A, _TraversableLike__Repr], typing.Generic[_TraversableLike__A, _TraversableLike__Repr]):
    @staticmethod
    def $init$($this: 'TraversableLike') -> None: ...
    _$plus$plus__B = typing.TypeVar('_$plus$plus__B')  # <B>
    _$plus$plus__That = typing.TypeVar('_$plus$plus__That')  # <That>
    def $plus$plus(self, that: GenTraversableOnce[_.plus.plus__B], bf: scala.collection.generic.CanBuildFrom[_TraversableLike__Repr, _.plus.plus__B, _.plus.plus__That]) -> _.plus.plus__That: ...
    _$plus$plus$colon_0__B = typing.TypeVar('_$plus$plus$colon_0__B')  # <B>
    _$plus$plus$colon_0__That = typing.TypeVar('_$plus$plus$colon_0__That')  # <That>
    _$plus$plus$colon_1__B = typing.TypeVar('_$plus$plus$colon_1__B')  # <B>
    _$plus$plus$colon_1__That = typing.TypeVar('_$plus$plus$colon_1__That')  # <That>
    @typing.overload
    def $plus$plus$colon(self, that: Traversable[_.plus.plus.colon_0__B], bf: scala.collection.generic.CanBuildFrom[_TraversableLike__Repr, _.plus.plus.colon_0__B, _.plus.plus.colon_0__That]) -> _.plus.plus.colon_0__That: ...
    @typing.overload
    def $plus$plus$colon(self, that: 'TraversableOnce'[_.plus.plus.colon_1__B], bf: scala.collection.generic.CanBuildFrom[_TraversableLike__Repr, _.plus.plus.colon_1__B, _.plus.plus.colon_1__That]) -> _.plus.plus.colon_1__That: ...
    _collect__B = typing.TypeVar('_collect__B')  # <B>
    _collect__That = typing.TypeVar('_collect__That')  # <That>
    def collect(self, pf: scala.PartialFunction[_TraversableLike__A, _collect__B], bf: scala.collection.generic.CanBuildFrom[_TraversableLike__Repr, _collect__B, _collect__That]) -> _collect__That: ...
    _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
    _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
    _copyToArray_2__B = typing.TypeVar('_copyToArray_2__B')  # <B>
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int) -> None: ...
    def drop(self, n: int) -> _TraversableLike__Repr: ...
    def dropWhile(self, p: scala.Function1[_TraversableLike__A, typing.Any]) -> _TraversableLike__Repr: ...
    def exists(self, p: scala.Function1[_TraversableLike__A, typing.Any]) -> bool: ...
    def filter(self, p: scala.Function1[_TraversableLike__A, typing.Any]) -> _TraversableLike__Repr: ...
    def filterImpl(self, p: scala.Function1[_TraversableLike__A, typing.Any], isFlipped: bool) -> _TraversableLike__Repr: ...
    def filterNot(self, p: scala.Function1[_TraversableLike__A, typing.Any]) -> _TraversableLike__Repr: ...
    def find(self, p: scala.Function1[_TraversableLike__A, typing.Any]) -> scala.Option[_TraversableLike__A]: ...
    _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
    _flatMap__That = typing.TypeVar('_flatMap__That')  # <That>
    def flatMap(self, f: scala.Function1[_TraversableLike__A, GenTraversableOnce[_flatMap__B]], bf: scala.collection.generic.CanBuildFrom[_TraversableLike__Repr, _flatMap__B, _flatMap__That]) -> _flatMap__That: ...
    def forall(self, p: scala.Function1[_TraversableLike__A, typing.Any]) -> bool: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_TraversableLike__A, _foreach__U]) -> None: ...
    _groupBy_0__K = typing.TypeVar('_groupBy_0__K')  # <K>
    _groupBy_1__K = typing.TypeVar('_groupBy_1__K')  # <K>
    @typing.overload
    def groupBy(self, f: scala.Function1[_TraversableLike__A, _groupBy_0__K]) -> GenMap[_groupBy_0__K, _TraversableLike__Repr]: ...
    @typing.overload
    def groupBy(self, f: scala.Function1[_TraversableLike__A, _groupBy_1__K]) -> scala.collection.immutable.Map[_groupBy_1__K, _TraversableLike__Repr]: ...
    def hasDefiniteSize(self) -> bool: ...
    def head(self) -> _TraversableLike__A: ...
    def headOption(self) -> scala.Option[_TraversableLike__A]: ...
    def init(self) -> _TraversableLike__Repr: ...
    def inits(self) -> Iterator[_TraversableLike__Repr]: ...
    def isEmpty(self) -> bool: ...
    def isTraversableAgain(self) -> bool: ...
    def last(self) -> _TraversableLike__A: ...
    def lastOption(self) -> scala.Option[_TraversableLike__A]: ...
    _map__B = typing.TypeVar('_map__B')  # <B>
    _map__That = typing.TypeVar('_map__That')  # <That>
    def map(self, f: scala.Function1[_TraversableLike__A, _map__B], bf: scala.collection.generic.CanBuildFrom[_TraversableLike__Repr, _map__B, _map__That]) -> _map__That: ...
    def newBuilder(self) -> scala.collection.mutable.Builder[_TraversableLike__A, _TraversableLike__Repr]: ...
    def parCombiner(self) -> scala.collection.parallel.Combiner[_TraversableLike__A, scala.collection.parallel.ParIterable[_TraversableLike__A]]: ...
    def partition(self, p: scala.Function1[_TraversableLike__A, typing.Any]) -> scala.Tuple2[_TraversableLike__Repr, _TraversableLike__Repr]: ...
    def repr(self) -> _TraversableLike__Repr: ...
    _scan__B = typing.TypeVar('_scan__B')  # <B>
    _scan__That = typing.TypeVar('_scan__That')  # <That>
    def scan(self, z: _scan__B, op: scala.Function2[_scan__B, _scan__B, _scan__B], cbf: scala.collection.generic.CanBuildFrom[_TraversableLike__Repr, _scan__B, _scan__That]) -> _scan__That: ...
    _scanLeft__B = typing.TypeVar('_scanLeft__B')  # <B>
    _scanLeft__That = typing.TypeVar('_scanLeft__That')  # <That>
    def scanLeft(self, z: _scanLeft__B, op: scala.Function2[_scanLeft__B, _TraversableLike__A, _scanLeft__B], bf: scala.collection.generic.CanBuildFrom[_TraversableLike__Repr, _scanLeft__B, _scanLeft__That]) -> _scanLeft__That: ...
    _scanRight__B = typing.TypeVar('_scanRight__B')  # <B>
    _scanRight__That = typing.TypeVar('_scanRight__That')  # <That>
    def scanRight(self, z: _scanRight__B, op: scala.Function2[_TraversableLike__A, _scanRight__B, _scanRight__B], bf: scala.collection.generic.CanBuildFrom[_TraversableLike__Repr, _scanRight__B, _scanRight__That]) -> _scanRight__That: ...
    def slice(self, from_: int, until: int) -> _TraversableLike__Repr: ...
    def sliceWithKnownBound(self, from_: int, until: int) -> _TraversableLike__Repr: ...
    def sliceWithKnownDelta(self, from_: int, until: int, delta: int) -> _TraversableLike__Repr: ...
    def span(self, p: scala.Function1[_TraversableLike__A, typing.Any]) -> scala.Tuple2[_TraversableLike__Repr, _TraversableLike__Repr]: ...
    def splitAt(self, n: int) -> scala.Tuple2[_TraversableLike__Repr, _TraversableLike__Repr]: ...
    def stringPrefix(self) -> str: ...
    def tail(self) -> _TraversableLike__Repr: ...
    def tails(self) -> Iterator[_TraversableLike__Repr]: ...
    def take(self, n: int) -> _TraversableLike__Repr: ...
    def takeWhile(self, p: scala.Function1[_TraversableLike__A, typing.Any]) -> _TraversableLike__Repr: ...
    def thisCollection(self) -> Traversable[_TraversableLike__A]: ...
    _to__Col = typing.TypeVar('_to__Col')  # <Col>
    def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., _TraversableLike__A, _to__Col]) -> _to__Col: ...
    def toCollection(self, repr: _TraversableLike__Repr) -> Traversable[_TraversableLike__A]: ...
    def toIterator(self) -> Iterator[_TraversableLike__A]: ...
    def toStream(self) -> scala.collection.immutable.Stream[_TraversableLike__A]: ...
    def toString(self) -> str: ...
    @typing.overload
    def toTraversable(self) -> GenTraversable[_TraversableLike__A]: ...
    @typing.overload
    def toTraversable(self) -> Traversable[_TraversableLike__A]: ...
    @typing.overload
    def view(self) -> 'TraversableView'[_TraversableLike__A, _TraversableLike__Repr]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> 'TraversableView'[_TraversableLike__A, _TraversableLike__Repr]: ...
    def withFilter(self, p: scala.Function1[_TraversableLike__A, typing.Any]) -> scala.collection.generic.FilterMonadic[_TraversableLike__A, _TraversableLike__Repr]: ...
    class WithFilter(scala.collection.generic.FilterMonadic[_TraversableLike__A, _TraversableLike__Repr]):
        $outer: 'TraversableLike' = ...
        def __init__(self, $outer: 'TraversableLike', p: scala.Function1[_TraversableLike__A, typing.Any]): ...
        _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
        _flatMap__That = typing.TypeVar('_flatMap__That')  # <That>
        def flatMap(self, f: scala.Function1[_TraversableLike__A, GenTraversableOnce[_flatMap__B]], bf: scala.collection.generic.CanBuildFrom[_TraversableLike__Repr, _flatMap__B, _flatMap__That]) -> _flatMap__That: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[_TraversableLike__A, _foreach__U]) -> None: ...
        _map__B = typing.TypeVar('_map__B')  # <B>
        _map__That = typing.TypeVar('_map__That')  # <That>
        def map(self, f: scala.Function1[_TraversableLike__A, _map__B], bf: scala.collection.generic.CanBuildFrom[_TraversableLike__Repr, _map__B, _map__That]) -> _map__That: ...
        def withFilter(self, q: scala.Function1[_TraversableLike__A, typing.Any]) -> 'TraversableLike.WithFilter': ...

_TraversableOnce__BufferedCanBuildFrom__A = typing.TypeVar('_TraversableOnce__BufferedCanBuildFrom__A')  # <A>
_TraversableOnce__BufferedCanBuildFrom__CC = typing.TypeVar('_TraversableOnce__BufferedCanBuildFrom__CC', bound='TraversableOnce')  # <CC>
_TraversableOnce__FlattenOps__A = typing.TypeVar('_TraversableOnce__FlattenOps__A')  # <A>
_TraversableOnce__MonadOps__A = typing.TypeVar('_TraversableOnce__MonadOps__A')  # <A>
_TraversableOnce__OnceCanBuildFrom__A = typing.TypeVar('_TraversableOnce__OnceCanBuildFrom__A')  # <A>
_TraversableOnce__A = typing.TypeVar('_TraversableOnce__A')  # <A>
class TraversableOnce(GenTraversableOnce[_TraversableOnce__A], typing.Generic[_TraversableOnce__A]):
    _$colon$bslash__B = typing.TypeVar('_$colon$bslash__B')  # <B>
    def $colon$bslash(self, z: _.colon.bslash__B, op: scala.Function2[_TraversableOnce__A, _.colon.bslash__B, _.colon.bslash__B]) -> _.colon.bslash__B: ...
    _$div$colon__B = typing.TypeVar('_$div$colon__B')  # <B>
    def $div$colon(self, z: _.div.colon__B, op: scala.Function2[_.div.colon__B, _TraversableOnce__A, _.div.colon__B]) -> _.div.colon__B: ...
    @staticmethod
    def $init$($this: 'TraversableOnce') -> None: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder) -> scala.collection.mutable.StringBuilder: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder, sep: str) -> scala.collection.mutable.StringBuilder: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder, start: str, sep: str, end: str) -> scala.collection.mutable.StringBuilder: ...
    _aggregate__B = typing.TypeVar('_aggregate__B')  # <B>
    def aggregate(self, z: scala.Function0[_aggregate__B], seqop: scala.Function2[_aggregate__B, _TraversableOnce__A, _aggregate__B], combop: scala.Function2[_aggregate__B, _aggregate__B, _aggregate__B]) -> _aggregate__B: ...
    _alternateImplicit__A = typing.TypeVar('_alternateImplicit__A')  # <A>
    @staticmethod
    def alternateImplicit(trav: 'TraversableOnce'[_alternateImplicit__A]) -> 'TraversableOnce.ForceImplicitAmbiguity': ...
    _collectFirst__B = typing.TypeVar('_collectFirst__B')  # <B>
    def collectFirst(self, pf: scala.PartialFunction[_TraversableOnce__A, _collectFirst__B]) -> scala.Option[_collectFirst__B]: ...
    _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
    _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
    _copyToArray_2__B = typing.TypeVar('_copyToArray_2__B')  # <B>
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int) -> None: ...
    _copyToBuffer__B = typing.TypeVar('_copyToBuffer__B')  # <B>
    def copyToBuffer(self, dest: scala.collection.mutable.Buffer[_copyToBuffer__B]) -> None: ...
    def count(self, p: scala.Function1[_TraversableOnce__A, typing.Any]) -> int: ...
    def exists(self, p: scala.Function1[_TraversableOnce__A, typing.Any]) -> bool: ...
    def find(self, p: scala.Function1[_TraversableOnce__A, typing.Any]) -> scala.Option[_TraversableOnce__A]: ...
    _flattenTraversableOnce__A = typing.TypeVar('_flattenTraversableOnce__A')  # <A>
    _flattenTraversableOnce__CC = typing.TypeVar('_flattenTraversableOnce__CC')  # <CC>
    @staticmethod
    def flattenTraversableOnce(travs: 'TraversableOnce'[_flattenTraversableOnce__CC], ev: scala.Function1[_flattenTraversableOnce__CC, 'TraversableOnce'[_flattenTraversableOnce__A]]) -> 'TraversableOnce.FlattenOps'[_flattenTraversableOnce__A]: ...
    _fold__A1 = typing.TypeVar('_fold__A1')  # <A1>
    def fold(self, z: _fold__A1, op: scala.Function2[_fold__A1, _fold__A1, _fold__A1]) -> _fold__A1: ...
    _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
    def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, _TraversableOnce__A, _foldLeft__B]) -> _foldLeft__B: ...
    _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
    def foldRight(self, z: _foldRight__B, op: scala.Function2[_TraversableOnce__A, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
    def forall(self, p: scala.Function1[_TraversableOnce__A, typing.Any]) -> bool: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_TraversableOnce__A, _foreach__U]) -> None: ...
    def hasDefiniteSize(self) -> bool: ...
    def isEmpty(self) -> bool: ...
    _max__B = typing.TypeVar('_max__B')  # <B>
    def max(self, cmp: scala.math.Ordering[_max__B]) -> _TraversableOnce__A: ...
    _maxBy__B = typing.TypeVar('_maxBy__B')  # <B>
    def maxBy(self, f: scala.Function1[_TraversableOnce__A, _maxBy__B], cmp: scala.math.Ordering[_maxBy__B]) -> _TraversableOnce__A: ...
    _min__B = typing.TypeVar('_min__B')  # <B>
    def min(self, cmp: scala.math.Ordering[_min__B]) -> _TraversableOnce__A: ...
    _minBy__B = typing.TypeVar('_minBy__B')  # <B>
    def minBy(self, f: scala.Function1[_TraversableOnce__A, _minBy__B], cmp: scala.math.Ordering[_minBy__B]) -> _TraversableOnce__A: ...
    @typing.overload
    def mkString(self) -> str: ...
    @typing.overload
    def mkString(self, sep: str) -> str: ...
    @typing.overload
    def mkString(self, start: str, sep: str, end: str) -> str: ...
    def nonEmpty(self) -> bool: ...
    _product__B = typing.TypeVar('_product__B')  # <B>
    def product(self, num: scala.math.Numeric[_product__B]) -> _product__B: ...
    _reduce__A1 = typing.TypeVar('_reduce__A1')  # <A1>
    def reduce(self, op: scala.Function2[_reduce__A1, _reduce__A1, _reduce__A1]) -> _reduce__A1: ...
    _reduceLeft__B = typing.TypeVar('_reduceLeft__B')  # <B>
    def reduceLeft(self, op: scala.Function2[_reduceLeft__B, _TraversableOnce__A, _reduceLeft__B]) -> _reduceLeft__B: ...
    _reduceLeftOption__B = typing.TypeVar('_reduceLeftOption__B')  # <B>
    def reduceLeftOption(self, op: scala.Function2[_reduceLeftOption__B, _TraversableOnce__A, _reduceLeftOption__B]) -> scala.Option[_reduceLeftOption__B]: ...
    _reduceOption__A1 = typing.TypeVar('_reduceOption__A1')  # <A1>
    def reduceOption(self, op: scala.Function2[_reduceOption__A1, _reduceOption__A1, _reduceOption__A1]) -> scala.Option[_reduceOption__A1]: ...
    _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
    def reduceRight(self, op: scala.Function2[_TraversableOnce__A, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
    _reduceRightOption__B = typing.TypeVar('_reduceRightOption__B')  # <B>
    def reduceRightOption(self, op: scala.Function2[_TraversableOnce__A, _reduceRightOption__B, _reduceRightOption__B]) -> scala.Option[_reduceRightOption__B]: ...
    def reversed(self) -> scala.collection.immutable.List[_TraversableOnce__A]: ...
    def seq(self) -> 'TraversableOnce'[_TraversableOnce__A]: ...
    def size(self) -> int: ...
    _sum__B = typing.TypeVar('_sum__B')  # <B>
    def sum(self, num: scala.math.Numeric[_sum__B]) -> _sum__B: ...
    _to__Col = typing.TypeVar('_to__Col')  # <Col>
    def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., _TraversableOnce__A, _to__Col]) -> _to__Col: ...
    _toArray__B = typing.TypeVar('_toArray__B')  # <B>
    def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__B]) -> typing.Any: ...
    _toBuffer__B = typing.TypeVar('_toBuffer__B')  # <B>
    def toBuffer(self) -> scala.collection.mutable.Buffer[_toBuffer__B]: ...
    def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq[_TraversableOnce__A]: ...
    @typing.overload
    def toIterable(self) -> GenIterable[_TraversableOnce__A]: ...
    @typing.overload
    def toIterable(self) -> Iterable[_TraversableOnce__A]: ...
    def toList(self) -> scala.collection.immutable.List[_TraversableOnce__A]: ...
    _toMap_0__K = typing.TypeVar('_toMap_0__K')  # <K>
    _toMap_0__V = typing.TypeVar('_toMap_0__V')  # <V>
    _toMap_1__T = typing.TypeVar('_toMap_1__T')  # <T>
    _toMap_1__U = typing.TypeVar('_toMap_1__U')  # <U>
    @typing.overload
    def toMap(self, ev: scala.Predef..less.colon.less[_TraversableOnce__A, scala.Tuple2[_toMap_0__K, _toMap_0__V]]) -> GenMap[_toMap_0__K, _toMap_0__V]: ...
    @typing.overload
    def toMap(self, ev: scala.Predef..less.colon.less[_TraversableOnce__A, scala.Tuple2[_toMap_1__T, _toMap_1__U]]) -> scala.collection.immutable.Map[_toMap_1__T, _toMap_1__U]: ...
    @typing.overload
    def toSeq(self) -> GenSeq[_TraversableOnce__A]: ...
    @typing.overload
    def toSeq(self) -> Seq[_TraversableOnce__A]: ...
    _toSet_0__A1 = typing.TypeVar('_toSet_0__A1')  # <A1>
    _toSet_1__B = typing.TypeVar('_toSet_1__B')  # <B>
    @typing.overload
    def toSet(self) -> GenSet[_toSet_0__A1]: ...
    @typing.overload
    def toSet(self) -> scala.collection.immutable.Set[_toSet_1__B]: ...
    @typing.overload
    def toTraversable(self) -> GenTraversable[_TraversableOnce__A]: ...
    @typing.overload
    def toTraversable(self) -> Traversable[_TraversableOnce__A]: ...
    def toVector(self) -> scala.collection.immutable.Vector[_TraversableOnce__A]: ...
    class BufferedCanBuildFrom(scala.collection.generic.CanBuildFrom[_TraversableOnce__BufferedCanBuildFrom__CC, _TraversableOnce__BufferedCanBuildFrom__A, _TraversableOnce__BufferedCanBuildFrom__CC], typing.Generic[_TraversableOnce__BufferedCanBuildFrom__A, _TraversableOnce__BufferedCanBuildFrom__CC]):
        def __init__(self): ...
        @typing.overload
        def apply(self) -> scala.collection.mutable.Builder[_TraversableOnce__BufferedCanBuildFrom__A, _TraversableOnce__BufferedCanBuildFrom__CC]: ...
        @typing.overload
        def apply(self, from_: _TraversableOnce__BufferedCanBuildFrom__CC) -> scala.collection.mutable.Builder[_TraversableOnce__BufferedCanBuildFrom__A, _TraversableOnce__BufferedCanBuildFrom__CC]: ...
        _bufferToColl__B = typing.TypeVar('_bufferToColl__B')  # <B>
        def bufferToColl(self, buff: scala.collection.mutable.ArrayBuffer[_bufferToColl__B]) -> _TraversableOnce__BufferedCanBuildFrom__CC: ...
        def newIterator(self) -> scala.collection.mutable.Builder[_TraversableOnce__BufferedCanBuildFrom__A, _TraversableOnce__BufferedCanBuildFrom__CC]: ...
        _traversableToColl__B = typing.TypeVar('_traversableToColl__B')  # <B>
        def traversableToColl(self, t: GenTraversable[_traversableToColl__B]) -> _TraversableOnce__BufferedCanBuildFrom__CC: ...
    class FlattenOps(typing.Generic[_TraversableOnce__FlattenOps__A]):
        scala$collection$TraversableOnce$FlattenOps$$travs: 'TraversableOnce' = ...
        def __init__(self, travs: 'TraversableOnce'['TraversableOnce'[_TraversableOnce__FlattenOps__A]]): ...
        def flatten(self) -> Iterator[_TraversableOnce__FlattenOps__A]: ...
    class ForceImplicitAmbiguity:
        def __init__(self): ...
    class MonadOps(typing.Generic[_TraversableOnce__MonadOps__A]):
        def __init__(self, trav: 'TraversableOnce'[_TraversableOnce__MonadOps__A]): ...
        def filter(self, p: scala.Function1[_TraversableOnce__MonadOps__A, typing.Any]) -> 'TraversableOnce'[_TraversableOnce__MonadOps__A]: ...
        _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
        def flatMap(self, f: scala.Function1[_TraversableOnce__MonadOps__A, GenTraversableOnce[_flatMap__B]]) -> 'TraversableOnce'[_flatMap__B]: ...
        _map__B = typing.TypeVar('_map__B')  # <B>
        def map(self, f: scala.Function1[_TraversableOnce__MonadOps__A, _map__B]) -> 'TraversableOnce'[_map__B]: ...
        def withFilter(self, p: scala.Function1[_TraversableOnce__MonadOps__A, typing.Any]) -> Iterator[_TraversableOnce__MonadOps__A]: ...
    class OnceCanBuildFrom(scala.collection.TraversableOnce.BufferedCanBuildFrom[_TraversableOnce__OnceCanBuildFrom__A, 'TraversableOnce'], typing.Generic[_TraversableOnce__OnceCanBuildFrom__A]):
        def __init__(self): ...
        _bufferToColl__B = typing.TypeVar('_bufferToColl__B')  # <B>
        def bufferToColl(self, buff: scala.collection.mutable.ArrayBuffer[_bufferToColl__B]) -> Iterator[_bufferToColl__B]: ...
        _traversableToColl__B = typing.TypeVar('_traversableToColl__B')  # <B>
        def traversableToColl(self, t: GenTraversable[_traversableToColl__B]) -> Traversable[_traversableToColl__B]: ...

_TraversableProxy__A = typing.TypeVar('_TraversableProxy__A')  # <A>
class TraversableProxy(Traversable[_TraversableProxy__A], scala.collection.TraversableProxyLike[_TraversableProxy__A, Traversable[_TraversableProxy__A]], typing.Generic[_TraversableProxy__A]):
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self) -> str: ...

_TraversableProxyLike__A = typing.TypeVar('_TraversableProxyLike__A')  # <A>
_TraversableProxyLike__Repr = typing.TypeVar('_TraversableProxyLike__Repr', bound=TraversableLike)  # <Repr>
class TraversableProxyLike(TraversableLike[_TraversableProxyLike__A, _TraversableProxyLike__Repr], scala.Proxy, typing.Generic[_TraversableProxyLike__A, _TraversableProxyLike__Repr]):
    _$colon$bslash__B = typing.TypeVar('_$colon$bslash__B')  # <B>
    def $colon$bslash(self, z: _.colon.bslash__B, op: scala.Function2[_TraversableProxyLike__A, _.colon.bslash__B, _.colon.bslash__B]) -> _.colon.bslash__B: ...
    _$div$colon__B = typing.TypeVar('_$div$colon__B')  # <B>
    def $div$colon(self, z: _.div.colon__B, op: scala.Function2[_.div.colon__B, _TraversableProxyLike__A, _.div.colon__B]) -> _.div.colon__B: ...
    @staticmethod
    def $init$($this: 'TraversableProxyLike') -> None: ...
    _$plus$plus__B = typing.TypeVar('_$plus$plus__B')  # <B>
    _$plus$plus__That = typing.TypeVar('_$plus$plus__That')  # <That>
    def $plus$plus(self, xs: GenTraversableOnce[_.plus.plus__B], bf: scala.collection.generic.CanBuildFrom[_TraversableProxyLike__Repr, _.plus.plus__B, _.plus.plus__That]) -> _.plus.plus__That: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder) -> scala.collection.mutable.StringBuilder: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder, sep: str) -> scala.collection.mutable.StringBuilder: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder, start: str, sep: str, end: str) -> scala.collection.mutable.StringBuilder: ...
    _collect__B = typing.TypeVar('_collect__B')  # <B>
    _collect__That = typing.TypeVar('_collect__That')  # <That>
    def collect(self, pf: scala.PartialFunction[_TraversableProxyLike__A, _collect__B], bf: scala.collection.generic.CanBuildFrom[_TraversableProxyLike__Repr, _collect__B, _collect__That]) -> _collect__That: ...
    _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
    _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
    _copyToArray_2__B = typing.TypeVar('_copyToArray_2__B')  # <B>
    @typing.overload
    def copyToArray(self, xs: typing.Any) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
    _copyToBuffer__B = typing.TypeVar('_copyToBuffer__B')  # <B>
    def copyToBuffer(self, dest: scala.collection.mutable.Buffer[_copyToBuffer__B]) -> None: ...
    def count(self, p: scala.Function1[_TraversableProxyLike__A, typing.Any]) -> int: ...
    @typing.overload
    def drop(self, n: int) -> _TraversableProxyLike__Repr: ...
    @typing.overload
    def drop(self, n: int) -> _TraversableProxyLike__Repr: ...
    @typing.overload
    def dropWhile(self, p: scala.Function1[_TraversableProxyLike__A, typing.Any]) -> _TraversableProxyLike__Repr: ...
    @typing.overload
    def dropWhile(self, p: scala.Function1[_TraversableProxyLike__A, typing.Any]) -> _TraversableProxyLike__Repr: ...
    def equals(self, that: typing.Any) -> bool: ...
    def exists(self, p: scala.Function1[_TraversableProxyLike__A, typing.Any]) -> bool: ...
    @typing.overload
    def filter(self, p: scala.Function1[_TraversableProxyLike__A, typing.Any]) -> _TraversableProxyLike__Repr: ...
    @typing.overload
    def filter(self, p: scala.Function1[_TraversableProxyLike__A, typing.Any]) -> _TraversableProxyLike__Repr: ...
    @typing.overload
    def filterNot(self, p: scala.Function1[_TraversableProxyLike__A, typing.Any]) -> _TraversableProxyLike__Repr: ...
    @typing.overload
    def filterNot(self, p: scala.Function1[_TraversableProxyLike__A, typing.Any]) -> _TraversableProxyLike__Repr: ...
    def find(self, p: scala.Function1[_TraversableProxyLike__A, typing.Any]) -> scala.Option[_TraversableProxyLike__A]: ...
    _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
    _flatMap__That = typing.TypeVar('_flatMap__That')  # <That>
    def flatMap(self, f: scala.Function1[_TraversableProxyLike__A, GenTraversableOnce[_flatMap__B]], bf: scala.collection.generic.CanBuildFrom[_TraversableProxyLike__Repr, _flatMap__B, _flatMap__That]) -> _flatMap__That: ...
    _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
    def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, _TraversableProxyLike__A, _foldLeft__B]) -> _foldLeft__B: ...
    _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
    def foldRight(self, z: _foldRight__B, op: scala.Function2[_TraversableProxyLike__A, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
    def forall(self, p: scala.Function1[_TraversableProxyLike__A, typing.Any]) -> bool: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_TraversableProxyLike__A, _foreach__U]) -> None: ...
    _groupBy_0__K = typing.TypeVar('_groupBy_0__K')  # <K>
    _groupBy_1__K = typing.TypeVar('_groupBy_1__K')  # <K>
    @typing.overload
    def groupBy(self, f: scala.Function1[_TraversableProxyLike__A, _groupBy_0__K]) -> GenMap[_groupBy_0__K, _TraversableProxyLike__Repr]: ...
    @typing.overload
    def groupBy(self, f: scala.Function1[_TraversableProxyLike__A, _groupBy_1__K]) -> scala.collection.immutable.Map[_groupBy_1__K, _TraversableProxyLike__Repr]: ...
    def hasDefiniteSize(self) -> bool: ...
    def hashCode(self) -> int: ...
    def head(self) -> _TraversableProxyLike__A: ...
    def headOption(self) -> scala.Option[_TraversableProxyLike__A]: ...
    @typing.overload
    def init(self) -> _TraversableProxyLike__Repr: ...
    @typing.overload
    def init(self) -> _TraversableProxyLike__Repr: ...
    def isEmpty(self) -> bool: ...
    def last(self) -> _TraversableProxyLike__A: ...
    def lastOption(self) -> scala.Option[_TraversableProxyLike__A]: ...
    _map__B = typing.TypeVar('_map__B')  # <B>
    _map__That = typing.TypeVar('_map__That')  # <That>
    def map(self, f: scala.Function1[_TraversableProxyLike__A, _map__B], bf: scala.collection.generic.CanBuildFrom[_TraversableProxyLike__Repr, _map__B, _map__That]) -> _map__That: ...
    _max__B = typing.TypeVar('_max__B')  # <B>
    def max(self, cmp: scala.math.Ordering[_max__B]) -> _TraversableProxyLike__A: ...
    _min__B = typing.TypeVar('_min__B')  # <B>
    def min(self, cmp: scala.math.Ordering[_min__B]) -> _TraversableProxyLike__A: ...
    @typing.overload
    def mkString(self) -> str: ...
    @typing.overload
    def mkString(self, sep: str) -> str: ...
    @typing.overload
    def mkString(self, start: str, sep: str, end: str) -> str: ...
    def nonEmpty(self) -> bool: ...
    def partition(self, p: scala.Function1[_TraversableProxyLike__A, typing.Any]) -> scala.Tuple2[_TraversableProxyLike__Repr, _TraversableProxyLike__Repr]: ...
    _product__B = typing.TypeVar('_product__B')  # <B>
    def product(self, num: scala.math.Numeric[_product__B]) -> _product__B: ...
    _reduceLeft__B = typing.TypeVar('_reduceLeft__B')  # <B>
    def reduceLeft(self, op: scala.Function2[_reduceLeft__B, _TraversableProxyLike__A, _reduceLeft__B]) -> _reduceLeft__B: ...
    _reduceLeftOption__B = typing.TypeVar('_reduceLeftOption__B')  # <B>
    def reduceLeftOption(self, op: scala.Function2[_reduceLeftOption__B, _TraversableProxyLike__A, _reduceLeftOption__B]) -> scala.Option[_reduceLeftOption__B]: ...
    _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
    def reduceRight(self, op: scala.Function2[_TraversableProxyLike__A, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
    _reduceRightOption__B = typing.TypeVar('_reduceRightOption__B')  # <B>
    def reduceRightOption(self, op: scala.Function2[_TraversableProxyLike__A, _reduceRightOption__B, _reduceRightOption__B]) -> scala.Option[_reduceRightOption__B]: ...
    _scanLeft__B = typing.TypeVar('_scanLeft__B')  # <B>
    _scanLeft__That = typing.TypeVar('_scanLeft__That')  # <That>
    def scanLeft(self, z: _scanLeft__B, op: scala.Function2[_scanLeft__B, _TraversableProxyLike__A, _scanLeft__B], bf: scala.collection.generic.CanBuildFrom[_TraversableProxyLike__Repr, _scanLeft__B, _scanLeft__That]) -> _scanLeft__That: ...
    _scanRight__B = typing.TypeVar('_scanRight__B')  # <B>
    _scanRight__That = typing.TypeVar('_scanRight__That')  # <That>
    def scanRight(self, z: _scanRight__B, op: scala.Function2[_TraversableProxyLike__A, _scanRight__B, _scanRight__B], bf: scala.collection.generic.CanBuildFrom[_TraversableProxyLike__Repr, _scanRight__B, _scanRight__That]) -> _scanRight__That: ...
    @typing.overload
    def self(self) -> typing.Any: ...
    @typing.overload
    def self(self) -> _TraversableProxyLike__Repr: ...
    def size(self) -> int: ...
    @typing.overload
    def slice(self, from_: int, until: int) -> _TraversableProxyLike__Repr: ...
    @typing.overload
    def slice(self, from_: int, until: int) -> _TraversableProxyLike__Repr: ...
    def span(self, p: scala.Function1[_TraversableProxyLike__A, typing.Any]) -> scala.Tuple2[_TraversableProxyLike__Repr, _TraversableProxyLike__Repr]: ...
    def splitAt(self, n: int) -> scala.Tuple2[_TraversableProxyLike__Repr, _TraversableProxyLike__Repr]: ...
    def stringPrefix(self) -> str: ...
    _sum__B = typing.TypeVar('_sum__B')  # <B>
    def sum(self, num: scala.math.Numeric[_sum__B]) -> _sum__B: ...
    @typing.overload
    def tail(self) -> _TraversableProxyLike__Repr: ...
    @typing.overload
    def tail(self) -> _TraversableProxyLike__Repr: ...
    @typing.overload
    def take(self, n: int) -> _TraversableProxyLike__Repr: ...
    @typing.overload
    def take(self, n: int) -> _TraversableProxyLike__Repr: ...
    @typing.overload
    def takeWhile(self, p: scala.Function1[_TraversableProxyLike__A, typing.Any]) -> _TraversableProxyLike__Repr: ...
    @typing.overload
    def takeWhile(self, p: scala.Function1[_TraversableProxyLike__A, typing.Any]) -> _TraversableProxyLike__Repr: ...
    _toArray__B = typing.TypeVar('_toArray__B')  # <B>
    def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__B]) -> typing.Any: ...
    _toBuffer__B = typing.TypeVar('_toBuffer__B')  # <B>
    def toBuffer(self) -> scala.collection.mutable.Buffer[_toBuffer__B]: ...
    def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq[_TraversableProxyLike__A]: ...
    @typing.overload
    def toIterable(self) -> GenIterable[_TraversableProxyLike__A]: ...
    @typing.overload
    def toIterable(self) -> Iterable[_TraversableProxyLike__A]: ...
    def toIterator(self) -> Iterator[_TraversableProxyLike__A]: ...
    def toList(self) -> scala.collection.immutable.List[_TraversableProxyLike__A]: ...
    _toMap_0__K = typing.TypeVar('_toMap_0__K')  # <K>
    _toMap_0__V = typing.TypeVar('_toMap_0__V')  # <V>
    _toMap_1__T = typing.TypeVar('_toMap_1__T')  # <T>
    _toMap_1__U = typing.TypeVar('_toMap_1__U')  # <U>
    @typing.overload
    def toMap(self, ev: scala.Predef..less.colon.less[_TraversableProxyLike__A, scala.Tuple2[_toMap_0__K, _toMap_0__V]]) -> GenMap[_toMap_0__K, _toMap_0__V]: ...
    @typing.overload
    def toMap(self, ev: scala.Predef..less.colon.less[_TraversableProxyLike__A, scala.Tuple2[_toMap_1__T, _toMap_1__U]]) -> scala.collection.immutable.Map[_toMap_1__T, _toMap_1__U]: ...
    @typing.overload
    def toSeq(self) -> GenSeq[_TraversableProxyLike__A]: ...
    @typing.overload
    def toSeq(self) -> Seq[_TraversableProxyLike__A]: ...
    _toSet_0__A1 = typing.TypeVar('_toSet_0__A1')  # <A1>
    _toSet_1__B = typing.TypeVar('_toSet_1__B')  # <B>
    @typing.overload
    def toSet(self) -> GenSet[_toSet_0__A1]: ...
    @typing.overload
    def toSet(self) -> scala.collection.immutable.Set[_toSet_1__B]: ...
    def toStream(self) -> scala.collection.immutable.Stream[_TraversableProxyLike__A]: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toTraversable(self) -> GenTraversable[_TraversableProxyLike__A]: ...
    @typing.overload
    def toTraversable(self) -> Traversable[_TraversableProxyLike__A]: ...
    @typing.overload
    def view(self) -> 'TraversableView'[_TraversableProxyLike__A, _TraversableProxyLike__Repr]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> 'TraversableView'[_TraversableProxyLike__A, _TraversableProxyLike__Repr]: ...

_TraversableView__NoBuilder__A = typing.TypeVar('_TraversableView__NoBuilder__A')  # <A>
_TraversableView__A = typing.TypeVar('_TraversableView__A')  # <A>
_TraversableView__Coll = typing.TypeVar('_TraversableView__Coll')  # <Coll>
class TraversableView(scala.collection.TraversableViewLike[_TraversableView__A, _TraversableView__Coll, 'TraversableView'[_TraversableView__A, _TraversableView__Coll]], typing.Generic[_TraversableView__A, _TraversableView__Coll]):
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['TraversableView'[typing.Any, Traversable[typing.Any]], _canBuildFrom__A, 'TraversableView'[_canBuildFrom__A, Traversable[typing.Any]]]: ...
    def toString(self) -> str: ...
    class NoBuilder(scala.collection.mutable.Builder[_TraversableView__NoBuilder__A, scala.runtime.Nothing.], typing.Generic[_TraversableView__NoBuilder__A]):
        def __init__(self): ...
        @typing.overload
        def $plus$eq(self, elem: _TraversableView__NoBuilder__A) -> 'TraversableView.NoBuilder'[_TraversableView__NoBuilder__A]: ...
        @typing.overload
        def $plus$eq(self, elem1: _TraversableView__NoBuilder__A, elem2: _TraversableView__NoBuilder__A, elems: Seq[_TraversableView__NoBuilder__A]) -> scala.collection.generic.Growable[_TraversableView__NoBuilder__A]: ...
        def $plus$plus$eq(self, xs: TraversableOnce[_TraversableView__NoBuilder__A]) -> scala.collection.generic.Growable[_TraversableView__NoBuilder__A]: ...
        def clear(self) -> None: ...
        def iterator(self) -> Iterator[_TraversableView__NoBuilder__A]: ...
        _mapResult__NewTo = typing.TypeVar('_mapResult__NewTo')  # <NewTo>
        def mapResult(self, f: scala.Function1[scala.runtime.Nothing., _mapResult__NewTo]) -> scala.collection.mutable.Builder[_TraversableView__NoBuilder__A, _mapResult__NewTo]: ...
        def result(self) -> scala.runtime.Nothing.: ...
        @typing.overload
        def sizeHint(self, size: int) -> None: ...
        @typing.overload
        def sizeHint(self, coll: TraversableLike[typing.Any, typing.Any]) -> None: ...
        @typing.overload
        def sizeHint(self, coll: TraversableLike[typing.Any, typing.Any], delta: int) -> None: ...
        def sizeHintBounded(self, size: int, boundingColl: TraversableLike[typing.Any, typing.Any]) -> None: ...

class IterableViewLike: ...

class SeqViewLike: ...

class TraversableViewLike: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("scala.collection")``.

    AbstractIterable: typing.Type[AbstractIterable]
    AbstractIterator: typing.Type[AbstractIterator]
    AbstractMap: typing.Type[AbstractMap]
    AbstractSeq: typing.Type[AbstractSeq]
    AbstractSet: typing.Type[AbstractSet]
    AbstractTraversable: typing.Type[AbstractTraversable]
    BitSet: typing.Type[BitSet]
    BitSetLike: typing.Type[BitSetLike]
    BufferedIterator: typing.Type[BufferedIterator]
    CustomParallelizable: typing.Type[CustomParallelizable]
    DebugUtils: typing.Type[DebugUtils]
    DefaultMap: typing.Type[DefaultMap]
    GenIterable: typing.Type[GenIterable]
    GenIterableLike: typing.Type[GenIterableLike]
    GenMap: typing.Type[GenMap]
    GenMapLike: typing.Type[GenMapLike]
    GenSeq: typing.Type[GenSeq]
    GenSeqLike: typing.Type[GenSeqLike]
    GenSet: typing.Type[GenSet]
    GenSetLike: typing.Type[GenSetLike]
    GenTraversable: typing.Type[GenTraversable]
    GenTraversableLike: typing.Type[GenTraversableLike]
    GenTraversableOnce: typing.Type[GenTraversableOnce]
    IndexedSeq: typing.Type[IndexedSeq]
    IndexedSeqLike: typing.Type[IndexedSeqLike]
    IndexedSeqOptimized: typing.Type[IndexedSeqOptimized]
    Iterable: typing.Type[Iterable]
    IterableLike: typing.Type[IterableLike]
    IterableProxy: typing.Type[IterableProxy]
    IterableProxyLike: typing.Type[IterableProxyLike]
    IterableView: typing.Type[IterableView]
    IterableViewLike: typing.Type[IterableViewLike]
    Iterator: typing.Type[Iterator]
    JavaConversions: typing.Type[JavaConversions]
    JavaConverters: typing.Type[JavaConverters]
    LinearSeq: typing.Type[LinearSeq]
    LinearSeqLike: typing.Type[LinearSeqLike]
    LinearSeqOptimized: typing.Type[LinearSeqOptimized]
    Map: typing.Type[Map]
    MapLike: typing.Type[MapLike]
    MapProxy: typing.Type[MapProxy]
    MapProxyLike: typing.Type[MapProxyLike]
    Parallel: typing.Type[Parallel]
    Parallelizable: typing.Type[Parallelizable]
    Searching: typing.Type[Searching]
    Seq: typing.Type[Seq]
    SeqExtractors: typing.Type[SeqExtractors]
    SeqLike: typing.Type[SeqLike]
    SeqProxy: typing.Type[SeqProxy]
    SeqProxyLike: typing.Type[SeqProxyLike]
    SeqView: typing.Type[SeqView]
    SeqViewLike: typing.Type[SeqViewLike]
    Set: typing.Type[Set]
    SetLike: typing.Type[SetLike]
    SetProxy: typing.Type[SetProxy]
    SetProxyLike: typing.Type[SetProxyLike]
    SortedMap: typing.Type[SortedMap]
    SortedMapLike: typing.Type[SortedMapLike]
    SortedSet: typing.Type[SortedSet]
    SortedSetLike: typing.Type[SortedSetLike]
    Traversable: typing.Type[Traversable]
    TraversableLike: typing.Type[TraversableLike]
    TraversableOnce: typing.Type[TraversableOnce]
    TraversableProxy: typing.Type[TraversableProxy]
    TraversableProxyLike: typing.Type[TraversableProxyLike]
    TraversableView: typing.Type[TraversableView]
    TraversableViewLike: typing.Type[TraversableViewLike]
    ViewMkString: typing.Type[ViewMkString]
    package: typing.Type[package]
    concurrent: scala.collection.concurrent.__module_protocol__
    convert: scala.collection.convert.__module_protocol__
    generic: scala.collection.generic.__module_protocol__
    immutable: scala.collection.immutable.__module_protocol__
    mutable: scala.collection.mutable.__module_protocol__
    parallel: scala.collection.parallel.__module_protocol__
    script: scala.collection.script.__module_protocol__
