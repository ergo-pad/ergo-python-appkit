import scala
import scala.collection
import scala.collection.mutable
import typing



class End:
    @staticmethod
    def canEqual(x$1: typing.Any) -> bool: ...
    @staticmethod
    def hashCode() -> int: ...
    @staticmethod
    def productArity() -> int: ...
    @staticmethod
    def productElement(x$1: int) -> typing.Any: ...
    @staticmethod
    def productIterator() -> scala.collection.Iterator[typing.Any]: ...
    @staticmethod
    def productPrefix() -> str: ...
    @staticmethod
    def toString() -> str: ...

class Location:
    def __init__(self): ...

_Message__A = typing.TypeVar('_Message__A')  # <A>
class Message(typing.Generic[_Message__A]): ...

class NoLo:
    @staticmethod
    def canEqual(x$1: typing.Any) -> bool: ...
    @staticmethod
    def hashCode() -> int: ...
    @staticmethod
    def productArity() -> int: ...
    @staticmethod
    def productElement(x$1: int) -> typing.Any: ...
    @staticmethod
    def productIterator() -> scala.collection.Iterator[typing.Any]: ...
    @staticmethod
    def productPrefix() -> str: ...
    @staticmethod
    def toString() -> str: ...

_Scriptable__A = typing.TypeVar('_Scriptable__A')  # <A>
class Scriptable(typing.Generic[_Scriptable__A]):
    def $less$less(self, cmd: Message[_Scriptable__A]) -> None: ...

class Start:
    @staticmethod
    def canEqual(x$1: typing.Any) -> bool: ...
    @staticmethod
    def hashCode() -> int: ...
    @staticmethod
    def productArity() -> int: ...
    @staticmethod
    def productElement(x$1: int) -> typing.Any: ...
    @staticmethod
    def productIterator() -> scala.collection.Iterator[typing.Any]: ...
    @staticmethod
    def productPrefix() -> str: ...
    @staticmethod
    def toString() -> str: ...

_Include__A = typing.TypeVar('_Include__A')  # <A>
class Include(Message[_Include__A], scala.Product, scala.Serializable, typing.Generic[_Include__A]):
    @typing.overload
    def __init__(self, elem: _Include__A): ...
    @typing.overload
    def __init__(self, location: Location, elem: _Include__A): ...
    _apply__A = typing.TypeVar('_apply__A')  # <A>
    @staticmethod
    def apply(location: Location, elem: _apply__A) -> 'Include'[_apply__A]: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _copy__A = typing.TypeVar('_copy__A')  # <A>
    def copy(self, location: Location, elem: typing.Any) -> 'Include'[typing.Any]: ...
    _copy$default$1__A = typing.TypeVar('_copy$default$1__A')  # <A>
    def copy$default$1(self) -> Location: ...
    _copy$default$2__A = typing.TypeVar('_copy$default$2__A')  # <A>
    def copy$default$2(self) -> typing.Any: ...
    def elem(self) -> _Include__A: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def location(self) -> Location: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> str: ...
    def toString(self) -> str: ...
    _unapply__A = typing.TypeVar('_unapply__A')  # <A>
    @staticmethod
    def unapply(x$0: 'Include'[_unapply__A]) -> scala.Option[scala.Tuple2[Location, _unapply__A]]: ...

class Index(Location, scala.Product, scala.Serializable):
    def __init__(self, n: int): ...
    _andThen__A = typing.TypeVar('_andThen__A')  # <A>
    @staticmethod
    def andThen(g: scala.Function1['Index', _andThen__A]) -> scala.Function1[typing.Any, _andThen__A]: ...
    @staticmethod
    def apply(n: int) -> 'Index': ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    @staticmethod
    def compose(g: scala.Function1[_compose__A, typing.Any]) -> scala.Function1[_compose__A, 'Index']: ...
    def copy(self, n: int) -> 'Index': ...
    def copy$default$1(self) -> int: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def n(self) -> int: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> str: ...
    def toString(self) -> str: ...
    @staticmethod
    def unapply(x$0: 'Index') -> scala.Option[typing.Any]: ...

_Remove__A = typing.TypeVar('_Remove__A')  # <A>
class Remove(Message[_Remove__A], scala.Product, scala.Serializable, typing.Generic[_Remove__A]):
    @typing.overload
    def __init__(self, elem: _Remove__A): ...
    @typing.overload
    def __init__(self, location: Location, elem: _Remove__A): ...
    _apply__A = typing.TypeVar('_apply__A')  # <A>
    @staticmethod
    def apply(location: Location, elem: _apply__A) -> 'Remove'[_apply__A]: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _copy__A = typing.TypeVar('_copy__A')  # <A>
    def copy(self, location: Location, elem: typing.Any) -> 'Remove'[typing.Any]: ...
    _copy$default$1__A = typing.TypeVar('_copy$default$1__A')  # <A>
    def copy$default$1(self) -> Location: ...
    _copy$default$2__A = typing.TypeVar('_copy$default$2__A')  # <A>
    def copy$default$2(self) -> typing.Any: ...
    def elem(self) -> _Remove__A: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def location(self) -> Location: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> str: ...
    def toString(self) -> str: ...
    _unapply__A = typing.TypeVar('_unapply__A')  # <A>
    @staticmethod
    def unapply(x$0: 'Remove'[_unapply__A]) -> scala.Option[scala.Tuple2[Location, _unapply__A]]: ...

_Reset__A = typing.TypeVar('_Reset__A')  # <A>
class Reset(Message[_Reset__A], scala.Product, scala.Serializable, typing.Generic[_Reset__A]):
    def __init__(self): ...
    _apply__A = typing.TypeVar('_apply__A')  # <A>
    @staticmethod
    def apply() -> 'Reset'[_apply__A]: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _copy__A = typing.TypeVar('_copy__A')  # <A>
    def copy(self) -> 'Reset'[typing.Any]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> str: ...
    def toString(self) -> str: ...
    _unapply__A = typing.TypeVar('_unapply__A')  # <A>
    @staticmethod
    def unapply(x$0: 'Reset'[_unapply__A]) -> bool: ...

_Script__A = typing.TypeVar('_Script__A')  # <A>
class Script(scala.collection.mutable.ArrayBuffer[Message[_Script__A]], Message[_Script__A], typing.Generic[_Script__A]):
    def __init__(self): ...
    def toString(self) -> str: ...

_Update__A = typing.TypeVar('_Update__A')  # <A>
class Update(Message[_Update__A], scala.Product, scala.Serializable, typing.Generic[_Update__A]):
    @typing.overload
    def __init__(self, elem: _Update__A): ...
    @typing.overload
    def __init__(self, location: Location, elem: _Update__A): ...
    _apply__A = typing.TypeVar('_apply__A')  # <A>
    @staticmethod
    def apply(location: Location, elem: _apply__A) -> 'Update'[_apply__A]: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _copy__A = typing.TypeVar('_copy__A')  # <A>
    def copy(self, location: Location, elem: typing.Any) -> 'Update'[typing.Any]: ...
    _copy$default$1__A = typing.TypeVar('_copy$default$1__A')  # <A>
    def copy$default$1(self) -> Location: ...
    _copy$default$2__A = typing.TypeVar('_copy$default$2__A')  # <A>
    def copy$default$2(self) -> typing.Any: ...
    def elem(self) -> _Update__A: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def location(self) -> Location: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> str: ...
    def toString(self) -> str: ...
    _unapply__A = typing.TypeVar('_unapply__A')  # <A>
    @staticmethod
    def unapply(x$0: 'Update'[_unapply__A]) -> scala.Option[scala.Tuple2[Location, _unapply__A]]: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("scala.collection.script")``.

    End: typing.Type[End]
    Include: typing.Type[Include]
    Index: typing.Type[Index]
    Location: typing.Type[Location]
    Message: typing.Type[Message]
    NoLo: typing.Type[NoLo]
    Remove: typing.Type[Remove]
    Reset: typing.Type[Reset]
    Script: typing.Type[Script]
    Scriptable: typing.Type[Scriptable]
    Start: typing.Type[Start]
    Update: typing.Type[Update]
