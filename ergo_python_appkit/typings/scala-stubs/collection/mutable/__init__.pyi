import java.io
import java.lang
import java.util
import java.util.stream
import scala
import scala.collection
import scala.collection.convert
import scala.collection.generic
import scala.collection.immutable
import scala.collection.parallel
import scala.collection.parallel.mutable
import scala.collection.script
import scala.math
import scala.reflect
import scala.runtime
import scala.util
import scala.util.matching
import typing



_Builder__Elem = typing.TypeVar('_Builder__Elem')  # <Elem>
_Builder__To = typing.TypeVar('_Builder__To')  # <To>
class Builder(scala.collection.generic.Growable[_Builder__Elem], typing.Generic[_Builder__Elem, _Builder__To]):
    @staticmethod
    def $init$($this: 'Builder') -> None: ...
    @typing.overload
    def $plus$eq(self, elem: typing.Any) -> scala.collection.generic.Growable[typing.Any]: ...
    @typing.overload
    def $plus$eq(self, elem: _Builder__Elem) -> 'Builder'[_Builder__Elem, _Builder__To]: ...
    @typing.overload
    def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> scala.collection.generic.Growable[typing.Any]: ...
    def clear(self) -> None: ...
    _mapResult__NewTo = typing.TypeVar('_mapResult__NewTo')  # <NewTo>
    def mapResult(self, f: scala.Function1[_Builder__To, _mapResult__NewTo]) -> 'Builder'[_Builder__Elem, _mapResult__NewTo]: ...
    def result(self) -> _Builder__To: ...
    @typing.overload
    def sizeHint(self, size: int) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any], delta: int) -> None: ...
    def sizeHintBounded(self, size: int, boundingColl: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...

_Cloneable__A = typing.TypeVar('_Cloneable__A')  # <A>
class Cloneable(scala.Cloneable, typing.Generic[_Cloneable__A]):
    @staticmethod
    def $init$($this: 'Cloneable') -> None: ...
    def clone(self) -> _Cloneable__A: ...

_HashEntry__A = typing.TypeVar('_HashEntry__A')  # <A>
_HashEntry__E = typing.TypeVar('_HashEntry__E')  # <E>
class HashEntry(typing.Generic[_HashEntry__A, _HashEntry__E]):
    @staticmethod
    def $init$($this: 'HashEntry') -> None: ...
    def key(self) -> _HashEntry__A: ...
    def next(self) -> _HashEntry__E: ...
    def next_$eq(self, x$1: _HashEntry__E) -> None: ...

_IndexedSeqLike__A = typing.TypeVar('_IndexedSeqLike__A')  # <A>
_IndexedSeqLike__Repr = typing.TypeVar('_IndexedSeqLike__Repr')  # <Repr>
class IndexedSeqLike(scala.collection.IndexedSeqLike[_IndexedSeqLike__A, _IndexedSeqLike__Repr], typing.Generic[_IndexedSeqLike__A, _IndexedSeqLike__Repr]):
    @staticmethod
    def $init$($this: 'IndexedSeqLike') -> None: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def thisCollection(self) -> scala.collection.IndexedSeq[_IndexedSeqLike__A]: ...
    @typing.overload
    def thisCollection(self) -> scala.collection.Iterable[_IndexedSeqLike__A]: ...
    @typing.overload
    def thisCollection(self) -> scala.collection.Seq[_IndexedSeqLike__A]: ...
    @typing.overload
    def thisCollection(self) -> scala.collection.Traversable[_IndexedSeqLike__A]: ...
    @typing.overload
    def thisCollection(self) -> 'IndexedSeq'[_IndexedSeqLike__A]: ...
    @typing.overload
    def toCollection(self, repr: _IndexedSeqLike__Repr) -> scala.collection.IndexedSeq[_IndexedSeqLike__A]: ...
    @typing.overload
    def toCollection(self, repr: _IndexedSeqLike__Repr) -> scala.collection.Iterable[_IndexedSeqLike__A]: ...
    @typing.overload
    def toCollection(self, repr: _IndexedSeqLike__Repr) -> scala.collection.Seq[_IndexedSeqLike__A]: ...
    @typing.overload
    def toCollection(self, repr: _IndexedSeqLike__Repr) -> scala.collection.Traversable[_IndexedSeqLike__A]: ...
    @typing.overload
    def toCollection(self, repr: _IndexedSeqLike__Repr) -> 'IndexedSeq'[_IndexedSeqLike__A]: ...
    def toString(self) -> str: ...
    def update(self, idx: int, elem: _IndexedSeqLike__A) -> None: ...
    @typing.overload
    def view(self) -> scala.collection.IterableView[_IndexedSeqLike__A, _IndexedSeqLike__Repr]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> scala.collection.IterableView[_IndexedSeqLike__A, _IndexedSeqLike__Repr]: ...
    @typing.overload
    def view(self) -> scala.collection.SeqView[_IndexedSeqLike__A, _IndexedSeqLike__Repr]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> scala.collection.SeqView[_IndexedSeqLike__A, _IndexedSeqLike__Repr]: ...
    @typing.overload
    def view(self) -> scala.collection.TraversableView[_IndexedSeqLike__A, _IndexedSeqLike__Repr]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> scala.collection.TraversableView[_IndexedSeqLike__A, _IndexedSeqLike__Repr]: ...
    @typing.overload
    def view(self) -> 'IndexedSeqView'[_IndexedSeqLike__A, _IndexedSeqLike__Repr]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> 'IndexedSeqView'[_IndexedSeqLike__A, _IndexedSeqLike__Repr]: ...

_Publisher__Evt = typing.TypeVar('_Publisher__Evt')  # <Evt>
class Publisher(typing.Generic[_Publisher__Evt]):
    @staticmethod
    def $init$($this: 'Publisher') -> None: ...
    def activateSubscription(self, sub: 'Subscriber'[_Publisher__Evt, 'Publisher']) -> None: ...
    def equals(self, obj: typing.Any) -> bool: ...
    def publish(self, event: _Publisher__Evt) -> None: ...
    def removeSubscription(self, sub: 'Subscriber'[_Publisher__Evt, 'Publisher']) -> None: ...
    def removeSubscriptions(self) -> None: ...
    def scala$collection$mutable$Publisher$$filters(self) -> 'HashMap'['Subscriber'[_Publisher__Evt, 'Publisher'], 'Set'[scala.Function1[_Publisher__Evt, typing.Any]]]: ...
    def scala$collection$mutable$Publisher$$suspended(self) -> 'HashSet'['Subscriber'[_Publisher__Evt, 'Publisher']]: ...
    def scala$collection$mutable$Publisher$_setter_$scala$collection$mutable$Publisher$$filters_$eq(self, x$1: 'HashMap'['Subscriber'[_Publisher__Evt, 'Publisher'], 'Set'[scala.Function1[_Publisher__Evt, typing.Any]]]) -> None: ...
    def scala$collection$mutable$Publisher$_setter_$scala$collection$mutable$Publisher$$suspended_$eq(self, x$1: 'HashSet'['Subscriber'[_Publisher__Evt, 'Publisher']]) -> None: ...
    def scala$collection$mutable$Publisher$_setter_$self_$eq(self, x$1: 'Publisher') -> None: ...
    def self(self) -> 'Publisher': ...
    @typing.overload
    def subscribe(self, sub: 'Subscriber'[_Publisher__Evt, 'Publisher']) -> None: ...
    @typing.overload
    def subscribe(self, sub: 'Subscriber'[_Publisher__Evt, 'Publisher'], filter: scala.Function1[_Publisher__Evt, typing.Any]) -> None: ...
    def suspendSubscription(self, sub: 'Subscriber'[_Publisher__Evt, 'Publisher']) -> None: ...

_QueueProxy__A = typing.TypeVar('_QueueProxy__A')  # <A>
class QueueProxy(scala.Proxy, typing.Generic[_QueueProxy__A]):
    @staticmethod
    def $init$($this: 'QueueProxy') -> None: ...
    def $plus$eq(self, elem: _QueueProxy__A) -> 'QueueProxy'[_QueueProxy__A]: ...
    def $plus$plus$eq(self, it: scala.collection.TraversableOnce[_QueueProxy__A]) -> 'QueueProxy'[_QueueProxy__A]: ...
    def apply(self, n: int) -> _QueueProxy__A: ...
    def clear(self) -> None: ...
    def clone(self) -> 'Queue'[_QueueProxy__A]: ...
    def dequeue(self) -> _QueueProxy__A: ...
    def enqueue(self, elems: scala.collection.Seq[_QueueProxy__A]) -> None: ...
    def equals(self, that: typing.Any) -> bool: ...
    def front(self) -> _QueueProxy__A: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> scala.collection.Iterator[_QueueProxy__A]: ...
    def length(self) -> int: ...
    @typing.overload
    def self(self) -> typing.Any: ...
    @typing.overload
    def self(self) -> 'Queue'[_QueueProxy__A]: ...
    def toString(self) -> str: ...

_StackProxy__A = typing.TypeVar('_StackProxy__A')  # <A>
class StackProxy(scala.Proxy, typing.Generic[_StackProxy__A]):
    @staticmethod
    def $init$($this: 'StackProxy') -> None: ...
    def $plus$eq(self, elem: _StackProxy__A) -> 'StackProxy'[_StackProxy__A]: ...
    def apply(self, n: int) -> _StackProxy__A: ...
    def clear(self) -> None: ...
    def clone(self) -> 'Stack'[_StackProxy__A]: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> scala.collection.Iterator[_StackProxy__A]: ...
    def length(self) -> int: ...
    def pop(self) -> _StackProxy__A: ...
    @typing.overload
    def push(self, elem: _StackProxy__A) -> 'StackProxy'[_StackProxy__A]: ...
    @typing.overload
    def push(self, elem1: _StackProxy__A, elem2: _StackProxy__A, elems: scala.collection.Seq[_StackProxy__A]) -> 'StackProxy'[_StackProxy__A]: ...
    def pushAll(self, xs: scala.collection.TraversableOnce[_StackProxy__A]) -> 'StackProxy'[_StackProxy__A]: ...
    @typing.overload
    def self(self) -> typing.Any: ...
    @typing.overload
    def self(self) -> 'Stack'[_StackProxy__A]: ...
    def toList(self) -> scala.collection.immutable.List[_StackProxy__A]: ...
    def toString(self) -> str: ...
    def top(self) -> _StackProxy__A: ...

_Subscriber__Evt = typing.TypeVar('_Subscriber__Evt')  # <Evt>
_Subscriber__Pub = typing.TypeVar('_Subscriber__Pub')  # <Pub>
class Subscriber(typing.Generic[_Subscriber__Evt, _Subscriber__Pub]):
    def notify(self, pub: _Subscriber__Pub, event: _Subscriber__Evt) -> None: ...

_Traversable__A = typing.TypeVar('_Traversable__A')  # <A>
class Traversable(scala.collection.Traversable[_Traversable__A], scala.Mutable, typing.Generic[_Traversable__A]):
    @staticmethod
    def $init$($this: 'Traversable') -> None: ...
    @staticmethod
    def ReusableCBF() -> scala.collection.generic.GenTraversableFactory.GenericCanBuildFrom[scala.runtime.Nothing.]: ...
    @staticmethod
    def apply(elems: scala.collection.Seq) -> scala.collection.GenTraversable: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['Traversable'[typing.Any], _canBuildFrom__A, 'Traversable'[_canBuildFrom__A]]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['Traversable']: ...
    @staticmethod
    def concat(xss: scala.collection.Seq) -> scala.collection.GenTraversable: ...
    @staticmethod
    def empty() -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, n5: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @staticmethod
    def iterate(start: typing.Any, len: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, step: typing.Any, evidence$2: scala.math.Integral) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, evidence$1: scala.math.Integral) -> scala.collection.GenTraversable: ...
    @typing.overload
    def seq(self) -> scala.collection.TraversableOnce[_Traversable__A]: ...
    @typing.overload
    def seq(self) -> scala.collection.TraversableOnce[_Traversable__A]: ...
    @typing.overload
    def seq(self) -> scala.collection.Traversable[_Traversable__A]: ...
    @typing.overload
    def seq(self) -> 'Traversable'[_Traversable__A]: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, n5: int, f: scala.Function5) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, f: scala.Function4) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, f: scala.Function3) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, f: scala.Function2) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    def toString(self) -> str: ...

class Undoable:
    def undo(self) -> None: ...

_WeakHashMap__A = typing.TypeVar('_WeakHashMap__A')  # <A>
_WeakHashMap__B = typing.TypeVar('_WeakHashMap__B')  # <B>
class WeakHashMap(scala.collection.convert.Wrappers.JMapWrapper[_WeakHashMap__A, _WeakHashMap__B], typing.Generic[_WeakHashMap__A, _WeakHashMap__B]):
    def __init__(self): ...
    @typing.overload
    def $minus(self, key: typing.Any) -> 'Map'[typing.Any, typing.Any]: ...
    @typing.overload
    def $minus(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> 'Map'[typing.Any, typing.Any]: ...
    @typing.overload
    def $minus$eq(self, key: _WeakHashMap__A) -> scala.collection.convert.Wrappers.JMapWrapperLike[_WeakHashMap__A, _WeakHashMap__B, scala.collection.convert.Wrappers.JMapWrapper[_WeakHashMap__A, _WeakHashMap__B]]: ...
    @typing.overload
    def $minus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> scala.collection.generic.Shrinkable[typing.Any]: ...
    def $minus$minus(self, xs: scala.collection.GenTraversableOnce[typing.Any]) -> 'Map'[typing.Any, typing.Any]: ...
    _$plus_0__V1 = typing.TypeVar('_$plus_0__V1')  # <V1>
    _$plus_1__V1 = typing.TypeVar('_$plus_1__V1')  # <V1>
    @typing.overload
    def $plus(self, kv: scala.Tuple2[typing.Any, _.plus_0__V1]) -> 'Map'[typing.Any, _.plus_0__V1]: ...
    @typing.overload
    def $plus(self, elem1: scala.Tuple2[typing.Any, _.plus_1__V1], elem2: scala.Tuple2[typing.Any, _.plus_1__V1], elems: scala.collection.Seq[scala.Tuple2[typing.Any, _.plus_1__V1]]) -> 'Map'[typing.Any, _.plus_1__V1]: ...
    @typing.overload
    def $plus$eq(self, kv: scala.Tuple2[_WeakHashMap__A, _WeakHashMap__B]) -> scala.collection.convert.Wrappers.JMapWrapperLike[_WeakHashMap__A, _WeakHashMap__B, scala.collection.convert.Wrappers.JMapWrapper[_WeakHashMap__A, _WeakHashMap__B]]: ...
    @typing.overload
    def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq) -> scala.collection.generic.Growable: ...
    _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
    _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
    _$plus$plus_1__V1 = typing.TypeVar('_$plus$plus_1__V1')  # <V1>
    @typing.overload
    def $plus$plus(self, that: scala.collection.GenTraversableOnce[typing.Any], bf: scala.collection.generic.CanBuildFrom[scala.collection.Traversable[_WeakHashMap__A], typing.Any, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
    @typing.overload
    def $plus$plus(self, xs: scala.collection.GenTraversableOnce[scala.Tuple2[typing.Any, _.plus.plus_1__V1]]) -> 'Map'[typing.Any, _.plus.plus_1__V1]: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    _canBuildFrom__B = typing.TypeVar('_canBuildFrom__B')  # <B>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['WeakHashMap'[typing.Any, typing.Any], scala.Tuple2[_canBuildFrom__A, _canBuildFrom__B], 'WeakHashMap'[_canBuildFrom__A, _canBuildFrom__B]]: ...
    def clone(self) -> 'Map'[typing.Any, typing.Any]: ...
    def empty(self) -> 'WeakHashMap'[_WeakHashMap__A, _WeakHashMap__B]: ...
    def filterKeys(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.collection.Map[typing.Any, typing.Any]: ...
    def filterNot(self, p: scala.Function1[scala.Tuple2[typing.Any, typing.Any], typing.Any]) -> scala.collection.Map[typing.Any, typing.Any]: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[_WeakHashMap__A, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[_WeakHashMap__A]]: ...
    def keySet(self) -> scala.collection.Set[typing.Any]: ...
    def keys(self) -> scala.collection.Iterable[typing.Any]: ...
    _mapValues__W = typing.TypeVar('_mapValues__W')  # <W>
    def mapValues(self, f: scala.Function1[typing.Any, _mapValues__W]) -> scala.collection.Map[typing.Any, _mapValues__W]: ...
    def repr(self) -> typing.Any: ...
    def result(self) -> 'Map'[typing.Any, typing.Any]: ...
    def seq(self) -> 'Map'[typing.Any, typing.Any]: ...
    def thisCollection(self) -> scala.collection.Iterable[_WeakHashMap__A]: ...
    def toCollection(self, repr: typing.Any) -> scala.collection.Iterable: ...
    def toIterable(self) -> scala.collection.Iterable[_WeakHashMap__A]: ...
    def toSeq(self) -> scala.collection.Seq[scala.Tuple2[typing.Any, typing.Any]]: ...
    def toTraversable(self) -> scala.collection.Traversable[_WeakHashMap__A]: ...
    _updated__V1 = typing.TypeVar('_updated__V1')  # <V1>
    def updated(self, key: typing.Any, value: _updated__V1) -> 'Map'[typing.Any, _updated__V1]: ...
    def values(self) -> scala.collection.Iterable[typing.Any]: ...
    @typing.overload
    def view(self) -> scala.collection.IterableView[_WeakHashMap__A, scala.collection.Iterable[_WeakHashMap__A]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> scala.collection.IterableView[_WeakHashMap__A, scala.collection.Iterable[_WeakHashMap__A]]: ...

_DefaultEntry__A = typing.TypeVar('_DefaultEntry__A')  # <A>
_DefaultEntry__B = typing.TypeVar('_DefaultEntry__B')  # <B>
class DefaultEntry(HashEntry[_DefaultEntry__A, 'DefaultEntry'[_DefaultEntry__A, _DefaultEntry__B]], scala.Serializable, typing.Generic[_DefaultEntry__A, _DefaultEntry__B]):
    def __init__(self, key: _DefaultEntry__A, value: _DefaultEntry__B): ...
    def chainString(self) -> str: ...
    def key(self) -> _DefaultEntry__A: ...
    def next(self) -> 'DefaultEntry'[_DefaultEntry__A, _DefaultEntry__B]: ...
    def next_$eq(self, x$1: 'DefaultEntry'[_DefaultEntry__A, _DefaultEntry__B]) -> None: ...
    def toString(self) -> str: ...
    def value(self) -> _DefaultEntry__B: ...
    def value_$eq(self, x$1: _DefaultEntry__B) -> None: ...

_GrowingBuilder__Elem = typing.TypeVar('_GrowingBuilder__Elem')  # <Elem>
_GrowingBuilder__To = typing.TypeVar('_GrowingBuilder__To', bound=scala.collection.generic.Growable)  # <To>
class GrowingBuilder(Builder[_GrowingBuilder__Elem, _GrowingBuilder__To], typing.Generic[_GrowingBuilder__Elem, _GrowingBuilder__To]):
    def __init__(self, empty: _GrowingBuilder__To): ...
    @typing.overload
    def $plus$eq(self, elem1: _GrowingBuilder__Elem, elem2: _GrowingBuilder__Elem, elems: scala.collection.Seq[_GrowingBuilder__Elem]) -> scala.collection.generic.Growable[_GrowingBuilder__Elem]: ...
    @typing.overload
    def $plus$eq(self, x: _GrowingBuilder__Elem) -> 'GrowingBuilder'[_GrowingBuilder__Elem, _GrowingBuilder__To]: ...
    def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[_GrowingBuilder__Elem]) -> scala.collection.generic.Growable[_GrowingBuilder__Elem]: ...
    def clear(self) -> None: ...
    def elems(self) -> _GrowingBuilder__To: ...
    def elems_$eq(self, x$1: _GrowingBuilder__To) -> None: ...
    _mapResult__NewTo = typing.TypeVar('_mapResult__NewTo')  # <NewTo>
    def mapResult(self, f: scala.Function1[_GrowingBuilder__To, _mapResult__NewTo]) -> Builder[_GrowingBuilder__Elem, _mapResult__NewTo]: ...
    def result(self) -> _GrowingBuilder__To: ...
    @typing.overload
    def sizeHint(self, size: int) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any], delta: int) -> None: ...
    def sizeHintBounded(self, size: int, boundingColl: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...

_IndexedSeqOptimized__A = typing.TypeVar('_IndexedSeqOptimized__A')  # <A>
_IndexedSeqOptimized__Repr = typing.TypeVar('_IndexedSeqOptimized__Repr')  # <Repr>
class IndexedSeqOptimized(IndexedSeqLike[_IndexedSeqOptimized__A, _IndexedSeqOptimized__Repr], scala.collection.IndexedSeqOptimized[_IndexedSeqOptimized__A, _IndexedSeqOptimized__Repr], typing.Generic[_IndexedSeqOptimized__A, _IndexedSeqOptimized__Repr]):
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...

_Iterable__A = typing.TypeVar('_Iterable__A')  # <A>
class Iterable(Traversable[_Iterable__A], scala.collection.Iterable[_Iterable__A], typing.Generic[_Iterable__A]):
    @staticmethod
    def $init$($this: 'Iterable') -> None: ...
    @staticmethod
    def ReusableCBF() -> scala.collection.generic.GenTraversableFactory.GenericCanBuildFrom[scala.runtime.Nothing.]: ...
    @staticmethod
    def apply(elems: scala.collection.Seq) -> scala.collection.GenTraversable: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['Iterable'[typing.Any], _canBuildFrom__A, 'Iterable'[_canBuildFrom__A]]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['Iterable']: ...
    @staticmethod
    def concat(xss: scala.collection.Seq) -> scala.collection.GenTraversable: ...
    @staticmethod
    def empty() -> scala.collection.GenTraversable: ...
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, n5: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @staticmethod
    def iterate(start: typing.Any, len: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    def parCombiner(self) -> scala.collection.parallel.Combiner[_Iterable__A, scala.collection.parallel.mutable.ParIterable[_Iterable__A]]: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, step: typing.Any, evidence$2: scala.math.Integral) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, evidence$1: scala.math.Integral) -> scala.collection.GenTraversable: ...
    @typing.overload
    def seq(self) -> scala.collection.TraversableOnce[_Iterable__A]: ...
    @typing.overload
    def seq(self) -> scala.collection.TraversableOnce[_Iterable__A]: ...
    @typing.overload
    def seq(self) -> scala.collection.Iterable[_Iterable__A]: ...
    @typing.overload
    def seq(self) -> scala.collection.Traversable[_Iterable__A]: ...
    @typing.overload
    def seq(self) -> 'Iterable'[_Iterable__A]: ...
    @typing.overload
    def seq(self) -> Traversable[_Iterable__A]: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, n5: int, f: scala.Function5) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, f: scala.Function4) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, f: scala.Function3) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, f: scala.Function2) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    def toString(self) -> str: ...

_LinkedEntry__A = typing.TypeVar('_LinkedEntry__A')  # <A>
_LinkedEntry__B = typing.TypeVar('_LinkedEntry__B')  # <B>
class LinkedEntry(HashEntry[_LinkedEntry__A, 'LinkedEntry'[_LinkedEntry__A, _LinkedEntry__B]], scala.Serializable, typing.Generic[_LinkedEntry__A, _LinkedEntry__B]):
    def __init__(self, key: _LinkedEntry__A, value: _LinkedEntry__B): ...
    def earlier(self) -> 'LinkedEntry'[_LinkedEntry__A, _LinkedEntry__B]: ...
    def earlier_$eq(self, x$1: 'LinkedEntry'[_LinkedEntry__A, _LinkedEntry__B]) -> None: ...
    def key(self) -> _LinkedEntry__A: ...
    def later(self) -> 'LinkedEntry'[_LinkedEntry__A, _LinkedEntry__B]: ...
    def later_$eq(self, x$1: 'LinkedEntry'[_LinkedEntry__A, _LinkedEntry__B]) -> None: ...
    def next(self) -> 'LinkedEntry'[_LinkedEntry__A, _LinkedEntry__B]: ...
    def next_$eq(self, x$1: 'LinkedEntry'[_LinkedEntry__A, _LinkedEntry__B]) -> None: ...
    def value(self) -> _LinkedEntry__B: ...
    def value_$eq(self, x$1: _LinkedEntry__B) -> None: ...

_MapLike__K = typing.TypeVar('_MapLike__K')  # <K>
_MapLike__V = typing.TypeVar('_MapLike__V')  # <V>
_MapLike__This = typing.TypeVar('_MapLike__This', bound='MapLike')  # <This>
class MapLike(scala.collection.MapLike[_MapLike__K, _MapLike__V, _MapLike__This], Builder[scala.Tuple2[_MapLike__K, _MapLike__V], _MapLike__This], scala.collection.generic.Shrinkable[_MapLike__K], Cloneable[_MapLike__This], typing.Generic[_MapLike__K, _MapLike__V, _MapLike__This]):
    @staticmethod
    def $init$($this: 'MapLike') -> None: ...
    @typing.overload
    def $minus(self, key: _MapLike__K) -> typing.Any: ...
    @typing.overload
    def $minus(self, key: _MapLike__K) -> _MapLike__This: ...
    @typing.overload
    def $minus(self, elem: typing.Any) -> scala.collection.generic.Subtractable: ...
    @typing.overload
    def $minus(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> scala.collection.generic.Subtractable: ...
    @typing.overload
    def $minus(self, key: _MapLike__K) -> _MapLike__This: ...
    @typing.overload
    def $minus(self, elem1: _MapLike__K, elem2: _MapLike__K, elems: scala.collection.Seq[_MapLike__K]) -> _MapLike__This: ...
    @typing.overload
    def $minus$eq(self, elem: typing.Any) -> scala.collection.generic.Shrinkable[typing.Any]: ...
    @typing.overload
    def $minus$eq(self, key: _MapLike__K) -> 'MapLike'[_MapLike__K, _MapLike__V, _MapLike__This]: ...
    @typing.overload
    def $minus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> scala.collection.generic.Shrinkable[typing.Any]: ...
    @typing.overload
    def $minus$minus(self, xs: scala.collection.GenTraversableOnce[typing.Any]) -> scala.collection.generic.Subtractable: ...
    @typing.overload
    def $minus$minus(self, xs: scala.collection.GenTraversableOnce[_MapLike__K]) -> _MapLike__This: ...
    _$plus_0__V1 = typing.TypeVar('_$plus_0__V1')  # <V1>
    _$plus_1__V1 = typing.TypeVar('_$plus_1__V1')  # <V1>
    _$plus_2__V1 = typing.TypeVar('_$plus_2__V1')  # <V1>
    _$plus_3__V1 = typing.TypeVar('_$plus_3__V1')  # <V1>
    _$plus_4__V1 = typing.TypeVar('_$plus_4__V1')  # <V1>
    @typing.overload
    def $plus(self, kv: scala.Tuple2[_MapLike__K, _.plus_0__V1]) -> scala.collection.GenMap[_MapLike__K, _.plus_0__V1]: ...
    @typing.overload
    def $plus(self, kv: scala.Tuple2[_MapLike__K, _.plus_1__V1]) -> scala.collection.Map[_MapLike__K, _.plus_1__V1]: ...
    @typing.overload
    def $plus(self, kv1: scala.Tuple2[_MapLike__K, _.plus_2__V1], kv2: scala.Tuple2[_MapLike__K, _.plus_2__V1], kvs: scala.collection.Seq[scala.Tuple2[_MapLike__K, _.plus_2__V1]]) -> scala.collection.Map[_MapLike__K, _.plus_2__V1]: ...
    @typing.overload
    def $plus(self, kv: scala.Tuple2[_MapLike__K, _.plus_3__V1]) -> 'Map'[_MapLike__K, _.plus_3__V1]: ...
    @typing.overload
    def $plus(self, elem1: scala.Tuple2[_MapLike__K, _.plus_4__V1], elem2: scala.Tuple2[_MapLike__K, _.plus_4__V1], elems: scala.collection.Seq[scala.Tuple2[_MapLike__K, _.plus_4__V1]]) -> 'Map'[_MapLike__K, _.plus_4__V1]: ...
    @typing.overload
    def $plus$eq(self, elem: typing.Any) -> scala.collection.generic.Growable[typing.Any]: ...
    @typing.overload
    def $plus$eq(self, elem: typing.Any) -> Builder[typing.Any, typing.Any]: ...
    @typing.overload
    def $plus$eq(self, kv: scala.Tuple2[_MapLike__K, _MapLike__V]) -> 'MapLike'[_MapLike__K, _MapLike__V, _MapLike__This]: ...
    @typing.overload
    def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> scala.collection.generic.Growable[typing.Any]: ...
    _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
    _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
    _$plus$plus_1__V1 = typing.TypeVar('_$plus$plus_1__V1')  # <V1>
    _$plus$plus_2__V1 = typing.TypeVar('_$plus$plus_2__V1')  # <V1>
    @typing.overload
    def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus_0__B], bf: scala.collection.generic.CanBuildFrom[typing.Any, _.plus.plus_0__B, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
    @typing.overload
    def $plus$plus(self, xs: scala.collection.GenTraversableOnce[scala.Tuple2[_MapLike__K, _.plus.plus_1__V1]]) -> scala.collection.Map[_MapLike__K, _.plus.plus_1__V1]: ...
    @typing.overload
    def $plus$plus(self, xs: scala.collection.GenTraversableOnce[scala.Tuple2[_MapLike__K, _.plus.plus_2__V1]]) -> 'Map'[_MapLike__K, _.plus.plus_2__V1]: ...
    def clear(self) -> None: ...
    @typing.overload
    def clone(self) -> typing.Any: ...
    @typing.overload
    def clone(self) -> _MapLike__This: ...
    def equals(self, that: typing.Any) -> bool: ...
    def getOrElseUpdate(self, key: _MapLike__K, op: scala.Function0[_MapLike__V]) -> _MapLike__V: ...
    def hashCode(self) -> int: ...
    def newBuilder(self) -> Builder[scala.Tuple2[_MapLike__K, _MapLike__V], _MapLike__This]: ...
    def parCombiner(self) -> scala.collection.parallel.Combiner[scala.Tuple2[_MapLike__K, _MapLike__V], scala.collection.parallel.mutable.ParMap[_MapLike__K, _MapLike__V]]: ...
    def put(self, key: _MapLike__K, value: _MapLike__V) -> scala.Option[_MapLike__V]: ...
    def remove(self, key: _MapLike__K) -> scala.Option[_MapLike__V]: ...
    @typing.overload
    def result(self) -> typing.Any: ...
    @typing.overload
    def result(self) -> _MapLike__This: ...
    def retain(self, p: scala.Function2[_MapLike__K, _MapLike__V, typing.Any]) -> 'MapLike'[_MapLike__K, _MapLike__V, _MapLike__This]: ...
    @typing.overload
    def toSeq(self) -> scala.collection.GenSeq[typing.Any]: ...
    @typing.overload
    def toSeq(self) -> scala.collection.Seq[scala.Tuple2[_MapLike__K, _MapLike__V]]: ...
    def toString(self) -> str: ...
    def transform(self, f: scala.Function2[_MapLike__K, _MapLike__V, _MapLike__V]) -> 'MapLike'[_MapLike__K, _MapLike__V, _MapLike__This]: ...
    def update(self, key: _MapLike__K, value: _MapLike__V) -> None: ...
    _updated_0__V1 = typing.TypeVar('_updated_0__V1')  # <V1>
    _updated_1__V1 = typing.TypeVar('_updated_1__V1')  # <V1>
    @typing.overload
    def updated(self, key: _MapLike__K, value: _updated_0__V1) -> scala.collection.Map[_MapLike__K, _updated_0__V1]: ...
    @typing.overload
    def updated(self, key: _MapLike__K, value: _updated_1__V1) -> 'Map'[_MapLike__K, _updated_1__V1]: ...

_ReusableBuilder__Elem = typing.TypeVar('_ReusableBuilder__Elem')  # <Elem>
_ReusableBuilder__To = typing.TypeVar('_ReusableBuilder__To')  # <To>
class ReusableBuilder(Builder[_ReusableBuilder__Elem, _ReusableBuilder__To], typing.Generic[_ReusableBuilder__Elem, _ReusableBuilder__To]):
    def clear(self) -> None: ...
    def result(self) -> _ReusableBuilder__To: ...

_SeqLike__A = typing.TypeVar('_SeqLike__A')  # <A>
_SeqLike__This = typing.TypeVar('_SeqLike__This', bound='SeqLike')  # <This>
class SeqLike(scala.collection.SeqLike[_SeqLike__A, _SeqLike__This], Cloneable[_SeqLike__This], typing.Generic[_SeqLike__A, _SeqLike__This]):
    @staticmethod
    def $init$($this: 'SeqLike') -> None: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def parCombiner(self) -> scala.collection.parallel.Combiner[_SeqLike__A, scala.collection.parallel.mutable.ParSeq[_SeqLike__A]]: ...
    def toString(self) -> str: ...
    def transform(self, f: scala.Function1[_SeqLike__A, _SeqLike__A]) -> 'SeqLike'[_SeqLike__A, _SeqLike__This]: ...
    def update(self, idx: int, elem: _SeqLike__A) -> None: ...

_SetLike__A = typing.TypeVar('_SetLike__A')  # <A>
_SetLike__This = typing.TypeVar('_SetLike__This', bound='SetLike')  # <This>
class SetLike(scala.collection.SetLike[_SetLike__A, _SetLike__This], scala.collection.script.Scriptable[_SetLike__A], Builder[_SetLike__A, _SetLike__This], scala.collection.generic.Shrinkable[_SetLike__A], Cloneable['Set'[_SetLike__A]], typing.Generic[_SetLike__A, _SetLike__This]):
    @staticmethod
    def $init$($this: 'SetLike') -> None: ...
    def $less$less(self, cmd: scala.collection.script.Message[_SetLike__A]) -> None: ...
    @typing.overload
    def $minus(self, elem: _SetLike__A) -> typing.Any: ...
    @typing.overload
    def $minus(self, elem: _SetLike__A) -> _SetLike__This: ...
    @typing.overload
    def $minus(self, elem: _SetLike__A) -> scala.collection.generic.Subtractable: ...
    @typing.overload
    def $minus(self, elem1: _SetLike__A, elem2: _SetLike__A, elems: scala.collection.Seq[_SetLike__A]) -> scala.collection.generic.Subtractable: ...
    @typing.overload
    def $minus(self, elem: _SetLike__A) -> _SetLike__This: ...
    @typing.overload
    def $minus(self, elem1: _SetLike__A, elem2: _SetLike__A, elems: scala.collection.Seq[_SetLike__A]) -> _SetLike__This: ...
    @typing.overload
    def $minus$eq(self, elem: _SetLike__A) -> scala.collection.generic.Shrinkable[_SetLike__A]: ...
    @typing.overload
    def $minus$eq(self, elem: _SetLike__A) -> 'SetLike'[_SetLike__A, _SetLike__This]: ...
    @typing.overload
    def $minus$eq(self, elem1: _SetLike__A, elem2: _SetLike__A, elems: scala.collection.Seq[_SetLike__A]) -> scala.collection.generic.Shrinkable[_SetLike__A]: ...
    @typing.overload
    def $minus$minus(self, xs: scala.collection.GenTraversableOnce[_SetLike__A]) -> scala.collection.generic.Subtractable: ...
    @typing.overload
    def $minus$minus(self, xs: scala.collection.GenTraversableOnce[_SetLike__A]) -> _SetLike__This: ...
    @typing.overload
    def $plus(self, elem: _SetLike__A) -> typing.Any: ...
    @typing.overload
    def $plus(self, elem: _SetLike__A) -> _SetLike__This: ...
    @typing.overload
    def $plus(self, elem1: _SetLike__A, elem2: _SetLike__A, elems: scala.collection.Seq[_SetLike__A]) -> _SetLike__This: ...
    @typing.overload
    def $plus(self, elem: _SetLike__A) -> _SetLike__This: ...
    @typing.overload
    def $plus(self, elem1: _SetLike__A, elem2: _SetLike__A, elems: scala.collection.Seq[_SetLike__A]) -> _SetLike__This: ...
    @typing.overload
    def $plus$eq(self, elem: _SetLike__A) -> scala.collection.generic.Growable[_SetLike__A]: ...
    @typing.overload
    def $plus$eq(self, elem: typing.Any) -> Builder[typing.Any, typing.Any]: ...
    @typing.overload
    def $plus$eq(self, elem: _SetLike__A) -> 'SetLike'[_SetLike__A, _SetLike__This]: ...
    @typing.overload
    def $plus$eq(self, elem1: _SetLike__A, elem2: _SetLike__A, elems: scala.collection.Seq[_SetLike__A]) -> scala.collection.generic.Growable[_SetLike__A]: ...
    _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
    _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
    @typing.overload
    def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus_0__B], bf: scala.collection.generic.CanBuildFrom[typing.Any, _.plus.plus_0__B, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
    @typing.overload
    def $plus$plus(self, elems: scala.collection.GenTraversableOnce[_SetLike__A]) -> _SetLike__This: ...
    @typing.overload
    def $plus$plus(self, xs: scala.collection.GenTraversableOnce[_SetLike__A]) -> _SetLike__This: ...
    def add(self, elem: _SetLike__A) -> bool: ...
    def clear(self) -> None: ...
    @typing.overload
    def clone(self) -> _SetLike__A: ...
    @typing.overload
    def clone(self) -> _SetLike__This: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def newBuilder(self) -> Builder[_SetLike__A, _SetLike__This]: ...
    def parCombiner(self) -> scala.collection.parallel.Combiner[_SetLike__A, scala.collection.parallel.mutable.ParSet[_SetLike__A]]: ...
    def remove(self, elem: _SetLike__A) -> bool: ...
    @typing.overload
    def result(self) -> typing.Any: ...
    @typing.overload
    def result(self) -> _SetLike__This: ...
    def retain(self, p: scala.Function1[_SetLike__A, typing.Any]) -> None: ...
    @typing.overload
    def toSeq(self) -> scala.collection.GenSeq[_SetLike__A]: ...
    @typing.overload
    def toSeq(self) -> scala.collection.Seq[_SetLike__A]: ...
    def toString(self) -> str: ...
    def update(self, elem: _SetLike__A, included: bool) -> None: ...

_AbstractIterable__A = typing.TypeVar('_AbstractIterable__A')  # <A>
class AbstractIterable(scala.collection.AbstractIterable[_AbstractIterable__A], Iterable[_AbstractIterable__A], typing.Generic[_AbstractIterable__A]):
    def __init__(self): ...
    def companion(self) -> scala.collection.generic.GenericCompanion[Iterable]: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[_AbstractIterable__A, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[_AbstractIterable__A]]: ...
    def parCombiner(self) -> scala.collection.parallel.Combiner[_AbstractIterable__A, scala.collection.parallel.mutable.ParIterable[_AbstractIterable__A]]: ...
    def seq(self) -> Iterable[_AbstractIterable__A]: ...
    def thisCollection(self) -> scala.collection.Iterable[_AbstractIterable__A]: ...
    def toCollection(self, repr: typing.Any) -> scala.collection.Iterable: ...
    def toIterable(self) -> scala.collection.Iterable[_AbstractIterable__A]: ...
    def toTraversable(self) -> scala.collection.Traversable[_AbstractIterable__A]: ...
    @typing.overload
    def view(self) -> scala.collection.IterableView[_AbstractIterable__A, scala.collection.Iterable[_AbstractIterable__A]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> scala.collection.IterableView[_AbstractIterable__A, scala.collection.Iterable[_AbstractIterable__A]]: ...

_ArrayLike__A = typing.TypeVar('_ArrayLike__A')  # <A>
_ArrayLike__Repr = typing.TypeVar('_ArrayLike__Repr')  # <Repr>
class ArrayLike(IndexedSeqOptimized[_ArrayLike__A, _ArrayLike__Repr], typing.Generic[_ArrayLike__A, _ArrayLike__Repr]):
    @staticmethod
    def $init$($this: 'ArrayLike') -> None: ...
    def deep(self) -> scala.collection.IndexedSeq[typing.Any]: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...

_BufferLike__A = typing.TypeVar('_BufferLike__A')  # <A>
_BufferLike__This = typing.TypeVar('_BufferLike__This', bound='BufferLike')  # <This>
class BufferLike(scala.collection.generic.Growable[_BufferLike__A], scala.collection.generic.Shrinkable[_BufferLike__A], scala.collection.script.Scriptable[_BufferLike__A], scala.collection.generic.Subtractable[_BufferLike__A, _BufferLike__This], SeqLike[_BufferLike__A, _BufferLike__This], typing.Generic[_BufferLike__A, _BufferLike__This]):
    @staticmethod
    def $init$($this: 'BufferLike') -> None: ...
    def $less$less(self, cmd: scala.collection.script.Message[_BufferLike__A]) -> None: ...
    @typing.overload
    def $minus(self, elem: _BufferLike__A) -> scala.collection.generic.Subtractable: ...
    @typing.overload
    def $minus(self, elem1: _BufferLike__A, elem2: _BufferLike__A, elems: scala.collection.Seq[_BufferLike__A]) -> scala.collection.generic.Subtractable: ...
    @typing.overload
    def $minus(self, elem: _BufferLike__A) -> _BufferLike__This: ...
    @typing.overload
    def $minus(self, elem1: _BufferLike__A, elem2: _BufferLike__A, elems: scala.collection.Seq[_BufferLike__A]) -> _BufferLike__This: ...
    @typing.overload
    def $minus$eq(self, elem: _BufferLike__A) -> scala.collection.generic.Shrinkable[_BufferLike__A]: ...
    @typing.overload
    def $minus$eq(self, elem1: _BufferLike__A, elem2: _BufferLike__A, elems: scala.collection.Seq[_BufferLike__A]) -> scala.collection.generic.Shrinkable[_BufferLike__A]: ...
    @typing.overload
    def $minus$eq(self, x: _BufferLike__A) -> _BufferLike__This: ...
    @typing.overload
    def $minus$minus(self, xs: scala.collection.GenTraversableOnce[_BufferLike__A]) -> scala.collection.generic.Subtractable: ...
    @typing.overload
    def $minus$minus(self, xs: scala.collection.GenTraversableOnce[_BufferLike__A]) -> _BufferLike__This: ...
    @typing.overload
    def $plus$eq(self, elem: _BufferLike__A) -> scala.collection.generic.Growable[_BufferLike__A]: ...
    @typing.overload
    def $plus$eq(self, elem: _BufferLike__A) -> _BufferLike__This: ...
    @typing.overload
    def $plus$eq(self, elem1: _BufferLike__A, elem2: _BufferLike__A, elems: scala.collection.Seq[_BufferLike__A]) -> scala.collection.generic.Growable[_BufferLike__A]: ...
    def $plus$eq$colon(self, elem: _BufferLike__A) -> _BufferLike__This: ...
    _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
    _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
    @typing.overload
    def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus_0__B], bf: scala.collection.generic.CanBuildFrom[typing.Any, _.plus.plus_0__B, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
    @typing.overload
    def $plus$plus(self, xs: scala.collection.GenTraversableOnce[_BufferLike__A]) -> _BufferLike__This: ...
    def $plus$plus$eq$colon(self, xs: scala.collection.TraversableOnce[_BufferLike__A]) -> _BufferLike__This: ...
    def append(self, elems: scala.collection.Seq[_BufferLike__A]) -> None: ...
    def appendAll(self, xs: scala.collection.TraversableOnce[_BufferLike__A]) -> None: ...
    def apply(self, n: int) -> _BufferLike__A: ...
    def clear(self) -> None: ...
    @typing.overload
    def clone(self) -> _BufferLike__A: ...
    @typing.overload
    def clone(self) -> _BufferLike__This: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def insert(self, n: int, elems: scala.collection.Seq[_BufferLike__A]) -> None: ...
    def insertAll(self, n: int, elems: scala.collection.Traversable[_BufferLike__A]) -> None: ...
    def length(self) -> int: ...
    def prepend(self, elems: scala.collection.Seq[_BufferLike__A]) -> None: ...
    def prependAll(self, xs: scala.collection.TraversableOnce[_BufferLike__A]) -> None: ...
    @typing.overload
    def remove(self, n: int) -> _BufferLike__A: ...
    @typing.overload
    def remove(self, n: int, count: int) -> None: ...
    def stringPrefix(self) -> str: ...
    def toString(self) -> str: ...
    def trimEnd(self, n: int) -> None: ...
    def trimStart(self, n: int) -> None: ...
    def update(self, n: int, newelem: _BufferLike__A) -> None: ...

_LazyBuilder__Elem = typing.TypeVar('_LazyBuilder__Elem')  # <Elem>
_LazyBuilder__To = typing.TypeVar('_LazyBuilder__To')  # <To>
class LazyBuilder(ReusableBuilder[_LazyBuilder__Elem, _LazyBuilder__To], typing.Generic[_LazyBuilder__Elem, _LazyBuilder__To]):
    def __init__(self): ...
    @typing.overload
    def $plus$eq(self, elem1: _LazyBuilder__Elem, elem2: _LazyBuilder__Elem, elems: scala.collection.Seq[_LazyBuilder__Elem]) -> scala.collection.generic.Growable[_LazyBuilder__Elem]: ...
    @typing.overload
    def $plus$eq(self, x: _LazyBuilder__Elem) -> 'LazyBuilder'[_LazyBuilder__Elem, _LazyBuilder__To]: ...
    def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[_LazyBuilder__Elem]) -> 'LazyBuilder'[_LazyBuilder__Elem, _LazyBuilder__To]: ...
    def clear(self) -> None: ...
    _mapResult__NewTo = typing.TypeVar('_mapResult__NewTo')  # <NewTo>
    def mapResult(self, f: scala.Function1[_LazyBuilder__To, _mapResult__NewTo]) -> Builder[_LazyBuilder__Elem, _mapResult__NewTo]: ...
    def parts(self) -> 'ListBuffer'[scala.collection.TraversableOnce[_LazyBuilder__Elem]]: ...
    def parts_$eq(self, x$1: 'ListBuffer'[scala.collection.TraversableOnce[_LazyBuilder__Elem]]) -> None: ...
    def result(self) -> _LazyBuilder__To: ...
    @typing.overload
    def sizeHint(self, size: int) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any], delta: int) -> None: ...
    def sizeHintBounded(self, size: int, boundingColl: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...

_LinkedListLike__A = typing.TypeVar('_LinkedListLike__A')  # <A>
_LinkedListLike__This = typing.TypeVar('_LinkedListLike__This', bound='Seq')  # <This>
class LinkedListLike(SeqLike[_LinkedListLike__A, _LinkedListLike__This], typing.Generic[_LinkedListLike__A, _LinkedListLike__This]):
    @staticmethod
    def $init$($this: 'LinkedListLike') -> None: ...
    def append(self, that: _LinkedListLike__This) -> _LinkedListLike__This: ...
    def apply(self, n: int) -> _LinkedListLike__A: ...
    @typing.overload
    def clone(self) -> _LinkedListLike__A: ...
    @typing.overload
    def clone(self) -> _LinkedListLike__This: ...
    @typing.overload
    def drop(self, n: int) -> typing.Any: ...
    @typing.overload
    def drop(self, n: int) -> _LinkedListLike__This: ...
    def elem(self) -> _LinkedListLike__A: ...
    def elem_$eq(self, x$1: _LinkedListLike__A) -> None: ...
    def equals(self, that: typing.Any) -> bool: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_LinkedListLike__A, _foreach__U]) -> None: ...
    def get(self, n: int) -> scala.Option[_LinkedListLike__A]: ...
    def hashCode(self) -> int: ...
    def head(self) -> _LinkedListLike__A: ...
    def insert(self, that: _LinkedListLike__This) -> None: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> scala.collection.Iterator[_LinkedListLike__A]: ...
    def length(self) -> int: ...
    def next(self) -> _LinkedListLike__This: ...
    def next_$eq(self, x$1: _LinkedListLike__This) -> None: ...
    @typing.overload
    def tail(self) -> typing.Any: ...
    @typing.overload
    def tail(self) -> _LinkedListLike__This: ...
    def toString(self) -> str: ...
    def update(self, n: int, x: _LinkedListLike__A) -> None: ...

_MapBuilder__A = typing.TypeVar('_MapBuilder__A')  # <A>
_MapBuilder__B = typing.TypeVar('_MapBuilder__B')  # <B>
_MapBuilder__Coll = typing.TypeVar('_MapBuilder__Coll', bound=scala.collection.GenMap)  # <Coll>
class MapBuilder(ReusableBuilder[scala.Tuple2[_MapBuilder__A, _MapBuilder__B], _MapBuilder__Coll], typing.Generic[_MapBuilder__A, _MapBuilder__B, _MapBuilder__Coll]):
    def __init__(self, empty: _MapBuilder__Coll): ...
    @typing.overload
    def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq) -> scala.collection.generic.Growable: ...
    @typing.overload
    def $plus$eq(self, x: scala.Tuple2[_MapBuilder__A, _MapBuilder__B]) -> 'MapBuilder'[_MapBuilder__A, _MapBuilder__B, _MapBuilder__Coll]: ...
    def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[scala.Tuple2[_MapBuilder__A, _MapBuilder__B]]) -> scala.collection.generic.Growable[scala.Tuple2[_MapBuilder__A, _MapBuilder__B]]: ...
    def clear(self) -> None: ...
    def elems(self) -> _MapBuilder__Coll: ...
    def elems_$eq(self, x$1: _MapBuilder__Coll) -> None: ...
    _mapResult__NewTo = typing.TypeVar('_mapResult__NewTo')  # <NewTo>
    def mapResult(self, f: scala.Function1[_MapBuilder__Coll, _mapResult__NewTo]) -> Builder[scala.Tuple2[_MapBuilder__A, _MapBuilder__B], _mapResult__NewTo]: ...
    def result(self) -> _MapBuilder__Coll: ...
    @typing.overload
    def sizeHint(self, size: int) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any], delta: int) -> None: ...
    def sizeHintBounded(self, size: int, boundingColl: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...

_Seq__A = typing.TypeVar('_Seq__A')  # <A>
class Seq(Iterable[_Seq__A], scala.collection.Seq[_Seq__A], SeqLike[_Seq__A, 'Seq'[_Seq__A]], typing.Generic[_Seq__A]):
    @staticmethod
    def $init$($this: 'Seq') -> None: ...
    @staticmethod
    def ReusableCBF() -> scala.collection.generic.GenTraversableFactory.GenericCanBuildFrom[scala.runtime.Nothing.]: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['Seq'[typing.Any], _canBuildFrom__A, 'Seq'[_canBuildFrom__A]]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['Seq']: ...
    @staticmethod
    def concat(xss: scala.collection.Seq) -> scala.collection.GenTraversable: ...
    @staticmethod
    def empty() -> scala.collection.GenTraversable: ...
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, n5: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def iterate(start: typing.Any, len: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, step: typing.Any, evidence$2: scala.math.Integral) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, evidence$1: scala.math.Integral) -> scala.collection.GenTraversable: ...
    @typing.overload
    def seq(self) -> scala.collection.TraversableOnce[_Seq__A]: ...
    @typing.overload
    def seq(self) -> scala.collection.TraversableOnce[_Seq__A]: ...
    @typing.overload
    def seq(self) -> scala.collection.Iterable[_Seq__A]: ...
    @typing.overload
    def seq(self) -> scala.collection.Seq[_Seq__A]: ...
    @typing.overload
    def seq(self) -> scala.collection.Traversable[_Seq__A]: ...
    @typing.overload
    def seq(self) -> Iterable[_Seq__A]: ...
    @typing.overload
    def seq(self) -> 'Seq'[_Seq__A]: ...
    @typing.overload
    def seq(self) -> Traversable[_Seq__A]: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, n5: int, f: scala.Function5) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, f: scala.Function4) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, f: scala.Function3) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, f: scala.Function2) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self) -> str: ...
    @staticmethod
    def unapplySeq(x: scala.collection.Seq) -> scala.Some: ...

_Set__A = typing.TypeVar('_Set__A')  # <A>
class Set(Iterable[_Set__A], scala.collection.Set[_Set__A], SetLike[_Set__A, 'Set'[_Set__A]], typing.Generic[_Set__A]):
    @staticmethod
    def $init$($this: 'Set') -> None: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['Set'[typing.Any], _canBuildFrom__A, 'Set'[_canBuildFrom__A]]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['Set']: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def seq(self) -> scala.collection.TraversableOnce[_Set__A]: ...
    @typing.overload
    def seq(self) -> scala.collection.TraversableOnce[_Set__A]: ...
    @typing.overload
    def seq(self) -> scala.collection.Iterable[_Set__A]: ...
    @typing.overload
    def seq(self) -> scala.collection.Set[_Set__A]: ...
    @typing.overload
    def seq(self) -> scala.collection.Traversable[_Set__A]: ...
    @typing.overload
    def seq(self) -> Iterable[_Set__A]: ...
    @typing.overload
    def seq(self) -> 'Set'[_Set__A]: ...
    @typing.overload
    def seq(self) -> Traversable[_Set__A]: ...
    _setCanBuildFrom__A = typing.TypeVar('_setCanBuildFrom__A')  # <A>
    @staticmethod
    def setCanBuildFrom() -> scala.collection.generic.CanBuildFrom['Set'[typing.Any], _setCanBuildFrom__A, 'Set'[_setCanBuildFrom__A]]: ...
    def toString(self) -> str: ...

_SetBuilder__A = typing.TypeVar('_SetBuilder__A')  # <A>
_SetBuilder__Coll = typing.TypeVar('_SetBuilder__Coll', bound=scala.collection.Set)  # <Coll>
class SetBuilder(ReusableBuilder[_SetBuilder__A, _SetBuilder__Coll], typing.Generic[_SetBuilder__A, _SetBuilder__Coll]):
    def __init__(self, empty: _SetBuilder__Coll): ...
    @typing.overload
    def $plus$eq(self, elem1: _SetBuilder__A, elem2: _SetBuilder__A, elems: scala.collection.Seq[_SetBuilder__A]) -> scala.collection.generic.Growable[_SetBuilder__A]: ...
    @typing.overload
    def $plus$eq(self, x: _SetBuilder__A) -> 'SetBuilder'[_SetBuilder__A, _SetBuilder__Coll]: ...
    def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[_SetBuilder__A]) -> scala.collection.generic.Growable[_SetBuilder__A]: ...
    def clear(self) -> None: ...
    def elems(self) -> _SetBuilder__Coll: ...
    def elems_$eq(self, x$1: _SetBuilder__Coll) -> None: ...
    _mapResult__NewTo = typing.TypeVar('_mapResult__NewTo')  # <NewTo>
    def mapResult(self, f: scala.Function1[_SetBuilder__Coll, _mapResult__NewTo]) -> Builder[_SetBuilder__A, _mapResult__NewTo]: ...
    def result(self) -> _SetBuilder__Coll: ...
    @typing.overload
    def sizeHint(self, size: int) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any], delta: int) -> None: ...
    def sizeHintBounded(self, size: int, boundingColl: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...

_WrappedArrayBuilder__A = typing.TypeVar('_WrappedArrayBuilder__A')  # <A>
class WrappedArrayBuilder(ReusableBuilder[_WrappedArrayBuilder__A, 'WrappedArray'[_WrappedArrayBuilder__A]], typing.Generic[_WrappedArrayBuilder__A]):
    def __init__(self, tag: scala.reflect.ClassTag[_WrappedArrayBuilder__A]): ...
    @typing.overload
    def $plus$eq(self, elem1: _WrappedArrayBuilder__A, elem2: _WrappedArrayBuilder__A, elems: scala.collection.Seq[_WrappedArrayBuilder__A]) -> scala.collection.generic.Growable[_WrappedArrayBuilder__A]: ...
    @typing.overload
    def $plus$eq(self, elem: _WrappedArrayBuilder__A) -> 'WrappedArrayBuilder'[_WrappedArrayBuilder__A]: ...
    def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[_WrappedArrayBuilder__A]) -> scala.collection.generic.Growable[_WrappedArrayBuilder__A]: ...
    def clear(self) -> None: ...
    def manifest(self) -> scala.reflect.ClassTag[_WrappedArrayBuilder__A]: ...
    _mapResult__NewTo = typing.TypeVar('_mapResult__NewTo')  # <NewTo>
    def mapResult(self, f: scala.Function1['WrappedArray'[_WrappedArrayBuilder__A], _mapResult__NewTo]) -> Builder[_WrappedArrayBuilder__A, _mapResult__NewTo]: ...
    def result(self) -> 'WrappedArray'[_WrappedArrayBuilder__A]: ...
    @typing.overload
    def sizeHint(self, size: int) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any], delta: int) -> None: ...
    def sizeHintBounded(self, size: int, boundingColl: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...

_AbstractSeq__A = typing.TypeVar('_AbstractSeq__A')  # <A>
class AbstractSeq(scala.collection.AbstractSeq[_AbstractSeq__A], Seq[_AbstractSeq__A], typing.Generic[_AbstractSeq__A]):
    def __init__(self): ...
    def clone(self) -> typing.Any: ...
    def companion(self) -> scala.collection.generic.GenericCompanion[Seq]: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[_AbstractSeq__A, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[_AbstractSeq__A]]: ...
    def isDefinedAt(self, idx: int) -> bool: ...
    def parCombiner(self) -> scala.collection.parallel.Combiner[_AbstractSeq__A, scala.collection.parallel.mutable.ParSeq[_AbstractSeq__A]]: ...
    def seq(self) -> Seq[_AbstractSeq__A]: ...
    def thisCollection(self) -> scala.collection.Seq[_AbstractSeq__A]: ...
    def toCollection(self, repr: typing.Any) -> scala.collection.Seq: ...
    def toIterable(self) -> scala.collection.Iterable[_AbstractSeq__A]: ...
    def toSeq(self) -> scala.collection.Seq[_AbstractSeq__A]: ...
    def toTraversable(self) -> scala.collection.Traversable[_AbstractSeq__A]: ...
    def transform(self, f: scala.Function1[_AbstractSeq__A, _AbstractSeq__A]) -> SeqLike[_AbstractSeq__A, Seq[_AbstractSeq__A]]: ...
    @typing.overload
    def view(self) -> scala.collection.SeqView[_AbstractSeq__A, scala.collection.Seq[_AbstractSeq__A]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> scala.collection.SeqView[_AbstractSeq__A, scala.collection.Seq[_AbstractSeq__A]]: ...

_AbstractSet__A = typing.TypeVar('_AbstractSet__A')  # <A>
class AbstractSet(AbstractIterable[_AbstractSet__A], Set[_AbstractSet__A], typing.Generic[_AbstractSet__A]):
    def __init__(self): ...
    def $amp(self, that: scala.collection.GenSet) -> typing.Any: ...
    def $amp$tilde(self, that: scala.collection.GenSet) -> typing.Any: ...
    def $bar(self, that: scala.collection.GenSet) -> typing.Any: ...
    def $less$less(self, cmd: scala.collection.script.Message[_AbstractSet__A]) -> None: ...
    @typing.overload
    def $minus(self, elem: _AbstractSet__A) -> Set[_AbstractSet__A]: ...
    @typing.overload
    def $minus(self, elem1: _AbstractSet__A, elem2: _AbstractSet__A, elems: scala.collection.Seq[_AbstractSet__A]) -> Set[_AbstractSet__A]: ...
    @typing.overload
    def $minus$eq(self, elem: _AbstractSet__A) -> scala.collection.generic.Shrinkable[_AbstractSet__A]: ...
    @typing.overload
    def $minus$eq(self, elem: _AbstractSet__A) -> SetLike[_AbstractSet__A, SetLike]: ...
    @typing.overload
    def $minus$eq(self, elem1: _AbstractSet__A, elem2: _AbstractSet__A, elems: scala.collection.Seq[_AbstractSet__A]) -> scala.collection.generic.Shrinkable[_AbstractSet__A]: ...
    def $minus$minus(self, xs: scala.collection.GenTraversableOnce[_AbstractSet__A]) -> Set[_AbstractSet__A]: ...
    def $minus$minus$eq(self, xs: scala.collection.TraversableOnce[_AbstractSet__A]) -> scala.collection.generic.Shrinkable[_AbstractSet__A]: ...
    @typing.overload
    def $plus(self, elem: _AbstractSet__A) -> Set[_AbstractSet__A]: ...
    @typing.overload
    def $plus(self, elem1: _AbstractSet__A, elem2: _AbstractSet__A, elems: scala.collection.Seq[_AbstractSet__A]) -> Set[_AbstractSet__A]: ...
    @typing.overload
    def $plus$eq(self, elem: _AbstractSet__A) -> scala.collection.generic.Growable[_AbstractSet__A]: ...
    @typing.overload
    def $plus$eq(self, elem: typing.Any) -> Builder[typing.Any, typing.Any]: ...
    @typing.overload
    def $plus$eq(self, elem: _AbstractSet__A) -> SetLike[_AbstractSet__A, SetLike]: ...
    @typing.overload
    def $plus$eq(self, elem1: _AbstractSet__A, elem2: _AbstractSet__A, elems: scala.collection.Seq[_AbstractSet__A]) -> scala.collection.generic.Growable[_AbstractSet__A]: ...
    _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
    _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
    @typing.overload
    def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus_0__B], bf: scala.collection.generic.CanBuildFrom[scala.collection.Traversable[_AbstractSet__A], _.plus.plus_0__B, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
    @typing.overload
    def $plus$plus(self, xs: scala.collection.GenTraversableOnce[_AbstractSet__A]) -> Set[_AbstractSet__A]: ...
    def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[_AbstractSet__A]) -> scala.collection.generic.Growable[_AbstractSet__A]: ...
    def add(self, elem: _AbstractSet__A) -> bool: ...
    _andThen__A = typing.TypeVar('_andThen__A')  # <A>
    def andThen(self, g: scala.Function1[typing.Any, typing.Any]) -> scala.Function1[typing.Any, typing.Any]: ...
    def apply(self, elem: _AbstractSet__A) -> bool: ...
    def apply$mcDD$sp(self, v1: float) -> float: ...
    def apply$mcDF$sp(self, v1: float) -> float: ...
    def apply$mcDI$sp(self, v1: int) -> float: ...
    def apply$mcDJ$sp(self, v1: int) -> float: ...
    def apply$mcFD$sp(self, v1: float) -> float: ...
    def apply$mcFF$sp(self, v1: float) -> float: ...
    def apply$mcFI$sp(self, v1: int) -> float: ...
    def apply$mcFJ$sp(self, v1: int) -> float: ...
    def apply$mcID$sp(self, v1: float) -> int: ...
    def apply$mcIF$sp(self, v1: float) -> int: ...
    def apply$mcII$sp(self, v1: int) -> int: ...
    def apply$mcIJ$sp(self, v1: int) -> int: ...
    def apply$mcJD$sp(self, v1: float) -> int: ...
    def apply$mcJF$sp(self, v1: float) -> int: ...
    def apply$mcJI$sp(self, v1: int) -> int: ...
    def apply$mcJJ$sp(self, v1: int) -> int: ...
    def apply$mcVD$sp(self, v1: float) -> None: ...
    def apply$mcVF$sp(self, v1: float) -> None: ...
    def apply$mcVI$sp(self, v1: int) -> None: ...
    def apply$mcVJ$sp(self, v1: int) -> None: ...
    def apply$mcZD$sp(self, v1: float) -> bool: ...
    def apply$mcZF$sp(self, v1: float) -> bool: ...
    def apply$mcZI$sp(self, v1: int) -> bool: ...
    def apply$mcZJ$sp(self, v1: int) -> bool: ...
    def clear(self) -> None: ...
    def clone(self) -> Set[_AbstractSet__A]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion[Set]: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    def compose(self, g: scala.Function1[typing.Any, typing.Any]) -> scala.Function1[typing.Any, typing.Any]: ...
    def diff(self, that: scala.collection.GenSet) -> scala.collection.Set: ...
    def empty(self) -> scala.collection.GenSet: ...
    def equals(self, that: typing.Any) -> bool: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[_AbstractSet__A, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[_AbstractSet__A]]: ...
    def hashCode(self) -> int: ...
    def intersect(self, that: scala.collection.GenSet) -> typing.Any: ...
    def isEmpty(self) -> bool: ...
    _map__B = typing.TypeVar('_map__B')  # <B>
    _map__That = typing.TypeVar('_map__That')  # <That>
    def map(self, f: scala.Function1[_AbstractSet__A, _map__B], bf: scala.collection.generic.CanBuildFrom[Set[_AbstractSet__A], _map__B, _map__That]) -> _map__That: ...
    _mapResult__NewTo = typing.TypeVar('_mapResult__NewTo')  # <NewTo>
    def mapResult(self, f: scala.Function1[Set[_AbstractSet__A], _mapResult__NewTo]) -> Builder[_AbstractSet__A, _mapResult__NewTo]: ...
    def newBuilder(self) -> Builder[_AbstractSet__A, Set[_AbstractSet__A]]: ...
    def parCombiner(self) -> scala.collection.parallel.Combiner[_AbstractSet__A, scala.collection.parallel.mutable.ParSet[_AbstractSet__A]]: ...
    def remove(self, elem: _AbstractSet__A) -> bool: ...
    def repr(self) -> typing.Any: ...
    def result(self) -> Set[_AbstractSet__A]: ...
    def retain(self, p: scala.Function1[_AbstractSet__A, typing.Any]) -> None: ...
    def seq(self) -> Set[_AbstractSet__A]: ...
    @typing.overload
    def sizeHint(self, size: int) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any], delta: int) -> None: ...
    def sizeHintBounded(self, size: int, boundingColl: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
    def stringPrefix(self) -> str: ...
    def subsetOf(self, that: scala.collection.GenSet[_AbstractSet__A]) -> bool: ...
    @typing.overload
    def subsets(self) -> scala.collection.Iterator[Set[_AbstractSet__A]]: ...
    @typing.overload
    def subsets(self, len: int) -> scala.collection.Iterator[Set[_AbstractSet__A]]: ...
    def thisCollection(self) -> scala.collection.Iterable[_AbstractSet__A]: ...
    _toBuffer__A1 = typing.TypeVar('_toBuffer__A1')  # <A1>
    def toBuffer(self) -> 'Buffer'[_toBuffer__A1]: ...
    def toCollection(self, repr: typing.Any) -> scala.collection.Iterable: ...
    def toIterable(self) -> scala.collection.Iterable[_AbstractSet__A]: ...
    def toSeq(self) -> scala.collection.Seq[_AbstractSet__A]: ...
    def toString(self) -> str: ...
    def toTraversable(self) -> scala.collection.Traversable[_AbstractSet__A]: ...
    def union(self, that: scala.collection.GenSet) -> scala.collection.Set: ...
    def update(self, elem: _AbstractSet__A, included: bool) -> None: ...
    @typing.overload
    def view(self) -> scala.collection.IterableView[_AbstractSet__A, scala.collection.Iterable[_AbstractSet__A]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> scala.collection.IterableView[_AbstractSet__A, scala.collection.Iterable[_AbstractSet__A]]: ...

_Buffer__A = typing.TypeVar('_Buffer__A')  # <A>
class Buffer(Seq[_Buffer__A], BufferLike[_Buffer__A, 'Buffer'[_Buffer__A]], typing.Generic[_Buffer__A]):
    @staticmethod
    def $init$($this: 'Buffer') -> None: ...
    @staticmethod
    def ReusableCBF() -> scala.collection.generic.GenTraversableFactory.GenericCanBuildFrom[scala.runtime.Nothing.]: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['Buffer'[typing.Any], _canBuildFrom__A, 'Buffer'[_canBuildFrom__A]]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['Buffer']: ...
    @staticmethod
    def concat(xss: scala.collection.Seq) -> scala.collection.GenTraversable: ...
    @staticmethod
    def empty() -> scala.collection.GenTraversable: ...
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, n5: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def iterate(start: typing.Any, len: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, step: typing.Any, evidence$2: scala.math.Integral) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, evidence$1: scala.math.Integral) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, n5: int, f: scala.Function5) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, f: scala.Function4) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, f: scala.Function3) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, f: scala.Function2) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self) -> str: ...
    @staticmethod
    def unapplySeq(x: scala.collection.Seq) -> scala.Some: ...

_DoubleLinkedListLike__A = typing.TypeVar('_DoubleLinkedListLike__A')  # <A>
_DoubleLinkedListLike__This = typing.TypeVar('_DoubleLinkedListLike__This', bound=Seq)  # <This>
class DoubleLinkedListLike(LinkedListLike[_DoubleLinkedListLike__A, _DoubleLinkedListLike__This], typing.Generic[_DoubleLinkedListLike__A, _DoubleLinkedListLike__This]):
    @staticmethod
    def $init$($this: 'DoubleLinkedListLike') -> None: ...
    def append(self, that: _DoubleLinkedListLike__This) -> _DoubleLinkedListLike__This: ...
    def apply(self, n: int) -> _DoubleLinkedListLike__A: ...
    @typing.overload
    def drop(self, n: int) -> typing.Any: ...
    @typing.overload
    def drop(self, n: int) -> _DoubleLinkedListLike__This: ...
    def equals(self, that: typing.Any) -> bool: ...
    def get(self, n: int) -> scala.Option[_DoubleLinkedListLike__A]: ...
    def hashCode(self) -> int: ...
    def insert(self, that: _DoubleLinkedListLike__This) -> None: ...
    def prev(self) -> _DoubleLinkedListLike__This: ...
    def prev_$eq(self, x$1: _DoubleLinkedListLike__This) -> None: ...
    def remove(self) -> None: ...
    @typing.overload
    def tail(self) -> typing.Any: ...
    @typing.overload
    def tail(self) -> _DoubleLinkedListLike__This: ...
    def toString(self) -> str: ...
    def update(self, n: int, x: _DoubleLinkedListLike__A) -> None: ...

_History__Evt = typing.TypeVar('_History__Evt')  # <Evt>
_History__Pub = typing.TypeVar('_History__Pub')  # <Pub>
class History(AbstractIterable[scala.Tuple2[_History__Pub, _History__Evt]], Subscriber[_History__Evt, _History__Pub], scala.Serializable, typing.Generic[_History__Evt, _History__Pub]):
    serialVersionUID: typing.ClassVar[int] = ...
    def __init__(self): ...
    def clear(self) -> None: ...
    def equals(self, obj: typing.Any) -> bool: ...
    def events(self) -> scala.collection.Iterator[_History__Evt]: ...
    def hashCode(self) -> int: ...
    def iterator(self) -> scala.collection.Iterator[scala.Tuple2[_History__Pub, _History__Evt]]: ...
    def log(self) -> 'Queue'[scala.Tuple2[_History__Pub, _History__Evt]]: ...
    def maxHistory(self) -> int: ...
    @typing.overload
    def notify(self) -> None: ...
    @typing.overload
    def notify(self, pub: _History__Pub, event: _History__Evt) -> None: ...
    def size(self) -> int: ...

_IndexedSeq__A = typing.TypeVar('_IndexedSeq__A')  # <A>
class IndexedSeq(Seq[_IndexedSeq__A], scala.collection.IndexedSeq[_IndexedSeq__A], IndexedSeqLike[_IndexedSeq__A, 'IndexedSeq'[_IndexedSeq__A]], typing.Generic[_IndexedSeq__A]):
    @staticmethod
    def $init$($this: 'IndexedSeq') -> None: ...
    @staticmethod
    def ReusableCBF() -> scala.collection.generic.GenTraversableFactory.GenericCanBuildFrom[scala.runtime.Nothing.]: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['IndexedSeq'[typing.Any], _canBuildFrom__A, 'IndexedSeq'[_canBuildFrom__A]]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['IndexedSeq']: ...
    @staticmethod
    def concat(xss: scala.collection.Seq) -> scala.collection.GenTraversable: ...
    @staticmethod
    def empty() -> scala.collection.GenTraversable: ...
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, n5: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def iterate(start: typing.Any, len: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, step: typing.Any, evidence$2: scala.math.Integral) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, evidence$1: scala.math.Integral) -> scala.collection.GenTraversable: ...
    @typing.overload
    def seq(self) -> scala.collection.TraversableOnce[_IndexedSeq__A]: ...
    @typing.overload
    def seq(self) -> scala.collection.TraversableOnce[_IndexedSeq__A]: ...
    @typing.overload
    def seq(self) -> scala.collection.IndexedSeq[_IndexedSeq__A]: ...
    @typing.overload
    def seq(self) -> scala.collection.Iterable[_IndexedSeq__A]: ...
    @typing.overload
    def seq(self) -> scala.collection.Seq[_IndexedSeq__A]: ...
    @typing.overload
    def seq(self) -> scala.collection.Traversable[_IndexedSeq__A]: ...
    @typing.overload
    def seq(self) -> 'IndexedSeq'[_IndexedSeq__A]: ...
    @typing.overload
    def seq(self) -> Iterable[_IndexedSeq__A]: ...
    @typing.overload
    def seq(self) -> Seq[_IndexedSeq__A]: ...
    @typing.overload
    def seq(self) -> Traversable[_IndexedSeq__A]: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, n5: int, f: scala.Function5) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, f: scala.Function4) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, f: scala.Function3) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, f: scala.Function2) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self) -> str: ...
    @staticmethod
    def unapplySeq(x: scala.collection.Seq) -> scala.Some: ...

_LinearSeq__A = typing.TypeVar('_LinearSeq__A')  # <A>
class LinearSeq(Seq[_LinearSeq__A], scala.collection.LinearSeq[_LinearSeq__A], typing.Generic[_LinearSeq__A]):
    @staticmethod
    def $init$($this: 'LinearSeq') -> None: ...
    @staticmethod
    def ReusableCBF() -> scala.collection.generic.GenTraversableFactory.GenericCanBuildFrom[scala.runtime.Nothing.]: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['LinearSeq'[typing.Any], _canBuildFrom__A, 'LinearSeq'[_canBuildFrom__A]]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['LinearSeq']: ...
    @staticmethod
    def concat(xss: scala.collection.Seq) -> scala.collection.GenTraversable: ...
    @staticmethod
    def empty() -> scala.collection.GenTraversable: ...
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, n5: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def iterate(start: typing.Any, len: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, step: typing.Any, evidence$2: scala.math.Integral) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, evidence$1: scala.math.Integral) -> scala.collection.GenTraversable: ...
    @typing.overload
    def seq(self) -> scala.collection.TraversableOnce[_LinearSeq__A]: ...
    @typing.overload
    def seq(self) -> scala.collection.TraversableOnce[_LinearSeq__A]: ...
    @typing.overload
    def seq(self) -> scala.collection.Iterable[_LinearSeq__A]: ...
    @typing.overload
    def seq(self) -> scala.collection.LinearSeq[_LinearSeq__A]: ...
    @typing.overload
    def seq(self) -> scala.collection.Seq[_LinearSeq__A]: ...
    @typing.overload
    def seq(self) -> scala.collection.Traversable[_LinearSeq__A]: ...
    @typing.overload
    def seq(self) -> Iterable[_LinearSeq__A]: ...
    @typing.overload
    def seq(self) -> 'LinearSeq'[_LinearSeq__A]: ...
    @typing.overload
    def seq(self) -> Seq[_LinearSeq__A]: ...
    @typing.overload
    def seq(self) -> Traversable[_LinearSeq__A]: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, n5: int, f: scala.Function5) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, f: scala.Function4) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, f: scala.Function3) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, f: scala.Function2) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self) -> str: ...
    @staticmethod
    def unapplySeq(x: scala.collection.Seq) -> scala.Some: ...

_ObservableSet__A = typing.TypeVar('_ObservableSet__A')  # <A>
class ObservableSet(Set[_ObservableSet__A], Publisher[scala.collection.script.Message[_ObservableSet__A]], typing.Generic[_ObservableSet__A]):
    @staticmethod
    def $init$($this: 'ObservableSet') -> None: ...
    @typing.overload
    def $minus$eq(self, elem: _ObservableSet__A) -> scala.collection.generic.Shrinkable[_ObservableSet__A]: ...
    @typing.overload
    def $minus$eq(self, elem: _ObservableSet__A) -> SetLike[_ObservableSet__A, SetLike]: ...
    @typing.overload
    def $minus$eq(self, elem1: _ObservableSet__A, elem2: _ObservableSet__A, elems: scala.collection.Seq[_ObservableSet__A]) -> scala.collection.generic.Shrinkable[_ObservableSet__A]: ...
    @typing.overload
    def $minus$eq(self, elem: _ObservableSet__A) -> 'ObservableSet'[_ObservableSet__A]: ...
    @typing.overload
    def $plus$eq(self, elem: _ObservableSet__A) -> scala.collection.generic.Growable[_ObservableSet__A]: ...
    @typing.overload
    def $plus$eq(self, elem: typing.Any) -> Builder[typing.Any, typing.Any]: ...
    @typing.overload
    def $plus$eq(self, elem: _ObservableSet__A) -> SetLike[_ObservableSet__A, SetLike]: ...
    @typing.overload
    def $plus$eq(self, elem1: _ObservableSet__A, elem2: _ObservableSet__A, elems: scala.collection.Seq[_ObservableSet__A]) -> scala.collection.generic.Growable[_ObservableSet__A]: ...
    @typing.overload
    def $plus$eq(self, elem: _ObservableSet__A) -> 'ObservableSet'[_ObservableSet__A]: ...
    def clear(self) -> None: ...
    @typing.overload
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    def equals(self, obj: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...

_SetProxy__A = typing.TypeVar('_SetProxy__A')  # <A>
class SetProxy(Set[_SetProxy__A], scala.collection.SetProxyLike[_SetProxy__A, Set[_SetProxy__A]], typing.Generic[_SetProxy__A]):
    @staticmethod
    def $init$($this: 'SetProxy') -> None: ...
    @typing.overload
    def $minus(self, elem: _SetProxy__A) -> typing.Any: ...
    @typing.overload
    def $minus(self, elem: _SetProxy__A) -> scala.collection.generic.Subtractable: ...
    @typing.overload
    def $minus(self, elem: _SetProxy__A) -> scala.collection.SetLike: ...
    @typing.overload
    def $minus(self, elem1: _SetProxy__A, elem2: _SetProxy__A, elems: scala.collection.Seq[_SetProxy__A]) -> scala.collection.generic.Subtractable: ...
    @typing.overload
    def $minus(self, elem: _SetProxy__A) -> SetLike: ...
    @typing.overload
    def $minus(self, elem1: _SetProxy__A, elem2: _SetProxy__A, elems: scala.collection.Seq[_SetProxy__A]) -> SetLike: ...
    @typing.overload
    def $minus(self, elem: _SetProxy__A) -> 'SetProxy'[_SetProxy__A]: ...
    @typing.overload
    def $minus$eq(self, elem: _SetProxy__A) -> scala.collection.generic.Shrinkable[_SetProxy__A]: ...
    @typing.overload
    def $minus$eq(self, elem: _SetProxy__A) -> SetLike[_SetProxy__A, SetLike]: ...
    @typing.overload
    def $minus$eq(self, elem1: _SetProxy__A, elem2: _SetProxy__A, elems: scala.collection.Seq[_SetProxy__A]) -> scala.collection.generic.Shrinkable[_SetProxy__A]: ...
    @typing.overload
    def $minus$eq(self, elem: _SetProxy__A) -> 'SetProxy'[_SetProxy__A]: ...
    @typing.overload
    def $plus(self, elem: _SetProxy__A) -> typing.Any: ...
    @typing.overload
    def $plus(self, elem1: _SetProxy__A, elem2: _SetProxy__A, elems: scala.collection.Seq[_SetProxy__A]) -> scala.collection.SetLike: ...
    @typing.overload
    def $plus(self, elem: _SetProxy__A) -> scala.collection.SetLike: ...
    @typing.overload
    def $plus(self, elem: _SetProxy__A) -> SetLike: ...
    @typing.overload
    def $plus(self, elem1: _SetProxy__A, elem2: _SetProxy__A, elems: scala.collection.Seq[_SetProxy__A]) -> SetLike: ...
    @typing.overload
    def $plus(self, elem: _SetProxy__A) -> 'SetProxy'[_SetProxy__A]: ...
    @typing.overload
    def $plus$eq(self, elem: _SetProxy__A) -> scala.collection.generic.Growable[_SetProxy__A]: ...
    @typing.overload
    def $plus$eq(self, elem: typing.Any) -> Builder[typing.Any, typing.Any]: ...
    @typing.overload
    def $plus$eq(self, elem: _SetProxy__A) -> SetLike[_SetProxy__A, SetLike]: ...
    @typing.overload
    def $plus$eq(self, elem1: _SetProxy__A, elem2: _SetProxy__A, elems: scala.collection.Seq[_SetProxy__A]) -> scala.collection.generic.Growable[_SetProxy__A]: ...
    @typing.overload
    def $plus$eq(self, elem: _SetProxy__A) -> 'SetProxy'[_SetProxy__A]: ...
    @typing.overload
    def empty(self) -> scala.collection.SetLike: ...
    @typing.overload
    def empty(self) -> scala.collection.GenSet: ...
    @typing.overload
    def empty(self) -> 'SetProxy'[_SetProxy__A]: ...
    @typing.overload
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @typing.overload
    def repr(self) -> scala.collection.generic.Subtractable: ...
    @typing.overload
    def repr(self) -> typing.Any: ...
    @typing.overload
    def repr(self) -> 'SetProxy'[_SetProxy__A]: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self) -> str: ...

_SortedSet__A = typing.TypeVar('_SortedSet__A')  # <A>
class SortedSet(scala.collection.SortedSet[_SortedSet__A], Set[_SortedSet__A], typing.Generic[_SortedSet__A]):
    @staticmethod
    def $init$($this: 'SortedSet') -> None: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom(ord: scala.math.Ordering[_canBuildFrom__A]) -> scala.collection.generic.CanBuildFrom['SortedSet'[typing.Any], _canBuildFrom__A, 'SortedSet'[_canBuildFrom__A]]: ...
    @typing.overload
    def empty(self) -> scala.collection.SetLike: ...
    @typing.overload
    def empty(self) -> scala.collection.GenSet: ...
    @typing.overload
    def empty(self) -> scala.collection.SortedSet[_SortedSet__A]: ...
    @typing.overload
    def empty(self) -> 'SortedSet'[_SortedSet__A]: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    _newCanBuildFrom__A = typing.TypeVar('_newCanBuildFrom__A')  # <A>
    @staticmethod
    def newCanBuildFrom(ord: scala.math.Ordering[_newCanBuildFrom__A]) -> scala.collection.generic.CanBuildFrom['SortedSet'[typing.Any], _newCanBuildFrom__A, 'SortedSet'[_newCanBuildFrom__A]]: ...
    def toString(self) -> str: ...

_SynchronizedSet__A = typing.TypeVar('_SynchronizedSet__A')  # <A>
class SynchronizedSet(Set[_SynchronizedSet__A], typing.Generic[_SynchronizedSet__A]):
    @staticmethod
    def $init$($this: 'SynchronizedSet') -> None: ...
    def $less$less(self, cmd: scala.collection.script.Message[_SynchronizedSet__A]) -> None: ...
    @typing.overload
    def $minus$eq(self, elem: _SynchronizedSet__A) -> scala.collection.generic.Shrinkable[_SynchronizedSet__A]: ...
    @typing.overload
    def $minus$eq(self, elem: _SynchronizedSet__A) -> SetLike[_SynchronizedSet__A, SetLike]: ...
    @typing.overload
    def $minus$eq(self, elem1: _SynchronizedSet__A, elem2: _SynchronizedSet__A, elems: scala.collection.Seq[_SynchronizedSet__A]) -> scala.collection.generic.Shrinkable[_SynchronizedSet__A]: ...
    @typing.overload
    def $minus$eq(self, elem: _SynchronizedSet__A) -> 'SynchronizedSet'[_SynchronizedSet__A]: ...
    @typing.overload
    def $minus$minus$eq(self, xs: scala.collection.TraversableOnce[_SynchronizedSet__A]) -> scala.collection.generic.Shrinkable[_SynchronizedSet__A]: ...
    @typing.overload
    def $minus$minus$eq(self, xs: scala.collection.TraversableOnce[_SynchronizedSet__A]) -> 'SynchronizedSet'[_SynchronizedSet__A]: ...
    @typing.overload
    def $plus$eq(self, elem: _SynchronizedSet__A) -> scala.collection.generic.Growable[_SynchronizedSet__A]: ...
    @typing.overload
    def $plus$eq(self, elem: typing.Any) -> Builder[typing.Any, typing.Any]: ...
    @typing.overload
    def $plus$eq(self, elem: _SynchronizedSet__A) -> SetLike[_SynchronizedSet__A, SetLike]: ...
    @typing.overload
    def $plus$eq(self, elem1: _SynchronizedSet__A, elem2: _SynchronizedSet__A, elems: scala.collection.Seq[_SynchronizedSet__A]) -> scala.collection.generic.Growable[_SynchronizedSet__A]: ...
    @typing.overload
    def $plus$eq(self, elem: _SynchronizedSet__A) -> 'SynchronizedSet'[_SynchronizedSet__A]: ...
    @typing.overload
    def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[_SynchronizedSet__A]) -> scala.collection.generic.Growable[_SynchronizedSet__A]: ...
    @typing.overload
    def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[_SynchronizedSet__A]) -> 'SynchronizedSet'[_SynchronizedSet__A]: ...
    def add(self, elem: _SynchronizedSet__A) -> bool: ...
    def clear(self) -> None: ...
    @typing.overload
    def clone(self) -> _SynchronizedSet__A: ...
    @typing.overload
    def clone(self) -> Set[_SynchronizedSet__A]: ...
    def contains(self, elem: _SynchronizedSet__A) -> bool: ...
    def equals(self, that: typing.Any) -> bool: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_SynchronizedSet__A, _foreach__U]) -> None: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def intersect(self, that: scala.collection.GenSet[_SynchronizedSet__A]) -> typing.Any: ...
    @typing.overload
    def intersect(self, that: scala.collection.GenSet[_SynchronizedSet__A]) -> Set[_SynchronizedSet__A]: ...
    def isEmpty(self) -> bool: ...
    def remove(self, elem: _SynchronizedSet__A) -> bool: ...
    def retain(self, p: scala.Function1[_SynchronizedSet__A, typing.Any]) -> None: ...
    def size(self) -> int: ...
    def subsetOf(self, that: scala.collection.GenSet[_SynchronizedSet__A]) -> bool: ...
    def toList(self) -> scala.collection.immutable.List[_SynchronizedSet__A]: ...
    def toString(self) -> str: ...
    def update(self, elem: _SynchronizedSet__A, included: bool) -> None: ...

_AbstractBuffer__A = typing.TypeVar('_AbstractBuffer__A')  # <A>
class AbstractBuffer(AbstractSeq[_AbstractBuffer__A], Buffer[_AbstractBuffer__A], typing.Generic[_AbstractBuffer__A]):
    def __init__(self): ...
    def $less$less(self, cmd: scala.collection.script.Message[_AbstractBuffer__A]) -> None: ...
    @typing.overload
    def $minus(self, elem: _AbstractBuffer__A) -> Buffer[_AbstractBuffer__A]: ...
    @typing.overload
    def $minus(self, elem1: _AbstractBuffer__A, elem2: _AbstractBuffer__A, elems: scala.collection.Seq[_AbstractBuffer__A]) -> Buffer[_AbstractBuffer__A]: ...
    @typing.overload
    def $minus$eq(self, elem1: _AbstractBuffer__A, elem2: _AbstractBuffer__A, elems: scala.collection.Seq[_AbstractBuffer__A]) -> scala.collection.generic.Shrinkable[_AbstractBuffer__A]: ...
    @typing.overload
    def $minus$eq(self, x: typing.Any) -> Buffer: ...
    def $minus$minus(self, xs: scala.collection.GenTraversableOnce[_AbstractBuffer__A]) -> Buffer[_AbstractBuffer__A]: ...
    def $minus$minus$eq(self, xs: scala.collection.TraversableOnce[_AbstractBuffer__A]) -> scala.collection.generic.Shrinkable[_AbstractBuffer__A]: ...
    @typing.overload
    def $plus$eq(self, elem: _AbstractBuffer__A) -> scala.collection.generic.Growable[_AbstractBuffer__A]: ...
    @typing.overload
    def $plus$eq(self, elem: _AbstractBuffer__A) -> BufferLike: ...
    @typing.overload
    def $plus$eq(self, elem1: _AbstractBuffer__A, elem2: _AbstractBuffer__A, elems: scala.collection.Seq[_AbstractBuffer__A]) -> scala.collection.generic.Growable[_AbstractBuffer__A]: ...
    _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
    _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
    @typing.overload
    def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus_0__B], bf: scala.collection.generic.CanBuildFrom[scala.collection.Traversable[_AbstractBuffer__A], _.plus.plus_0__B, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
    @typing.overload
    def $plus$plus(self, xs: scala.collection.GenTraversableOnce[_AbstractBuffer__A]) -> Buffer[_AbstractBuffer__A]: ...
    def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[_AbstractBuffer__A]) -> scala.collection.generic.Growable[_AbstractBuffer__A]: ...
    def $plus$plus$eq$colon(self, xs: scala.collection.TraversableOnce) -> Buffer: ...
    def append(self, elems: scala.collection.Seq[_AbstractBuffer__A]) -> None: ...
    def appendAll(self, xs: scala.collection.TraversableOnce[_AbstractBuffer__A]) -> None: ...
    def clone(self) -> Buffer[_AbstractBuffer__A]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion[Buffer]: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[_AbstractBuffer__A, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[_AbstractBuffer__A]]: ...
    def insert(self, n: int, elems: scala.collection.Seq[_AbstractBuffer__A]) -> None: ...
    def isDefinedAt(self, idx: int) -> bool: ...
    def prepend(self, elems: scala.collection.Seq[_AbstractBuffer__A]) -> None: ...
    def prependAll(self, xs: scala.collection.TraversableOnce[_AbstractBuffer__A]) -> None: ...
    @typing.overload
    def remove(self, n: int) -> _AbstractBuffer__A: ...
    @typing.overload
    def remove(self, n: int, count: int) -> None: ...
    def repr(self) -> typing.Any: ...
    def seq(self) -> Seq[_AbstractBuffer__A]: ...
    def stringPrefix(self) -> str: ...
    def thisCollection(self) -> scala.collection.Seq[_AbstractBuffer__A]: ...
    def toCollection(self, repr: typing.Any) -> scala.collection.Seq: ...
    def toIterable(self) -> scala.collection.Iterable[_AbstractBuffer__A]: ...
    def toSeq(self) -> scala.collection.Seq[_AbstractBuffer__A]: ...
    def toTraversable(self) -> scala.collection.Traversable[_AbstractBuffer__A]: ...
    def trimEnd(self, n: int) -> None: ...
    def trimStart(self, n: int) -> None: ...
    @typing.overload
    def view(self) -> scala.collection.SeqView[_AbstractBuffer__A, scala.collection.Seq[_AbstractBuffer__A]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> scala.collection.SeqView[_AbstractBuffer__A, scala.collection.Seq[_AbstractBuffer__A]]: ...

_AbstractSortedSet__A = typing.TypeVar('_AbstractSortedSet__A')  # <A>
class AbstractSortedSet(AbstractSet[_AbstractSortedSet__A], SortedSet[_AbstractSortedSet__A], typing.Generic[_AbstractSortedSet__A]):
    def __init__(self): ...
    @typing.overload
    def $minus(self, elem: _AbstractSortedSet__A) -> Set[_AbstractSortedSet__A]: ...
    @typing.overload
    def $minus(self, elem1: _AbstractSortedSet__A, elem2: _AbstractSortedSet__A, elems: scala.collection.Seq[_AbstractSortedSet__A]) -> Set[_AbstractSortedSet__A]: ...
    def $minus$minus(self, xs: scala.collection.GenTraversableOnce[_AbstractSortedSet__A]) -> Set[_AbstractSortedSet__A]: ...
    @typing.overload
    def $plus(self, elem: _AbstractSortedSet__A) -> Set[_AbstractSortedSet__A]: ...
    @typing.overload
    def $plus(self, elem1: _AbstractSortedSet__A, elem2: _AbstractSortedSet__A, elems: scala.collection.Seq[_AbstractSortedSet__A]) -> Set[_AbstractSortedSet__A]: ...
    _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
    _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
    @typing.overload
    def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus_0__B], bf: scala.collection.generic.CanBuildFrom[scala.collection.Traversable[_AbstractSortedSet__A], _.plus.plus_0__B, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
    @typing.overload
    def $plus$plus(self, xs: scala.collection.GenTraversableOnce[_AbstractSortedSet__A]) -> Set[_AbstractSortedSet__A]: ...
    def apply(self, elem: _AbstractSortedSet__A) -> bool: ...
    def clone(self) -> Set[_AbstractSortedSet__A]: ...
    def compare(self, k0: _AbstractSortedSet__A, k1: _AbstractSortedSet__A) -> int: ...
    def diff(self, that: scala.collection.GenSet) -> scala.collection.Set: ...
    def empty(self) -> SortedSet[_AbstractSortedSet__A]: ...
    def firstKey(self) -> _AbstractSortedSet__A: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[_AbstractSortedSet__A, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[_AbstractSortedSet__A]]: ...
    def hasAll(self, j: scala.collection.Iterator[_AbstractSortedSet__A]) -> bool: ...
    def iteratorFrom(self, start: _AbstractSortedSet__A) -> scala.collection.Iterator[_AbstractSortedSet__A]: ...
    def keySet(self) -> scala.collection.SortedSet: ...
    def lastKey(self) -> _AbstractSortedSet__A: ...
    def range(self, from_: typing.Any, until: typing.Any) -> scala.collection.SortedSet: ...
    def repr(self) -> typing.Any: ...
    def result(self) -> Set[_AbstractSortedSet__A]: ...
    def seq(self) -> Set[_AbstractSortedSet__A]: ...
    def subsetOf(self, that: scala.collection.GenSet[_AbstractSortedSet__A]) -> bool: ...
    def thisCollection(self) -> scala.collection.Iterable[_AbstractSortedSet__A]: ...
    _to_0__Col = typing.TypeVar('_to_0__Col')  # <Col>
    @typing.overload
    def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., _AbstractSortedSet__A, _to_0__Col]) -> _to_0__Col: ...
    @typing.overload
    def to(self, to: typing.Any) -> scala.collection.generic.Sorted: ...
    def toCollection(self, repr: typing.Any) -> scala.collection.Iterable: ...
    def toIterable(self) -> scala.collection.Iterable[_AbstractSortedSet__A]: ...
    def toSeq(self) -> scala.collection.Seq[_AbstractSortedSet__A]: ...
    def toTraversable(self) -> scala.collection.Traversable[_AbstractSortedSet__A]: ...
    def union(self, that: scala.collection.GenSet) -> scala.collection.Set: ...
    def until(self, until: typing.Any) -> scala.collection.SortedSet: ...
    @typing.overload
    def view(self) -> scala.collection.IterableView[_AbstractSortedSet__A, scala.collection.Iterable[_AbstractSortedSet__A]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> scala.collection.IterableView[_AbstractSortedSet__A, scala.collection.Iterable[_AbstractSortedSet__A]]: ...

_ArraySeq__A = typing.TypeVar('_ArraySeq__A')  # <A>
class ArraySeq(AbstractSeq[_ArraySeq__A], IndexedSeq[_ArraySeq__A], IndexedSeqOptimized[_ArraySeq__A, 'ArraySeq'[_ArraySeq__A]], scala.collection.CustomParallelizable[_ArraySeq__A, scala.collection.parallel.mutable.ParArray[_ArraySeq__A]], scala.Serializable, typing.Generic[_ArraySeq__A]):
    serialVersionUID: typing.ClassVar[int] = ...
    def __init__(self, length: int): ...
    @staticmethod
    def ReusableCBF() -> scala.collection.generic.GenTraversableFactory.GenericCanBuildFrom[scala.runtime.Nothing.]: ...
    def apply(self, idx: int) -> _ArraySeq__A: ...
    def array(self) -> typing.List[typing.Any]: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['ArraySeq'[typing.Any], _canBuildFrom__A, 'ArraySeq'[_canBuildFrom__A]]: ...
    def clone(self) -> 'ArraySeq'[_ArraySeq__A]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['ArraySeq']: ...
    @staticmethod
    def concat(xss: scala.collection.Seq) -> scala.collection.GenTraversable: ...
    _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
    _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
    _copyToArray_2__B = typing.TypeVar('_copyToArray_2__B')  # <B>
    @typing.overload
    def copyToArray(self, xs: typing.Any) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
    def drop(self, n: int) -> typing.Any: ...
    def dropRight(self, n: int) -> typing.Any: ...
    def dropWhile(self, p: scala.Function1) -> typing.Any: ...
    @staticmethod
    def empty() -> scala.collection.GenTraversable: ...
    _endsWith__B = typing.TypeVar('_endsWith__B')  # <B>
    def endsWith(self, that: scala.collection.GenSeq[_endsWith__B]) -> bool: ...
    def exists(self, p: scala.Function1[_ArraySeq__A, typing.Any]) -> bool: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, n5: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    def find(self, p: scala.Function1[_ArraySeq__A, typing.Any]) -> scala.Option[_ArraySeq__A]: ...
    _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
    def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, _ArraySeq__A, _foldLeft__B]) -> _foldLeft__B: ...
    _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
    def foldRight(self, z: _foldRight__B, op: scala.Function2[_ArraySeq__A, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
    def forall(self, p: scala.Function1[_ArraySeq__A, typing.Any]) -> bool: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_ArraySeq__A, _foreach__U]) -> None: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[_ArraySeq__A, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[_ArraySeq__A]]: ...
    def hashCode(self) -> int: ...
    def head(self) -> _ArraySeq__A: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[_ArraySeq__A, typing.Any]) -> int: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[_ArraySeq__A, typing.Any], from_: int) -> int: ...
    def init(self) -> typing.Any: ...
    def isDefinedAt(self, idx: int) -> bool: ...
    def isEmpty(self) -> bool: ...
    @staticmethod
    def iterate(start: typing.Any, len: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    def iterator(self) -> scala.collection.Iterator[_ArraySeq__A]: ...
    def last(self) -> _ArraySeq__A: ...
    @typing.overload
    def lastIndexWhere(self, p: scala.Function1[_ArraySeq__A, typing.Any]) -> int: ...
    @typing.overload
    def lastIndexWhere(self, p: scala.Function1[_ArraySeq__A, typing.Any], end: int) -> int: ...
    def length(self) -> int: ...
    def lengthCompare(self, len: int) -> int: ...
    def par(self) -> scala.collection.parallel.mutable.ParArray[_ArraySeq__A]: ...
    def parCombiner(self) -> scala.collection.parallel.Combiner[_ArraySeq__A, scala.collection.parallel.mutable.ParArray[_ArraySeq__A]]: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, step: typing.Any, evidence$2: scala.math.Integral) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, evidence$1: scala.math.Integral) -> scala.collection.GenTraversable: ...
    _reduceLeft__B = typing.TypeVar('_reduceLeft__B')  # <B>
    def reduceLeft(self, op: scala.Function2[_reduceLeft__B, _ArraySeq__A, _reduceLeft__B]) -> _reduceLeft__B: ...
    _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
    def reduceRight(self, op: scala.Function2[_ArraySeq__A, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
    def reverse(self) -> typing.Any: ...
    def reverseIterator(self) -> scala.collection.Iterator[_ArraySeq__A]: ...
    _sameElements__B = typing.TypeVar('_sameElements__B')  # <B>
    def sameElements(self, that: scala.collection.GenIterable[_sameElements__B]) -> bool: ...
    def segmentLength(self, p: scala.Function1[_ArraySeq__A, typing.Any], from_: int) -> int: ...
    def seq(self) -> IndexedSeq[_ArraySeq__A]: ...
    def sizeHintIfCheap(self) -> int: ...
    def slice(self, from_: int, until: int) -> typing.Any: ...
    def span(self, p: scala.Function1[_ArraySeq__A, typing.Any]) -> scala.Tuple2['ArraySeq'[_ArraySeq__A], 'ArraySeq'[_ArraySeq__A]]: ...
    def splitAt(self, n: int) -> scala.Tuple2['ArraySeq'[_ArraySeq__A], 'ArraySeq'[_ArraySeq__A]]: ...
    _startsWith_0__B = typing.TypeVar('_startsWith_0__B')  # <B>
    _startsWith_1__B = typing.TypeVar('_startsWith_1__B')  # <B>
    @typing.overload
    def startsWith(self, that: scala.collection.GenSeq[_startsWith_0__B]) -> bool: ...
    @typing.overload
    def startsWith(self, that: scala.collection.GenSeq[_startsWith_1__B], offset: int) -> bool: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, n5: int, f: scala.Function5) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, f: scala.Function4) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, f: scala.Function3) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, f: scala.Function2) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    def tail(self) -> typing.Any: ...
    def take(self, n: int) -> typing.Any: ...
    def takeRight(self, n: int) -> typing.Any: ...
    def takeWhile(self, p: scala.Function1) -> typing.Any: ...
    def thisCollection(self) -> IndexedSeq[_ArraySeq__A]: ...
    _toBuffer__A1 = typing.TypeVar('_toBuffer__A1')  # <A1>
    def toBuffer(self) -> Buffer[_toBuffer__A1]: ...
    def toCollection(self, repr: typing.Any) -> IndexedSeq: ...
    def toIterable(self) -> scala.collection.Iterable[_ArraySeq__A]: ...
    def toList(self) -> scala.collection.immutable.List[_ArraySeq__A]: ...
    def toSeq(self) -> scala.collection.Seq[_ArraySeq__A]: ...
    def toTraversable(self) -> scala.collection.Traversable[_ArraySeq__A]: ...
    @staticmethod
    def unapplySeq(x: scala.collection.Seq) -> scala.Some: ...
    def update(self, idx: int, elem: _ArraySeq__A) -> None: ...
    @typing.overload
    def view(self) -> 'IndexedSeqView'[_ArraySeq__A, 'ArraySeq'[_ArraySeq__A]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> 'IndexedSeqView'[_ArraySeq__A, 'ArraySeq'[_ArraySeq__A]]: ...
    _zip__A1 = typing.TypeVar('_zip__A1')  # <A1>
    _zip__B = typing.TypeVar('_zip__B')  # <B>
    _zip__That = typing.TypeVar('_zip__That')  # <That>
    def zip(self, that: scala.collection.GenIterable[_zip__B], bf: scala.collection.generic.CanBuildFrom['ArraySeq'[_ArraySeq__A], scala.Tuple2[_zip__A1, _zip__B], _zip__That]) -> _zip__That: ...
    _zipWithIndex__A1 = typing.TypeVar('_zipWithIndex__A1')  # <A1>
    _zipWithIndex__That = typing.TypeVar('_zipWithIndex__That')  # <That>
    def zipWithIndex(self, bf: scala.collection.generic.CanBuildFrom['ArraySeq'[_ArraySeq__A], scala.Tuple2[_zipWithIndex__A1, typing.Any], _zipWithIndex__That]) -> _zipWithIndex__That: ...

_ArrayStack__T = typing.TypeVar('_ArrayStack__T')  # <T>
class ArrayStack(AbstractSeq[_ArrayStack__T], IndexedSeq[_ArrayStack__T], IndexedSeqOptimized[_ArrayStack__T, 'ArrayStack'[_ArrayStack__T]], Builder[_ArrayStack__T, 'ArrayStack'[_ArrayStack__T]], scala.Serializable, typing.Generic[_ArrayStack__T]):
    serialVersionUID: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, table: typing.List[typing.Any], index: int): ...
    @typing.overload
    def $plus$eq(self, elem1: _ArrayStack__T, elem2: _ArrayStack__T, elems: scala.collection.Seq[_ArrayStack__T]) -> scala.collection.generic.Growable[_ArrayStack__T]: ...
    @typing.overload
    def $plus$eq(self, x: _ArrayStack__T) -> 'ArrayStack'[_ArrayStack__T]: ...
    def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[_ArrayStack__T]) -> 'ArrayStack'[_ArrayStack__T]: ...
    @staticmethod
    def ReusableCBF() -> scala.collection.generic.GenTraversableFactory.GenericCanBuildFrom[scala.runtime.Nothing.]: ...
    def apply(self, n: int) -> _ArrayStack__T: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['ArrayStack'[typing.Any], _canBuildFrom__A, 'ArrayStack'[_canBuildFrom__A]]: ...
    def clear(self) -> None: ...
    def clone(self) -> 'ArrayStack'[_ArrayStack__T]: ...
    def combine(self, f: scala.Function2[_ArrayStack__T, _ArrayStack__T, _ArrayStack__T]) -> None: ...
    def companion(self) -> 'ArrayStack.': ...
    @staticmethod
    def concat(xss: scala.collection.Seq) -> scala.collection.GenTraversable: ...
    _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
    _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
    _copyToArray_2__B = typing.TypeVar('_copyToArray_2__B')  # <B>
    @typing.overload
    def copyToArray(self, xs: typing.Any) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
    def drain(self, f: scala.Function1[_ArrayStack__T, scala.runtime.BoxedUnit]) -> None: ...
    def drop(self, n: int) -> typing.Any: ...
    def dropRight(self, n: int) -> typing.Any: ...
    def dropWhile(self, p: scala.Function1) -> typing.Any: ...
    def dup(self) -> None: ...
    @typing.overload
    @staticmethod
    def empty() -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def empty() -> 'ArrayStack'[scala.runtime.Nothing.]: ...
    _endsWith__B = typing.TypeVar('_endsWith__B')  # <B>
    def endsWith(self, that: scala.collection.GenSeq[_endsWith__B]) -> bool: ...
    def exists(self, p: scala.Function1[_ArrayStack__T, typing.Any]) -> bool: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, n5: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    def find(self, p: scala.Function1[_ArrayStack__T, typing.Any]) -> scala.Option[_ArrayStack__T]: ...
    _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
    def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, _ArrayStack__T, _foldLeft__B]) -> _foldLeft__B: ...
    _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
    def foldRight(self, z: _foldRight__B, op: scala.Function2[_ArrayStack__T, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
    def forall(self, p: scala.Function1[_ArrayStack__T, typing.Any]) -> bool: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_ArrayStack__T, _foreach__U]) -> None: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[typing.Any, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[typing.Any]]: ...
    def hashCode(self) -> int: ...
    def head(self) -> _ArrayStack__T: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[_ArrayStack__T, typing.Any], from_: int) -> int: ...
    def init(self) -> typing.Any: ...
    def isDefinedAt(self, idx: int) -> bool: ...
    def isEmpty(self) -> bool: ...
    @staticmethod
    def iterate(start: typing.Any, len: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    def iterator(self) -> scala.collection.Iterator[_ArrayStack__T]: ...
    def last(self) -> _ArrayStack__T: ...
    @typing.overload
    def lastIndexWhere(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
    @typing.overload
    def lastIndexWhere(self, p: scala.Function1[_ArrayStack__T, typing.Any], end: int) -> int: ...
    def length(self) -> int: ...
    def lengthCompare(self, len: int) -> int: ...
    _mapResult__NewTo = typing.TypeVar('_mapResult__NewTo')  # <NewTo>
    def mapResult(self, f: scala.Function1['ArrayStack'[_ArrayStack__T], _mapResult__NewTo]) -> Builder[_ArrayStack__T, _mapResult__NewTo]: ...
    def pop(self) -> _ArrayStack__T: ...
    _preserving__T = typing.TypeVar('_preserving__T')  # <T>
    def preserving(self, action: scala.Function0[typing.Any]) -> typing.Any: ...
    def push(self, x: _ArrayStack__T) -> None: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, step: typing.Any, evidence$2: scala.math.Integral) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, evidence$1: scala.math.Integral) -> scala.collection.GenTraversable: ...
    _reduceLeft__B = typing.TypeVar('_reduceLeft__B')  # <B>
    def reduceLeft(self, op: scala.Function2[_reduceLeft__B, _ArrayStack__T, _reduceLeft__B]) -> _reduceLeft__B: ...
    _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
    def reduceRight(self, op: scala.Function2[_ArrayStack__T, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
    def reduceWith(self, f: scala.Function2[_ArrayStack__T, _ArrayStack__T, _ArrayStack__T]) -> None: ...
    def result(self) -> 'ArrayStack'[_ArrayStack__T]: ...
    def reverse(self) -> typing.Any: ...
    def reverseIterator(self) -> scala.collection.Iterator[_ArrayStack__T]: ...
    _sameElements__B = typing.TypeVar('_sameElements__B')  # <B>
    def sameElements(self, that: scala.collection.GenIterable[_sameElements__B]) -> bool: ...
    def scala$collection$mutable$ArrayStack$$index(self) -> int: ...
    def scala$collection$mutable$ArrayStack$$table(self) -> typing.List[typing.Any]: ...
    def segmentLength(self, p: scala.Function1[_ArrayStack__T, typing.Any], from_: int) -> int: ...
    def seq(self) -> IndexedSeq[_ArrayStack__T]: ...
    def size(self) -> int: ...
    @typing.overload
    def sizeHint(self, size: int) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any], delta: int) -> None: ...
    def sizeHintBounded(self, size: int, boundingColl: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
    def sizeHintIfCheap(self) -> int: ...
    def slice(self, from_: int, until: int) -> typing.Any: ...
    def span(self, p: scala.Function1[_ArrayStack__T, typing.Any]) -> scala.Tuple2['ArrayStack'[_ArrayStack__T], 'ArrayStack'[_ArrayStack__T]]: ...
    def splitAt(self, n: int) -> scala.Tuple2['ArrayStack'[_ArrayStack__T], 'ArrayStack'[_ArrayStack__T]]: ...
    _startsWith_0__B = typing.TypeVar('_startsWith_0__B')  # <B>
    _startsWith_1__B = typing.TypeVar('_startsWith_1__B')  # <B>
    @typing.overload
    def startsWith(self, that: scala.collection.GenSeq[_startsWith_0__B]) -> bool: ...
    @typing.overload
    def startsWith(self, that: scala.collection.GenSeq[_startsWith_1__B], offset: int) -> bool: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, n5: int, f: scala.Function5) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, f: scala.Function4) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, f: scala.Function3) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, f: scala.Function2) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    def tail(self) -> typing.Any: ...
    def take(self, n: int) -> typing.Any: ...
    def takeRight(self, n: int) -> typing.Any: ...
    def takeWhile(self, p: scala.Function1) -> typing.Any: ...
    def thisCollection(self) -> IndexedSeq[_ArrayStack__T]: ...
    _toBuffer__A1 = typing.TypeVar('_toBuffer__A1')  # <A1>
    def toBuffer(self) -> Buffer[_toBuffer__A1]: ...
    def toCollection(self, repr: typing.Any) -> IndexedSeq: ...
    def toIterable(self) -> scala.collection.Iterable[typing.Any]: ...
    def toList(self) -> scala.collection.immutable.List[_ArrayStack__T]: ...
    def toSeq(self) -> scala.collection.Seq[typing.Any]: ...
    def toTraversable(self) -> scala.collection.Traversable[typing.Any]: ...
    def top(self) -> _ArrayStack__T: ...
    @staticmethod
    def unapplySeq(x: scala.collection.Seq) -> scala.Some: ...
    def update(self, n: int, newelem: _ArrayStack__T) -> None: ...
    @typing.overload
    def view(self) -> 'IndexedSeqView'[_ArrayStack__T, 'ArrayStack'[_ArrayStack__T]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> 'IndexedSeqView'[_ArrayStack__T, 'ArrayStack'[_ArrayStack__T]]: ...
    _zip__A1 = typing.TypeVar('_zip__A1')  # <A1>
    _zip__B = typing.TypeVar('_zip__B')  # <B>
    _zip__That = typing.TypeVar('_zip__That')  # <That>
    def zip(self, that: scala.collection.GenIterable[_zip__B], bf: scala.collection.generic.CanBuildFrom['ArrayStack'[_ArrayStack__T], scala.Tuple2[_zip__A1, _zip__B], _zip__That]) -> _zip__That: ...
    _zipWithIndex__A1 = typing.TypeVar('_zipWithIndex__A1')  # <A1>
    _zipWithIndex__That = typing.TypeVar('_zipWithIndex__That')  # <That>
    def zipWithIndex(self, bf: scala.collection.generic.CanBuildFrom['ArrayStack'[_ArrayStack__T], scala.Tuple2[_zipWithIndex__A1, typing.Any], _zipWithIndex__That]) -> _zipWithIndex__That: ...
    class : ...

class BitSet(AbstractSet[typing.Any], SortedSet[typing.Any], scala.collection.BitSet, scala.Serializable):
    serialVersionUID: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, initSize: int): ...
    @typing.overload
    def __init__(self, elems: typing.List[int]): ...
    @typing.overload
    def $amp(self, that: scala.collection.GenSet) -> typing.Any: ...
    @typing.overload
    def $amp(self, other: scala.collection.BitSet) -> scala.collection.BitSetLike: ...
    def $amp$eq(self, other: 'BitSet') -> 'BitSet': ...
    @typing.overload
    def $amp$tilde(self, that: scala.collection.GenSet) -> typing.Any: ...
    @typing.overload
    def $amp$tilde(self, other: scala.collection.BitSet) -> scala.collection.BitSetLike: ...
    def $amp$tilde$eq(self, other: 'BitSet') -> 'BitSet': ...
    @typing.overload
    def $bar(self, that: scala.collection.GenSet) -> typing.Any: ...
    @typing.overload
    def $bar(self, other: scala.collection.BitSet) -> scala.collection.BitSetLike: ...
    def $bar$eq(self, other: 'BitSet') -> 'BitSet': ...
    @typing.overload
    def $minus(self, elem: typing.Any) -> Set[typing.Any]: ...
    @typing.overload
    def $minus(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> Set[typing.Any]: ...
    @typing.overload
    def $minus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> scala.collection.generic.Shrinkable[typing.Any]: ...
    @typing.overload
    def $minus$eq(self, elem: int) -> 'BitSet': ...
    def $minus$minus(self, xs: scala.collection.GenTraversableOnce[typing.Any]) -> Set[typing.Any]: ...
    @typing.overload
    def $plus(self, elem: typing.Any) -> Set[typing.Any]: ...
    @typing.overload
    def $plus(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> Set[typing.Any]: ...
    @typing.overload
    def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> scala.collection.generic.Growable[typing.Any]: ...
    @typing.overload
    def $plus$eq(self, elem: int) -> 'BitSet': ...
    _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
    _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
    @typing.overload
    def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus_0__B], bf: scala.collection.generic.CanBuildFrom[scala.collection.Traversable[typing.Any], _.plus.plus_0__B, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
    @typing.overload
    def $plus$plus(self, xs: scala.collection.GenTraversableOnce[typing.Any]) -> Set[typing.Any]: ...
    def $up(self, other: scala.collection.BitSet) -> scala.collection.BitSetLike: ...
    def $up$eq(self, other: 'BitSet') -> 'BitSet': ...
    def add(self, elem: int) -> bool: ...
    @typing.overload
    def addString(self, b: 'StringBuilder') -> 'StringBuilder': ...
    @typing.overload
    def addString(self, b: 'StringBuilder', sep: str) -> 'StringBuilder': ...
    @typing.overload
    def addString(self, sb: 'StringBuilder', start: str, sep: str, end: str) -> 'StringBuilder': ...
    def apply(self, elem: typing.Any) -> bool: ...
    @staticmethod
    def bitsetCanBuildFrom() -> scala.collection.generic.CanBuildFrom['BitSet', typing.Any, 'BitSet']: ...
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['BitSet', typing.Any, 'BitSet']: ...
    def clear(self) -> None: ...
    def clone(self) -> 'BitSet': ...
    def compare(self, k0: typing.Any, k1: typing.Any) -> int: ...
    def contains(self, elem: int) -> bool: ...
    def diff(self, that: scala.collection.GenSet) -> scala.collection.Set: ...
    def elems(self) -> typing.List[int]: ...
    def elems_$eq(self, x$1: typing.List[int]) -> None: ...
    def empty(self) -> 'BitSet': ...
    def ensureCapacity(self, idx: int) -> None: ...
    def firstKey(self) -> typing.Any: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[typing.Any, _foreach__U]) -> None: ...
    @staticmethod
    def fromBitMask(elems: typing.List[int]) -> 'BitSet': ...
    def fromBitMaskNoCopy(self, words: typing.List[int]) -> 'BitSet': ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[typing.Any, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[typing.Any]]: ...
    def hasAll(self, j: scala.collection.Iterator[typing.Any]) -> bool: ...
    def head(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def iteratorFrom(self, start: typing.Any) -> scala.collection.Iterator: ...
    def keySet(self) -> scala.collection.SortedSet: ...
    def keysIteratorFrom(self, start: int) -> scala.collection.AbstractIterator[typing.Any]: ...
    def last(self) -> int: ...
    def lastKey(self) -> typing.Any: ...
    def nwords(self) -> int: ...
    def ordering(self) -> scala.math.Ordering[typing.Any]: ...
    def range(self, from_: typing.Any, until: typing.Any) -> scala.collection.SortedSet: ...
    def rangeImpl(self, from_: scala.Option, until: scala.Option) -> scala.collection.BitSetLike: ...
    def remove(self, elem: int) -> bool: ...
    def repr(self) -> typing.Any: ...
    def result(self) -> Set[typing.Any]: ...
    def seq(self) -> Set[typing.Any]: ...
    def size(self) -> int: ...
    def stringPrefix(self) -> str: ...
    @typing.overload
    def subsetOf(self, other: scala.collection.BitSet) -> bool: ...
    @typing.overload
    def subsetOf(self, that: scala.collection.GenSet[typing.Any]) -> bool: ...
    def thisCollection(self) -> scala.collection.Iterable[typing.Any]: ...
    _to_0__Col = typing.TypeVar('_to_0__Col')  # <Col>
    @typing.overload
    def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., typing.Any, _to_0__Col]) -> _to_0__Col: ...
    @typing.overload
    def to(self, to: typing.Any) -> scala.collection.generic.Sorted: ...
    def toBitMask(self) -> typing.List[int]: ...
    def toCollection(self, repr: typing.Any) -> scala.collection.Iterable: ...
    def toImmutable(self) -> scala.collection.immutable.BitSet: ...
    def toIterable(self) -> scala.collection.Iterable[typing.Any]: ...
    def toSeq(self) -> scala.collection.Seq[typing.Any]: ...
    def toTraversable(self) -> scala.collection.Traversable[typing.Any]: ...
    def union(self, that: scala.collection.GenSet) -> scala.collection.Set: ...
    def until(self, until: typing.Any) -> scala.collection.SortedSet: ...
    def updateWord(self, idx: int, w: int) -> None: ...
    @typing.overload
    def view(self) -> scala.collection.IterableView[typing.Any, scala.collection.Iterable[typing.Any]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> scala.collection.IterableView[typing.Any, scala.collection.Iterable[typing.Any]]: ...
    def word(self, idx: int) -> int: ...

_BufferProxy__A = typing.TypeVar('_BufferProxy__A')  # <A>
class BufferProxy(Buffer[_BufferProxy__A], scala.Proxy, typing.Generic[_BufferProxy__A]):
    @staticmethod
    def $init$($this: 'BufferProxy') -> None: ...
    def $less$less(self, cmd: scala.collection.script.Message[_BufferProxy__A]) -> None: ...
    @typing.overload
    def $plus$eq(self, elem: _BufferProxy__A) -> scala.collection.generic.Growable[_BufferProxy__A]: ...
    @typing.overload
    def $plus$eq(self, elem: _BufferProxy__A) -> BufferLike: ...
    @typing.overload
    def $plus$eq(self, elem1: _BufferProxy__A, elem2: _BufferProxy__A, elems: scala.collection.Seq[_BufferProxy__A]) -> scala.collection.generic.Growable[_BufferProxy__A]: ...
    @typing.overload
    def $plus$eq(self, elem: _BufferProxy__A) -> 'BufferProxy'[_BufferProxy__A]: ...
    @typing.overload
    def $plus$eq$colon(self, elem: _BufferProxy__A) -> BufferLike: ...
    @typing.overload
    def $plus$eq$colon(self, elem: _BufferProxy__A) -> 'BufferProxy'[_BufferProxy__A]: ...
    @typing.overload
    def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[_BufferProxy__A]) -> scala.collection.generic.Growable[_BufferProxy__A]: ...
    @typing.overload
    def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[_BufferProxy__A]) -> 'BufferProxy'[_BufferProxy__A]: ...
    @typing.overload
    def $plus$plus$eq$colon(self, xs: scala.collection.TraversableOnce[_BufferProxy__A]) -> BufferLike: ...
    @typing.overload
    def $plus$plus$eq$colon(self, xs: scala.collection.TraversableOnce[_BufferProxy__A]) -> 'BufferProxy'[_BufferProxy__A]: ...
    def append(self, elems: scala.collection.Seq[_BufferProxy__A]) -> None: ...
    def appendAll(self, xs: scala.collection.TraversableOnce[_BufferProxy__A]) -> None: ...
    @typing.overload
    def apply(self, v1: typing.Any) -> typing.Any: ...
    @typing.overload
    def apply(self, n: int) -> _BufferProxy__A: ...
    def clear(self) -> None: ...
    @typing.overload
    def clone(self) -> _BufferProxy__A: ...
    @typing.overload
    def clone(self) -> Buffer[_BufferProxy__A]: ...
    @typing.overload
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @typing.overload
    def hashCode(self) -> int: ...
    def insert(self, n: int, elems: scala.collection.Seq[_BufferProxy__A]) -> None: ...
    @typing.overload
    def insertAll(self, n: int, iter: scala.collection.Iterable[_BufferProxy__A]) -> None: ...
    @typing.overload
    def insertAll(self, n: int, iter: scala.collection.Traversable[_BufferProxy__A]) -> None: ...
    def iterator(self) -> scala.collection.Iterator[_BufferProxy__A]: ...
    def length(self) -> int: ...
    def prepend(self, elems: scala.collection.Seq[_BufferProxy__A]) -> None: ...
    def prependAll(self, xs: scala.collection.TraversableOnce[_BufferProxy__A]) -> None: ...
    @typing.overload
    def remove(self, n: int) -> _BufferProxy__A: ...
    @typing.overload
    def remove(self, n: int, count: int) -> None: ...
    @typing.overload
    def self(self) -> typing.Any: ...
    @typing.overload
    def self(self) -> Buffer[_BufferProxy__A]: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self) -> str: ...
    def update(self, n: int, newelem: _BufferProxy__A) -> None: ...

_DoubleLinkedList__A = typing.TypeVar('_DoubleLinkedList__A')  # <A>
class DoubleLinkedList(AbstractSeq[_DoubleLinkedList__A], LinearSeq[_DoubleLinkedList__A], DoubleLinkedListLike[_DoubleLinkedList__A, 'DoubleLinkedList'[_DoubleLinkedList__A]], scala.Serializable, typing.Generic[_DoubleLinkedList__A]):
    serialVersionUID: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, elem: _DoubleLinkedList__A, next: 'DoubleLinkedList'[_DoubleLinkedList__A]): ...
    @staticmethod
    def ReusableCBF() -> scala.collection.generic.GenTraversableFactory.GenericCanBuildFrom[scala.runtime.Nothing.]: ...
    def append(self, that: Seq) -> Seq: ...
    def apply(self, n: int) -> _DoubleLinkedList__A: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['DoubleLinkedList'[typing.Any], _canBuildFrom__A, 'DoubleLinkedList'[_canBuildFrom__A]]: ...
    def clone(self) -> 'DoubleLinkedList'[_DoubleLinkedList__A]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['DoubleLinkedList']: ...
    @staticmethod
    def concat(xss: scala.collection.Seq) -> scala.collection.GenTraversable: ...
    _corresponds__B = typing.TypeVar('_corresponds__B')  # <B>
    def corresponds(self, that: scala.collection.GenSeq[_corresponds__B], p: scala.Function2[_DoubleLinkedList__A, _corresponds__B, typing.Any]) -> bool: ...
    def drop(self, n: int) -> Seq: ...
    def elem(self) -> _DoubleLinkedList__A: ...
    def elem_$eq(self, x$1: _DoubleLinkedList__A) -> None: ...
    @staticmethod
    def empty() -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, n5: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_DoubleLinkedList__A, _foreach__U]) -> None: ...
    def get(self, n: int) -> scala.Option[_DoubleLinkedList__A]: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[_DoubleLinkedList__A, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[_DoubleLinkedList__A]]: ...
    def hashCode(self) -> int: ...
    def head(self) -> _DoubleLinkedList__A: ...
    def insert(self, that: Seq) -> None: ...
    def isDefinedAt(self, idx: int) -> bool: ...
    def isEmpty(self) -> bool: ...
    @staticmethod
    def iterate(start: typing.Any, len: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    def iterator(self) -> scala.collection.Iterator[_DoubleLinkedList__A]: ...
    def length(self) -> int: ...
    def next(self) -> 'DoubleLinkedList'[_DoubleLinkedList__A]: ...
    def next_$eq(self, x$1: 'DoubleLinkedList'[_DoubleLinkedList__A]) -> None: ...
    def prev(self) -> 'DoubleLinkedList'[_DoubleLinkedList__A]: ...
    def prev_$eq(self, x$1: 'DoubleLinkedList'[_DoubleLinkedList__A]) -> None: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, step: typing.Any, evidence$2: scala.math.Integral) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, evidence$1: scala.math.Integral) -> scala.collection.GenTraversable: ...
    def remove(self) -> None: ...
    def seq(self) -> LinearSeq[_DoubleLinkedList__A]: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, n5: int, f: scala.Function5) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, f: scala.Function4) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, f: scala.Function3) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, f: scala.Function2) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    def tail(self) -> Seq: ...
    def thisCollection(self) -> scala.collection.LinearSeq[_DoubleLinkedList__A]: ...
    @typing.overload
    def toCollection(self, repr: scala.collection.LinearSeqLike) -> scala.collection.LinearSeq: ...
    @typing.overload
    def toCollection(self, repr: typing.Any) -> scala.collection.Seq: ...
    def toIterable(self) -> scala.collection.Iterable[_DoubleLinkedList__A]: ...
    def toSeq(self) -> scala.collection.Seq[_DoubleLinkedList__A]: ...
    def toTraversable(self) -> scala.collection.Traversable[_DoubleLinkedList__A]: ...
    @staticmethod
    def unapplySeq(x: scala.collection.Seq) -> scala.Some: ...
    def update(self, n: int, x: _DoubleLinkedList__A) -> None: ...
    @typing.overload
    def view(self) -> scala.collection.SeqView[_DoubleLinkedList__A, scala.collection.Seq[_DoubleLinkedList__A]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> scala.collection.SeqView[_DoubleLinkedList__A, scala.collection.Seq[_DoubleLinkedList__A]]: ...

_ImmutableSetAdaptor__A = typing.TypeVar('_ImmutableSetAdaptor__A')  # <A>
class ImmutableSetAdaptor(AbstractSet[_ImmutableSetAdaptor__A], scala.Serializable, typing.Generic[_ImmutableSetAdaptor__A]):
    def __init__(self, set: scala.collection.immutable.Set[_ImmutableSetAdaptor__A]): ...
    @typing.overload
    def $minus$eq(self, elem1: _ImmutableSetAdaptor__A, elem2: _ImmutableSetAdaptor__A, elems: scala.collection.Seq[_ImmutableSetAdaptor__A]) -> scala.collection.generic.Shrinkable[_ImmutableSetAdaptor__A]: ...
    @typing.overload
    def $minus$eq(self, elem: _ImmutableSetAdaptor__A) -> 'ImmutableSetAdaptor'[_ImmutableSetAdaptor__A]: ...
    @typing.overload
    def $plus$eq(self, elem1: _ImmutableSetAdaptor__A, elem2: _ImmutableSetAdaptor__A, elems: scala.collection.Seq[_ImmutableSetAdaptor__A]) -> scala.collection.generic.Growable[_ImmutableSetAdaptor__A]: ...
    @typing.overload
    def $plus$eq(self, elem: _ImmutableSetAdaptor__A) -> 'ImmutableSetAdaptor'[_ImmutableSetAdaptor__A]: ...
    def clear(self) -> None: ...
    def contains(self, elem: _ImmutableSetAdaptor__A) -> bool: ...
    def exists(self, p: scala.Function1[_ImmutableSetAdaptor__A, typing.Any]) -> bool: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_ImmutableSetAdaptor__A, _foreach__U]) -> None: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> scala.collection.Iterator[_ImmutableSetAdaptor__A]: ...
    def set(self) -> scala.collection.immutable.Set[_ImmutableSetAdaptor__A]: ...
    def set_$eq(self, x$1: scala.collection.immutable.Set[_ImmutableSetAdaptor__A]) -> None: ...
    def size(self) -> int: ...
    def toList(self) -> scala.collection.immutable.List[_ImmutableSetAdaptor__A]: ...
    def toString(self) -> str: ...

_LinkedList__A = typing.TypeVar('_LinkedList__A')  # <A>
class LinkedList(AbstractSeq[_LinkedList__A], LinearSeq[_LinkedList__A], LinkedListLike[_LinkedList__A, 'LinkedList'[_LinkedList__A]], scala.Serializable, typing.Generic[_LinkedList__A]):
    serialVersionUID: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, elem: _LinkedList__A, next: 'LinkedList'[_LinkedList__A]): ...
    @staticmethod
    def ReusableCBF() -> scala.collection.generic.GenTraversableFactory.GenericCanBuildFrom[scala.runtime.Nothing.]: ...
    def append(self, that: Seq) -> Seq: ...
    def apply(self, n: int) -> _LinkedList__A: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['LinkedList'[typing.Any], _canBuildFrom__A, 'LinkedList'[_canBuildFrom__A]]: ...
    def clone(self) -> Seq: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['LinkedList']: ...
    @staticmethod
    def concat(xss: scala.collection.Seq) -> scala.collection.GenTraversable: ...
    _corresponds__B = typing.TypeVar('_corresponds__B')  # <B>
    def corresponds(self, that: scala.collection.GenSeq[_corresponds__B], p: scala.Function2[_LinkedList__A, _corresponds__B, typing.Any]) -> bool: ...
    def drop(self, n: int) -> Seq: ...
    def elem(self) -> _LinkedList__A: ...
    def elem_$eq(self, x$1: _LinkedList__A) -> None: ...
    _empty__A = typing.TypeVar('_empty__A')  # <A>
    @staticmethod
    def empty() -> 'LinkedList'[_empty__A]: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, n5: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_LinkedList__A, _foreach__U]) -> None: ...
    def get(self, n: int) -> scala.Option[_LinkedList__A]: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[_LinkedList__A, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[_LinkedList__A]]: ...
    def hashCode(self) -> int: ...
    def head(self) -> _LinkedList__A: ...
    def insert(self, that: Seq) -> None: ...
    def isDefinedAt(self, idx: int) -> bool: ...
    def isEmpty(self) -> bool: ...
    @staticmethod
    def iterate(start: typing.Any, len: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    def iterator(self) -> scala.collection.Iterator[_LinkedList__A]: ...
    def length(self) -> int: ...
    def next(self) -> 'LinkedList'[_LinkedList__A]: ...
    def next_$eq(self, x$1: 'LinkedList'[_LinkedList__A]) -> None: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, step: typing.Any, evidence$2: scala.math.Integral) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, evidence$1: scala.math.Integral) -> scala.collection.GenTraversable: ...
    def seq(self) -> LinearSeq[_LinkedList__A]: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, n5: int, f: scala.Function5) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, f: scala.Function4) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, f: scala.Function3) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, f: scala.Function2) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    def tail(self) -> Seq: ...
    def thisCollection(self) -> scala.collection.LinearSeq[_LinkedList__A]: ...
    @typing.overload
    def toCollection(self, repr: scala.collection.LinearSeqLike) -> scala.collection.LinearSeq: ...
    @typing.overload
    def toCollection(self, repr: typing.Any) -> scala.collection.Seq: ...
    def toIterable(self) -> scala.collection.Iterable[_LinkedList__A]: ...
    def toSeq(self) -> scala.collection.Seq[_LinkedList__A]: ...
    def toTraversable(self) -> scala.collection.Traversable[_LinkedList__A]: ...
    @staticmethod
    def unapplySeq(x: scala.collection.Seq) -> scala.Some: ...
    def update(self, n: int, x: _LinkedList__A) -> None: ...
    @typing.overload
    def view(self) -> scala.collection.SeqView[_LinkedList__A, scala.collection.Seq[_LinkedList__A]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> scala.collection.SeqView[_LinkedList__A, scala.collection.Seq[_LinkedList__A]]: ...

_MutableList__A = typing.TypeVar('_MutableList__A')  # <A>
class MutableList(AbstractSeq[_MutableList__A], LinearSeq[_MutableList__A], scala.collection.LinearSeqOptimized[_MutableList__A, 'MutableList'[_MutableList__A]], Builder[_MutableList__A, 'MutableList'[_MutableList__A]], scala.Serializable, typing.Generic[_MutableList__A]):
    serialVersionUID: typing.ClassVar[int] = ...
    def __init__(self): ...
    @typing.overload
    def $plus$eq(self, elem1: _MutableList__A, elem2: _MutableList__A, elems: scala.collection.Seq[_MutableList__A]) -> scala.collection.generic.Growable[_MutableList__A]: ...
    @typing.overload
    def $plus$eq(self, elem: _MutableList__A) -> 'MutableList'[_MutableList__A]: ...
    def $plus$eq$colon(self, elem: _MutableList__A) -> 'MutableList'[_MutableList__A]: ...
    def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[_MutableList__A]) -> scala.collection.generic.Growable[_MutableList__A]: ...
    @staticmethod
    def ReusableCBF() -> scala.collection.generic.GenTraversableFactory.GenericCanBuildFrom[scala.runtime.Nothing.]: ...
    def appendElem(self, elem: _MutableList__A) -> None: ...
    def apply(self, n: int) -> _MutableList__A: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['MutableList'[typing.Any], _canBuildFrom__A, 'MutableList'[_canBuildFrom__A]]: ...
    def clear(self) -> None: ...
    def clone(self) -> 'MutableList'[_MutableList__A]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['MutableList']: ...
    @staticmethod
    def concat(xss: scala.collection.Seq) -> scala.collection.GenTraversable: ...
    _contains__A1 = typing.TypeVar('_contains__A1')  # <A1>
    def contains(self, elem: _contains__A1) -> bool: ...
    _corresponds__B = typing.TypeVar('_corresponds__B')  # <B>
    def corresponds(self, that: scala.collection.GenSeq[_corresponds__B], p: scala.Function2[_MutableList__A, _corresponds__B, typing.Any]) -> bool: ...
    def drop(self, n: int) -> scala.collection.LinearSeqOptimized: ...
    def dropRight(self, n: int) -> scala.collection.LinearSeqOptimized: ...
    @staticmethod
    def empty() -> scala.collection.GenTraversable: ...
    def exists(self, p: scala.Function1[_MutableList__A, typing.Any]) -> bool: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, n5: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    def find(self, p: scala.Function1[_MutableList__A, typing.Any]) -> scala.Option[_MutableList__A]: ...
    def first0(self) -> LinkedList[_MutableList__A]: ...
    def first0_$eq(self, x$1: LinkedList[_MutableList__A]) -> None: ...
    _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
    def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, _MutableList__A, _foldLeft__B]) -> _foldLeft__B: ...
    _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
    def foldRight(self, z: _foldRight__B, op: scala.Function2[_MutableList__A, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
    def forall(self, p: scala.Function1[_MutableList__A, typing.Any]) -> bool: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_MutableList__A, _foreach__U]) -> None: ...
    def get(self, n: int) -> scala.Option[_MutableList__A]: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[_MutableList__A, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[_MutableList__A]]: ...
    def hashCode(self) -> int: ...
    def head(self) -> _MutableList__A: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[_MutableList__A, typing.Any]) -> int: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[_MutableList__A, typing.Any], from_: int) -> int: ...
    def isDefinedAt(self, x: int) -> bool: ...
    def isEmpty(self) -> bool: ...
    @staticmethod
    def iterate(start: typing.Any, len: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    def iterator(self) -> scala.collection.Iterator[_MutableList__A]: ...
    def last(self) -> _MutableList__A: ...
    def last0(self) -> LinkedList[_MutableList__A]: ...
    def last0_$eq(self, x$1: LinkedList[_MutableList__A]) -> None: ...
    @typing.overload
    def lastIndexWhere(self, p: scala.Function1[_MutableList__A, typing.Any]) -> int: ...
    @typing.overload
    def lastIndexWhere(self, p: scala.Function1[_MutableList__A, typing.Any], end: int) -> int: ...
    def len(self) -> int: ...
    def len_$eq(self, x$1: int) -> None: ...
    def length(self) -> int: ...
    def lengthCompare(self, len: int) -> int: ...
    _mapResult__NewTo = typing.TypeVar('_mapResult__NewTo')  # <NewTo>
    def mapResult(self, f: scala.Function1['MutableList'[_MutableList__A], _mapResult__NewTo]) -> Builder[_MutableList__A, _mapResult__NewTo]: ...
    def newBuilder(self) -> Builder[_MutableList__A, 'MutableList'[_MutableList__A]]: ...
    def prependElem(self, elem: _MutableList__A) -> None: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, step: typing.Any, evidence$2: scala.math.Integral) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, evidence$1: scala.math.Integral) -> scala.collection.GenTraversable: ...
    _reduceLeft__B = typing.TypeVar('_reduceLeft__B')  # <B>
    def reduceLeft(self, op: scala.Function2[_reduceLeft__B, _MutableList__A, _reduceLeft__B]) -> _reduceLeft__B: ...
    _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
    def reduceRight(self, op: scala.Function2[_MutableList__A, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
    def result(self) -> 'MutableList'[_MutableList__A]: ...
    _sameElements__B = typing.TypeVar('_sameElements__B')  # <B>
    def sameElements(self, that: scala.collection.GenIterable[_sameElements__B]) -> bool: ...
    def segmentLength(self, p: scala.Function1[_MutableList__A, typing.Any], from_: int) -> int: ...
    def seq(self) -> LinearSeq[_MutableList__A]: ...
    @typing.overload
    def sizeHint(self, size: int) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any], delta: int) -> None: ...
    def sizeHintBounded(self, size: int, boundingColl: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
    def slice(self, from_: int, until: int) -> scala.collection.LinearSeqOptimized: ...
    def span(self, p: scala.Function1[_MutableList__A, typing.Any]) -> scala.Tuple2['MutableList'[_MutableList__A], 'MutableList'[_MutableList__A]]: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, n5: int, f: scala.Function5) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, f: scala.Function4) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, f: scala.Function3) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, f: scala.Function2) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    def tail(self) -> 'MutableList'[_MutableList__A]: ...
    def tailImpl(self, tl: 'MutableList'[_MutableList__A]) -> None: ...
    def tails(self) -> scala.collection.Iterator['MutableList'[_MutableList__A]]: ...
    def take(self, n: int) -> scala.collection.LinearSeqOptimized: ...
    def takeWhile(self, p: scala.Function1) -> scala.collection.LinearSeqOptimized: ...
    def thisCollection(self) -> scala.collection.LinearSeq[_MutableList__A]: ...
    def toCollection(self, repr: scala.collection.LinearSeqLike) -> scala.collection.LinearSeq: ...
    def toIterable(self) -> scala.collection.Iterable[_MutableList__A]: ...
    def toLinkedList(self) -> LinkedList[_MutableList__A]: ...
    def toList(self) -> scala.collection.immutable.List[_MutableList__A]: ...
    def toQueue(self) -> 'Queue'[_MutableList__A]: ...
    def toSeq(self) -> scala.collection.Seq[_MutableList__A]: ...
    def toTraversable(self) -> scala.collection.Traversable[_MutableList__A]: ...
    @staticmethod
    def unapplySeq(x: scala.collection.Seq) -> scala.Some: ...
    def update(self, n: int, x: _MutableList__A) -> None: ...
    @typing.overload
    def view(self) -> scala.collection.SeqView[_MutableList__A, scala.collection.Seq[_MutableList__A]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> scala.collection.SeqView[_MutableList__A, scala.collection.Seq[_MutableList__A]]: ...

_ObservableBuffer__A = typing.TypeVar('_ObservableBuffer__A')  # <A>
class ObservableBuffer(Buffer[_ObservableBuffer__A], Publisher[scala.collection.script.Message[_ObservableBuffer__A]], typing.Generic[_ObservableBuffer__A]):
    @staticmethod
    def $init$($this: 'ObservableBuffer') -> None: ...
    @typing.overload
    def $plus$eq(self, elem: _ObservableBuffer__A) -> scala.collection.generic.Growable[_ObservableBuffer__A]: ...
    @typing.overload
    def $plus$eq(self, elem: _ObservableBuffer__A) -> BufferLike: ...
    @typing.overload
    def $plus$eq(self, elem1: _ObservableBuffer__A, elem2: _ObservableBuffer__A, elems: scala.collection.Seq[_ObservableBuffer__A]) -> scala.collection.generic.Growable[_ObservableBuffer__A]: ...
    @typing.overload
    def $plus$eq(self, element: _ObservableBuffer__A) -> 'ObservableBuffer'[_ObservableBuffer__A]: ...
    @typing.overload
    def $plus$eq$colon(self, elem: _ObservableBuffer__A) -> BufferLike: ...
    @typing.overload
    def $plus$eq$colon(self, element: _ObservableBuffer__A) -> 'ObservableBuffer'[_ObservableBuffer__A]: ...
    @typing.overload
    def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[_ObservableBuffer__A]) -> scala.collection.generic.Growable[_ObservableBuffer__A]: ...
    @typing.overload
    def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[_ObservableBuffer__A]) -> 'ObservableBuffer'[_ObservableBuffer__A]: ...
    def clear(self) -> None: ...
    @typing.overload
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    def equals(self, obj: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def insertAll(self, n: int, elems: scala.collection.Traversable[_ObservableBuffer__A]) -> None: ...
    @typing.overload
    def remove(self, n: int) -> _ObservableBuffer__A: ...
    @typing.overload
    def remove(self, n: int, count: int) -> None: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self) -> str: ...
    def update(self, n: int, newelement: _ObservableBuffer__A) -> None: ...

_ResizableArray__A = typing.TypeVar('_ResizableArray__A')  # <A>
class ResizableArray(IndexedSeq[_ResizableArray__A], IndexedSeqOptimized[_ResizableArray__A, 'ResizableArray'[_ResizableArray__A]], typing.Generic[_ResizableArray__A]):
    @staticmethod
    def $init$($this: 'ResizableArray') -> None: ...
    @staticmethod
    def ReusableCBF() -> scala.collection.generic.GenTraversableFactory.GenericCanBuildFrom[scala.runtime.Nothing.]: ...
    @typing.overload
    def apply(self, v1: typing.Any) -> typing.Any: ...
    @typing.overload
    def apply(self, idx: int) -> _ResizableArray__A: ...
    def array(self) -> typing.List[typing.Any]: ...
    def array_$eq(self, x$1: typing.List[typing.Any]) -> None: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['ResizableArray'[typing.Any], _canBuildFrom__A, 'ResizableArray'[_canBuildFrom__A]]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['ResizableArray']: ...
    @staticmethod
    def concat(xss: scala.collection.Seq) -> scala.collection.GenTraversable: ...
    def copy(self, m: int, n: int, len: int) -> None: ...
    _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
    _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
    _copyToArray_2__B = typing.TypeVar('_copyToArray_2__B')  # <B>
    @typing.overload
    def copyToArray(self, xs: typing.Any) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
    @staticmethod
    def empty() -> scala.collection.GenTraversable: ...
    def ensureSize(self, n: int) -> None: ...
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, n5: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_ResizableArray__A, _foreach__U]) -> None: ...
    def hashCode(self) -> int: ...
    def initialSize(self) -> int: ...
    @staticmethod
    def iterate(start: typing.Any, len: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    def length(self) -> int: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, step: typing.Any, evidence$2: scala.math.Integral) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, evidence$1: scala.math.Integral) -> scala.collection.GenTraversable: ...
    def reduceToSize(self, sz: int) -> None: ...
    def size0(self) -> int: ...
    def size0_$eq(self, x$1: int) -> None: ...
    def swap(self, a: int, b: int) -> None: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, n5: int, f: scala.Function5) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, f: scala.Function4) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, f: scala.Function3) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, f: scala.Function2) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self) -> str: ...
    @staticmethod
    def unapplySeq(x: scala.collection.Seq) -> scala.Some: ...
    def update(self, idx: int, elem: _ResizableArray__A) -> None: ...

_RevertibleHistory__Evt = typing.TypeVar('_RevertibleHistory__Evt', bound=Undoable)  # <Evt>
_RevertibleHistory__Pub = typing.TypeVar('_RevertibleHistory__Pub')  # <Pub>
class RevertibleHistory(History[_RevertibleHistory__Evt, _RevertibleHistory__Pub], Undoable, typing.Generic[_RevertibleHistory__Evt, _RevertibleHistory__Pub]):
    def __init__(self): ...
    def undo(self) -> None: ...

_Stack__StackBuilder__A = typing.TypeVar('_Stack__StackBuilder__A')  # <A>
_Stack__A = typing.TypeVar('_Stack__A')  # <A>
class Stack(AbstractSeq[_Stack__A], scala.Serializable, typing.Generic[_Stack__A]):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, elems: scala.collection.immutable.List[_Stack__A]): ...
    @staticmethod
    def ReusableCBF() -> scala.collection.generic.GenTraversableFactory.GenericCanBuildFrom[scala.runtime.Nothing.]: ...
    def apply(self, index: int) -> _Stack__A: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['Stack'[typing.Any], _canBuildFrom__A, 'Stack'[_canBuildFrom__A]]: ...
    def clear(self) -> None: ...
    def clone(self) -> 'Stack'[_Stack__A]: ...
    def companion(self) -> 'Stack.': ...
    @staticmethod
    def concat(xss: scala.collection.Seq) -> scala.collection.GenTraversable: ...
    def elems(self) -> scala.collection.immutable.List[_Stack__A]: ...
    def elems_$eq(self, x$1: scala.collection.immutable.List[_Stack__A]) -> None: ...
    @typing.overload
    @staticmethod
    def empty() -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def empty() -> 'Stack'[scala.runtime.Nothing.]: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, n5: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_Stack__A, _foreach__U]) -> None: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[_Stack__A, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[_Stack__A]]: ...
    def isDefinedAt(self, idx: int) -> bool: ...
    def isEmpty(self) -> bool: ...
    @staticmethod
    def iterate(start: typing.Any, len: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    def iterator(self) -> scala.collection.Iterator[_Stack__A]: ...
    def length(self) -> int: ...
    def pop(self) -> _Stack__A: ...
    @typing.overload
    def push(self, elem: _Stack__A) -> 'Stack'[_Stack__A]: ...
    @typing.overload
    def push(self, elem1: _Stack__A, elem2: _Stack__A, elems: scala.collection.Seq[_Stack__A]) -> 'Stack'[_Stack__A]: ...
    def pushAll(self, xs: scala.collection.TraversableOnce[_Stack__A]) -> 'Stack'[_Stack__A]: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, step: typing.Any, evidence$2: scala.math.Integral) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, evidence$1: scala.math.Integral) -> scala.collection.GenTraversable: ...
    def seq(self) -> Seq[_Stack__A]: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, n5: int, f: scala.Function5) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, f: scala.Function4) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, f: scala.Function3) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, f: scala.Function2) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    def thisCollection(self) -> scala.collection.Seq[_Stack__A]: ...
    def toCollection(self, repr: typing.Any) -> scala.collection.Seq: ...
    def toIterable(self) -> scala.collection.Iterable[_Stack__A]: ...
    def toList(self) -> scala.collection.immutable.List[_Stack__A]: ...
    def toSeq(self) -> scala.collection.Seq[_Stack__A]: ...
    def toTraversable(self) -> scala.collection.Traversable[_Stack__A]: ...
    def top(self) -> _Stack__A: ...
    @staticmethod
    def unapplySeq(x: scala.collection.Seq) -> scala.Some: ...
    def update(self, n: int, newelem: _Stack__A) -> None: ...
    @typing.overload
    def view(self) -> scala.collection.SeqView[_Stack__A, scala.collection.Seq[_Stack__A]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> scala.collection.SeqView[_Stack__A, scala.collection.Seq[_Stack__A]]: ...
    class StackBuilder(Builder[_Stack__StackBuilder__A, 'Stack'[_Stack__StackBuilder__A]], typing.Generic[_Stack__StackBuilder__A]):
        def __init__(self): ...
        @typing.overload
        def $plus$eq(self, elem1: _Stack__StackBuilder__A, elem2: _Stack__StackBuilder__A, elems: scala.collection.Seq[_Stack__StackBuilder__A]) -> scala.collection.generic.Growable[_Stack__StackBuilder__A]: ...
        @typing.overload
        def $plus$eq(self, elem: _Stack__StackBuilder__A) -> 'Stack.StackBuilder'[_Stack__StackBuilder__A]: ...
        def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[_Stack__StackBuilder__A]) -> scala.collection.generic.Growable[_Stack__StackBuilder__A]: ...
        def clear(self) -> None: ...
        def lbuff(self) -> 'ListBuffer'[_Stack__StackBuilder__A]: ...
        _mapResult__NewTo = typing.TypeVar('_mapResult__NewTo')  # <NewTo>
        def mapResult(self, f: scala.Function1['Stack'[_Stack__StackBuilder__A], _mapResult__NewTo]) -> Builder[_Stack__StackBuilder__A, _mapResult__NewTo]: ...
        def result(self) -> 'Stack'[_Stack__StackBuilder__A]: ...
        @typing.overload
        def sizeHint(self, size: int) -> None: ...
        @typing.overload
        def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
        @typing.overload
        def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any], delta: int) -> None: ...
        def sizeHintBounded(self, size: int, boundingColl: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
    class : ...

class StringBuilder(AbstractSeq[typing.Any], java.lang.CharSequence, IndexedSeq[typing.Any], scala.collection.immutable.StringLike['StringBuilder'], ReusableBuilder[typing.Any, str], scala.Serializable):
    serialVersionUID: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, capacity: int): ...
    @typing.overload
    def __init__(self, initCapacity: int, initValue: str): ...
    @typing.overload
    def __init__(self, str: str): ...
    @typing.overload
    def __init__(self, underlying: java.lang.StringBuilder): ...
    def $greater(self, that: typing.Any) -> bool: ...
    def $greater$eq(self, that: typing.Any) -> bool: ...
    def $less(self, that: typing.Any) -> bool: ...
    def $less$eq(self, that: typing.Any) -> bool: ...
    def $plus(self, x: str) -> 'StringBuilder': ...
    @typing.overload
    def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq) -> scala.collection.generic.Growable: ...
    @typing.overload
    def $plus$eq(self, x: str) -> 'StringBuilder': ...
    @typing.overload
    def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[typing.Any]) -> scala.collection.generic.Growable[typing.Any]: ...
    @typing.overload
    def $plus$plus$eq(self, s: str) -> 'StringBuilder': ...
    def $times(self, n: int) -> str: ...
    @typing.overload
    def append(self, x: bool) -> 'StringBuilder': ...
    @typing.overload
    def append(self, x: int) -> 'StringBuilder': ...
    @typing.overload
    def append(self, x: str) -> 'StringBuilder': ...
    @typing.overload
    def append(self, x: float) -> 'StringBuilder': ...
    @typing.overload
    def append(self, x: float) -> 'StringBuilder': ...
    @typing.overload
    def append(self, x: int) -> 'StringBuilder': ...
    @typing.overload
    def append(self, x: typing.Any) -> 'StringBuilder': ...
    @typing.overload
    def append(self, s: str) -> 'StringBuilder': ...
    @typing.overload
    def append(self, x: int) -> 'StringBuilder': ...
    @typing.overload
    def append(self, sb: 'StringBuilder') -> 'StringBuilder': ...
    @typing.overload
    def append(self, x: int) -> 'StringBuilder': ...
    @typing.overload
    def appendAll(self, xs: typing.List[str]) -> 'StringBuilder': ...
    @typing.overload
    def appendAll(self, xs: typing.List[str], offset: int, len: int) -> 'StringBuilder': ...
    @typing.overload
    def appendAll(self, xs: str) -> 'StringBuilder': ...
    @typing.overload
    def appendAll(self, xs: scala.collection.TraversableOnce[typing.Any]) -> 'StringBuilder': ...
    def apply(self, index: int) -> str: ...
    def capacity(self) -> int: ...
    def capitalize(self) -> str: ...
    def charAt(self, index: int) -> str: ...
    def chars(self) -> java.util.stream.IntStream: ...
    def clear(self) -> None: ...
    def clone(self) -> 'StringBuilder': ...
    def codePoints(self) -> java.util.stream.IntStream: ...
    def companion(self) -> scala.collection.generic.GenericCompanion[IndexedSeq]: ...
    def compare(self, other: str) -> int: ...
    def compareTo(self, that: typing.Any) -> int: ...
    _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
    _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
    _copyToArray_2__B = typing.TypeVar('_copyToArray_2__B')  # <B>
    @typing.overload
    def copyToArray(self, xs: typing.Any) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
    def delete(self, start: int, end: int) -> 'StringBuilder': ...
    def deleteCharAt(self, index: int) -> 'StringBuilder': ...
    def drop(self, n: int) -> typing.Any: ...
    def dropRight(self, n: int) -> typing.Any: ...
    def dropWhile(self, p: scala.Function1) -> typing.Any: ...
    _endsWith__B = typing.TypeVar('_endsWith__B')  # <B>
    def endsWith(self, that: scala.collection.GenSeq[_endsWith__B]) -> bool: ...
    def ensureCapacity(self, newCapacity: int) -> None: ...
    def exists(self, p: scala.Function1[typing.Any, typing.Any]) -> bool: ...
    def find(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.Option[typing.Any]: ...
    _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
    def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, typing.Any, _foldLeft__B]) -> _foldLeft__B: ...
    _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
    def foldRight(self, z: _foldRight__B, op: scala.Function2[typing.Any, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
    def forall(self, p: scala.Function1[typing.Any, typing.Any]) -> bool: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[typing.Any, _foreach__U]) -> None: ...
    def format(self, args: scala.collection.Seq[typing.Any]) -> str: ...
    def formatLocal(self, l: java.util.Locale, args: scala.collection.Seq[typing.Any]) -> str: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[typing.Any, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[typing.Any]]: ...
    def hashCode(self) -> int: ...
    def head(self) -> typing.Any: ...
    _indexOf_0__B = typing.TypeVar('_indexOf_0__B')  # <B>
    _indexOf_1__B = typing.TypeVar('_indexOf_1__B')  # <B>
    @typing.overload
    def indexOf(self, elem: _indexOf_0__B) -> int: ...
    @typing.overload
    def indexOf(self, elem: _indexOf_1__B, from_: int) -> int: ...
    @typing.overload
    def indexOf(self, str: str) -> int: ...
    @typing.overload
    def indexOf(self, str: str, fromIndex: int) -> int: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[typing.Any, typing.Any], from_: int) -> int: ...
    def init(self) -> typing.Any: ...
    @typing.overload
    def insert(self, index: int, x: bool) -> 'StringBuilder': ...
    @typing.overload
    def insert(self, index: int, x: int) -> 'StringBuilder': ...
    @typing.overload
    def insert(self, index: int, x: str) -> 'StringBuilder': ...
    @typing.overload
    def insert(self, index: int, x: float) -> 'StringBuilder': ...
    @typing.overload
    def insert(self, index: int, x: float) -> 'StringBuilder': ...
    @typing.overload
    def insert(self, index: int, x: int) -> 'StringBuilder': ...
    @typing.overload
    def insert(self, index: int, x: typing.Any) -> 'StringBuilder': ...
    @typing.overload
    def insert(self, index: int, x: str) -> 'StringBuilder': ...
    @typing.overload
    def insert(self, index: int, x: int) -> 'StringBuilder': ...
    @typing.overload
    def insert(self, index: int, x: int) -> 'StringBuilder': ...
    @typing.overload
    def insertAll(self, index: int, xs: typing.List[str]) -> 'StringBuilder': ...
    @typing.overload
    def insertAll(self, index: int, str: typing.List[str], offset: int, len: int) -> 'StringBuilder': ...
    @typing.overload
    def insertAll(self, index: int, xs: scala.collection.TraversableOnce[typing.Any]) -> 'StringBuilder': ...
    def isDefinedAt(self, idx: int) -> bool: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def last(self) -> typing.Any: ...
    _lastIndexOf_0__B = typing.TypeVar('_lastIndexOf_0__B')  # <B>
    _lastIndexOf_1__B = typing.TypeVar('_lastIndexOf_1__B')  # <B>
    @typing.overload
    def lastIndexOf(self, elem: _lastIndexOf_0__B) -> int: ...
    @typing.overload
    def lastIndexOf(self, elem: _lastIndexOf_1__B, end: int) -> int: ...
    @typing.overload
    def lastIndexOf(self, str: str) -> int: ...
    @typing.overload
    def lastIndexOf(self, str: str, fromIndex: int) -> int: ...
    @typing.overload
    def lastIndexWhere(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
    @typing.overload
    def lastIndexWhere(self, p: scala.Function1[typing.Any, typing.Any], end: int) -> int: ...
    def length(self) -> int: ...
    def lengthCompare(self, len: int) -> int: ...
    def length_$eq(self, n: int) -> None: ...
    def lines(self) -> scala.collection.Iterator[str]: ...
    def linesIterator(self) -> scala.collection.Iterator[str]: ...
    def linesWithSeparators(self) -> scala.collection.Iterator[str]: ...
    _mapResult__NewTo = typing.TypeVar('_mapResult__NewTo')  # <NewTo>
    def mapResult(self, f: scala.Function1[str, _mapResult__NewTo]) -> Builder[typing.Any, _mapResult__NewTo]: ...
    @typing.overload
    def mkString(self, sep: str) -> str: ...
    @typing.overload
    def mkString(self, start: str, sep: str, end: str) -> str: ...
    @typing.overload
    def mkString(self) -> str: ...
    def newBuilder(self) -> GrowingBuilder[typing.Any, 'StringBuilder']: ...
    @typing.overload
    def r(self) -> scala.util.matching.Regex: ...
    @typing.overload
    def r(self, groupNames: scala.collection.Seq[str]) -> scala.util.matching.Regex: ...
    _reduceLeft__B = typing.TypeVar('_reduceLeft__B')  # <B>
    def reduceLeft(self, op: scala.Function2[_reduceLeft__B, typing.Any, _reduceLeft__B]) -> _reduceLeft__B: ...
    _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
    def reduceRight(self, op: scala.Function2[typing.Any, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
    def replace(self, start: int, end: int, str: str) -> 'StringBuilder': ...
    def replaceAllLiterally(self, literal: str, replacement: str) -> str: ...
    def result(self) -> str: ...
    def reverse(self) -> 'StringBuilder': ...
    def reverseContents(self) -> 'StringBuilder': ...
    def reverseIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    _sameElements__B = typing.TypeVar('_sameElements__B')  # <B>
    def sameElements(self, that: scala.collection.GenIterable[_sameElements__B]) -> bool: ...
    def segmentLength(self, p: scala.Function1[typing.Any, typing.Any], from_: int) -> int: ...
    def seq(self) -> IndexedSeq[typing.Any]: ...
    def setCharAt(self, index: int, ch: str) -> None: ...
    def setLength(self, len: int) -> None: ...
    @typing.overload
    def sizeHint(self, size: int) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any], delta: int) -> None: ...
    def sizeHintBounded(self, size: int, boundingColl: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
    def sizeHintIfCheap(self) -> int: ...
    def slice(self, from_: int, until: int) -> typing.Any: ...
    def span(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.Tuple2['StringBuilder', 'StringBuilder']: ...
    @typing.overload
    def split(self, separator: str) -> typing.List[str]: ...
    @typing.overload
    def split(self, separators: typing.List[str]) -> typing.List[str]: ...
    def splitAt(self, n: int) -> scala.Tuple2['StringBuilder', 'StringBuilder']: ...
    _startsWith_0__B = typing.TypeVar('_startsWith_0__B')  # <B>
    _startsWith_1__B = typing.TypeVar('_startsWith_1__B')  # <B>
    @typing.overload
    def startsWith(self, that: scala.collection.GenSeq[_startsWith_0__B]) -> bool: ...
    @typing.overload
    def startsWith(self, that: scala.collection.GenSeq[_startsWith_1__B], offset: int) -> bool: ...
    def stripLineEnd(self) -> str: ...
    @typing.overload
    def stripMargin(self) -> str: ...
    @typing.overload
    def stripMargin(self, marginChar: str) -> str: ...
    def stripPrefix(self, prefix: str) -> str: ...
    def stripSuffix(self, suffix: str) -> str: ...
    def subSequence(self, start: int, end: int) -> java.lang.CharSequence: ...
    @typing.overload
    def substring(self, start: int) -> str: ...
    @typing.overload
    def substring(self, start: int, end: int) -> str: ...
    def tail(self) -> typing.Any: ...
    def take(self, n: int) -> typing.Any: ...
    def takeRight(self, n: int) -> typing.Any: ...
    def takeWhile(self, p: scala.Function1) -> typing.Any: ...
    def thisCollection(self) -> 'StringBuilder': ...
    _toArray_1__B = typing.TypeVar('_toArray_1__B')  # <B>
    @typing.overload
    def toArray(self) -> typing.List[str]: ...
    @typing.overload
    def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray_1__B]) -> typing.Any: ...
    def toBoolean(self) -> bool: ...
    _toBuffer__A1 = typing.TypeVar('_toBuffer__A1')  # <A1>
    def toBuffer(self) -> Buffer[_toBuffer__A1]: ...
    def toByte(self) -> int: ...
    @typing.overload
    def toCollection(self, repr: typing.Any) -> IndexedSeq: ...
    @typing.overload
    def toCollection(self, repr: 'StringBuilder') -> 'StringBuilder': ...
    def toDouble(self) -> float: ...
    def toFloat(self) -> float: ...
    def toInt(self) -> int: ...
    def toIterable(self) -> scala.collection.Iterable[typing.Any]: ...
    def toList(self) -> scala.collection.immutable.List[typing.Any]: ...
    def toLong(self) -> int: ...
    def toSeq(self) -> scala.collection.Seq[typing.Any]: ...
    def toShort(self) -> int: ...
    def toString(self) -> str: ...
    def toTraversable(self) -> scala.collection.Traversable[typing.Any]: ...
    def update(self, i: int, c: str) -> None: ...
    @typing.overload
    def view(self) -> 'IndexedSeqView'[typing.Any, IndexedSeq[typing.Any]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> 'IndexedSeqView'[typing.Any, IndexedSeq[typing.Any]]: ...
    _zip__A1 = typing.TypeVar('_zip__A1')  # <A1>
    _zip__B = typing.TypeVar('_zip__B')  # <B>
    _zip__That = typing.TypeVar('_zip__That')  # <That>
    def zip(self, that: scala.collection.GenIterable[_zip__B], bf: scala.collection.generic.CanBuildFrom['StringBuilder', scala.Tuple2[_zip__A1, _zip__B], _zip__That]) -> _zip__That: ...
    _zipWithIndex__A1 = typing.TypeVar('_zipWithIndex__A1')  # <A1>
    _zipWithIndex__That = typing.TypeVar('_zipWithIndex__That')  # <That>
    def zipWithIndex(self, bf: scala.collection.generic.CanBuildFrom['StringBuilder', scala.Tuple2[_zipWithIndex__A1, typing.Any], _zipWithIndex__That]) -> _zipWithIndex__That: ...

_SynchronizedBuffer__A = typing.TypeVar('_SynchronizedBuffer__A')  # <A>
class SynchronizedBuffer(Buffer[_SynchronizedBuffer__A], typing.Generic[_SynchronizedBuffer__A]):
    @staticmethod
    def $init$($this: 'SynchronizedBuffer') -> None: ...
    def $less$less(self, cmd: scala.collection.script.Message[_SynchronizedBuffer__A]) -> None: ...
    @typing.overload
    def $plus$eq(self, elem: _SynchronizedBuffer__A) -> scala.collection.generic.Growable[_SynchronizedBuffer__A]: ...
    @typing.overload
    def $plus$eq(self, elem: _SynchronizedBuffer__A) -> BufferLike: ...
    @typing.overload
    def $plus$eq(self, elem1: _SynchronizedBuffer__A, elem2: _SynchronizedBuffer__A, elems: scala.collection.Seq[_SynchronizedBuffer__A]) -> scala.collection.generic.Growable[_SynchronizedBuffer__A]: ...
    @typing.overload
    def $plus$eq(self, elem: _SynchronizedBuffer__A) -> 'SynchronizedBuffer'[_SynchronizedBuffer__A]: ...
    @typing.overload
    def $plus$eq$colon(self, elem: _SynchronizedBuffer__A) -> BufferLike: ...
    @typing.overload
    def $plus$eq$colon(self, elem: _SynchronizedBuffer__A) -> 'SynchronizedBuffer'[_SynchronizedBuffer__A]: ...
    _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
    _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
    @typing.overload
    def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus_0__B], bf: scala.collection.generic.CanBuildFrom[typing.Any, _.plus.plus_0__B, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
    @typing.overload
    def $plus$plus(self, xs: scala.collection.GenTraversableOnce[_SynchronizedBuffer__A]) -> Buffer[_SynchronizedBuffer__A]: ...
    @typing.overload
    def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[_SynchronizedBuffer__A]) -> scala.collection.generic.Growable[_SynchronizedBuffer__A]: ...
    @typing.overload
    def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[_SynchronizedBuffer__A]) -> 'SynchronizedBuffer'[_SynchronizedBuffer__A]: ...
    @typing.overload
    def $plus$plus$eq$colon(self, xs: scala.collection.TraversableOnce[_SynchronizedBuffer__A]) -> BufferLike: ...
    @typing.overload
    def $plus$plus$eq$colon(self, xs: scala.collection.TraversableOnce[_SynchronizedBuffer__A]) -> 'SynchronizedBuffer'[_SynchronizedBuffer__A]: ...
    def append(self, elems: scala.collection.Seq[_SynchronizedBuffer__A]) -> None: ...
    def appendAll(self, xs: scala.collection.TraversableOnce[_SynchronizedBuffer__A]) -> None: ...
    @typing.overload
    def apply(self, v1: typing.Any) -> typing.Any: ...
    @typing.overload
    def apply(self, n: int) -> _SynchronizedBuffer__A: ...
    def clear(self) -> None: ...
    @typing.overload
    def clone(self) -> _SynchronizedBuffer__A: ...
    @typing.overload
    def clone(self) -> Buffer[_SynchronizedBuffer__A]: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def insert(self, n: int, elems: scala.collection.Seq[_SynchronizedBuffer__A]) -> None: ...
    def insertAll(self, n: int, xs: scala.collection.Traversable[_SynchronizedBuffer__A]) -> None: ...
    def iterator(self) -> scala.collection.Iterator[_SynchronizedBuffer__A]: ...
    def length(self) -> int: ...
    def prepend(self, elems: scala.collection.Seq[_SynchronizedBuffer__A]) -> None: ...
    def prependAll(self, xs: scala.collection.TraversableOnce[_SynchronizedBuffer__A]) -> None: ...
    @typing.overload
    def remove(self, n: int) -> _SynchronizedBuffer__A: ...
    @typing.overload
    def remove(self, n: int, count: int) -> None: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self) -> str: ...
    def update(self, n: int, newelem: _SynchronizedBuffer__A) -> None: ...

_ArrayBuffer__A = typing.TypeVar('_ArrayBuffer__A')  # <A>
class ArrayBuffer(AbstractBuffer[_ArrayBuffer__A], Builder[_ArrayBuffer__A, 'ArrayBuffer'[_ArrayBuffer__A]], ResizableArray[_ArrayBuffer__A], scala.collection.CustomParallelizable[_ArrayBuffer__A, scala.collection.parallel.mutable.ParArray[_ArrayBuffer__A]], scala.Serializable, typing.Generic[_ArrayBuffer__A]):
    serialVersionUID: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, initialSize: int): ...
    @typing.overload
    def $minus(self, elem: _ArrayBuffer__A) -> Buffer[_ArrayBuffer__A]: ...
    @typing.overload
    def $minus(self, elem1: _ArrayBuffer__A, elem2: _ArrayBuffer__A, elems: scala.collection.Seq[_ArrayBuffer__A]) -> Buffer[_ArrayBuffer__A]: ...
    @typing.overload
    def $minus$eq(self, elem1: _ArrayBuffer__A, elem2: _ArrayBuffer__A, elems: scala.collection.Seq[_ArrayBuffer__A]) -> scala.collection.generic.Shrinkable[_ArrayBuffer__A]: ...
    @typing.overload
    def $minus$eq(self, x: typing.Any) -> Buffer: ...
    def $minus$minus(self, xs: scala.collection.GenTraversableOnce[_ArrayBuffer__A]) -> Buffer[_ArrayBuffer__A]: ...
    @typing.overload
    def $plus$eq(self, elem1: _ArrayBuffer__A, elem2: _ArrayBuffer__A, elems: scala.collection.Seq[_ArrayBuffer__A]) -> scala.collection.generic.Growable[_ArrayBuffer__A]: ...
    @typing.overload
    def $plus$eq(self, elem: _ArrayBuffer__A) -> 'ArrayBuffer'[_ArrayBuffer__A]: ...
    def $plus$eq$colon(self, elem: _ArrayBuffer__A) -> 'ArrayBuffer'[_ArrayBuffer__A]: ...
    def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[_ArrayBuffer__A]) -> 'ArrayBuffer'[_ArrayBuffer__A]: ...
    def $plus$plus$eq$colon(self, xs: scala.collection.TraversableOnce[_ArrayBuffer__A]) -> 'ArrayBuffer'[_ArrayBuffer__A]: ...
    @staticmethod
    def ReusableCBF() -> scala.collection.generic.GenTraversableFactory.GenericCanBuildFrom[scala.runtime.Nothing.]: ...
    def apply(self, idx: int) -> _ArrayBuffer__A: ...
    def array(self) -> typing.List[typing.Any]: ...
    def array_$eq(self, x$1: typing.List[typing.Any]) -> None: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['ArrayBuffer'[typing.Any], _canBuildFrom__A, 'ArrayBuffer'[_canBuildFrom__A]]: ...
    def clear(self) -> None: ...
    def clone(self) -> Buffer[_ArrayBuffer__A]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['ArrayBuffer']: ...
    @staticmethod
    def concat(xss: scala.collection.Seq) -> scala.collection.GenTraversable: ...
    def copy(self, m: int, n: int, len: int) -> None: ...
    _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
    _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
    _copyToArray_2__B = typing.TypeVar('_copyToArray_2__B')  # <B>
    @typing.overload
    def copyToArray(self, xs: typing.Any) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
    def drop(self, n: int) -> typing.Any: ...
    def dropRight(self, n: int) -> typing.Any: ...
    def dropWhile(self, p: scala.Function1) -> typing.Any: ...
    @staticmethod
    def empty() -> scala.collection.GenTraversable: ...
    _endsWith__B = typing.TypeVar('_endsWith__B')  # <B>
    def endsWith(self, that: scala.collection.GenSeq[_endsWith__B]) -> bool: ...
    def ensureSize(self, n: int) -> None: ...
    def exists(self, p: scala.Function1[_ArrayBuffer__A, typing.Any]) -> bool: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, n5: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    def find(self, p: scala.Function1[_ArrayBuffer__A, typing.Any]) -> scala.Option[_ArrayBuffer__A]: ...
    _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
    def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, _ArrayBuffer__A, _foldLeft__B]) -> _foldLeft__B: ...
    _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
    def foldRight(self, z: _foldRight__B, op: scala.Function2[_ArrayBuffer__A, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
    def forall(self, p: scala.Function1[_ArrayBuffer__A, typing.Any]) -> bool: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_ArrayBuffer__A, _foreach__U]) -> None: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[_ArrayBuffer__A, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[_ArrayBuffer__A]]: ...
    def hashCode(self) -> int: ...
    def head(self) -> _ArrayBuffer__A: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[_ArrayBuffer__A, typing.Any]) -> int: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[_ArrayBuffer__A, typing.Any], from_: int) -> int: ...
    def init(self) -> typing.Any: ...
    def initialSize(self) -> int: ...
    def insertAll(self, n: int, seq: scala.collection.Traversable[_ArrayBuffer__A]) -> None: ...
    def isDefinedAt(self, idx: int) -> bool: ...
    def isEmpty(self) -> bool: ...
    @staticmethod
    def iterate(start: typing.Any, len: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    def iterator(self) -> scala.collection.Iterator[_ArrayBuffer__A]: ...
    def last(self) -> _ArrayBuffer__A: ...
    @typing.overload
    def lastIndexWhere(self, p: scala.Function1[_ArrayBuffer__A, typing.Any]) -> int: ...
    @typing.overload
    def lastIndexWhere(self, p: scala.Function1[_ArrayBuffer__A, typing.Any], end: int) -> int: ...
    def length(self) -> int: ...
    def lengthCompare(self, len: int) -> int: ...
    _mapResult__NewTo = typing.TypeVar('_mapResult__NewTo')  # <NewTo>
    def mapResult(self, f: scala.Function1['ArrayBuffer'[_ArrayBuffer__A], _mapResult__NewTo]) -> Builder[_ArrayBuffer__A, _mapResult__NewTo]: ...
    def par(self) -> scala.collection.parallel.mutable.ParArray[_ArrayBuffer__A]: ...
    def parCombiner(self) -> scala.collection.parallel.Combiner[_ArrayBuffer__A, scala.collection.parallel.mutable.ParArray[_ArrayBuffer__A]]: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, step: typing.Any, evidence$2: scala.math.Integral) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, evidence$1: scala.math.Integral) -> scala.collection.GenTraversable: ...
    _reduceLeft__B = typing.TypeVar('_reduceLeft__B')  # <B>
    def reduceLeft(self, op: scala.Function2[_reduceLeft__B, _ArrayBuffer__A, _reduceLeft__B]) -> _reduceLeft__B: ...
    _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
    def reduceRight(self, op: scala.Function2[_ArrayBuffer__A, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
    def reduceToSize(self, sz: int) -> None: ...
    @typing.overload
    def remove(self, n: int) -> _ArrayBuffer__A: ...
    @typing.overload
    def remove(self, n: int, count: int) -> None: ...
    def repr(self) -> typing.Any: ...
    def result(self) -> 'ArrayBuffer'[_ArrayBuffer__A]: ...
    def reverse(self) -> typing.Any: ...
    def reverseIterator(self) -> scala.collection.Iterator[_ArrayBuffer__A]: ...
    _sameElements__B = typing.TypeVar('_sameElements__B')  # <B>
    def sameElements(self, that: scala.collection.GenIterable[_sameElements__B]) -> bool: ...
    def segmentLength(self, p: scala.Function1[_ArrayBuffer__A, typing.Any], from_: int) -> int: ...
    def seq(self) -> IndexedSeq[_ArrayBuffer__A]: ...
    def size0(self) -> int: ...
    def size0_$eq(self, x$1: int) -> None: ...
    @typing.overload
    def sizeHint(self, len: int) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any], delta: int) -> None: ...
    def sizeHintBounded(self, size: int, boundingColl: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
    def sizeHintIfCheap(self) -> int: ...
    def slice(self, from_: int, until: int) -> typing.Any: ...
    def span(self, p: scala.Function1[_ArrayBuffer__A, typing.Any]) -> scala.Tuple2['ArrayBuffer'[_ArrayBuffer__A], 'ArrayBuffer'[_ArrayBuffer__A]]: ...
    def splitAt(self, n: int) -> scala.Tuple2['ArrayBuffer'[_ArrayBuffer__A], 'ArrayBuffer'[_ArrayBuffer__A]]: ...
    _startsWith_0__B = typing.TypeVar('_startsWith_0__B')  # <B>
    _startsWith_1__B = typing.TypeVar('_startsWith_1__B')  # <B>
    @typing.overload
    def startsWith(self, that: scala.collection.GenSeq[_startsWith_0__B]) -> bool: ...
    @typing.overload
    def startsWith(self, that: scala.collection.GenSeq[_startsWith_1__B], offset: int) -> bool: ...
    def stringPrefix(self) -> str: ...
    def swap(self, a: int, b: int) -> None: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, n5: int, f: scala.Function5) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, f: scala.Function4) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, f: scala.Function3) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, f: scala.Function2) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    def tail(self) -> typing.Any: ...
    def take(self, n: int) -> typing.Any: ...
    def takeRight(self, n: int) -> typing.Any: ...
    def takeWhile(self, p: scala.Function1) -> typing.Any: ...
    def thisCollection(self) -> IndexedSeq[_ArrayBuffer__A]: ...
    _toBuffer__A1 = typing.TypeVar('_toBuffer__A1')  # <A1>
    def toBuffer(self) -> Buffer[_toBuffer__A1]: ...
    def toCollection(self, repr: typing.Any) -> IndexedSeq: ...
    def toIterable(self) -> scala.collection.Iterable[_ArrayBuffer__A]: ...
    def toList(self) -> scala.collection.immutable.List[_ArrayBuffer__A]: ...
    def toSeq(self) -> scala.collection.Seq[_ArrayBuffer__A]: ...
    def toTraversable(self) -> scala.collection.Traversable[_ArrayBuffer__A]: ...
    @staticmethod
    def unapplySeq(x: scala.collection.Seq) -> scala.Some: ...
    def update(self, idx: int, elem: _ArrayBuffer__A) -> None: ...
    @typing.overload
    def view(self) -> 'IndexedSeqView'[_ArrayBuffer__A, 'ArrayBuffer'[_ArrayBuffer__A]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> 'IndexedSeqView'[_ArrayBuffer__A, 'ArrayBuffer'[_ArrayBuffer__A]]: ...
    _zip__A1 = typing.TypeVar('_zip__A1')  # <A1>
    _zip__B = typing.TypeVar('_zip__B')  # <B>
    _zip__That = typing.TypeVar('_zip__That')  # <That>
    def zip(self, that: scala.collection.GenIterable[_zip__B], bf: scala.collection.generic.CanBuildFrom['ArrayBuffer'[_ArrayBuffer__A], scala.Tuple2[_zip__A1, _zip__B], _zip__That]) -> _zip__That: ...
    _zipWithIndex__A1 = typing.TypeVar('_zipWithIndex__A1')  # <A1>
    _zipWithIndex__That = typing.TypeVar('_zipWithIndex__That')  # <That>
    def zipWithIndex(self, bf: scala.collection.generic.CanBuildFrom['ArrayBuffer'[_ArrayBuffer__A], scala.Tuple2[_zipWithIndex__A1, typing.Any], _zipWithIndex__That]) -> _zipWithIndex__That: ...

_ListBuffer__A = typing.TypeVar('_ListBuffer__A')  # <A>
class ListBuffer(AbstractBuffer[_ListBuffer__A], ReusableBuilder[_ListBuffer__A, scala.collection.immutable.List[_ListBuffer__A]], scala.collection.generic.SeqForwarder[_ListBuffer__A], scala.Serializable, typing.Generic[_ListBuffer__A]):
    serialVersionUID: typing.ClassVar[int] = ...
    def __init__(self): ...
    _$colon$bslash__B = typing.TypeVar('_$colon$bslash__B')  # <B>
    def $colon$bslash(self, z: _.colon.bslash__B, op: scala.Function2[_ListBuffer__A, _.colon.bslash__B, _.colon.bslash__B]) -> _.colon.bslash__B: ...
    _$div$colon__B = typing.TypeVar('_$div$colon__B')  # <B>
    def $div$colon(self, z: _.div.colon__B, op: scala.Function2[_.div.colon__B, _ListBuffer__A, _.div.colon__B]) -> _.div.colon__B: ...
    @typing.overload
    def $minus(self, elem: _ListBuffer__A) -> Buffer[_ListBuffer__A]: ...
    @typing.overload
    def $minus(self, elem1: _ListBuffer__A, elem2: _ListBuffer__A, elems: scala.collection.Seq[_ListBuffer__A]) -> Buffer[_ListBuffer__A]: ...
    @typing.overload
    def $minus$eq(self, elem1: _ListBuffer__A, elem2: _ListBuffer__A, elems: scala.collection.Seq[_ListBuffer__A]) -> scala.collection.generic.Shrinkable[_ListBuffer__A]: ...
    @typing.overload
    def $minus$eq(self, elem: _ListBuffer__A) -> 'ListBuffer'[_ListBuffer__A]: ...
    def $minus$minus(self, xs: scala.collection.GenTraversableOnce[_ListBuffer__A]) -> Buffer[_ListBuffer__A]: ...
    @typing.overload
    def $plus$eq(self, elem1: _ListBuffer__A, elem2: _ListBuffer__A, elems: scala.collection.Seq[_ListBuffer__A]) -> scala.collection.generic.Growable[_ListBuffer__A]: ...
    @typing.overload
    def $plus$eq(self, x: _ListBuffer__A) -> 'ListBuffer'[_ListBuffer__A]: ...
    def $plus$eq$colon(self, x: _ListBuffer__A) -> 'ListBuffer'[_ListBuffer__A]: ...
    def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[_ListBuffer__A]) -> 'ListBuffer'[_ListBuffer__A]: ...
    def $plus$plus$eq$colon(self, xs: scala.collection.TraversableOnce[_ListBuffer__A]) -> 'ListBuffer'[_ListBuffer__A]: ...
    @staticmethod
    def ReusableCBF() -> scala.collection.generic.GenTraversableFactory.GenericCanBuildFrom[scala.runtime.Nothing.]: ...
    @typing.overload
    def addString(self, b: StringBuilder) -> StringBuilder: ...
    @typing.overload
    def addString(self, b: StringBuilder, sep: str) -> StringBuilder: ...
    @typing.overload
    def addString(self, b: StringBuilder, start: str, sep: str, end: str) -> StringBuilder: ...
    def apply(self, n: int) -> _ListBuffer__A: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['ListBuffer'[typing.Any], _canBuildFrom__A, 'ListBuffer'[_canBuildFrom__A]]: ...
    def clear(self) -> None: ...
    def clone(self) -> 'ListBuffer'[_ListBuffer__A]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['ListBuffer']: ...
    @staticmethod
    def concat(xss: scala.collection.Seq) -> scala.collection.GenTraversable: ...
    _contains__A1 = typing.TypeVar('_contains__A1')  # <A1>
    def contains(self, elem: _contains__A1) -> bool: ...
    _containsSlice__B = typing.TypeVar('_containsSlice__B')  # <B>
    def containsSlice(self, that: scala.collection.GenSeq[_containsSlice__B]) -> bool: ...
    _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
    _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
    _copyToArray_2__B = typing.TypeVar('_copyToArray_2__B')  # <B>
    @typing.overload
    def copyToArray(self, xs: typing.Any) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
    _copyToBuffer__B = typing.TypeVar('_copyToBuffer__B')  # <B>
    def copyToBuffer(self, dest: Buffer[_copyToBuffer__B]) -> None: ...
    _corresponds__B = typing.TypeVar('_corresponds__B')  # <B>
    def corresponds(self, that: scala.collection.GenSeq[_corresponds__B], p: scala.Function2[_ListBuffer__A, _corresponds__B, typing.Any]) -> bool: ...
    def count(self, p: scala.Function1[_ListBuffer__A, typing.Any]) -> int: ...
    @staticmethod
    def empty() -> scala.collection.GenTraversable: ...
    _endsWith__B = typing.TypeVar('_endsWith__B')  # <B>
    def endsWith(self, that: scala.collection.GenSeq[_endsWith__B]) -> bool: ...
    def equals(self, that: typing.Any) -> bool: ...
    def exists(self, p: scala.Function1[_ListBuffer__A, typing.Any]) -> bool: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, n5: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    def find(self, p: scala.Function1[_ListBuffer__A, typing.Any]) -> scala.Option[_ListBuffer__A]: ...
    _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
    def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, _ListBuffer__A, _foldLeft__B]) -> _foldLeft__B: ...
    _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
    def foldRight(self, z: _foldRight__B, op: scala.Function2[_ListBuffer__A, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
    def forall(self, p: scala.Function1[_ListBuffer__A, typing.Any]) -> bool: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_ListBuffer__A, _foreach__U]) -> None: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[_ListBuffer__A, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[_ListBuffer__A]]: ...
    def hasDefiniteSize(self) -> bool: ...
    def head(self) -> _ListBuffer__A: ...
    def headOption(self) -> scala.Option[_ListBuffer__A]: ...
    _indexOf_0__B = typing.TypeVar('_indexOf_0__B')  # <B>
    _indexOf_1__B = typing.TypeVar('_indexOf_1__B')  # <B>
    @typing.overload
    def indexOf(self, elem: _indexOf_0__B) -> int: ...
    @typing.overload
    def indexOf(self, elem: _indexOf_1__B, from_: int) -> int: ...
    _indexOfSlice_0__B = typing.TypeVar('_indexOfSlice_0__B')  # <B>
    _indexOfSlice_1__B = typing.TypeVar('_indexOfSlice_1__B')  # <B>
    @typing.overload
    def indexOfSlice(self, that: scala.collection.GenSeq[_indexOfSlice_0__B]) -> int: ...
    @typing.overload
    def indexOfSlice(self, that: scala.collection.GenSeq[_indexOfSlice_1__B], from_: int) -> int: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[_ListBuffer__A, typing.Any]) -> int: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[_ListBuffer__A, typing.Any], from_: int) -> int: ...
    def indices(self) -> scala.collection.immutable.Range: ...
    def insertAll(self, n: int, seq: scala.collection.Traversable[_ListBuffer__A]) -> None: ...
    def isDefinedAt(self, x: int) -> bool: ...
    def isEmpty(self) -> bool: ...
    @staticmethod
    def iterate(start: typing.Any, len: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    def iterator(self) -> scala.collection.Iterator[_ListBuffer__A]: ...
    def last(self) -> _ListBuffer__A: ...
    _lastIndexOf_0__B = typing.TypeVar('_lastIndexOf_0__B')  # <B>
    _lastIndexOf_1__B = typing.TypeVar('_lastIndexOf_1__B')  # <B>
    @typing.overload
    def lastIndexOf(self, elem: _lastIndexOf_0__B) -> int: ...
    @typing.overload
    def lastIndexOf(self, elem: _lastIndexOf_1__B, end: int) -> int: ...
    _lastIndexOfSlice_0__B = typing.TypeVar('_lastIndexOfSlice_0__B')  # <B>
    _lastIndexOfSlice_1__B = typing.TypeVar('_lastIndexOfSlice_1__B')  # <B>
    @typing.overload
    def lastIndexOfSlice(self, that: scala.collection.GenSeq[_lastIndexOfSlice_0__B]) -> int: ...
    @typing.overload
    def lastIndexOfSlice(self, that: scala.collection.GenSeq[_lastIndexOfSlice_1__B], end: int) -> int: ...
    @typing.overload
    def lastIndexWhere(self, p: scala.Function1[_ListBuffer__A, typing.Any]) -> int: ...
    @typing.overload
    def lastIndexWhere(self, p: scala.Function1[_ListBuffer__A, typing.Any], end: int) -> int: ...
    def lastOption(self) -> scala.Option[_ListBuffer__A]: ...
    def length(self) -> int: ...
    def lengthCompare(self, len: int) -> int: ...
    _mapResult__NewTo = typing.TypeVar('_mapResult__NewTo')  # <NewTo>
    def mapResult(self, f: scala.Function1[scala.collection.immutable.List[_ListBuffer__A], _mapResult__NewTo]) -> Builder[_ListBuffer__A, _mapResult__NewTo]: ...
    _max__B = typing.TypeVar('_max__B')  # <B>
    def max(self, cmp: scala.math.Ordering[_max__B]) -> _ListBuffer__A: ...
    _min__B = typing.TypeVar('_min__B')  # <B>
    def min(self, cmp: scala.math.Ordering[_min__B]) -> _ListBuffer__A: ...
    @typing.overload
    def mkString(self) -> str: ...
    @typing.overload
    def mkString(self, sep: str) -> str: ...
    @typing.overload
    def mkString(self, start: str, sep: str, end: str) -> str: ...
    def nonEmpty(self) -> bool: ...
    def prefixLength(self, p: scala.Function1[_ListBuffer__A, typing.Any]) -> int: ...
    def prependToList(self, xs: scala.collection.immutable.List[_ListBuffer__A]) -> scala.collection.immutable.List[_ListBuffer__A]: ...
    _product__B = typing.TypeVar('_product__B')  # <B>
    def product(self, num: scala.math.Numeric[_product__B]) -> _product__B: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, step: typing.Any, evidence$2: scala.math.Integral) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, evidence$1: scala.math.Integral) -> scala.collection.GenTraversable: ...
    _reduceLeft__B = typing.TypeVar('_reduceLeft__B')  # <B>
    def reduceLeft(self, op: scala.Function2[_reduceLeft__B, _ListBuffer__A, _reduceLeft__B]) -> _reduceLeft__B: ...
    _reduceLeftOption__B = typing.TypeVar('_reduceLeftOption__B')  # <B>
    def reduceLeftOption(self, op: scala.Function2[_reduceLeftOption__B, _ListBuffer__A, _reduceLeftOption__B]) -> scala.Option[_reduceLeftOption__B]: ...
    _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
    def reduceRight(self, op: scala.Function2[_ListBuffer__A, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
    _reduceRightOption__B = typing.TypeVar('_reduceRightOption__B')  # <B>
    def reduceRightOption(self, op: scala.Function2[_ListBuffer__A, _reduceRightOption__B, _reduceRightOption__B]) -> scala.Option[_reduceRightOption__B]: ...
    @typing.overload
    def remove(self, n: int) -> _ListBuffer__A: ...
    @typing.overload
    def remove(self, n: int, count: int) -> None: ...
    def repr(self) -> typing.Any: ...
    def result(self) -> scala.collection.immutable.List[_ListBuffer__A]: ...
    def reverseIterator(self) -> scala.collection.Iterator[_ListBuffer__A]: ...
    _sameElements__B = typing.TypeVar('_sameElements__B')  # <B>
    def sameElements(self, that: scala.collection.GenIterable[_sameElements__B]) -> bool: ...
    def scala$collection$mutable$ListBuffer$$start(self) -> scala.collection.immutable.List[_ListBuffer__A]: ...
    def segmentLength(self, p: scala.Function1[_ListBuffer__A, typing.Any], from_: int) -> int: ...
    def seq(self) -> Seq[_ListBuffer__A]: ...
    def size(self) -> int: ...
    @typing.overload
    def sizeHint(self, size: int) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any], delta: int) -> None: ...
    def sizeHintBounded(self, size: int, boundingColl: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
    _startsWith_0__B = typing.TypeVar('_startsWith_0__B')  # <B>
    _startsWith_1__B = typing.TypeVar('_startsWith_1__B')  # <B>
    @typing.overload
    def startsWith(self, that: scala.collection.GenSeq[_startsWith_0__B]) -> bool: ...
    @typing.overload
    def startsWith(self, that: scala.collection.GenSeq[_startsWith_1__B], offset: int) -> bool: ...
    def stringPrefix(self) -> str: ...
    _sum__B = typing.TypeVar('_sum__B')  # <B>
    def sum(self, num: scala.math.Numeric[_sum__B]) -> _sum__B: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, n5: int, f: scala.Function5) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, f: scala.Function4) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, f: scala.Function3) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, f: scala.Function2) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    def thisCollection(self) -> scala.collection.Seq[_ListBuffer__A]: ...
    _toArray__B = typing.TypeVar('_toArray__B')  # <B>
    def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__B]) -> typing.Any: ...
    _toBuffer__B = typing.TypeVar('_toBuffer__B')  # <B>
    def toBuffer(self) -> Buffer[_toBuffer__B]: ...
    def toCollection(self, repr: typing.Any) -> scala.collection.Seq: ...
    def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq[_ListBuffer__A]: ...
    def toIterable(self) -> scala.collection.Iterable[_ListBuffer__A]: ...
    def toList(self) -> scala.collection.immutable.List[_ListBuffer__A]: ...
    _toMap__T = typing.TypeVar('_toMap__T')  # <T>
    _toMap__U = typing.TypeVar('_toMap__U')  # <U>
    def toMap(self, ev: scala.Predef..less.colon.less[_ListBuffer__A, scala.Tuple2[_toMap__T, _toMap__U]]) -> scala.collection.immutable.Map[_toMap__T, _toMap__U]: ...
    def toSeq(self) -> scala.collection.Seq[_ListBuffer__A]: ...
    _toSet__B = typing.TypeVar('_toSet__B')  # <B>
    def toSet(self) -> scala.collection.immutable.Set[_toSet__B]: ...
    def toStream(self) -> scala.collection.immutable.Stream[_ListBuffer__A]: ...
    def toTraversable(self) -> scala.collection.Traversable[_ListBuffer__A]: ...
    @staticmethod
    def unapplySeq(x: scala.collection.Seq) -> scala.Some: ...
    def underlying(self) -> scala.collection.immutable.List[_ListBuffer__A]: ...
    def update(self, n: int, x: _ListBuffer__A) -> None: ...
    @typing.overload
    def view(self) -> scala.collection.SeqView[_ListBuffer__A, scala.collection.Seq[_ListBuffer__A]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> scala.collection.SeqView[_ListBuffer__A, scala.collection.Seq[_ListBuffer__A]]: ...

_PriorityQueue__ResizableArrayAccess__A = typing.TypeVar('_PriorityQueue__ResizableArrayAccess__A')  # <A>
_PriorityQueue__A = typing.TypeVar('_PriorityQueue__A')  # <A>
class PriorityQueue(AbstractIterable[_PriorityQueue__A], scala.collection.generic.GenericOrderedTraversableTemplate[_PriorityQueue__A, 'PriorityQueue'], Builder[_PriorityQueue__A, 'PriorityQueue'[_PriorityQueue__A]], scala.Serializable, scala.Cloneable, typing.Generic[_PriorityQueue__A]):
    def __init__(self, ord: scala.math.Ordering[_PriorityQueue__A]): ...
    @typing.overload
    def $plus$eq(self, elem1: _PriorityQueue__A, elem2: _PriorityQueue__A, elems: scala.collection.Seq[_PriorityQueue__A]) -> scala.collection.generic.Growable[_PriorityQueue__A]: ...
    @typing.overload
    def $plus$eq(self, elem: _PriorityQueue__A) -> 'PriorityQueue'[_PriorityQueue__A]: ...
    _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
    _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
    @typing.overload
    def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus_0__B], bf: scala.collection.generic.CanBuildFrom[scala.collection.Traversable[_PriorityQueue__A], _.plus.plus_0__B, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
    @typing.overload
    def $plus$plus(self, xs: scala.collection.GenTraversableOnce[_PriorityQueue__A]) -> 'PriorityQueue'[_PriorityQueue__A]: ...
    def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[_PriorityQueue__A]) -> 'PriorityQueue'[_PriorityQueue__A]: ...
    @staticmethod
    def apply(elems: scala.collection.Seq, ord: scala.math.Ordering) -> scala.collection.Traversable: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom(ord: scala.math.Ordering[_canBuildFrom__A]) -> scala.collection.generic.CanBuildFrom['PriorityQueue'[typing.Any], _canBuildFrom__A, 'PriorityQueue'[_canBuildFrom__A]]: ...
    def clear(self) -> None: ...
    def clone(self) -> 'PriorityQueue'[_PriorityQueue__A]: ...
    def dequeue(self) -> _PriorityQueue__A: ...
    _dequeueAll__A1 = typing.TypeVar('_dequeueAll__A1')  # <A1>
    _dequeueAll__That = typing.TypeVar('_dequeueAll__That')  # <That>
    def dequeueAll(self, bf: scala.collection.generic.CanBuildFrom[typing.Any, _dequeueAll__A1, _dequeueAll__That]) -> _dequeueAll__That: ...
    @staticmethod
    def empty(evidence$1: scala.math.Ordering) -> scala.collection.Traversable: ...
    def enqueue(self, elems: scala.collection.Seq[_PriorityQueue__A]) -> None: ...
    def fixDown(self, as_: typing.List[typing.Any], m: int, n: int) -> bool: ...
    def fixUp(self, as_: typing.List[typing.Any], m: int) -> None: ...
    _genericOrderedBuilder__B = typing.TypeVar('_genericOrderedBuilder__B')  # <B>
    def genericOrderedBuilder(self, ord: scala.math.Ordering[_genericOrderedBuilder__B]) -> Builder[_genericOrderedBuilder__B, 'PriorityQueue'[_genericOrderedBuilder__B]]: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[_PriorityQueue__A, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[_PriorityQueue__A]]: ...
    def hashCode(self) -> int: ...
    def head(self) -> _PriorityQueue__A: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> scala.collection.Iterator[_PriorityQueue__A]: ...
    def length(self) -> int: ...
    _mapResult__NewTo = typing.TypeVar('_mapResult__NewTo')  # <NewTo>
    def mapResult(self, f: scala.Function1['PriorityQueue'[_PriorityQueue__A], _mapResult__NewTo]) -> Builder[_PriorityQueue__A, _mapResult__NewTo]: ...
    def newBuilder(self) -> Builder[_PriorityQueue__A, 'PriorityQueue'[_PriorityQueue__A]]: ...
    def ord(self) -> scala.math.Ordering[_PriorityQueue__A]: ...
    def orderedCompanion(self) -> 'PriorityQueue.': ...
    def repr(self) -> 'PriorityQueue'[_PriorityQueue__A]: ...
    def result(self) -> 'PriorityQueue'[_PriorityQueue__A]: ...
    def reverse(self) -> 'PriorityQueue'[_PriorityQueue__A]: ...
    def reverseIterator(self) -> scala.collection.Iterator[_PriorityQueue__A]: ...
    def scala$collection$mutable$PriorityQueue$$heapify(self, from_: int) -> None: ...
    def scala$collection$mutable$PriorityQueue$$resarr(self) -> 'PriorityQueue.ResizableArrayAccess'[_PriorityQueue__A]: ...
    def scala$collection$mutable$PriorityQueue$$toA(self, x: typing.Any) -> _PriorityQueue__A: ...
    def scala$collection$mutable$PriorityQueue$$unsafeAdd(self, elem: _PriorityQueue__A) -> None: ...
    def size(self) -> int: ...
    @typing.overload
    def sizeHint(self, size: int) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any], delta: int) -> None: ...
    def sizeHintBounded(self, size: int, boundingColl: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
    def thisCollection(self) -> scala.collection.Iterable[_PriorityQueue__A]: ...
    def toCollection(self, repr: typing.Any) -> scala.collection.Iterable: ...
    def toIterable(self) -> scala.collection.Iterable[_PriorityQueue__A]: ...
    def toList(self) -> scala.collection.immutable.List[_PriorityQueue__A]: ...
    def toQueue(self) -> 'Queue'[_PriorityQueue__A]: ...
    def toString(self) -> str: ...
    def toTraversable(self) -> scala.collection.Traversable[_PriorityQueue__A]: ...
    @typing.overload
    def view(self) -> scala.collection.IterableView[_PriorityQueue__A, scala.collection.Iterable[_PriorityQueue__A]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> scala.collection.IterableView[_PriorityQueue__A, scala.collection.Iterable[_PriorityQueue__A]]: ...
    class ResizableArrayAccess(AbstractSeq[typing.Any], ResizableArray[typing.Any], scala.Serializable, typing.Generic[_PriorityQueue__ResizableArrayAccess__A]):
        $outer: 'PriorityQueue' = ...
        def __init__(self, $outer: 'PriorityQueue'): ...
        def apply(self, idx: int) -> typing.Any: ...
        def array(self) -> typing.List[typing.Any]: ...
        def array_$eq(self, x$1: typing.List[typing.Any]) -> None: ...
        def companion(self) -> scala.collection.generic.GenericCompanion[ResizableArray]: ...
        def copy(self, m: int, n: int, len: int) -> None: ...
        _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
        _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
        _copyToArray_2__B = typing.TypeVar('_copyToArray_2__B')  # <B>
        @typing.overload
        def copyToArray(self, xs: typing.Any) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
        def drop(self, n: int) -> typing.Any: ...
        def dropRight(self, n: int) -> typing.Any: ...
        def dropWhile(self, p: scala.Function1) -> typing.Any: ...
        _endsWith__B = typing.TypeVar('_endsWith__B')  # <B>
        def endsWith(self, that: scala.collection.GenSeq[_endsWith__B]) -> bool: ...
        def ensureSize(self, n: int) -> None: ...
        def exists(self, p: scala.Function1[typing.Any, typing.Any]) -> bool: ...
        def find(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.Option[typing.Any]: ...
        _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
        def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, typing.Any, _foldLeft__B]) -> _foldLeft__B: ...
        _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
        def foldRight(self, z: _foldRight__B, op: scala.Function2[typing.Any, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
        def forall(self, p: scala.Function1[typing.Any, typing.Any]) -> bool: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[typing.Any, _foreach__U]) -> None: ...
        _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
        def groupBy(self, f: scala.Function1[typing.Any, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[typing.Any]]: ...
        def hashCode(self) -> int: ...
        def head(self) -> typing.Any: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[typing.Any, typing.Any], from_: int) -> int: ...
        def init(self) -> typing.Any: ...
        def initialSize(self) -> int: ...
        def isDefinedAt(self, idx: int) -> bool: ...
        def isEmpty(self) -> bool: ...
        def iterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def last(self) -> typing.Any: ...
        @typing.overload
        def lastIndexWhere(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        @typing.overload
        def lastIndexWhere(self, p: scala.Function1[typing.Any, typing.Any], end: int) -> int: ...
        def length(self) -> int: ...
        def lengthCompare(self, len: int) -> int: ...
        def p_array(self) -> typing.List[typing.Any]: ...
        def p_ensureSize(self, n: int) -> None: ...
        def p_size0(self) -> int: ...
        def p_size0_$eq(self, s: int) -> None: ...
        def p_swap(self, a: int, b: int) -> None: ...
        _reduceLeft__B = typing.TypeVar('_reduceLeft__B')  # <B>
        def reduceLeft(self, op: scala.Function2[_reduceLeft__B, typing.Any, _reduceLeft__B]) -> _reduceLeft__B: ...
        _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
        def reduceRight(self, op: scala.Function2[typing.Any, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
        def reduceToSize(self, sz: int) -> None: ...
        def reverse(self) -> typing.Any: ...
        def reverseIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        _sameElements__B = typing.TypeVar('_sameElements__B')  # <B>
        def sameElements(self, that: scala.collection.GenIterable[_sameElements__B]) -> bool: ...
        def segmentLength(self, p: scala.Function1[typing.Any, typing.Any], from_: int) -> int: ...
        def seq(self) -> IndexedSeq[typing.Any]: ...
        def size0(self) -> int: ...
        def size0_$eq(self, x$1: int) -> None: ...
        def sizeHintIfCheap(self) -> int: ...
        def slice(self, from_: int, until: int) -> typing.Any: ...
        def span(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.Tuple2[ResizableArray[typing.Any], ResizableArray[typing.Any]]: ...
        def splitAt(self, n: int) -> scala.Tuple2[ResizableArray[typing.Any], ResizableArray[typing.Any]]: ...
        _startsWith_0__B = typing.TypeVar('_startsWith_0__B')  # <B>
        _startsWith_1__B = typing.TypeVar('_startsWith_1__B')  # <B>
        @typing.overload
        def startsWith(self, that: scala.collection.GenSeq[_startsWith_0__B]) -> bool: ...
        @typing.overload
        def startsWith(self, that: scala.collection.GenSeq[_startsWith_1__B], offset: int) -> bool: ...
        def swap(self, a: int, b: int) -> None: ...
        def tail(self) -> typing.Any: ...
        def take(self, n: int) -> typing.Any: ...
        def takeRight(self, n: int) -> typing.Any: ...
        def takeWhile(self, p: scala.Function1) -> typing.Any: ...
        def thisCollection(self) -> IndexedSeq[typing.Any]: ...
        _toBuffer__A1 = typing.TypeVar('_toBuffer__A1')  # <A1>
        def toBuffer(self) -> Buffer[_toBuffer__A1]: ...
        def toCollection(self, repr: typing.Any) -> IndexedSeq: ...
        def toIterable(self) -> scala.collection.Iterable[typing.Any]: ...
        def toList(self) -> scala.collection.immutable.List[typing.Any]: ...
        def toSeq(self) -> scala.collection.Seq[typing.Any]: ...
        def toTraversable(self) -> scala.collection.Traversable[typing.Any]: ...
        def update(self, idx: int, elem: typing.Any) -> None: ...
        @typing.overload
        def view(self) -> 'IndexedSeqView'[typing.Any, ResizableArray[typing.Any]]: ...
        @typing.overload
        def view(self, from_: int, until: int) -> 'IndexedSeqView'[typing.Any, ResizableArray[typing.Any]]: ...
        _zip__A1 = typing.TypeVar('_zip__A1')  # <A1>
        _zip__B = typing.TypeVar('_zip__B')  # <B>
        _zip__That = typing.TypeVar('_zip__That')  # <That>
        def zip(self, that: scala.collection.GenIterable[_zip__B], bf: scala.collection.generic.CanBuildFrom[ResizableArray[typing.Any], scala.Tuple2[_zip__A1, _zip__B], _zip__That]) -> _zip__That: ...
        _zipWithIndex__A1 = typing.TypeVar('_zipWithIndex__A1')  # <A1>
        _zipWithIndex__That = typing.TypeVar('_zipWithIndex__That')  # <That>
        def zipWithIndex(self, bf: scala.collection.generic.CanBuildFrom[ResizableArray[typing.Any], scala.Tuple2[_zipWithIndex__A1, typing.Any], _zipWithIndex__That]) -> _zipWithIndex__That: ...
    class : ...

_Queue__A = typing.TypeVar('_Queue__A')  # <A>
class Queue(MutableList[_Queue__A], typing.Generic[_Queue__A]):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, fst: LinkedList[_Queue__A], lst: LinkedList[_Queue__A], lng: int): ...
    @staticmethod
    def ReusableCBF() -> scala.collection.generic.GenTraversableFactory.GenericCanBuildFrom[scala.runtime.Nothing.]: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['Queue'[typing.Any], _canBuildFrom__A, 'Queue'[_canBuildFrom__A]]: ...
    def clone(self) -> 'Queue'[_Queue__A]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['Queue']: ...
    @staticmethod
    def concat(xss: scala.collection.Seq) -> scala.collection.GenTraversable: ...
    def dequeue(self) -> _Queue__A: ...
    def dequeueAll(self, p: scala.Function1[_Queue__A, typing.Any]) -> Seq[_Queue__A]: ...
    def dequeueFirst(self, p: scala.Function1[_Queue__A, typing.Any]) -> scala.Option[_Queue__A]: ...
    def drop(self, n: int) -> scala.collection.LinearSeqOptimized: ...
    def dropRight(self, n: int) -> scala.collection.LinearSeqOptimized: ...
    @staticmethod
    def empty() -> scala.collection.GenTraversable: ...
    def enqueue(self, elems: scala.collection.Seq[_Queue__A]) -> None: ...
    def extractFirst(self, start: LinkedList[_Queue__A], p: scala.Function1[_Queue__A, typing.Any]) -> scala.Option[LinkedList[_Queue__A]]: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, n5: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    def front(self) -> _Queue__A: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[_Queue__A, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[_Queue__A]]: ...
    def isDefinedAt(self, x: int) -> bool: ...
    @staticmethod
    def iterate(start: typing.Any, len: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    def newBuilder(self) -> Builder[_Queue__A, 'Queue'[_Queue__A]]: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, step: typing.Any, evidence$2: scala.math.Integral) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, evidence$1: scala.math.Integral) -> scala.collection.GenTraversable: ...
    def seq(self) -> LinearSeq[_Queue__A]: ...
    def slice(self, from_: int, until: int) -> scala.collection.LinearSeqOptimized: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, n5: int, f: scala.Function5) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, f: scala.Function4) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, f: scala.Function3) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, f: scala.Function2) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    def tail(self) -> 'Queue'[_Queue__A]: ...
    def take(self, n: int) -> scala.collection.LinearSeqOptimized: ...
    def takeWhile(self, p: scala.Function1) -> scala.collection.LinearSeqOptimized: ...
    def thisCollection(self) -> scala.collection.LinearSeq[_Queue__A]: ...
    def toCollection(self, repr: scala.collection.LinearSeqLike) -> scala.collection.LinearSeq: ...
    def toIterable(self) -> scala.collection.Iterable[_Queue__A]: ...
    def toSeq(self) -> scala.collection.Seq[_Queue__A]: ...
    def toTraversable(self) -> scala.collection.Traversable[_Queue__A]: ...
    @staticmethod
    def unapplySeq(x: scala.collection.Seq) -> scala.Some: ...
    @typing.overload
    def view(self) -> scala.collection.SeqView[_Queue__A, scala.collection.Seq[_Queue__A]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> scala.collection.SeqView[_Queue__A, scala.collection.Seq[_Queue__A]]: ...

_SynchronizedStack__A = typing.TypeVar('_SynchronizedStack__A')  # <A>
class SynchronizedStack(Stack[_SynchronizedStack__A], typing.Generic[_SynchronizedStack__A]):
    def __init__(self): ...
    def clear(self) -> None: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> scala.collection.Iterator[_SynchronizedStack__A]: ...
    def pop(self) -> _SynchronizedStack__A: ...
    @typing.overload
    def push(self, elem: _SynchronizedStack__A) -> 'SynchronizedStack'[_SynchronizedStack__A]: ...
    @typing.overload
    def push(self, elem1: _SynchronizedStack__A, elem2: _SynchronizedStack__A, elems: scala.collection.Seq[_SynchronizedStack__A]) -> 'SynchronizedStack'[_SynchronizedStack__A]: ...
    def pushAll(self, xs: scala.collection.TraversableOnce[_SynchronizedStack__A]) -> 'SynchronizedStack'[_SynchronizedStack__A]: ...
    def toList(self) -> scala.collection.immutable.List[_SynchronizedStack__A]: ...
    def toString(self) -> str: ...
    def top(self) -> _SynchronizedStack__A: ...

_UnrolledBuffer__Unrolled__T = typing.TypeVar('_UnrolledBuffer__Unrolled__T')  # <T>
_UnrolledBuffer__T = typing.TypeVar('_UnrolledBuffer__T')  # <T>
class UnrolledBuffer(AbstractBuffer[_UnrolledBuffer__T], scala.collection.generic.GenericClassTagTraversableTemplate[_UnrolledBuffer__T, 'UnrolledBuffer'], Builder[_UnrolledBuffer__T, 'UnrolledBuffer'[_UnrolledBuffer__T]], scala.Serializable, typing.Generic[_UnrolledBuffer__T]):
    serialVersionUID: typing.ClassVar[int] = ...
    def __init__(self, tag: scala.reflect.ClassTag[_UnrolledBuffer__T]): ...
    @typing.overload
    def $minus(self, elem: typing.Any) -> Buffer[typing.Any]: ...
    @typing.overload
    def $minus(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> Buffer[typing.Any]: ...
    @typing.overload
    def $minus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> scala.collection.generic.Shrinkable[typing.Any]: ...
    @typing.overload
    def $minus$eq(self, x: typing.Any) -> Buffer: ...
    def $minus$minus(self, xs: scala.collection.GenTraversableOnce[typing.Any]) -> Buffer[typing.Any]: ...
    @typing.overload
    def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> scala.collection.generic.Growable[typing.Any]: ...
    @typing.overload
    def $plus$eq(self, elem: _UnrolledBuffer__T) -> 'UnrolledBuffer'[_UnrolledBuffer__T]: ...
    def $plus$eq$colon(self, elem: _UnrolledBuffer__T) -> 'UnrolledBuffer'[_UnrolledBuffer__T]: ...
    def apply(self, idx: int) -> _UnrolledBuffer__T: ...
    def calcNextLength(self, sz: int) -> int: ...
    _canBuildFrom__T = typing.TypeVar('_canBuildFrom__T')  # <T>
    @staticmethod
    def canBuildFrom(t: scala.reflect.ClassTag[_canBuildFrom__T]) -> scala.collection.generic.CanBuildFrom['UnrolledBuffer'[typing.Any], _canBuildFrom__T, 'UnrolledBuffer'[_canBuildFrom__T]]: ...
    def classManifestCompanion(self) -> scala.collection.generic.GenericClassTagCompanion['UnrolledBuffer']: ...
    def classTagCompanion(self) -> 'UnrolledBuffer.': ...
    def clear(self) -> None: ...
    def clone(self) -> 'UnrolledBuffer'[_UnrolledBuffer__T]: ...
    def concat(self, that: 'UnrolledBuffer'[_UnrolledBuffer__T]) -> 'UnrolledBuffer'[_UnrolledBuffer__T]: ...
    @staticmethod
    def empty(evidence$1: scala.reflect.ClassTag) -> scala.collection.Traversable: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_UnrolledBuffer__T, _foreach__U]) -> None: ...
    _genericClassManifestBuilder__B = typing.TypeVar('_genericClassManifestBuilder__B')  # <B>
    def genericClassManifestBuilder(self, manifest: scala.reflect.ClassTag[_genericClassManifestBuilder__B]) -> Builder[_genericClassManifestBuilder__B, 'UnrolledBuffer'[_genericClassManifestBuilder__B]]: ...
    _genericClassTagBuilder__B = typing.TypeVar('_genericClassTagBuilder__B')  # <B>
    def genericClassTagBuilder(self, tag: scala.reflect.ClassTag[_genericClassTagBuilder__B]) -> Builder[_genericClassTagBuilder__B, 'UnrolledBuffer'[_genericClassTagBuilder__B]]: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[typing.Any, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[typing.Any]]: ...
    def headPtr(self) -> 'UnrolledBuffer.Unrolled'[_UnrolledBuffer__T]: ...
    def headPtr_$eq(self, head: 'UnrolledBuffer.Unrolled'[_UnrolledBuffer__T]) -> None: ...
    def insertAll(self, idx: int, elems: scala.collection.Traversable[_UnrolledBuffer__T]) -> None: ...
    def isDefinedAt(self, idx: int) -> bool: ...
    def iterator(self) -> scala.collection.Iterator[_UnrolledBuffer__T]: ...
    def lastPtr(self) -> 'UnrolledBuffer.Unrolled'[_UnrolledBuffer__T]: ...
    def lastPtr_$eq(self, last: 'UnrolledBuffer.Unrolled'[_UnrolledBuffer__T]) -> None: ...
    def length(self) -> int: ...
    _mapResult__NewTo = typing.TypeVar('_mapResult__NewTo')  # <NewTo>
    def mapResult(self, f: scala.Function1['UnrolledBuffer'[_UnrolledBuffer__T], _mapResult__NewTo]) -> Builder[_UnrolledBuffer__T, _mapResult__NewTo]: ...
    def newBuilder(self) -> 'UnrolledBuffer'[_UnrolledBuffer__T]: ...
    def newUnrolled(self) -> 'UnrolledBuffer.Unrolled'[_UnrolledBuffer__T]: ...
    @typing.overload
    def remove(self, idx: int) -> _UnrolledBuffer__T: ...
    @typing.overload
    def remove(self, n: int, count: int) -> None: ...
    def repr(self) -> typing.Any: ...
    def result(self) -> 'UnrolledBuffer'[_UnrolledBuffer__T]: ...
    def scala$collection$mutable$UnrolledBuffer$$headptr(self) -> 'UnrolledBuffer.Unrolled'[_UnrolledBuffer__T]: ...
    def seq(self) -> Seq[typing.Any]: ...
    @typing.overload
    def sizeHint(self, size: int) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any], delta: int) -> None: ...
    def sizeHintBounded(self, size: int, boundingColl: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
    def size_$eq(self, s: int) -> None: ...
    def stringPrefix(self) -> str: ...
    def tag(self) -> scala.reflect.ClassTag[_UnrolledBuffer__T]: ...
    def thisCollection(self) -> scala.collection.Seq[typing.Any]: ...
    def toCollection(self, repr: typing.Any) -> scala.collection.Seq: ...
    def toIterable(self) -> scala.collection.Iterable[typing.Any]: ...
    def toSeq(self) -> scala.collection.Seq[typing.Any]: ...
    def toTraversable(self) -> scala.collection.Traversable[typing.Any]: ...
    def update(self, idx: int, newelem: _UnrolledBuffer__T) -> None: ...
    @typing.overload
    def view(self) -> scala.collection.SeqView[typing.Any, scala.collection.Seq[typing.Any]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> scala.collection.SeqView[typing.Any, scala.collection.Seq[typing.Any]]: ...
    @staticmethod
    def waterline() -> int: ...
    @staticmethod
    def waterlineDelim() -> int: ...
    class Unrolled(typing.Generic[_UnrolledBuffer__Unrolled__T]):
        @typing.overload
        def __init__(self, size: int, array: typing.Any, next: 'UnrolledBuffer.Unrolled'[_UnrolledBuffer__Unrolled__T], buff: 'UnrolledBuffer'[_UnrolledBuffer__Unrolled__T], evidence$1: scala.reflect.ClassTag[_UnrolledBuffer__Unrolled__T]): ...
        @typing.overload
        def __init__(self, b: 'UnrolledBuffer'[_UnrolledBuffer__Unrolled__T], evidence$3: scala.reflect.ClassTag[_UnrolledBuffer__Unrolled__T]): ...
        @typing.overload
        def __init__(self, evidence$2: scala.reflect.ClassTag[_UnrolledBuffer__Unrolled__T]): ...
        def append(self, elem: _UnrolledBuffer__Unrolled__T) -> 'UnrolledBuffer.Unrolled'[_UnrolledBuffer__Unrolled__T]: ...
        def apply(self, idx: int) -> _UnrolledBuffer__Unrolled__T: ...
        def array(self) -> typing.Any: ...
        def array_$eq(self, x$1: typing.Any) -> None: ...
        def bind(self, thathead: 'UnrolledBuffer.Unrolled'[_UnrolledBuffer__Unrolled__T]) -> bool: ...
        def buff(self) -> 'UnrolledBuffer'[_UnrolledBuffer__Unrolled__T]: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[_UnrolledBuffer__Unrolled__T, _foreach__U]) -> None: ...
        def insertAll(self, idx: int, t: scala.collection.Traversable[_UnrolledBuffer__Unrolled__T], buffer: 'UnrolledBuffer'[_UnrolledBuffer__Unrolled__T]) -> None: ...
        def locate(self, idx: int) -> 'UnrolledBuffer.Unrolled'[_UnrolledBuffer__Unrolled__T]: ...
        def next(self) -> 'UnrolledBuffer.Unrolled'[_UnrolledBuffer__Unrolled__T]: ...
        def next_$eq(self, x$1: 'UnrolledBuffer.Unrolled'[_UnrolledBuffer__Unrolled__T]) -> None: ...
        def prepend(self, elem: _UnrolledBuffer__Unrolled__T) -> 'UnrolledBuffer.Unrolled'[_UnrolledBuffer__Unrolled__T]: ...
        def remove(self, idx: int, buffer: 'UnrolledBuffer'[_UnrolledBuffer__Unrolled__T]) -> _UnrolledBuffer__Unrolled__T: ...
        def size(self) -> int: ...
        def size_$eq(self, x$1: int) -> None: ...
        def toString(self) -> str: ...
        def tryMergeWithNext(self) -> bool: ...
        def update(self, idx: int, newelem: _UnrolledBuffer__Unrolled__T) -> None: ...
    class Unrolled$:
        MODULE$: typing.ClassVar['UnrolledBuffer.Unrolled.'] = ...
        def __init__(self): ...
        _$lessinit$greater$default$4__T = typing.TypeVar('_$lessinit$greater$default$4__T')  # <T>
        def $lessinit$greater$default$4(self) -> scala.runtime.Null.: ...
    class : ...

_DoublingUnrolledBuffer__T = typing.TypeVar('_DoublingUnrolledBuffer__T')  # <T>
class DoublingUnrolledBuffer(UnrolledBuffer[_DoublingUnrolledBuffer__T], typing.Generic[_DoublingUnrolledBuffer__T]):
    def __init__(self, t: scala.reflect.ClassTag[_DoublingUnrolledBuffer__T]): ...
    def calcNextLength(self, sz: int) -> int: ...
    def newUnrolled(self) -> UnrolledBuffer.Unrolled[_DoublingUnrolledBuffer__T]: ...

_PriorityQueueProxy__A = typing.TypeVar('_PriorityQueueProxy__A')  # <A>
class PriorityQueueProxy(PriorityQueue[_PriorityQueueProxy__A], scala.Proxy, typing.Generic[_PriorityQueueProxy__A]):
    def __init__(self, ord: scala.math.Ordering[_PriorityQueueProxy__A]): ...
    @typing.overload
    def $plus$eq(self, elem1: _PriorityQueueProxy__A, elem2: _PriorityQueueProxy__A, elems: scala.collection.Seq[_PriorityQueueProxy__A]) -> scala.collection.generic.Growable[_PriorityQueueProxy__A]: ...
    @typing.overload
    def $plus$eq(self, elem: _PriorityQueueProxy__A) -> 'PriorityQueueProxy'[_PriorityQueueProxy__A]: ...
    def $plus$plus$eq(self, it: scala.collection.TraversableOnce[_PriorityQueueProxy__A]) -> 'PriorityQueueProxy'[_PriorityQueueProxy__A]: ...
    def clear(self) -> None: ...
    def clone(self) -> PriorityQueue[_PriorityQueueProxy__A]: ...
    def dequeue(self) -> _PriorityQueueProxy__A: ...
    def enqueue(self, elems: scala.collection.Seq[_PriorityQueueProxy__A]) -> None: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def head(self) -> _PriorityQueueProxy__A: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> scala.collection.Iterator[_PriorityQueueProxy__A]: ...
    def length(self) -> int: ...
    @typing.overload
    def self(self) -> typing.Any: ...
    @typing.overload
    def self(self) -> PriorityQueue[_PriorityQueueProxy__A]: ...
    def toQueue(self) -> Queue[_PriorityQueueProxy__A]: ...
    def toString(self) -> str: ...

_SynchronizedPriorityQueue__A = typing.TypeVar('_SynchronizedPriorityQueue__A')  # <A>
class SynchronizedPriorityQueue(PriorityQueue[_SynchronizedPriorityQueue__A], typing.Generic[_SynchronizedPriorityQueue__A]):
    def __init__(self, ord: scala.math.Ordering[_SynchronizedPriorityQueue__A]): ...
    @typing.overload
    def $plus$eq(self, elem1: _SynchronizedPriorityQueue__A, elem2: _SynchronizedPriorityQueue__A, elems: scala.collection.Seq[_SynchronizedPriorityQueue__A]) -> scala.collection.generic.Growable[_SynchronizedPriorityQueue__A]: ...
    @typing.overload
    def $plus$eq(self, elem: _SynchronizedPriorityQueue__A) -> 'SynchronizedPriorityQueue'[_SynchronizedPriorityQueue__A]: ...
    def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[_SynchronizedPriorityQueue__A]) -> 'SynchronizedPriorityQueue'[_SynchronizedPriorityQueue__A]: ...
    def clear(self) -> None: ...
    def dequeue(self) -> _SynchronizedPriorityQueue__A: ...
    def enqueue(self, elems: scala.collection.Seq[_SynchronizedPriorityQueue__A]) -> None: ...
    def equals(self, that: typing.Any) -> bool: ...
    def head(self) -> _SynchronizedPriorityQueue__A: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> scala.collection.Iterator[_SynchronizedPriorityQueue__A]: ...
    def toString(self) -> str: ...

_SynchronizedQueue__A = typing.TypeVar('_SynchronizedQueue__A')  # <A>
class SynchronizedQueue(Queue[_SynchronizedQueue__A], typing.Generic[_SynchronizedQueue__A]):
    def __init__(self): ...
    @typing.overload
    def $plus$eq(self, elem1: _SynchronizedQueue__A, elem2: _SynchronizedQueue__A, elems: scala.collection.Seq[_SynchronizedQueue__A]) -> scala.collection.generic.Growable[_SynchronizedQueue__A]: ...
    @typing.overload
    def $plus$eq(self, elem: _SynchronizedQueue__A) -> 'SynchronizedQueue'[_SynchronizedQueue__A]: ...
    def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[_SynchronizedQueue__A]) -> 'SynchronizedQueue'[_SynchronizedQueue__A]: ...
    def clear(self) -> None: ...
    def dequeue(self) -> _SynchronizedQueue__A: ...
    def dequeueAll(self, p: scala.Function1[_SynchronizedQueue__A, typing.Any]) -> Seq[_SynchronizedQueue__A]: ...
    def dequeueFirst(self, p: scala.Function1[_SynchronizedQueue__A, typing.Any]) -> scala.Option[_SynchronizedQueue__A]: ...
    def enqueue(self, elems: scala.collection.Seq[_SynchronizedQueue__A]) -> None: ...
    def equals(self, that: typing.Any) -> bool: ...
    def front(self) -> _SynchronizedQueue__A: ...
    def isEmpty(self) -> bool: ...
    def toString(self) -> str: ...

_AbstractMap__K = typing.TypeVar('_AbstractMap__K')  # <K>
_AbstractMap__V = typing.TypeVar('_AbstractMap__V')  # <V>
class AbstractMap(scala.collection.AbstractMap[_AbstractMap__K, _AbstractMap__V], scala.collection.mutable.Map[_AbstractMap__K, _AbstractMap__V], typing.Generic[_AbstractMap__K, _AbstractMap__V]):
    def __init__(self): ...
    @typing.overload
    def $minus(self, key: _AbstractMap__K) -> 'Map'[_AbstractMap__K, _AbstractMap__V]: ...
    @typing.overload
    def $minus(self, elem1: _AbstractMap__K, elem2: _AbstractMap__K, elems: scala.collection.Seq[_AbstractMap__K]) -> 'Map'[_AbstractMap__K, _AbstractMap__V]: ...
    @typing.overload
    def $minus$eq(self, elem: typing.Any) -> scala.collection.generic.Shrinkable[typing.Any]: ...
    @typing.overload
    def $minus$eq(self, key: _AbstractMap__K) -> MapLike[_AbstractMap__K, _AbstractMap__V, MapLike]: ...
    @typing.overload
    def $minus$eq(self, elem1: _AbstractMap__K, elem2: _AbstractMap__K, elems: scala.collection.Seq[_AbstractMap__K]) -> scala.collection.generic.Shrinkable[_AbstractMap__K]: ...
    def $minus$minus(self, xs: scala.collection.GenTraversableOnce[_AbstractMap__K]) -> 'Map'[_AbstractMap__K, _AbstractMap__V]: ...
    def $minus$minus$eq(self, xs: scala.collection.TraversableOnce[_AbstractMap__K]) -> scala.collection.generic.Shrinkable[_AbstractMap__K]: ...
    _$plus_0__V1 = typing.TypeVar('_$plus_0__V1')  # <V1>
    _$plus_1__V1 = typing.TypeVar('_$plus_1__V1')  # <V1>
    @typing.overload
    def $plus(self, kv: scala.Tuple2[_AbstractMap__K, _.plus_0__V1]) -> 'Map'[_AbstractMap__K, _.plus_0__V1]: ...
    @typing.overload
    def $plus(self, elem1: scala.Tuple2[_AbstractMap__K, _.plus_1__V1], elem2: scala.Tuple2[_AbstractMap__K, _.plus_1__V1], elems: scala.collection.Seq[scala.Tuple2[_AbstractMap__K, _.plus_1__V1]]) -> 'Map'[_AbstractMap__K, _.plus_1__V1]: ...
    @typing.overload
    def $plus$eq(self, elem: typing.Any) -> scala.collection.generic.Growable[typing.Any]: ...
    @typing.overload
    def $plus$eq(self, elem: typing.Any) -> Builder[typing.Any, typing.Any]: ...
    @typing.overload
    def $plus$eq(self, kv: scala.Tuple2[_AbstractMap__K, _AbstractMap__V]) -> MapLike[_AbstractMap__K, _AbstractMap__V, MapLike]: ...
    @typing.overload
    def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq) -> scala.collection.generic.Growable: ...
    _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
    _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
    _$plus$plus_1__V1 = typing.TypeVar('_$plus$plus_1__V1')  # <V1>
    @typing.overload
    def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus_0__B], bf: scala.collection.generic.CanBuildFrom[scala.collection.Traversable[typing.Any], _.plus.plus_0__B, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
    @typing.overload
    def $plus$plus(self, xs: scala.collection.GenTraversableOnce[scala.Tuple2[_AbstractMap__K, _.plus.plus_1__V1]]) -> 'Map'[_AbstractMap__K, _.plus.plus_1__V1]: ...
    def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[scala.Tuple2[_AbstractMap__K, _AbstractMap__V]]) -> scala.collection.generic.Growable[scala.Tuple2[_AbstractMap__K, _AbstractMap__V]]: ...
    def clear(self) -> None: ...
    def clone(self) -> 'Map'[_AbstractMap__K, _AbstractMap__V]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion[Iterable]: ...
    def empty(self) -> 'Map'[_AbstractMap__K, _AbstractMap__V]: ...
    def filterKeys(self, p: scala.Function1[_AbstractMap__K, typing.Any]) -> scala.collection.Map[_AbstractMap__K, _AbstractMap__V]: ...
    def filterNot(self, p: scala.Function1[scala.Tuple2[_AbstractMap__K, _AbstractMap__V], typing.Any]) -> scala.collection.Map[_AbstractMap__K, _AbstractMap__V]: ...
    def getOrElseUpdate(self, key: _AbstractMap__K, op: scala.Function0[_AbstractMap__V]) -> _AbstractMap__V: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[typing.Any, typing.Any]) -> scala.collection.immutable.Map[typing.Any, scala.collection.Traversable[typing.Any]]: ...
    def keySet(self) -> scala.collection.Set[_AbstractMap__K]: ...
    def keys(self) -> scala.collection.Iterable[_AbstractMap__K]: ...
    _mapResult__NewTo = typing.TypeVar('_mapResult__NewTo')  # <NewTo>
    def mapResult(self, f: scala.Function1['Map'[_AbstractMap__K, _AbstractMap__V], _mapResult__NewTo]) -> Builder[scala.Tuple2[_AbstractMap__K, _AbstractMap__V], _mapResult__NewTo]: ...
    _mapValues__W = typing.TypeVar('_mapValues__W')  # <W>
    def mapValues(self, f: scala.Function1[_AbstractMap__V, _mapValues__W]) -> scala.collection.Map[_AbstractMap__K, _mapValues__W]: ...
    def newBuilder(self) -> Builder[scala.Tuple2[_AbstractMap__K, _AbstractMap__V], 'Map'[_AbstractMap__K, _AbstractMap__V]]: ...
    def parCombiner(self) -> scala.collection.parallel.Combiner[scala.Tuple2[_AbstractMap__K, _AbstractMap__V], scala.collection.parallel.mutable.ParMap[_AbstractMap__K, _AbstractMap__V]]: ...
    def put(self, key: _AbstractMap__K, value: _AbstractMap__V) -> scala.Option[_AbstractMap__V]: ...
    def remove(self, key: _AbstractMap__K) -> scala.Option[_AbstractMap__V]: ...
    def repr(self) -> typing.Any: ...
    def result(self) -> 'Map'[_AbstractMap__K, _AbstractMap__V]: ...
    def retain(self, p: scala.Function2[_AbstractMap__K, _AbstractMap__V, typing.Any]) -> MapLike[_AbstractMap__K, _AbstractMap__V, 'Map'[_AbstractMap__K, _AbstractMap__V]]: ...
    def seq(self) -> 'Map'[_AbstractMap__K, _AbstractMap__V]: ...
    @typing.overload
    def sizeHint(self, size: int) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any], delta: int) -> None: ...
    def sizeHintBounded(self, size: int, boundingColl: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
    def thisCollection(self) -> scala.collection.Iterable[typing.Any]: ...
    def toCollection(self, repr: typing.Any) -> scala.collection.Iterable: ...
    def toIterable(self) -> scala.collection.Iterable[typing.Any]: ...
    def toSeq(self) -> scala.collection.Seq[scala.Tuple2[_AbstractMap__K, _AbstractMap__V]]: ...
    def toTraversable(self) -> scala.collection.Traversable[typing.Any]: ...
    def transform(self, f: scala.Function2[_AbstractMap__K, _AbstractMap__V, _AbstractMap__V]) -> MapLike[_AbstractMap__K, _AbstractMap__V, 'Map'[_AbstractMap__K, _AbstractMap__V]]: ...
    def update(self, key: _AbstractMap__K, value: _AbstractMap__V) -> None: ...
    _updated__V1 = typing.TypeVar('_updated__V1')  # <V1>
    def updated(self, key: _AbstractMap__K, value: _updated__V1) -> 'Map'[_AbstractMap__K, _updated__V1]: ...
    def values(self) -> scala.collection.Iterable[_AbstractMap__V]: ...
    @typing.overload
    def view(self) -> scala.collection.IterableView[typing.Any, scala.collection.Iterable[typing.Any]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> scala.collection.IterableView[typing.Any, scala.collection.Iterable[typing.Any]]: ...
    def withDefault(self, d: scala.Function1[_AbstractMap__K, _AbstractMap__V]) -> 'Map'[_AbstractMap__K, _AbstractMap__V]: ...
    def withDefaultValue(self, d: _AbstractMap__V) -> 'Map'[_AbstractMap__K, _AbstractMap__V]: ...

_AbstractSortedMap__A = typing.TypeVar('_AbstractSortedMap__A')  # <A>
_AbstractSortedMap__B = typing.TypeVar('_AbstractSortedMap__B')  # <B>
class AbstractSortedMap(AbstractMap[_AbstractSortedMap__A, _AbstractSortedMap__B], scala.collection.mutable.SortedMap[_AbstractSortedMap__A, _AbstractSortedMap__B], typing.Generic[_AbstractSortedMap__A, _AbstractSortedMap__B]):
    def __init__(self): ...
    @typing.overload
    def $minus(self, key: typing.Any) -> 'Map'[typing.Any, typing.Any]: ...
    @typing.overload
    def $minus(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> 'Map'[typing.Any, typing.Any]: ...
    def $minus$minus(self, xs: scala.collection.GenTraversableOnce[typing.Any]) -> 'Map'[typing.Any, typing.Any]: ...
    _$plus_0__B1 = typing.TypeVar('_$plus_0__B1')  # <B1>
    _$plus_1__B1 = typing.TypeVar('_$plus_1__B1')  # <B1>
    @typing.overload
    def $plus(self, kv: scala.Tuple2[_AbstractSortedMap__A, _.plus_0__B1]) -> 'SortedMap'[_AbstractSortedMap__A, _.plus_0__B1]: ...
    @typing.overload
    def $plus(self, elem1: scala.Tuple2[_AbstractSortedMap__A, _.plus_1__B1], elem2: scala.Tuple2[_AbstractSortedMap__A, _.plus_1__B1], elems: scala.collection.Seq[scala.Tuple2[_AbstractSortedMap__A, _.plus_1__B1]]) -> 'SortedMap'[_AbstractSortedMap__A, _.plus_1__B1]: ...
    _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
    _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
    _$plus$plus_1__B1 = typing.TypeVar('_$plus$plus_1__B1')  # <B1>
    @typing.overload
    def $plus$plus(self, that: scala.collection.GenTraversableOnce[typing.Any], bf: scala.collection.generic.CanBuildFrom[scala.collection.Traversable[_AbstractSortedMap__A], typing.Any, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
    @typing.overload
    def $plus$plus(self, xs: scala.collection.GenTraversableOnce[scala.Tuple2[_AbstractSortedMap__A, _.plus.plus_1__B1]]) -> 'SortedMap'[_AbstractSortedMap__A, _.plus.plus_1__B1]: ...
    def clone(self) -> 'Map'[typing.Any, typing.Any]: ...
    def compare(self, k0: _AbstractSortedMap__A, k1: _AbstractSortedMap__A) -> int: ...
    def empty(self) -> 'SortedMap'[_AbstractSortedMap__A, _AbstractSortedMap__B]: ...
    def filterKeys(self, p: scala.Function1[_AbstractSortedMap__A, typing.Any]) -> scala.collection.SortedMap[_AbstractSortedMap__A, _AbstractSortedMap__B]: ...
    def filterNot(self, p: scala.Function1[scala.Tuple2[typing.Any, typing.Any], typing.Any]) -> scala.collection.Map[typing.Any, typing.Any]: ...
    def firstKey(self) -> _AbstractSortedMap__A: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[_AbstractSortedMap__A, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[_AbstractSortedMap__A]]: ...
    def hasAll(self, j: scala.collection.Iterator[_AbstractSortedMap__A]) -> bool: ...
    def keySet(self) -> scala.collection.SortedSet[_AbstractSortedMap__A]: ...
    def keys(self) -> scala.collection.Iterable[typing.Any]: ...
    def lastKey(self) -> _AbstractSortedMap__A: ...
    _mapValues__C = typing.TypeVar('_mapValues__C')  # <C>
    def mapValues(self, f: scala.Function1[_AbstractSortedMap__B, _mapValues__C]) -> scala.collection.SortedMap[_AbstractSortedMap__A, _mapValues__C]: ...
    def newBuilder(self) -> Builder[scala.Tuple2[_AbstractSortedMap__A, _AbstractSortedMap__B], 'SortedMap'[_AbstractSortedMap__A, _AbstractSortedMap__B]]: ...
    def range(self, from_: typing.Any, until: typing.Any) -> scala.collection.generic.Sorted: ...
    def repr(self) -> typing.Any: ...
    def result(self) -> 'Map'[typing.Any, typing.Any]: ...
    def seq(self) -> 'Map'[typing.Any, typing.Any]: ...
    def thisCollection(self) -> scala.collection.Iterable[_AbstractSortedMap__A]: ...
    _to_0__Col = typing.TypeVar('_to_0__Col')  # <Col>
    @typing.overload
    def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., _AbstractSortedMap__A, _to_0__Col]) -> _to_0__Col: ...
    @typing.overload
    def to(self, to: typing.Any) -> scala.collection.generic.Sorted: ...
    def toCollection(self, repr: typing.Any) -> scala.collection.Iterable: ...
    def toIterable(self) -> scala.collection.Iterable[_AbstractSortedMap__A]: ...
    def toSeq(self) -> scala.collection.Seq[scala.Tuple2[typing.Any, typing.Any]]: ...
    def toTraversable(self) -> scala.collection.Traversable[_AbstractSortedMap__A]: ...
    def until(self, until: typing.Any) -> scala.collection.generic.Sorted: ...
    _updated__B1 = typing.TypeVar('_updated__B1')  # <B1>
    def updated(self, key: _AbstractSortedMap__A, value: _updated__B1) -> 'SortedMap'[_AbstractSortedMap__A, _updated__B1]: ...
    def values(self) -> scala.collection.Iterable[typing.Any]: ...
    @typing.overload
    def view(self) -> scala.collection.IterableView[_AbstractSortedMap__A, scala.collection.Iterable[_AbstractSortedMap__A]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> scala.collection.IterableView[_AbstractSortedMap__A, scala.collection.Iterable[_AbstractSortedMap__A]]: ...

_AnyRefMap__AnyRefMapBuilder__K = typing.TypeVar('_AnyRefMap__AnyRefMapBuilder__K')  # <K>
_AnyRefMap__AnyRefMapBuilder__V = typing.TypeVar('_AnyRefMap__AnyRefMapBuilder__V')  # <V>
_AnyRefMap__K = typing.TypeVar('_AnyRefMap__K')  # <K>
_AnyRefMap__V = typing.TypeVar('_AnyRefMap__V')  # <V>
class AnyRefMap(AbstractMap[_AnyRefMap__K, _AnyRefMap__V], scala.Serializable, typing.Generic[_AnyRefMap__K, _AnyRefMap__V]):
    serialVersionUID: typing.ClassVar[int] = ...
    scala$collection$mutable$AnyRefMap$$_hashes: typing.List[int] = ...
    scala$collection$mutable$AnyRefMap$$_keys: typing.List[typing.Any] = ...
    scala$collection$mutable$AnyRefMap$$_values: typing.List[typing.Any] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, initialBufferSize: int): ...
    @typing.overload
    def __init__(self, defaultEntry: scala.Function1[_AnyRefMap__K, _AnyRefMap__V]): ...
    @typing.overload
    def __init__(self, defaultEntry: scala.Function1[_AnyRefMap__K, _AnyRefMap__V], initialBufferSize: int): ...
    @typing.overload
    def __init__(self, defaultEntry: scala.Function1[_AnyRefMap__K, _AnyRefMap__V], initialBufferSize: int, initBlank: bool): ...
    @typing.overload
    def $minus(self, key: _AnyRefMap__K) -> 'Map'[_AnyRefMap__K, _AnyRefMap__V]: ...
    @typing.overload
    def $minus(self, elem1: _AnyRefMap__K, elem2: _AnyRefMap__K, elems: scala.collection.Seq[_AnyRefMap__K]) -> 'Map'[_AnyRefMap__K, _AnyRefMap__V]: ...
    @typing.overload
    def $minus$eq(self, elem1: _AnyRefMap__K, elem2: _AnyRefMap__K, elems: scala.collection.Seq[_AnyRefMap__K]) -> scala.collection.generic.Shrinkable[_AnyRefMap__K]: ...
    @typing.overload
    def $minus$eq(self, key: _AnyRefMap__K) -> 'AnyRefMap'[_AnyRefMap__K, _AnyRefMap__V]: ...
    def $minus$minus(self, xs: scala.collection.GenTraversableOnce[_AnyRefMap__K]) -> 'Map'[_AnyRefMap__K, _AnyRefMap__V]: ...
    _$plus_0__V1 = typing.TypeVar('_$plus_0__V1')  # <V1>
    _$plus_1__V1 = typing.TypeVar('_$plus_1__V1')  # <V1>
    @typing.overload
    def $plus(self, kv: scala.Tuple2[_AnyRefMap__K, _.plus_0__V1]) -> 'AnyRefMap'[_AnyRefMap__K, _.plus_0__V1]: ...
    @typing.overload
    def $plus(self, elem1: scala.Tuple2[_AnyRefMap__K, _.plus_1__V1], elem2: scala.Tuple2[_AnyRefMap__K, _.plus_1__V1], elems: scala.collection.Seq[scala.Tuple2[_AnyRefMap__K, _.plus_1__V1]]) -> 'Map'[_AnyRefMap__K, _.plus_1__V1]: ...
    @typing.overload
    def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq) -> scala.collection.generic.Growable: ...
    @typing.overload
    def $plus$eq(self, key: _AnyRefMap__K, value: _AnyRefMap__V) -> 'AnyRefMap'[_AnyRefMap__K, _AnyRefMap__V]: ...
    @typing.overload
    def $plus$eq(self, kv: scala.Tuple2[_AnyRefMap__K, _AnyRefMap__V]) -> 'AnyRefMap'[_AnyRefMap__K, _AnyRefMap__V]: ...
    _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
    _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
    _$plus$plus_1__V1 = typing.TypeVar('_$plus$plus_1__V1')  # <V1>
    @typing.overload
    def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus_0__B], bf: scala.collection.generic.CanBuildFrom[scala.collection.Traversable[typing.Any], _.plus.plus_0__B, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
    @typing.overload
    def $plus$plus(self, xs: scala.collection.GenTraversableOnce[scala.Tuple2[_AnyRefMap__K, _.plus.plus_1__V1]]) -> 'AnyRefMap'[_AnyRefMap__K, _.plus.plus_1__V1]: ...
    def apply(self, key: _AnyRefMap__K) -> _AnyRefMap__V: ...
    _canBuildFrom__K = typing.TypeVar('_canBuildFrom__K')  # <K>
    _canBuildFrom__V = typing.TypeVar('_canBuildFrom__V')  # <V>
    _canBuildFrom__J = typing.TypeVar('_canBuildFrom__J')  # <J>
    _canBuildFrom__U = typing.TypeVar('_canBuildFrom__U')  # <U>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['AnyRefMap'[_canBuildFrom__K, _canBuildFrom__V], scala.Tuple2[_canBuildFrom__J, _canBuildFrom__U], 'AnyRefMap'[_canBuildFrom__J, _canBuildFrom__U]]: ...
    def clone(self) -> 'AnyRefMap'[_AnyRefMap__K, _AnyRefMap__V]: ...
    def contains(self, key: _AnyRefMap__K) -> bool: ...
    def default(self, key: _AnyRefMap__K) -> _AnyRefMap__V: ...
    def empty(self) -> 'AnyRefMap'[_AnyRefMap__K, _AnyRefMap__V]: ...
    def filterKeys(self, p: scala.Function1[_AnyRefMap__K, typing.Any]) -> scala.collection.Map[_AnyRefMap__K, _AnyRefMap__V]: ...
    def filterNot(self, p: scala.Function1[scala.Tuple2[_AnyRefMap__K, _AnyRefMap__V], typing.Any]) -> scala.collection.Map[_AnyRefMap__K, _AnyRefMap__V]: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[scala.Tuple2[_AnyRefMap__K, _AnyRefMap__V], _foreach__U]) -> None: ...
    _foreachKey__A = typing.TypeVar('_foreachKey__A')  # <A>
    def foreachKey(self, f: scala.Function1[_AnyRefMap__K, _foreachKey__A]) -> None: ...
    _foreachValue__A = typing.TypeVar('_foreachValue__A')  # <A>
    def foreachValue(self, f: scala.Function1[_AnyRefMap__V, _foreachValue__A]) -> None: ...
    _fromZip_0__K = typing.TypeVar('_fromZip_0__K')  # <K>
    _fromZip_0__V = typing.TypeVar('_fromZip_0__V')  # <V>
    _fromZip_1__K = typing.TypeVar('_fromZip_1__K')  # <K>
    _fromZip_1__V = typing.TypeVar('_fromZip_1__V')  # <V>
    @typing.overload
    @staticmethod
    def fromZip(keys: typing.List[_fromZip_0__K], values: typing.Any) -> 'AnyRefMap'[_fromZip_0__K, _fromZip_0__V]: ...
    @typing.overload
    @staticmethod
    def fromZip(keys: Iterable[_fromZip_1__K], values: Iterable[_fromZip_1__V]) -> 'AnyRefMap'[_fromZip_1__K, _fromZip_1__V]: ...
    def get(self, key: _AnyRefMap__K) -> scala.Option[_AnyRefMap__V]: ...
    _getOrElse__V1 = typing.TypeVar('_getOrElse__V1')  # <V1>
    def getOrElse(self, key: _AnyRefMap__K, default: scala.Function0[_getOrElse__V1]) -> _getOrElse__V1: ...
    def getOrElseUpdate(self, key: _AnyRefMap__K, defaultValue: scala.Function0[_AnyRefMap__V]) -> _AnyRefMap__V: ...
    def getOrNull(self, key: _AnyRefMap__K) -> _AnyRefMap__V: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[typing.Any, typing.Any]) -> scala.collection.immutable.Map[typing.Any, scala.collection.Traversable[typing.Any]]: ...
    def initializeTo(self, m: int, sz: int, vc: int, hz: typing.List[int], kz: typing.List[typing.Any], vz: typing.List[typing.Any]) -> None: ...
    def iterator(self) -> scala.collection.Iterator[scala.Tuple2[_AnyRefMap__K, _AnyRefMap__V]]: ...
    def keySet(self) -> scala.collection.Set[_AnyRefMap__K]: ...
    def keys(self) -> scala.collection.Iterable[_AnyRefMap__K]: ...
    _mapValues__W = typing.TypeVar('_mapValues__W')  # <W>
    def mapValues(self, f: scala.Function1[_AnyRefMap__V, _mapValues__W]) -> scala.collection.Map[_AnyRefMap__K, _mapValues__W]: ...
    _mapValuesNow__V1 = typing.TypeVar('_mapValuesNow__V1')  # <V1>
    def mapValuesNow(self, f: scala.Function1[_AnyRefMap__V, _mapValuesNow__V1]) -> 'AnyRefMap'[_AnyRefMap__K, _mapValuesNow__V1]: ...
    def put(self, key: _AnyRefMap__K, value: _AnyRefMap__V) -> scala.Option[_AnyRefMap__V]: ...
    def repack(self) -> None: ...
    def repr(self) -> typing.Any: ...
    def result(self) -> 'Map'[_AnyRefMap__K, _AnyRefMap__V]: ...
    def seq(self) -> 'Map'[_AnyRefMap__K, _AnyRefMap__V]: ...
    def size(self) -> int: ...
    def thisCollection(self) -> scala.collection.Iterable[typing.Any]: ...
    def toCollection(self, repr: typing.Any) -> scala.collection.Iterable: ...
    def toIterable(self) -> scala.collection.Iterable[typing.Any]: ...
    def toSeq(self) -> scala.collection.Seq[scala.Tuple2[_AnyRefMap__K, _AnyRefMap__V]]: ...
    def toTraversable(self) -> scala.collection.Traversable[typing.Any]: ...
    def transformValues(self, f: scala.Function1[_AnyRefMap__V, _AnyRefMap__V]) -> 'AnyRefMap'[_AnyRefMap__K, _AnyRefMap__V]: ...
    def update(self, key: _AnyRefMap__K, value: _AnyRefMap__V) -> None: ...
    _updated__V1 = typing.TypeVar('_updated__V1')  # <V1>
    def updated(self, key: _AnyRefMap__K, value: _updated__V1) -> 'AnyRefMap'[_AnyRefMap__K, _updated__V1]: ...
    def values(self) -> scala.collection.Iterable[_AnyRefMap__V]: ...
    @typing.overload
    def view(self) -> scala.collection.IterableView[typing.Any, scala.collection.Iterable[typing.Any]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> scala.collection.IterableView[typing.Any, scala.collection.Iterable[typing.Any]]: ...
    class AnyRefMapBuilder(ReusableBuilder[scala.Tuple2[_AnyRefMap__AnyRefMapBuilder__K, _AnyRefMap__AnyRefMapBuilder__V], 'AnyRefMap'[_AnyRefMap__AnyRefMapBuilder__K, _AnyRefMap__AnyRefMapBuilder__V]], typing.Generic[_AnyRefMap__AnyRefMapBuilder__K, _AnyRefMap__AnyRefMapBuilder__V]):
        def __init__(self): ...
        @typing.overload
        def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq) -> scala.collection.generic.Growable: ...
        @typing.overload
        def $plus$eq(self, entry: scala.Tuple2[_AnyRefMap__AnyRefMapBuilder__K, _AnyRefMap__AnyRefMapBuilder__V]) -> 'AnyRefMap.AnyRefMapBuilder'[_AnyRefMap__AnyRefMapBuilder__K, _AnyRefMap__AnyRefMapBuilder__V]: ...
        def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[scala.Tuple2[_AnyRefMap__AnyRefMapBuilder__K, _AnyRefMap__AnyRefMapBuilder__V]]) -> scala.collection.generic.Growable[scala.Tuple2[_AnyRefMap__AnyRefMapBuilder__K, _AnyRefMap__AnyRefMapBuilder__V]]: ...
        def clear(self) -> None: ...
        def elems(self) -> 'AnyRefMap'[_AnyRefMap__AnyRefMapBuilder__K, _AnyRefMap__AnyRefMapBuilder__V]: ...
        def elems_$eq(self, x$1: 'AnyRefMap'[_AnyRefMap__AnyRefMapBuilder__K, _AnyRefMap__AnyRefMapBuilder__V]) -> None: ...
        _mapResult__NewTo = typing.TypeVar('_mapResult__NewTo')  # <NewTo>
        def mapResult(self, f: scala.Function1['AnyRefMap'[_AnyRefMap__AnyRefMapBuilder__K, _AnyRefMap__AnyRefMapBuilder__V], _mapResult__NewTo]) -> Builder[scala.Tuple2[_AnyRefMap__AnyRefMapBuilder__K, _AnyRefMap__AnyRefMapBuilder__V], _mapResult__NewTo]: ...
        def result(self) -> 'AnyRefMap'[_AnyRefMap__AnyRefMapBuilder__K, _AnyRefMap__AnyRefMapBuilder__V]: ...
        @typing.overload
        def sizeHint(self, size: int) -> None: ...
        @typing.overload
        def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
        @typing.overload
        def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any], delta: int) -> None: ...
        def sizeHintBounded(self, size: int, boundingColl: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
    class ExceptionDefault(scala.Function1[typing.Any, scala.runtime.Nothing.], scala.Serializable):
        serialVersionUID: typing.ClassVar[int] = ...
        def __init__(self): ...
        _andThen__A = typing.TypeVar('_andThen__A')  # <A>
        def andThen(self, g: scala.Function1[scala.runtime.Nothing., _andThen__A]) -> scala.Function1[typing.Any, _andThen__A]: ...
        def apply(self, k: typing.Any) -> scala.runtime.Nothing.: ...
        def apply$mcDD$sp(self, v1: float) -> float: ...
        def apply$mcDF$sp(self, v1: float) -> float: ...
        def apply$mcDI$sp(self, v1: int) -> float: ...
        def apply$mcDJ$sp(self, v1: int) -> float: ...
        def apply$mcFD$sp(self, v1: float) -> float: ...
        def apply$mcFF$sp(self, v1: float) -> float: ...
        def apply$mcFI$sp(self, v1: int) -> float: ...
        def apply$mcFJ$sp(self, v1: int) -> float: ...
        def apply$mcID$sp(self, v1: float) -> int: ...
        def apply$mcIF$sp(self, v1: float) -> int: ...
        def apply$mcII$sp(self, v1: int) -> int: ...
        def apply$mcIJ$sp(self, v1: int) -> int: ...
        def apply$mcJD$sp(self, v1: float) -> int: ...
        def apply$mcJF$sp(self, v1: float) -> int: ...
        def apply$mcJI$sp(self, v1: int) -> int: ...
        def apply$mcJJ$sp(self, v1: int) -> int: ...
        def apply$mcVD$sp(self, v1: float) -> None: ...
        def apply$mcVF$sp(self, v1: float) -> None: ...
        def apply$mcVI$sp(self, v1: int) -> None: ...
        def apply$mcVJ$sp(self, v1: int) -> None: ...
        def apply$mcZD$sp(self, v1: float) -> bool: ...
        def apply$mcZF$sp(self, v1: float) -> bool: ...
        def apply$mcZI$sp(self, v1: int) -> bool: ...
        def apply$mcZJ$sp(self, v1: int) -> bool: ...
        _compose__A = typing.TypeVar('_compose__A')  # <A>
        def compose(self, g: scala.Function1[_compose__A, typing.Any]) -> scala.Function1[_compose__A, scala.runtime.Nothing.]: ...
        def toString(self) -> str: ...

_ArrayBuilder__ofRef__T = typing.TypeVar('_ArrayBuilder__ofRef__T')  # <T>
_ArrayBuilder__T = typing.TypeVar('_ArrayBuilder__T')  # <T>
class ArrayBuilder(ReusableBuilder[_ArrayBuilder__T, typing.Any], scala.Serializable, typing.Generic[_ArrayBuilder__T]):
    def __init__(self): ...
    @typing.overload
    def $plus$eq(self, elem: typing.Any) -> scala.collection.generic.Growable[typing.Any]: ...
    @typing.overload
    def $plus$eq(self, elem: typing.Any) -> Builder[typing.Any, typing.Any]: ...
    @typing.overload
    def $plus$eq(self, elem1: _ArrayBuilder__T, elem2: _ArrayBuilder__T, elems: scala.collection.Seq[_ArrayBuilder__T]) -> scala.collection.generic.Growable[_ArrayBuilder__T]: ...
    def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[_ArrayBuilder__T]) -> scala.collection.generic.Growable[_ArrayBuilder__T]: ...
    _make__T = typing.TypeVar('_make__T')  # <T>
    @staticmethod
    def make(evidence$1: scala.reflect.ClassTag[_make__T]) -> 'ArrayBuilder'[_make__T]: ...
    _mapResult__NewTo = typing.TypeVar('_mapResult__NewTo')  # <NewTo>
    def mapResult(self, f: scala.Function1[typing.Any, _mapResult__NewTo]) -> Builder[_ArrayBuilder__T, _mapResult__NewTo]: ...
    @typing.overload
    def sizeHint(self, size: int) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any], delta: int) -> None: ...
    def sizeHintBounded(self, size: int, boundingColl: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
    class ofBoolean(scala.collection.mutable.ArrayBuilder[typing.Any]):
        def __init__(self): ...
        @typing.overload
        def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> scala.collection.generic.Growable[typing.Any]: ...
        @typing.overload
        def $plus$eq(self, elem: bool) -> 'ArrayBuilder.ofBoolean': ...
        def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[typing.Any]) -> 'ArrayBuilder.ofBoolean': ...
        def clear(self) -> None: ...
        def equals(self, other: typing.Any) -> bool: ...
        def result(self) -> typing.List[bool]: ...
        @typing.overload
        def sizeHint(self, size: int) -> None: ...
        @typing.overload
        def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
        @typing.overload
        def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any], delta: int) -> None: ...
        def toString(self) -> str: ...
    class ofByte(scala.collection.mutable.ArrayBuilder[typing.Any]):
        def __init__(self): ...
        @typing.overload
        def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> scala.collection.generic.Growable[typing.Any]: ...
        @typing.overload
        def $plus$eq(self, elem: int) -> 'ArrayBuilder.ofByte': ...
        def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[typing.Any]) -> 'ArrayBuilder.ofByte': ...
        def clear(self) -> None: ...
        def equals(self, other: typing.Any) -> bool: ...
        def result(self) -> typing.List[int]: ...
        @typing.overload
        def sizeHint(self, size: int) -> None: ...
        @typing.overload
        def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
        @typing.overload
        def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any], delta: int) -> None: ...
        def toString(self) -> str: ...
    class ofChar(scala.collection.mutable.ArrayBuilder[typing.Any]):
        def __init__(self): ...
        @typing.overload
        def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> scala.collection.generic.Growable[typing.Any]: ...
        @typing.overload
        def $plus$eq(self, elem: str) -> 'ArrayBuilder.ofChar': ...
        def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[typing.Any]) -> 'ArrayBuilder.ofChar': ...
        def clear(self) -> None: ...
        def equals(self, other: typing.Any) -> bool: ...
        def result(self) -> typing.List[str]: ...
        @typing.overload
        def sizeHint(self, size: int) -> None: ...
        @typing.overload
        def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
        @typing.overload
        def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any], delta: int) -> None: ...
        def toString(self) -> str: ...
    class ofDouble(scala.collection.mutable.ArrayBuilder[typing.Any]):
        def __init__(self): ...
        @typing.overload
        def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> scala.collection.generic.Growable[typing.Any]: ...
        @typing.overload
        def $plus$eq(self, elem: float) -> 'ArrayBuilder.ofDouble': ...
        def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[typing.Any]) -> 'ArrayBuilder.ofDouble': ...
        def clear(self) -> None: ...
        def equals(self, other: typing.Any) -> bool: ...
        def result(self) -> typing.List[float]: ...
        @typing.overload
        def sizeHint(self, size: int) -> None: ...
        @typing.overload
        def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
        @typing.overload
        def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any], delta: int) -> None: ...
        def toString(self) -> str: ...
    class ofFloat(scala.collection.mutable.ArrayBuilder[typing.Any]):
        def __init__(self): ...
        @typing.overload
        def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> scala.collection.generic.Growable[typing.Any]: ...
        @typing.overload
        def $plus$eq(self, elem: float) -> 'ArrayBuilder.ofFloat': ...
        def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[typing.Any]) -> 'ArrayBuilder.ofFloat': ...
        def clear(self) -> None: ...
        def equals(self, other: typing.Any) -> bool: ...
        def result(self) -> typing.List[float]: ...
        @typing.overload
        def sizeHint(self, size: int) -> None: ...
        @typing.overload
        def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
        @typing.overload
        def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any], delta: int) -> None: ...
        def toString(self) -> str: ...
    class ofInt(scala.collection.mutable.ArrayBuilder[typing.Any]):
        def __init__(self): ...
        @typing.overload
        def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> scala.collection.generic.Growable[typing.Any]: ...
        @typing.overload
        def $plus$eq(self, elem: int) -> 'ArrayBuilder.ofInt': ...
        def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[typing.Any]) -> 'ArrayBuilder.ofInt': ...
        def clear(self) -> None: ...
        def equals(self, other: typing.Any) -> bool: ...
        def result(self) -> typing.List[int]: ...
        @typing.overload
        def sizeHint(self, size: int) -> None: ...
        @typing.overload
        def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
        @typing.overload
        def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any], delta: int) -> None: ...
        def toString(self) -> str: ...
    class ofLong(scala.collection.mutable.ArrayBuilder[typing.Any]):
        def __init__(self): ...
        @typing.overload
        def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> scala.collection.generic.Growable[typing.Any]: ...
        @typing.overload
        def $plus$eq(self, elem: int) -> 'ArrayBuilder.ofLong': ...
        def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[typing.Any]) -> 'ArrayBuilder.ofLong': ...
        def clear(self) -> None: ...
        def equals(self, other: typing.Any) -> bool: ...
        def result(self) -> typing.List[int]: ...
        @typing.overload
        def sizeHint(self, size: int) -> None: ...
        @typing.overload
        def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
        @typing.overload
        def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any], delta: int) -> None: ...
        def toString(self) -> str: ...
    class ofRef(scala.collection.mutable.ArrayBuilder[_ArrayBuilder__ofRef__T], typing.Generic[_ArrayBuilder__ofRef__T]):
        def __init__(self, evidence$2: scala.reflect.ClassTag[_ArrayBuilder__ofRef__T]): ...
        @typing.overload
        def $plus$eq(self, elem1: _ArrayBuilder__ofRef__T, elem2: _ArrayBuilder__ofRef__T, elems: scala.collection.Seq[_ArrayBuilder__ofRef__T]) -> scala.collection.generic.Growable[_ArrayBuilder__ofRef__T]: ...
        @typing.overload
        def $plus$eq(self, elem: _ArrayBuilder__ofRef__T) -> 'ArrayBuilder.ofRef'[_ArrayBuilder__ofRef__T]: ...
        def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[_ArrayBuilder__ofRef__T]) -> 'ArrayBuilder.ofRef'[_ArrayBuilder__ofRef__T]: ...
        def clear(self) -> None: ...
        def equals(self, other: typing.Any) -> bool: ...
        def result(self) -> typing.List[_ArrayBuilder__ofRef__T]: ...
        @typing.overload
        def sizeHint(self, size: int) -> None: ...
        @typing.overload
        def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
        @typing.overload
        def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any], delta: int) -> None: ...
        def toString(self) -> str: ...
    class ofShort(scala.collection.mutable.ArrayBuilder[typing.Any]):
        def __init__(self): ...
        @typing.overload
        def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> scala.collection.generic.Growable[typing.Any]: ...
        @typing.overload
        def $plus$eq(self, elem: int) -> 'ArrayBuilder.ofShort': ...
        def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[typing.Any]) -> 'ArrayBuilder.ofShort': ...
        def clear(self) -> None: ...
        def equals(self, other: typing.Any) -> bool: ...
        def result(self) -> typing.List[int]: ...
        @typing.overload
        def sizeHint(self, size: int) -> None: ...
        @typing.overload
        def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
        @typing.overload
        def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any], delta: int) -> None: ...
        def toString(self) -> str: ...
    class ofUnit(scala.collection.mutable.ArrayBuilder[scala.runtime.BoxedUnit]):
        def __init__(self): ...
        @typing.overload
        def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> scala.collection.generic.Growable[typing.Any]: ...
        @typing.overload
        def $plus$eq(self, elem: scala.runtime.BoxedUnit) -> 'ArrayBuilder.ofUnit': ...
        def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[scala.runtime.BoxedUnit]) -> 'ArrayBuilder.ofUnit': ...
        def clear(self) -> None: ...
        def equals(self, other: typing.Any) -> bool: ...
        def result(self) -> typing.List[scala.runtime.BoxedUnit]: ...
        def toString(self) -> str: ...

_ArrayOps__ofRef__T = typing.TypeVar('_ArrayOps__ofRef__T')  # <T>
_ArrayOps__T = typing.TypeVar('_ArrayOps__T')  # <T>
class ArrayOps(ArrayLike[_ArrayOps__T, typing.Any], scala.collection.CustomParallelizable[_ArrayOps__T, scala.collection.parallel.mutable.ParArray[_ArrayOps__T]], typing.Generic[_ArrayOps__T]):
    _$colon$plus_0__B = typing.TypeVar('_$colon$plus_0__B')  # <B>
    _$colon$plus_0__That = typing.TypeVar('_$colon$plus_0__That')  # <That>
    _$colon$plus_1__B = typing.TypeVar('_$colon$plus_1__B')  # <B>
    @typing.overload
    def $colon$plus(self, elem: _.colon.plus_0__B, bf: scala.collection.generic.CanBuildFrom[typing.Any, _.colon.plus_0__B, _.colon.plus_0__That]) -> _.colon.plus_0__That: ...
    @typing.overload
    def $colon$plus(self, elem: _.colon.plus_1__B, evidence$2: scala.reflect.ClassTag[_.colon.plus_1__B]) -> typing.Any: ...
    @staticmethod
    def $init$($this: 'ArrayOps') -> None: ...
    _$plus$colon_0__B = typing.TypeVar('_$plus$colon_0__B')  # <B>
    _$plus$colon_0__That = typing.TypeVar('_$plus$colon_0__That')  # <That>
    _$plus$colon_1__B = typing.TypeVar('_$plus$colon_1__B')  # <B>
    @typing.overload
    def $plus$colon(self, elem: _.plus.colon_0__B, bf: scala.collection.generic.CanBuildFrom[typing.Any, _.plus.colon_0__B, _.plus.colon_0__That]) -> _.plus.colon_0__That: ...
    @typing.overload
    def $plus$colon(self, elem: _.plus.colon_1__B, evidence$3: scala.reflect.ClassTag[_.plus.colon_1__B]) -> typing.Any: ...
    _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
    _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
    _copyToArray_2__U = typing.TypeVar('_copyToArray_2__U')  # <U>
    @typing.overload
    def copyToArray(self, xs: typing.Any) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
    def equals(self, that: typing.Any) -> bool: ...
    _flatten__U = typing.TypeVar('_flatten__U')  # <U>
    def flatten(self, asTrav: scala.Function1[_ArrayOps__T, scala.collection.Traversable[_flatten__U]], m: scala.reflect.ClassTag[_flatten__U]) -> typing.Any: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def par(self) -> scala.collection.Parallel: ...
    @typing.overload
    def par(self) -> scala.collection.parallel.mutable.ParArray[_ArrayOps__T]: ...
    @typing.overload
    def seq(self) -> scala.collection.IndexedSeq[typing.Any]: ...
    @typing.overload
    def seq(self) -> scala.collection.Seq[typing.Any]: ...
    @typing.overload
    def seq(self) -> scala.collection.TraversableOnce[typing.Any]: ...
    @typing.overload
    def seq(self) -> scala.collection.TraversableOnce[typing.Any]: ...
    @typing.overload
    def seq(self) -> IndexedSeq[_ArrayOps__T]: ...
    def slice(self, from_: int, until: int) -> typing.Any: ...
    _toArray__U = typing.TypeVar('_toArray__U')  # <U>
    def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__U]) -> typing.Any: ...
    def toString(self) -> str: ...
    _transpose__U = typing.TypeVar('_transpose__U')  # <U>
    def transpose(self, asArray: scala.Function1[_ArrayOps__T, typing.Any]) -> typing.List[typing.Any]: ...
    _unzip__T1 = typing.TypeVar('_unzip__T1')  # <T1>
    _unzip__T2 = typing.TypeVar('_unzip__T2')  # <T2>
    def unzip(self, asPair: scala.Function1[_ArrayOps__T, scala.Tuple2[_unzip__T1, _unzip__T2]], ct1: scala.reflect.ClassTag[_unzip__T1], ct2: scala.reflect.ClassTag[_unzip__T2]) -> scala.Tuple2[typing.Any, typing.Any]: ...
    _unzip3__T1 = typing.TypeVar('_unzip3__T1')  # <T1>
    _unzip3__T2 = typing.TypeVar('_unzip3__T2')  # <T2>
    _unzip3__T3 = typing.TypeVar('_unzip3__T3')  # <T3>
    def unzip3(self, asTriple: scala.Function1[_ArrayOps__T, scala.Tuple3[_unzip3__T1, _unzip3__T2, _unzip3__T3]], ct1: scala.reflect.ClassTag[_unzip3__T1], ct2: scala.reflect.ClassTag[_unzip3__T2], ct3: scala.reflect.ClassTag[_unzip3__T3]) -> scala.Tuple3[typing.Any, typing.Any, typing.Any]: ...
    class ofBoolean(scala.collection.mutable.ArrayOps[typing.Any]):
        def __init__(self, repr: typing.List[bool]): ...
        _$colon$bslash__B = typing.TypeVar('_$colon$bslash__B')  # <B>
        def $colon$bslash(self, z: _.colon.bslash__B, op: scala.Function2[typing.Any, _.colon.bslash__B, _.colon.bslash__B]) -> _.colon.bslash__B: ...
        _$colon$plus_0__B = typing.TypeVar('_$colon$plus_0__B')  # <B>
        _$colon$plus_0__That = typing.TypeVar('_$colon$plus_0__That')  # <That>
        _$colon$plus_1__B = typing.TypeVar('_$colon$plus_1__B')  # <B>
        @typing.overload
        def $colon$plus(self, elem: _.colon.plus_0__B, bf: scala.collection.generic.CanBuildFrom[typing.List[bool], _.colon.plus_0__B, _.colon.plus_0__That]) -> _.colon.plus_0__That: ...
        @typing.overload
        def $colon$plus(self, elem: _.colon.plus_1__B, evidence$2: scala.reflect.ClassTag[_.colon.plus_1__B]) -> typing.Any: ...
        _$div$colon__B = typing.TypeVar('_$div$colon__B')  # <B>
        def $div$colon(self, z: _.div.colon__B, op: scala.Function2[_.div.colon__B, typing.Any, _.div.colon__B]) -> _.div.colon__B: ...
        _$plus$colon_0__B = typing.TypeVar('_$plus$colon_0__B')  # <B>
        _$plus$colon_0__That = typing.TypeVar('_$plus$colon_0__That')  # <That>
        _$plus$colon_1__B = typing.TypeVar('_$plus$colon_1__B')  # <B>
        @typing.overload
        def $plus$colon(self, elem: _.plus.colon_0__B, bf: scala.collection.generic.CanBuildFrom[typing.List[bool], _.plus.colon_0__B, _.plus.colon_0__That]) -> _.plus.colon_0__That: ...
        @typing.overload
        def $plus$colon(self, elem: _.plus.colon_1__B, evidence$3: scala.reflect.ClassTag[_.plus.colon_1__B]) -> typing.Any: ...
        _$plus$plus__B = typing.TypeVar('_$plus$plus__B')  # <B>
        _$plus$plus__That = typing.TypeVar('_$plus$plus__That')  # <That>
        def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus__B], bf: scala.collection.generic.CanBuildFrom[typing.List[bool], _.plus.plus__B, _.plus.plus__That]) -> _.plus.plus__That: ...
        _$plus$plus$colon_0__B = typing.TypeVar('_$plus$plus$colon_0__B')  # <B>
        _$plus$plus$colon_0__That = typing.TypeVar('_$plus$plus$colon_0__That')  # <That>
        _$plus$plus$colon_1__B = typing.TypeVar('_$plus$plus$colon_1__B')  # <B>
        _$plus$plus$colon_1__That = typing.TypeVar('_$plus$plus$colon_1__That')  # <That>
        @typing.overload
        def $plus$plus$colon(self, that: scala.collection.Traversable[_.plus.plus.colon_0__B], bf: scala.collection.generic.CanBuildFrom[typing.List[bool], _.plus.plus.colon_0__B, _.plus.plus.colon_0__That]) -> _.plus.plus.colon_0__That: ...
        @typing.overload
        def $plus$plus$colon(self, that: scala.collection.TraversableOnce[_.plus.plus.colon_1__B], bf: scala.collection.generic.CanBuildFrom[typing.List[bool], _.plus.plus.colon_1__B, _.plus.plus.colon_1__That]) -> _.plus.plus.colon_1__That: ...
        @typing.overload
        def addString(self, b: StringBuilder) -> StringBuilder: ...
        @typing.overload
        def addString(self, b: StringBuilder, sep: str) -> StringBuilder: ...
        @typing.overload
        def addString(self, b: StringBuilder, start: str, sep: str, end: str) -> StringBuilder: ...
        _aggregate__B = typing.TypeVar('_aggregate__B')  # <B>
        def aggregate(self, z: scala.Function0[_aggregate__B], seqop: scala.Function2[_aggregate__B, typing.Any, _aggregate__B], combop: scala.Function2[_aggregate__B, _aggregate__B, _aggregate__B]) -> _aggregate__B: ...
        def apply(self, index: int) -> bool: ...
        def canEqual(self, that: typing.Any) -> bool: ...
        _collect__B = typing.TypeVar('_collect__B')  # <B>
        _collect__That = typing.TypeVar('_collect__That')  # <That>
        def collect(self, pf: scala.PartialFunction[typing.Any, _collect__B], bf: scala.collection.generic.CanBuildFrom[typing.List[bool], _collect__B, _collect__That]) -> _collect__That: ...
        _collectFirst__B = typing.TypeVar('_collectFirst__B')  # <B>
        def collectFirst(self, pf: scala.PartialFunction[typing.Any, _collectFirst__B]) -> scala.Option[_collectFirst__B]: ...
        def combinations(self, n: int) -> scala.collection.Iterator[typing.List[bool]]: ...
        _contains__A1 = typing.TypeVar('_contains__A1')  # <A1>
        def contains(self, elem: _contains__A1) -> bool: ...
        _containsSlice__B = typing.TypeVar('_containsSlice__B')  # <B>
        def containsSlice(self, that: scala.collection.GenSeq[_containsSlice__B]) -> bool: ...
        _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
        _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
        _copyToArray_2__U = typing.TypeVar('_copyToArray_2__U')  # <U>
        @typing.overload
        def copyToArray(self, xs: typing.Any) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
        _copyToBuffer__B = typing.TypeVar('_copyToBuffer__B')  # <B>
        def copyToBuffer(self, dest: Buffer[_copyToBuffer__B]) -> None: ...
        _corresponds__B = typing.TypeVar('_corresponds__B')  # <B>
        def corresponds(self, that: scala.collection.GenSeq[_corresponds__B], p: scala.Function2[typing.Any, _corresponds__B, typing.Any]) -> bool: ...
        def count(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        def deep(self) -> scala.collection.IndexedSeq[typing.Any]: ...
        def diff(self, that: scala.collection.GenSeq) -> typing.Any: ...
        def distinct(self) -> typing.Any: ...
        def drop(self, n: int) -> typing.Any: ...
        def dropRight(self, n: int) -> typing.Any: ...
        def dropWhile(self, p: scala.Function1) -> typing.Any: ...
        _endsWith__B = typing.TypeVar('_endsWith__B')  # <B>
        def endsWith(self, that: scala.collection.GenSeq[_endsWith__B]) -> bool: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def exists(self, p: scala.Function1[typing.Any, typing.Any]) -> bool: ...
        def filter(self, p: scala.Function1) -> typing.Any: ...
        def filterImpl(self, p: scala.Function1, isFlipped: bool) -> typing.Any: ...
        def filterNot(self, p: scala.Function1) -> typing.Any: ...
        def find(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.Option[typing.Any]: ...
        _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
        _flatMap__That = typing.TypeVar('_flatMap__That')  # <That>
        def flatMap(self, f: scala.Function1[typing.Any, scala.collection.GenTraversableOnce[_flatMap__B]], bf: scala.collection.generic.CanBuildFrom[typing.List[bool], _flatMap__B, _flatMap__That]) -> _flatMap__That: ...
        _flatten__U = typing.TypeVar('_flatten__U')  # <U>
        def flatten(self, asTrav: scala.Function1[typing.Any, scala.collection.Traversable[_flatten__U]], m: scala.reflect.ClassTag[_flatten__U]) -> typing.Any: ...
        _fold__A1 = typing.TypeVar('_fold__A1')  # <A1>
        def fold(self, z: _fold__A1, op: scala.Function2[_fold__A1, _fold__A1, _fold__A1]) -> _fold__A1: ...
        _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
        def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, typing.Any, _foldLeft__B]) -> _foldLeft__B: ...
        _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
        def foldRight(self, z: _foldRight__B, op: scala.Function2[typing.Any, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
        def forall(self, p: scala.Function1[typing.Any, typing.Any]) -> bool: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[typing.Any, _foreach__U]) -> None: ...
        _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
        def groupBy(self, f: scala.Function1[typing.Any, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, typing.List[bool]]: ...
        def grouped(self, size: int) -> scala.collection.Iterator[typing.List[bool]]: ...
        def hasDefiniteSize(self) -> bool: ...
        def hashCode(self) -> int: ...
        def head(self) -> typing.Any: ...
        def headOption(self) -> scala.Option[typing.Any]: ...
        _indexOf_0__B = typing.TypeVar('_indexOf_0__B')  # <B>
        _indexOf_1__B = typing.TypeVar('_indexOf_1__B')  # <B>
        @typing.overload
        def indexOf(self, elem: _indexOf_0__B) -> int: ...
        @typing.overload
        def indexOf(self, elem: _indexOf_1__B, from_: int) -> int: ...
        _indexOfSlice_0__B = typing.TypeVar('_indexOfSlice_0__B')  # <B>
        _indexOfSlice_1__B = typing.TypeVar('_indexOfSlice_1__B')  # <B>
        @typing.overload
        def indexOfSlice(self, that: scala.collection.GenSeq[_indexOfSlice_0__B]) -> int: ...
        @typing.overload
        def indexOfSlice(self, that: scala.collection.GenSeq[_indexOfSlice_1__B], from_: int) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[typing.Any, typing.Any], from_: int) -> int: ...
        def indices(self) -> scala.collection.immutable.Range: ...
        def init(self) -> typing.Any: ...
        def inits(self) -> scala.collection.Iterator[typing.List[bool]]: ...
        def intersect(self, that: scala.collection.GenSeq) -> typing.Any: ...
        def isDefinedAt(self, idx: int) -> bool: ...
        def isEmpty(self) -> bool: ...
        def isTraversableAgain(self) -> bool: ...
        def iterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def last(self) -> typing.Any: ...
        _lastIndexOf_0__B = typing.TypeVar('_lastIndexOf_0__B')  # <B>
        _lastIndexOf_1__B = typing.TypeVar('_lastIndexOf_1__B')  # <B>
        @typing.overload
        def lastIndexOf(self, elem: _lastIndexOf_0__B) -> int: ...
        @typing.overload
        def lastIndexOf(self, elem: _lastIndexOf_1__B, end: int) -> int: ...
        _lastIndexOfSlice_0__B = typing.TypeVar('_lastIndexOfSlice_0__B')  # <B>
        _lastIndexOfSlice_1__B = typing.TypeVar('_lastIndexOfSlice_1__B')  # <B>
        @typing.overload
        def lastIndexOfSlice(self, that: scala.collection.GenSeq[_lastIndexOfSlice_0__B]) -> int: ...
        @typing.overload
        def lastIndexOfSlice(self, that: scala.collection.GenSeq[_lastIndexOfSlice_1__B], end: int) -> int: ...
        @typing.overload
        def lastIndexWhere(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        @typing.overload
        def lastIndexWhere(self, p: scala.Function1[typing.Any, typing.Any], end: int) -> int: ...
        def lastOption(self) -> scala.Option[typing.Any]: ...
        def length(self) -> int: ...
        def lengthCompare(self, len: int) -> int: ...
        _map__B = typing.TypeVar('_map__B')  # <B>
        _map__That = typing.TypeVar('_map__That')  # <That>
        def map(self, f: scala.Function1[typing.Any, _map__B], bf: scala.collection.generic.CanBuildFrom[typing.List[bool], _map__B, _map__That]) -> _map__That: ...
        def max(self, cmp: scala.math.Ordering) -> typing.Any: ...
        def maxBy(self, f: scala.Function1, cmp: scala.math.Ordering) -> typing.Any: ...
        def min(self, cmp: scala.math.Ordering) -> typing.Any: ...
        def minBy(self, f: scala.Function1, cmp: scala.math.Ordering) -> typing.Any: ...
        @typing.overload
        def mkString(self) -> str: ...
        @typing.overload
        def mkString(self, sep: str) -> str: ...
        @typing.overload
        def mkString(self, start: str, sep: str, end: str) -> str: ...
        def newBuilder(self) -> ArrayBuilder.ofBoolean: ...
        def nonEmpty(self) -> bool: ...
        _padTo__B = typing.TypeVar('_padTo__B')  # <B>
        _padTo__That = typing.TypeVar('_padTo__That')  # <That>
        def padTo(self, len: int, elem: _padTo__B, bf: scala.collection.generic.CanBuildFrom[typing.List[bool], _padTo__B, _padTo__That]) -> _padTo__That: ...
        def par(self) -> scala.collection.parallel.mutable.ParArray[typing.Any]: ...
        def parCombiner(self) -> scala.collection.parallel.Combiner[typing.Any, scala.collection.parallel.mutable.ParArray[typing.Any]]: ...
        def partition(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.Tuple2[typing.List[bool], typing.List[bool]]: ...
        _patch__B = typing.TypeVar('_patch__B')  # <B>
        _patch__That = typing.TypeVar('_patch__That')  # <That>
        def patch(self, from_: int, patch: scala.collection.GenSeq[_patch__B], replaced: int, bf: scala.collection.generic.CanBuildFrom[typing.List[bool], _patch__B, _patch__That]) -> _patch__That: ...
        def permutations(self) -> scala.collection.Iterator[typing.List[bool]]: ...
        def prefixLength(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        _product__B = typing.TypeVar('_product__B')  # <B>
        def product(self, num: scala.math.Numeric[_product__B]) -> _product__B: ...
        _reduce__A1 = typing.TypeVar('_reduce__A1')  # <A1>
        def reduce(self, op: scala.Function2[_reduce__A1, _reduce__A1, _reduce__A1]) -> _reduce__A1: ...
        _reduceLeft__B = typing.TypeVar('_reduceLeft__B')  # <B>
        def reduceLeft(self, op: scala.Function2[_reduceLeft__B, typing.Any, _reduceLeft__B]) -> _reduceLeft__B: ...
        _reduceLeftOption__B = typing.TypeVar('_reduceLeftOption__B')  # <B>
        def reduceLeftOption(self, op: scala.Function2[_reduceLeftOption__B, typing.Any, _reduceLeftOption__B]) -> scala.Option[_reduceLeftOption__B]: ...
        _reduceOption__A1 = typing.TypeVar('_reduceOption__A1')  # <A1>
        def reduceOption(self, op: scala.Function2[_reduceOption__A1, _reduceOption__A1, _reduceOption__A1]) -> scala.Option[_reduceOption__A1]: ...
        _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
        def reduceRight(self, op: scala.Function2[typing.Any, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
        _reduceRightOption__B = typing.TypeVar('_reduceRightOption__B')  # <B>
        def reduceRightOption(self, op: scala.Function2[typing.Any, _reduceRightOption__B, _reduceRightOption__B]) -> scala.Option[_reduceRightOption__B]: ...
        def repr(self) -> typing.List[bool]: ...
        def reverse(self) -> typing.Any: ...
        def reverseIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        _reverseMap__B = typing.TypeVar('_reverseMap__B')  # <B>
        _reverseMap__That = typing.TypeVar('_reverseMap__That')  # <That>
        def reverseMap(self, f: scala.Function1[typing.Any, _reverseMap__B], bf: scala.collection.generic.CanBuildFrom[typing.List[bool], _reverseMap__B, _reverseMap__That]) -> _reverseMap__That: ...
        def reversed(self) -> scala.collection.immutable.List[typing.Any]: ...
        _sameElements__B = typing.TypeVar('_sameElements__B')  # <B>
        def sameElements(self, that: scala.collection.GenIterable[_sameElements__B]) -> bool: ...
        _scan__B = typing.TypeVar('_scan__B')  # <B>
        _scan__That = typing.TypeVar('_scan__That')  # <That>
        def scan(self, z: _scan__B, op: scala.Function2[_scan__B, _scan__B, _scan__B], cbf: scala.collection.generic.CanBuildFrom[typing.List[bool], _scan__B, _scan__That]) -> _scan__That: ...
        _scanLeft__B = typing.TypeVar('_scanLeft__B')  # <B>
        _scanLeft__That = typing.TypeVar('_scanLeft__That')  # <That>
        def scanLeft(self, z: _scanLeft__B, op: scala.Function2[_scanLeft__B, typing.Any, _scanLeft__B], bf: scala.collection.generic.CanBuildFrom[typing.List[bool], _scanLeft__B, _scanLeft__That]) -> _scanLeft__That: ...
        _scanRight__B = typing.TypeVar('_scanRight__B')  # <B>
        _scanRight__That = typing.TypeVar('_scanRight__That')  # <That>
        def scanRight(self, z: _scanRight__B, op: scala.Function2[typing.Any, _scanRight__B, _scanRight__B], bf: scala.collection.generic.CanBuildFrom[typing.List[bool], _scanRight__B, _scanRight__That]) -> _scanRight__That: ...
        def segmentLength(self, p: scala.Function1[typing.Any, typing.Any], from_: int) -> int: ...
        def seq(self) -> IndexedSeq[typing.Any]: ...
        def size(self) -> int: ...
        def sizeHintIfCheap(self) -> int: ...
        def slice(self, from_: int, until: int) -> typing.Any: ...
        def sliceWithKnownBound(self, from_: int, until: int) -> typing.Any: ...
        def sliceWithKnownDelta(self, from_: int, until: int, delta: int) -> typing.Any: ...
        @typing.overload
        def sliding(self, size: int) -> scala.collection.Iterator[typing.List[bool]]: ...
        @typing.overload
        def sliding(self, size: int, step: int) -> scala.collection.Iterator[typing.List[bool]]: ...
        def sortBy(self, f: scala.Function1, ord: scala.math.Ordering) -> typing.Any: ...
        def sortWith(self, lt: scala.Function2) -> typing.Any: ...
        def sorted(self, ord: scala.math.Ordering) -> typing.Any: ...
        def span(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.Tuple2[typing.List[bool], typing.List[bool]]: ...
        def splitAt(self, n: int) -> scala.Tuple2[typing.List[bool], typing.List[bool]]: ...
        _startsWith_0__B = typing.TypeVar('_startsWith_0__B')  # <B>
        _startsWith_1__B = typing.TypeVar('_startsWith_1__B')  # <B>
        @typing.overload
        def startsWith(self, that: scala.collection.GenSeq[_startsWith_0__B]) -> bool: ...
        @typing.overload
        def startsWith(self, that: scala.collection.GenSeq[_startsWith_1__B], offset: int) -> bool: ...
        def stringPrefix(self) -> str: ...
        _sum__B = typing.TypeVar('_sum__B')  # <B>
        def sum(self, num: scala.math.Numeric[_sum__B]) -> _sum__B: ...
        def tail(self) -> typing.Any: ...
        def tails(self) -> scala.collection.Iterator[typing.List[bool]]: ...
        def take(self, n: int) -> typing.Any: ...
        def takeRight(self, n: int) -> typing.Any: ...
        def takeWhile(self, p: scala.Function1) -> typing.Any: ...
        def thisCollection(self) -> 'WrappedArray'[typing.Any]: ...
        _to__Col = typing.TypeVar('_to__Col')  # <Col>
        def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., typing.Any, _to__Col]) -> _to__Col: ...
        _toArray__U = typing.TypeVar('_toArray__U')  # <U>
        def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__U]) -> typing.Any: ...
        _toBuffer__A1 = typing.TypeVar('_toBuffer__A1')  # <A1>
        def toBuffer(self) -> Buffer[_toBuffer__A1]: ...
        def toCollection(self, repr: typing.List[bool]) -> 'WrappedArray'[typing.Any]: ...
        def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq[typing.Any]: ...
        def toIterable(self) -> scala.collection.Iterable[typing.Any]: ...
        def toIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def toList(self) -> scala.collection.immutable.List[typing.Any]: ...
        _toMap__T = typing.TypeVar('_toMap__T')  # <T>
        _toMap__U = typing.TypeVar('_toMap__U')  # <U>
        def toMap(self, ev: scala.Predef..less.colon.less[typing.Any, scala.Tuple2[_toMap__T, _toMap__U]]) -> scala.collection.immutable.Map[_toMap__T, _toMap__U]: ...
        def toSeq(self) -> scala.collection.Seq[typing.Any]: ...
        _toSet__B = typing.TypeVar('_toSet__B')  # <B>
        def toSet(self) -> scala.collection.immutable.Set[_toSet__B]: ...
        def toStream(self) -> scala.collection.immutable.Stream[typing.Any]: ...
        def toString(self) -> str: ...
        def toTraversable(self) -> scala.collection.Traversable[typing.Any]: ...
        def toVector(self) -> scala.collection.immutable.Vector[typing.Any]: ...
        _transpose__U = typing.TypeVar('_transpose__U')  # <U>
        def transpose(self, asArray: scala.Function1[typing.Any, typing.Any]) -> typing.List[typing.Any]: ...
        _union__B = typing.TypeVar('_union__B')  # <B>
        _union__That = typing.TypeVar('_union__That')  # <That>
        def union(self, that: scala.collection.GenSeq[_union__B], bf: scala.collection.generic.CanBuildFrom[typing.List[bool], _union__B, _union__That]) -> _union__That: ...
        _unzip__T1 = typing.TypeVar('_unzip__T1')  # <T1>
        _unzip__T2 = typing.TypeVar('_unzip__T2')  # <T2>
        def unzip(self, asPair: scala.Function1[typing.Any, scala.Tuple2[_unzip__T1, _unzip__T2]], ct1: scala.reflect.ClassTag[_unzip__T1], ct2: scala.reflect.ClassTag[_unzip__T2]) -> scala.Tuple2[typing.Any, typing.Any]: ...
        _unzip3__T1 = typing.TypeVar('_unzip3__T1')  # <T1>
        _unzip3__T2 = typing.TypeVar('_unzip3__T2')  # <T2>
        _unzip3__T3 = typing.TypeVar('_unzip3__T3')  # <T3>
        def unzip3(self, asTriple: scala.Function1[typing.Any, scala.Tuple3[_unzip3__T1, _unzip3__T2, _unzip3__T3]], ct1: scala.reflect.ClassTag[_unzip3__T1], ct2: scala.reflect.ClassTag[_unzip3__T2], ct3: scala.reflect.ClassTag[_unzip3__T3]) -> scala.Tuple3[typing.Any, typing.Any, typing.Any]: ...
        def update(self, index: int, elem: bool) -> None: ...
        _updated__B = typing.TypeVar('_updated__B')  # <B>
        _updated__That = typing.TypeVar('_updated__That')  # <That>
        def updated(self, index: int, elem: _updated__B, bf: scala.collection.generic.CanBuildFrom[typing.List[bool], _updated__B, _updated__That]) -> _updated__That: ...
        @typing.overload
        def view(self) -> 'IndexedSeqView'[typing.Any, typing.List[bool]]: ...
        @typing.overload
        def view(self, from_: int, until: int) -> 'IndexedSeqView'[typing.Any, typing.List[bool]]: ...
        def withFilter(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.collection.generic.FilterMonadic[typing.Any, typing.List[bool]]: ...
        _zip__A1 = typing.TypeVar('_zip__A1')  # <A1>
        _zip__B = typing.TypeVar('_zip__B')  # <B>
        _zip__That = typing.TypeVar('_zip__That')  # <That>
        def zip(self, that: scala.collection.GenIterable[_zip__B], bf: scala.collection.generic.CanBuildFrom[typing.List[bool], scala.Tuple2[_zip__A1, _zip__B], _zip__That]) -> _zip__That: ...
        _zipAll__B = typing.TypeVar('_zipAll__B')  # <B>
        _zipAll__A1 = typing.TypeVar('_zipAll__A1')  # <A1>
        _zipAll__That = typing.TypeVar('_zipAll__That')  # <That>
        def zipAll(self, that: scala.collection.GenIterable[_zipAll__B], thisElem: _zipAll__A1, thatElem: _zipAll__B, bf: scala.collection.generic.CanBuildFrom[typing.List[bool], scala.Tuple2[_zipAll__A1, _zipAll__B], _zipAll__That]) -> _zipAll__That: ...
        _zipWithIndex__A1 = typing.TypeVar('_zipWithIndex__A1')  # <A1>
        _zipWithIndex__That = typing.TypeVar('_zipWithIndex__That')  # <That>
        def zipWithIndex(self, bf: scala.collection.generic.CanBuildFrom[typing.List[bool], scala.Tuple2[_zipWithIndex__A1, typing.Any], _zipWithIndex__That]) -> _zipWithIndex__That: ...
    class ofBoolean$:
        MODULE$: typing.ClassVar['ArrayOps.ofBoolean.'] = ...
        def __init__(self): ...
        def apply$extension(self, $this: typing.List[bool], index: int) -> bool: ...
        def equals$extension(self, $this: typing.List[bool], x$1: typing.Any) -> bool: ...
        def hashCode$extension(self, $this: typing.List[bool]) -> int: ...
        def length$extension(self, $this: typing.List[bool]) -> int: ...
        def newBuilder$extension(self, $this: typing.List[bool]) -> ArrayBuilder.ofBoolean: ...
        def thisCollection$extension(self, $this: typing.List[bool]) -> 'WrappedArray'[typing.Any]: ...
        def toCollection$extension(self, $this: typing.List[bool], repr: typing.List[bool]) -> 'WrappedArray'[typing.Any]: ...
        def update$extension(self, $this: typing.List[bool], index: int, elem: bool) -> None: ...
    class ofByte(scala.collection.mutable.ArrayOps[typing.Any]):
        def __init__(self, repr: typing.List[int]): ...
        _$colon$bslash__B = typing.TypeVar('_$colon$bslash__B')  # <B>
        def $colon$bslash(self, z: _.colon.bslash__B, op: scala.Function2[typing.Any, _.colon.bslash__B, _.colon.bslash__B]) -> _.colon.bslash__B: ...
        _$colon$plus_0__B = typing.TypeVar('_$colon$plus_0__B')  # <B>
        _$colon$plus_0__That = typing.TypeVar('_$colon$plus_0__That')  # <That>
        _$colon$plus_1__B = typing.TypeVar('_$colon$plus_1__B')  # <B>
        @typing.overload
        def $colon$plus(self, elem: _.colon.plus_0__B, bf: scala.collection.generic.CanBuildFrom[typing.List[int], _.colon.plus_0__B, _.colon.plus_0__That]) -> _.colon.plus_0__That: ...
        @typing.overload
        def $colon$plus(self, elem: _.colon.plus_1__B, evidence$2: scala.reflect.ClassTag[_.colon.plus_1__B]) -> typing.Any: ...
        _$div$colon__B = typing.TypeVar('_$div$colon__B')  # <B>
        def $div$colon(self, z: _.div.colon__B, op: scala.Function2[_.div.colon__B, typing.Any, _.div.colon__B]) -> _.div.colon__B: ...
        _$plus$colon_0__B = typing.TypeVar('_$plus$colon_0__B')  # <B>
        _$plus$colon_0__That = typing.TypeVar('_$plus$colon_0__That')  # <That>
        _$plus$colon_1__B = typing.TypeVar('_$plus$colon_1__B')  # <B>
        @typing.overload
        def $plus$colon(self, elem: _.plus.colon_0__B, bf: scala.collection.generic.CanBuildFrom[typing.List[int], _.plus.colon_0__B, _.plus.colon_0__That]) -> _.plus.colon_0__That: ...
        @typing.overload
        def $plus$colon(self, elem: _.plus.colon_1__B, evidence$3: scala.reflect.ClassTag[_.plus.colon_1__B]) -> typing.Any: ...
        _$plus$plus__B = typing.TypeVar('_$plus$plus__B')  # <B>
        _$plus$plus__That = typing.TypeVar('_$plus$plus__That')  # <That>
        def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _.plus.plus__B, _.plus.plus__That]) -> _.plus.plus__That: ...
        _$plus$plus$colon_0__B = typing.TypeVar('_$plus$plus$colon_0__B')  # <B>
        _$plus$plus$colon_0__That = typing.TypeVar('_$plus$plus$colon_0__That')  # <That>
        _$plus$plus$colon_1__B = typing.TypeVar('_$plus$plus$colon_1__B')  # <B>
        _$plus$plus$colon_1__That = typing.TypeVar('_$plus$plus$colon_1__That')  # <That>
        @typing.overload
        def $plus$plus$colon(self, that: scala.collection.Traversable[_.plus.plus.colon_0__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _.plus.plus.colon_0__B, _.plus.plus.colon_0__That]) -> _.plus.plus.colon_0__That: ...
        @typing.overload
        def $plus$plus$colon(self, that: scala.collection.TraversableOnce[_.plus.plus.colon_1__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _.plus.plus.colon_1__B, _.plus.plus.colon_1__That]) -> _.plus.plus.colon_1__That: ...
        @typing.overload
        def addString(self, b: StringBuilder) -> StringBuilder: ...
        @typing.overload
        def addString(self, b: StringBuilder, sep: str) -> StringBuilder: ...
        @typing.overload
        def addString(self, b: StringBuilder, start: str, sep: str, end: str) -> StringBuilder: ...
        _aggregate__B = typing.TypeVar('_aggregate__B')  # <B>
        def aggregate(self, z: scala.Function0[_aggregate__B], seqop: scala.Function2[_aggregate__B, typing.Any, _aggregate__B], combop: scala.Function2[_aggregate__B, _aggregate__B, _aggregate__B]) -> _aggregate__B: ...
        def apply(self, index: int) -> int: ...
        def canEqual(self, that: typing.Any) -> bool: ...
        _collect__B = typing.TypeVar('_collect__B')  # <B>
        _collect__That = typing.TypeVar('_collect__That')  # <That>
        def collect(self, pf: scala.PartialFunction[typing.Any, _collect__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _collect__B, _collect__That]) -> _collect__That: ...
        _collectFirst__B = typing.TypeVar('_collectFirst__B')  # <B>
        def collectFirst(self, pf: scala.PartialFunction[typing.Any, _collectFirst__B]) -> scala.Option[_collectFirst__B]: ...
        def combinations(self, n: int) -> scala.collection.Iterator[typing.List[int]]: ...
        _contains__A1 = typing.TypeVar('_contains__A1')  # <A1>
        def contains(self, elem: _contains__A1) -> bool: ...
        _containsSlice__B = typing.TypeVar('_containsSlice__B')  # <B>
        def containsSlice(self, that: scala.collection.GenSeq[_containsSlice__B]) -> bool: ...
        _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
        _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
        _copyToArray_2__U = typing.TypeVar('_copyToArray_2__U')  # <U>
        @typing.overload
        def copyToArray(self, xs: typing.Any) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
        _copyToBuffer__B = typing.TypeVar('_copyToBuffer__B')  # <B>
        def copyToBuffer(self, dest: Buffer[_copyToBuffer__B]) -> None: ...
        _corresponds__B = typing.TypeVar('_corresponds__B')  # <B>
        def corresponds(self, that: scala.collection.GenSeq[_corresponds__B], p: scala.Function2[typing.Any, _corresponds__B, typing.Any]) -> bool: ...
        def count(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        def deep(self) -> scala.collection.IndexedSeq[typing.Any]: ...
        def diff(self, that: scala.collection.GenSeq) -> typing.Any: ...
        def distinct(self) -> typing.Any: ...
        def drop(self, n: int) -> typing.Any: ...
        def dropRight(self, n: int) -> typing.Any: ...
        def dropWhile(self, p: scala.Function1) -> typing.Any: ...
        _endsWith__B = typing.TypeVar('_endsWith__B')  # <B>
        def endsWith(self, that: scala.collection.GenSeq[_endsWith__B]) -> bool: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def exists(self, p: scala.Function1[typing.Any, typing.Any]) -> bool: ...
        def filter(self, p: scala.Function1) -> typing.Any: ...
        def filterImpl(self, p: scala.Function1, isFlipped: bool) -> typing.Any: ...
        def filterNot(self, p: scala.Function1) -> typing.Any: ...
        def find(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.Option[typing.Any]: ...
        _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
        _flatMap__That = typing.TypeVar('_flatMap__That')  # <That>
        def flatMap(self, f: scala.Function1[typing.Any, scala.collection.GenTraversableOnce[_flatMap__B]], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _flatMap__B, _flatMap__That]) -> _flatMap__That: ...
        _flatten__U = typing.TypeVar('_flatten__U')  # <U>
        def flatten(self, asTrav: scala.Function1[typing.Any, scala.collection.Traversable[_flatten__U]], m: scala.reflect.ClassTag[_flatten__U]) -> typing.Any: ...
        _fold__A1 = typing.TypeVar('_fold__A1')  # <A1>
        def fold(self, z: _fold__A1, op: scala.Function2[_fold__A1, _fold__A1, _fold__A1]) -> _fold__A1: ...
        _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
        def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, typing.Any, _foldLeft__B]) -> _foldLeft__B: ...
        _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
        def foldRight(self, z: _foldRight__B, op: scala.Function2[typing.Any, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
        def forall(self, p: scala.Function1[typing.Any, typing.Any]) -> bool: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[typing.Any, _foreach__U]) -> None: ...
        _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
        def groupBy(self, f: scala.Function1[typing.Any, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, typing.List[int]]: ...
        def grouped(self, size: int) -> scala.collection.Iterator[typing.List[int]]: ...
        def hasDefiniteSize(self) -> bool: ...
        def hashCode(self) -> int: ...
        def head(self) -> typing.Any: ...
        def headOption(self) -> scala.Option[typing.Any]: ...
        _indexOf_0__B = typing.TypeVar('_indexOf_0__B')  # <B>
        _indexOf_1__B = typing.TypeVar('_indexOf_1__B')  # <B>
        @typing.overload
        def indexOf(self, elem: _indexOf_0__B) -> int: ...
        @typing.overload
        def indexOf(self, elem: _indexOf_1__B, from_: int) -> int: ...
        _indexOfSlice_0__B = typing.TypeVar('_indexOfSlice_0__B')  # <B>
        _indexOfSlice_1__B = typing.TypeVar('_indexOfSlice_1__B')  # <B>
        @typing.overload
        def indexOfSlice(self, that: scala.collection.GenSeq[_indexOfSlice_0__B]) -> int: ...
        @typing.overload
        def indexOfSlice(self, that: scala.collection.GenSeq[_indexOfSlice_1__B], from_: int) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[typing.Any, typing.Any], from_: int) -> int: ...
        def indices(self) -> scala.collection.immutable.Range: ...
        def init(self) -> typing.Any: ...
        def inits(self) -> scala.collection.Iterator[typing.List[int]]: ...
        def intersect(self, that: scala.collection.GenSeq) -> typing.Any: ...
        def isDefinedAt(self, idx: int) -> bool: ...
        def isEmpty(self) -> bool: ...
        def isTraversableAgain(self) -> bool: ...
        def iterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def last(self) -> typing.Any: ...
        _lastIndexOf_0__B = typing.TypeVar('_lastIndexOf_0__B')  # <B>
        _lastIndexOf_1__B = typing.TypeVar('_lastIndexOf_1__B')  # <B>
        @typing.overload
        def lastIndexOf(self, elem: _lastIndexOf_0__B) -> int: ...
        @typing.overload
        def lastIndexOf(self, elem: _lastIndexOf_1__B, end: int) -> int: ...
        _lastIndexOfSlice_0__B = typing.TypeVar('_lastIndexOfSlice_0__B')  # <B>
        _lastIndexOfSlice_1__B = typing.TypeVar('_lastIndexOfSlice_1__B')  # <B>
        @typing.overload
        def lastIndexOfSlice(self, that: scala.collection.GenSeq[_lastIndexOfSlice_0__B]) -> int: ...
        @typing.overload
        def lastIndexOfSlice(self, that: scala.collection.GenSeq[_lastIndexOfSlice_1__B], end: int) -> int: ...
        @typing.overload
        def lastIndexWhere(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        @typing.overload
        def lastIndexWhere(self, p: scala.Function1[typing.Any, typing.Any], end: int) -> int: ...
        def lastOption(self) -> scala.Option[typing.Any]: ...
        def length(self) -> int: ...
        def lengthCompare(self, len: int) -> int: ...
        _map__B = typing.TypeVar('_map__B')  # <B>
        _map__That = typing.TypeVar('_map__That')  # <That>
        def map(self, f: scala.Function1[typing.Any, _map__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _map__B, _map__That]) -> _map__That: ...
        def max(self, cmp: scala.math.Ordering) -> typing.Any: ...
        def maxBy(self, f: scala.Function1, cmp: scala.math.Ordering) -> typing.Any: ...
        def min(self, cmp: scala.math.Ordering) -> typing.Any: ...
        def minBy(self, f: scala.Function1, cmp: scala.math.Ordering) -> typing.Any: ...
        @typing.overload
        def mkString(self) -> str: ...
        @typing.overload
        def mkString(self, sep: str) -> str: ...
        @typing.overload
        def mkString(self, start: str, sep: str, end: str) -> str: ...
        def newBuilder(self) -> ArrayBuilder.ofByte: ...
        def nonEmpty(self) -> bool: ...
        _padTo__B = typing.TypeVar('_padTo__B')  # <B>
        _padTo__That = typing.TypeVar('_padTo__That')  # <That>
        def padTo(self, len: int, elem: _padTo__B, bf: scala.collection.generic.CanBuildFrom[typing.List[int], _padTo__B, _padTo__That]) -> _padTo__That: ...
        def par(self) -> scala.collection.parallel.mutable.ParArray[typing.Any]: ...
        def parCombiner(self) -> scala.collection.parallel.Combiner[typing.Any, scala.collection.parallel.mutable.ParArray[typing.Any]]: ...
        def partition(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.Tuple2[typing.List[int], typing.List[int]]: ...
        _patch__B = typing.TypeVar('_patch__B')  # <B>
        _patch__That = typing.TypeVar('_patch__That')  # <That>
        def patch(self, from_: int, patch: scala.collection.GenSeq[_patch__B], replaced: int, bf: scala.collection.generic.CanBuildFrom[typing.List[int], _patch__B, _patch__That]) -> _patch__That: ...
        def permutations(self) -> scala.collection.Iterator[typing.List[int]]: ...
        def prefixLength(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        _product__B = typing.TypeVar('_product__B')  # <B>
        def product(self, num: scala.math.Numeric[_product__B]) -> _product__B: ...
        _reduce__A1 = typing.TypeVar('_reduce__A1')  # <A1>
        def reduce(self, op: scala.Function2[_reduce__A1, _reduce__A1, _reduce__A1]) -> _reduce__A1: ...
        _reduceLeft__B = typing.TypeVar('_reduceLeft__B')  # <B>
        def reduceLeft(self, op: scala.Function2[_reduceLeft__B, typing.Any, _reduceLeft__B]) -> _reduceLeft__B: ...
        _reduceLeftOption__B = typing.TypeVar('_reduceLeftOption__B')  # <B>
        def reduceLeftOption(self, op: scala.Function2[_reduceLeftOption__B, typing.Any, _reduceLeftOption__B]) -> scala.Option[_reduceLeftOption__B]: ...
        _reduceOption__A1 = typing.TypeVar('_reduceOption__A1')  # <A1>
        def reduceOption(self, op: scala.Function2[_reduceOption__A1, _reduceOption__A1, _reduceOption__A1]) -> scala.Option[_reduceOption__A1]: ...
        _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
        def reduceRight(self, op: scala.Function2[typing.Any, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
        _reduceRightOption__B = typing.TypeVar('_reduceRightOption__B')  # <B>
        def reduceRightOption(self, op: scala.Function2[typing.Any, _reduceRightOption__B, _reduceRightOption__B]) -> scala.Option[_reduceRightOption__B]: ...
        def repr(self) -> typing.List[int]: ...
        def reverse(self) -> typing.Any: ...
        def reverseIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        _reverseMap__B = typing.TypeVar('_reverseMap__B')  # <B>
        _reverseMap__That = typing.TypeVar('_reverseMap__That')  # <That>
        def reverseMap(self, f: scala.Function1[typing.Any, _reverseMap__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _reverseMap__B, _reverseMap__That]) -> _reverseMap__That: ...
        def reversed(self) -> scala.collection.immutable.List[typing.Any]: ...
        _sameElements__B = typing.TypeVar('_sameElements__B')  # <B>
        def sameElements(self, that: scala.collection.GenIterable[_sameElements__B]) -> bool: ...
        _scan__B = typing.TypeVar('_scan__B')  # <B>
        _scan__That = typing.TypeVar('_scan__That')  # <That>
        def scan(self, z: _scan__B, op: scala.Function2[_scan__B, _scan__B, _scan__B], cbf: scala.collection.generic.CanBuildFrom[typing.List[int], _scan__B, _scan__That]) -> _scan__That: ...
        _scanLeft__B = typing.TypeVar('_scanLeft__B')  # <B>
        _scanLeft__That = typing.TypeVar('_scanLeft__That')  # <That>
        def scanLeft(self, z: _scanLeft__B, op: scala.Function2[_scanLeft__B, typing.Any, _scanLeft__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _scanLeft__B, _scanLeft__That]) -> _scanLeft__That: ...
        _scanRight__B = typing.TypeVar('_scanRight__B')  # <B>
        _scanRight__That = typing.TypeVar('_scanRight__That')  # <That>
        def scanRight(self, z: _scanRight__B, op: scala.Function2[typing.Any, _scanRight__B, _scanRight__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _scanRight__B, _scanRight__That]) -> _scanRight__That: ...
        def segmentLength(self, p: scala.Function1[typing.Any, typing.Any], from_: int) -> int: ...
        def seq(self) -> IndexedSeq[typing.Any]: ...
        def size(self) -> int: ...
        def sizeHintIfCheap(self) -> int: ...
        def slice(self, from_: int, until: int) -> typing.Any: ...
        def sliceWithKnownBound(self, from_: int, until: int) -> typing.Any: ...
        def sliceWithKnownDelta(self, from_: int, until: int, delta: int) -> typing.Any: ...
        @typing.overload
        def sliding(self, size: int) -> scala.collection.Iterator[typing.List[int]]: ...
        @typing.overload
        def sliding(self, size: int, step: int) -> scala.collection.Iterator[typing.List[int]]: ...
        def sortBy(self, f: scala.Function1, ord: scala.math.Ordering) -> typing.Any: ...
        def sortWith(self, lt: scala.Function2) -> typing.Any: ...
        def sorted(self, ord: scala.math.Ordering) -> typing.Any: ...
        def span(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.Tuple2[typing.List[int], typing.List[int]]: ...
        def splitAt(self, n: int) -> scala.Tuple2[typing.List[int], typing.List[int]]: ...
        _startsWith_0__B = typing.TypeVar('_startsWith_0__B')  # <B>
        _startsWith_1__B = typing.TypeVar('_startsWith_1__B')  # <B>
        @typing.overload
        def startsWith(self, that: scala.collection.GenSeq[_startsWith_0__B]) -> bool: ...
        @typing.overload
        def startsWith(self, that: scala.collection.GenSeq[_startsWith_1__B], offset: int) -> bool: ...
        def stringPrefix(self) -> str: ...
        _sum__B = typing.TypeVar('_sum__B')  # <B>
        def sum(self, num: scala.math.Numeric[_sum__B]) -> _sum__B: ...
        def tail(self) -> typing.Any: ...
        def tails(self) -> scala.collection.Iterator[typing.List[int]]: ...
        def take(self, n: int) -> typing.Any: ...
        def takeRight(self, n: int) -> typing.Any: ...
        def takeWhile(self, p: scala.Function1) -> typing.Any: ...
        def thisCollection(self) -> 'WrappedArray'[typing.Any]: ...
        _to__Col = typing.TypeVar('_to__Col')  # <Col>
        def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., typing.Any, _to__Col]) -> _to__Col: ...
        _toArray__U = typing.TypeVar('_toArray__U')  # <U>
        def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__U]) -> typing.Any: ...
        _toBuffer__A1 = typing.TypeVar('_toBuffer__A1')  # <A1>
        def toBuffer(self) -> Buffer[_toBuffer__A1]: ...
        def toCollection(self, repr: typing.List[int]) -> 'WrappedArray'[typing.Any]: ...
        def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq[typing.Any]: ...
        def toIterable(self) -> scala.collection.Iterable[typing.Any]: ...
        def toIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def toList(self) -> scala.collection.immutable.List[typing.Any]: ...
        _toMap__T = typing.TypeVar('_toMap__T')  # <T>
        _toMap__U = typing.TypeVar('_toMap__U')  # <U>
        def toMap(self, ev: scala.Predef..less.colon.less[typing.Any, scala.Tuple2[_toMap__T, _toMap__U]]) -> scala.collection.immutable.Map[_toMap__T, _toMap__U]: ...
        def toSeq(self) -> scala.collection.Seq[typing.Any]: ...
        _toSet__B = typing.TypeVar('_toSet__B')  # <B>
        def toSet(self) -> scala.collection.immutable.Set[_toSet__B]: ...
        def toStream(self) -> scala.collection.immutable.Stream[typing.Any]: ...
        def toString(self) -> str: ...
        def toTraversable(self) -> scala.collection.Traversable[typing.Any]: ...
        def toVector(self) -> scala.collection.immutable.Vector[typing.Any]: ...
        _transpose__U = typing.TypeVar('_transpose__U')  # <U>
        def transpose(self, asArray: scala.Function1[typing.Any, typing.Any]) -> typing.List[typing.Any]: ...
        _union__B = typing.TypeVar('_union__B')  # <B>
        _union__That = typing.TypeVar('_union__That')  # <That>
        def union(self, that: scala.collection.GenSeq[_union__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _union__B, _union__That]) -> _union__That: ...
        _unzip__T1 = typing.TypeVar('_unzip__T1')  # <T1>
        _unzip__T2 = typing.TypeVar('_unzip__T2')  # <T2>
        def unzip(self, asPair: scala.Function1[typing.Any, scala.Tuple2[_unzip__T1, _unzip__T2]], ct1: scala.reflect.ClassTag[_unzip__T1], ct2: scala.reflect.ClassTag[_unzip__T2]) -> scala.Tuple2[typing.Any, typing.Any]: ...
        _unzip3__T1 = typing.TypeVar('_unzip3__T1')  # <T1>
        _unzip3__T2 = typing.TypeVar('_unzip3__T2')  # <T2>
        _unzip3__T3 = typing.TypeVar('_unzip3__T3')  # <T3>
        def unzip3(self, asTriple: scala.Function1[typing.Any, scala.Tuple3[_unzip3__T1, _unzip3__T2, _unzip3__T3]], ct1: scala.reflect.ClassTag[_unzip3__T1], ct2: scala.reflect.ClassTag[_unzip3__T2], ct3: scala.reflect.ClassTag[_unzip3__T3]) -> scala.Tuple3[typing.Any, typing.Any, typing.Any]: ...
        def update(self, index: int, elem: int) -> None: ...
        _updated__B = typing.TypeVar('_updated__B')  # <B>
        _updated__That = typing.TypeVar('_updated__That')  # <That>
        def updated(self, index: int, elem: _updated__B, bf: scala.collection.generic.CanBuildFrom[typing.List[int], _updated__B, _updated__That]) -> _updated__That: ...
        @typing.overload
        def view(self) -> 'IndexedSeqView'[typing.Any, typing.List[int]]: ...
        @typing.overload
        def view(self, from_: int, until: int) -> 'IndexedSeqView'[typing.Any, typing.List[int]]: ...
        def withFilter(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.collection.generic.FilterMonadic[typing.Any, typing.List[int]]: ...
        _zip__A1 = typing.TypeVar('_zip__A1')  # <A1>
        _zip__B = typing.TypeVar('_zip__B')  # <B>
        _zip__That = typing.TypeVar('_zip__That')  # <That>
        def zip(self, that: scala.collection.GenIterable[_zip__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], scala.Tuple2[_zip__A1, _zip__B], _zip__That]) -> _zip__That: ...
        _zipAll__B = typing.TypeVar('_zipAll__B')  # <B>
        _zipAll__A1 = typing.TypeVar('_zipAll__A1')  # <A1>
        _zipAll__That = typing.TypeVar('_zipAll__That')  # <That>
        def zipAll(self, that: scala.collection.GenIterable[_zipAll__B], thisElem: _zipAll__A1, thatElem: _zipAll__B, bf: scala.collection.generic.CanBuildFrom[typing.List[int], scala.Tuple2[_zipAll__A1, _zipAll__B], _zipAll__That]) -> _zipAll__That: ...
        _zipWithIndex__A1 = typing.TypeVar('_zipWithIndex__A1')  # <A1>
        _zipWithIndex__That = typing.TypeVar('_zipWithIndex__That')  # <That>
        def zipWithIndex(self, bf: scala.collection.generic.CanBuildFrom[typing.List[int], scala.Tuple2[_zipWithIndex__A1, typing.Any], _zipWithIndex__That]) -> _zipWithIndex__That: ...
    class ofByte$:
        MODULE$: typing.ClassVar['ArrayOps.ofByte.'] = ...
        def __init__(self): ...
        def apply$extension(self, $this: typing.List[int], index: int) -> int: ...
        def equals$extension(self, $this: typing.List[int], x$1: typing.Any) -> bool: ...
        def hashCode$extension(self, $this: typing.List[int]) -> int: ...
        def length$extension(self, $this: typing.List[int]) -> int: ...
        def newBuilder$extension(self, $this: typing.List[int]) -> ArrayBuilder.ofByte: ...
        def thisCollection$extension(self, $this: typing.List[int]) -> 'WrappedArray'[typing.Any]: ...
        def toCollection$extension(self, $this: typing.List[int], repr: typing.List[int]) -> 'WrappedArray'[typing.Any]: ...
        def update$extension(self, $this: typing.List[int], index: int, elem: int) -> None: ...
    class ofChar(scala.collection.mutable.ArrayOps[typing.Any]):
        def __init__(self, repr: typing.List[str]): ...
        _$colon$bslash__B = typing.TypeVar('_$colon$bslash__B')  # <B>
        def $colon$bslash(self, z: _.colon.bslash__B, op: scala.Function2[typing.Any, _.colon.bslash__B, _.colon.bslash__B]) -> _.colon.bslash__B: ...
        _$colon$plus_0__B = typing.TypeVar('_$colon$plus_0__B')  # <B>
        _$colon$plus_0__That = typing.TypeVar('_$colon$plus_0__That')  # <That>
        _$colon$plus_1__B = typing.TypeVar('_$colon$plus_1__B')  # <B>
        @typing.overload
        def $colon$plus(self, elem: _.colon.plus_0__B, bf: scala.collection.generic.CanBuildFrom[typing.List[str], _.colon.plus_0__B, _.colon.plus_0__That]) -> _.colon.plus_0__That: ...
        @typing.overload
        def $colon$plus(self, elem: _.colon.plus_1__B, evidence$2: scala.reflect.ClassTag[_.colon.plus_1__B]) -> typing.Any: ...
        _$div$colon__B = typing.TypeVar('_$div$colon__B')  # <B>
        def $div$colon(self, z: _.div.colon__B, op: scala.Function2[_.div.colon__B, typing.Any, _.div.colon__B]) -> _.div.colon__B: ...
        _$plus$colon_0__B = typing.TypeVar('_$plus$colon_0__B')  # <B>
        _$plus$colon_0__That = typing.TypeVar('_$plus$colon_0__That')  # <That>
        _$plus$colon_1__B = typing.TypeVar('_$plus$colon_1__B')  # <B>
        @typing.overload
        def $plus$colon(self, elem: _.plus.colon_0__B, bf: scala.collection.generic.CanBuildFrom[typing.List[str], _.plus.colon_0__B, _.plus.colon_0__That]) -> _.plus.colon_0__That: ...
        @typing.overload
        def $plus$colon(self, elem: _.plus.colon_1__B, evidence$3: scala.reflect.ClassTag[_.plus.colon_1__B]) -> typing.Any: ...
        _$plus$plus__B = typing.TypeVar('_$plus$plus__B')  # <B>
        _$plus$plus__That = typing.TypeVar('_$plus$plus__That')  # <That>
        def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus__B], bf: scala.collection.generic.CanBuildFrom[typing.List[str], _.plus.plus__B, _.plus.plus__That]) -> _.plus.plus__That: ...
        _$plus$plus$colon_0__B = typing.TypeVar('_$plus$plus$colon_0__B')  # <B>
        _$plus$plus$colon_0__That = typing.TypeVar('_$plus$plus$colon_0__That')  # <That>
        _$plus$plus$colon_1__B = typing.TypeVar('_$plus$plus$colon_1__B')  # <B>
        _$plus$plus$colon_1__That = typing.TypeVar('_$plus$plus$colon_1__That')  # <That>
        @typing.overload
        def $plus$plus$colon(self, that: scala.collection.Traversable[_.plus.plus.colon_0__B], bf: scala.collection.generic.CanBuildFrom[typing.List[str], _.plus.plus.colon_0__B, _.plus.plus.colon_0__That]) -> _.plus.plus.colon_0__That: ...
        @typing.overload
        def $plus$plus$colon(self, that: scala.collection.TraversableOnce[_.plus.plus.colon_1__B], bf: scala.collection.generic.CanBuildFrom[typing.List[str], _.plus.plus.colon_1__B, _.plus.plus.colon_1__That]) -> _.plus.plus.colon_1__That: ...
        @typing.overload
        def addString(self, b: StringBuilder) -> StringBuilder: ...
        @typing.overload
        def addString(self, b: StringBuilder, sep: str) -> StringBuilder: ...
        @typing.overload
        def addString(self, b: StringBuilder, start: str, sep: str, end: str) -> StringBuilder: ...
        _aggregate__B = typing.TypeVar('_aggregate__B')  # <B>
        def aggregate(self, z: scala.Function0[_aggregate__B], seqop: scala.Function2[_aggregate__B, typing.Any, _aggregate__B], combop: scala.Function2[_aggregate__B, _aggregate__B, _aggregate__B]) -> _aggregate__B: ...
        def apply(self, index: int) -> str: ...
        def canEqual(self, that: typing.Any) -> bool: ...
        _collect__B = typing.TypeVar('_collect__B')  # <B>
        _collect__That = typing.TypeVar('_collect__That')  # <That>
        def collect(self, pf: scala.PartialFunction[typing.Any, _collect__B], bf: scala.collection.generic.CanBuildFrom[typing.List[str], _collect__B, _collect__That]) -> _collect__That: ...
        _collectFirst__B = typing.TypeVar('_collectFirst__B')  # <B>
        def collectFirst(self, pf: scala.PartialFunction[typing.Any, _collectFirst__B]) -> scala.Option[_collectFirst__B]: ...
        def combinations(self, n: int) -> scala.collection.Iterator[typing.List[str]]: ...
        _contains__A1 = typing.TypeVar('_contains__A1')  # <A1>
        def contains(self, elem: _contains__A1) -> bool: ...
        _containsSlice__B = typing.TypeVar('_containsSlice__B')  # <B>
        def containsSlice(self, that: scala.collection.GenSeq[_containsSlice__B]) -> bool: ...
        _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
        _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
        _copyToArray_2__U = typing.TypeVar('_copyToArray_2__U')  # <U>
        @typing.overload
        def copyToArray(self, xs: typing.Any) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
        _copyToBuffer__B = typing.TypeVar('_copyToBuffer__B')  # <B>
        def copyToBuffer(self, dest: Buffer[_copyToBuffer__B]) -> None: ...
        _corresponds__B = typing.TypeVar('_corresponds__B')  # <B>
        def corresponds(self, that: scala.collection.GenSeq[_corresponds__B], p: scala.Function2[typing.Any, _corresponds__B, typing.Any]) -> bool: ...
        def count(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        def deep(self) -> scala.collection.IndexedSeq[typing.Any]: ...
        def diff(self, that: scala.collection.GenSeq) -> typing.Any: ...
        def distinct(self) -> typing.Any: ...
        def drop(self, n: int) -> typing.Any: ...
        def dropRight(self, n: int) -> typing.Any: ...
        def dropWhile(self, p: scala.Function1) -> typing.Any: ...
        _endsWith__B = typing.TypeVar('_endsWith__B')  # <B>
        def endsWith(self, that: scala.collection.GenSeq[_endsWith__B]) -> bool: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def exists(self, p: scala.Function1[typing.Any, typing.Any]) -> bool: ...
        def filter(self, p: scala.Function1) -> typing.Any: ...
        def filterImpl(self, p: scala.Function1, isFlipped: bool) -> typing.Any: ...
        def filterNot(self, p: scala.Function1) -> typing.Any: ...
        def find(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.Option[typing.Any]: ...
        _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
        _flatMap__That = typing.TypeVar('_flatMap__That')  # <That>
        def flatMap(self, f: scala.Function1[typing.Any, scala.collection.GenTraversableOnce[_flatMap__B]], bf: scala.collection.generic.CanBuildFrom[typing.List[str], _flatMap__B, _flatMap__That]) -> _flatMap__That: ...
        _flatten__U = typing.TypeVar('_flatten__U')  # <U>
        def flatten(self, asTrav: scala.Function1[typing.Any, scala.collection.Traversable[_flatten__U]], m: scala.reflect.ClassTag[_flatten__U]) -> typing.Any: ...
        _fold__A1 = typing.TypeVar('_fold__A1')  # <A1>
        def fold(self, z: _fold__A1, op: scala.Function2[_fold__A1, _fold__A1, _fold__A1]) -> _fold__A1: ...
        _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
        def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, typing.Any, _foldLeft__B]) -> _foldLeft__B: ...
        _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
        def foldRight(self, z: _foldRight__B, op: scala.Function2[typing.Any, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
        def forall(self, p: scala.Function1[typing.Any, typing.Any]) -> bool: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[typing.Any, _foreach__U]) -> None: ...
        _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
        def groupBy(self, f: scala.Function1[typing.Any, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, typing.List[str]]: ...
        def grouped(self, size: int) -> scala.collection.Iterator[typing.List[str]]: ...
        def hasDefiniteSize(self) -> bool: ...
        def hashCode(self) -> int: ...
        def head(self) -> typing.Any: ...
        def headOption(self) -> scala.Option[typing.Any]: ...
        _indexOf_0__B = typing.TypeVar('_indexOf_0__B')  # <B>
        _indexOf_1__B = typing.TypeVar('_indexOf_1__B')  # <B>
        @typing.overload
        def indexOf(self, elem: _indexOf_0__B) -> int: ...
        @typing.overload
        def indexOf(self, elem: _indexOf_1__B, from_: int) -> int: ...
        _indexOfSlice_0__B = typing.TypeVar('_indexOfSlice_0__B')  # <B>
        _indexOfSlice_1__B = typing.TypeVar('_indexOfSlice_1__B')  # <B>
        @typing.overload
        def indexOfSlice(self, that: scala.collection.GenSeq[_indexOfSlice_0__B]) -> int: ...
        @typing.overload
        def indexOfSlice(self, that: scala.collection.GenSeq[_indexOfSlice_1__B], from_: int) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[typing.Any, typing.Any], from_: int) -> int: ...
        def indices(self) -> scala.collection.immutable.Range: ...
        def init(self) -> typing.Any: ...
        def inits(self) -> scala.collection.Iterator[typing.List[str]]: ...
        def intersect(self, that: scala.collection.GenSeq) -> typing.Any: ...
        def isDefinedAt(self, idx: int) -> bool: ...
        def isEmpty(self) -> bool: ...
        def isTraversableAgain(self) -> bool: ...
        def iterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def last(self) -> typing.Any: ...
        _lastIndexOf_0__B = typing.TypeVar('_lastIndexOf_0__B')  # <B>
        _lastIndexOf_1__B = typing.TypeVar('_lastIndexOf_1__B')  # <B>
        @typing.overload
        def lastIndexOf(self, elem: _lastIndexOf_0__B) -> int: ...
        @typing.overload
        def lastIndexOf(self, elem: _lastIndexOf_1__B, end: int) -> int: ...
        _lastIndexOfSlice_0__B = typing.TypeVar('_lastIndexOfSlice_0__B')  # <B>
        _lastIndexOfSlice_1__B = typing.TypeVar('_lastIndexOfSlice_1__B')  # <B>
        @typing.overload
        def lastIndexOfSlice(self, that: scala.collection.GenSeq[_lastIndexOfSlice_0__B]) -> int: ...
        @typing.overload
        def lastIndexOfSlice(self, that: scala.collection.GenSeq[_lastIndexOfSlice_1__B], end: int) -> int: ...
        @typing.overload
        def lastIndexWhere(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        @typing.overload
        def lastIndexWhere(self, p: scala.Function1[typing.Any, typing.Any], end: int) -> int: ...
        def lastOption(self) -> scala.Option[typing.Any]: ...
        def length(self) -> int: ...
        def lengthCompare(self, len: int) -> int: ...
        _map__B = typing.TypeVar('_map__B')  # <B>
        _map__That = typing.TypeVar('_map__That')  # <That>
        def map(self, f: scala.Function1[typing.Any, _map__B], bf: scala.collection.generic.CanBuildFrom[typing.List[str], _map__B, _map__That]) -> _map__That: ...
        def max(self, cmp: scala.math.Ordering) -> typing.Any: ...
        def maxBy(self, f: scala.Function1, cmp: scala.math.Ordering) -> typing.Any: ...
        def min(self, cmp: scala.math.Ordering) -> typing.Any: ...
        def minBy(self, f: scala.Function1, cmp: scala.math.Ordering) -> typing.Any: ...
        @typing.overload
        def mkString(self) -> str: ...
        @typing.overload
        def mkString(self, sep: str) -> str: ...
        @typing.overload
        def mkString(self, start: str, sep: str, end: str) -> str: ...
        def newBuilder(self) -> ArrayBuilder.ofChar: ...
        def nonEmpty(self) -> bool: ...
        _padTo__B = typing.TypeVar('_padTo__B')  # <B>
        _padTo__That = typing.TypeVar('_padTo__That')  # <That>
        def padTo(self, len: int, elem: _padTo__B, bf: scala.collection.generic.CanBuildFrom[typing.List[str], _padTo__B, _padTo__That]) -> _padTo__That: ...
        def par(self) -> scala.collection.parallel.mutable.ParArray[typing.Any]: ...
        def parCombiner(self) -> scala.collection.parallel.Combiner[typing.Any, scala.collection.parallel.mutable.ParArray[typing.Any]]: ...
        def partition(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.Tuple2[typing.List[str], typing.List[str]]: ...
        _patch__B = typing.TypeVar('_patch__B')  # <B>
        _patch__That = typing.TypeVar('_patch__That')  # <That>
        def patch(self, from_: int, patch: scala.collection.GenSeq[_patch__B], replaced: int, bf: scala.collection.generic.CanBuildFrom[typing.List[str], _patch__B, _patch__That]) -> _patch__That: ...
        def permutations(self) -> scala.collection.Iterator[typing.List[str]]: ...
        def prefixLength(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        _product__B = typing.TypeVar('_product__B')  # <B>
        def product(self, num: scala.math.Numeric[_product__B]) -> _product__B: ...
        _reduce__A1 = typing.TypeVar('_reduce__A1')  # <A1>
        def reduce(self, op: scala.Function2[_reduce__A1, _reduce__A1, _reduce__A1]) -> _reduce__A1: ...
        _reduceLeft__B = typing.TypeVar('_reduceLeft__B')  # <B>
        def reduceLeft(self, op: scala.Function2[_reduceLeft__B, typing.Any, _reduceLeft__B]) -> _reduceLeft__B: ...
        _reduceLeftOption__B = typing.TypeVar('_reduceLeftOption__B')  # <B>
        def reduceLeftOption(self, op: scala.Function2[_reduceLeftOption__B, typing.Any, _reduceLeftOption__B]) -> scala.Option[_reduceLeftOption__B]: ...
        _reduceOption__A1 = typing.TypeVar('_reduceOption__A1')  # <A1>
        def reduceOption(self, op: scala.Function2[_reduceOption__A1, _reduceOption__A1, _reduceOption__A1]) -> scala.Option[_reduceOption__A1]: ...
        _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
        def reduceRight(self, op: scala.Function2[typing.Any, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
        _reduceRightOption__B = typing.TypeVar('_reduceRightOption__B')  # <B>
        def reduceRightOption(self, op: scala.Function2[typing.Any, _reduceRightOption__B, _reduceRightOption__B]) -> scala.Option[_reduceRightOption__B]: ...
        def repr(self) -> typing.List[str]: ...
        def reverse(self) -> typing.Any: ...
        def reverseIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        _reverseMap__B = typing.TypeVar('_reverseMap__B')  # <B>
        _reverseMap__That = typing.TypeVar('_reverseMap__That')  # <That>
        def reverseMap(self, f: scala.Function1[typing.Any, _reverseMap__B], bf: scala.collection.generic.CanBuildFrom[typing.List[str], _reverseMap__B, _reverseMap__That]) -> _reverseMap__That: ...
        def reversed(self) -> scala.collection.immutable.List[typing.Any]: ...
        _sameElements__B = typing.TypeVar('_sameElements__B')  # <B>
        def sameElements(self, that: scala.collection.GenIterable[_sameElements__B]) -> bool: ...
        _scan__B = typing.TypeVar('_scan__B')  # <B>
        _scan__That = typing.TypeVar('_scan__That')  # <That>
        def scan(self, z: _scan__B, op: scala.Function2[_scan__B, _scan__B, _scan__B], cbf: scala.collection.generic.CanBuildFrom[typing.List[str], _scan__B, _scan__That]) -> _scan__That: ...
        _scanLeft__B = typing.TypeVar('_scanLeft__B')  # <B>
        _scanLeft__That = typing.TypeVar('_scanLeft__That')  # <That>
        def scanLeft(self, z: _scanLeft__B, op: scala.Function2[_scanLeft__B, typing.Any, _scanLeft__B], bf: scala.collection.generic.CanBuildFrom[typing.List[str], _scanLeft__B, _scanLeft__That]) -> _scanLeft__That: ...
        _scanRight__B = typing.TypeVar('_scanRight__B')  # <B>
        _scanRight__That = typing.TypeVar('_scanRight__That')  # <That>
        def scanRight(self, z: _scanRight__B, op: scala.Function2[typing.Any, _scanRight__B, _scanRight__B], bf: scala.collection.generic.CanBuildFrom[typing.List[str], _scanRight__B, _scanRight__That]) -> _scanRight__That: ...
        def segmentLength(self, p: scala.Function1[typing.Any, typing.Any], from_: int) -> int: ...
        def seq(self) -> IndexedSeq[typing.Any]: ...
        def size(self) -> int: ...
        def sizeHintIfCheap(self) -> int: ...
        def slice(self, from_: int, until: int) -> typing.Any: ...
        def sliceWithKnownBound(self, from_: int, until: int) -> typing.Any: ...
        def sliceWithKnownDelta(self, from_: int, until: int, delta: int) -> typing.Any: ...
        @typing.overload
        def sliding(self, size: int) -> scala.collection.Iterator[typing.List[str]]: ...
        @typing.overload
        def sliding(self, size: int, step: int) -> scala.collection.Iterator[typing.List[str]]: ...
        def sortBy(self, f: scala.Function1, ord: scala.math.Ordering) -> typing.Any: ...
        def sortWith(self, lt: scala.Function2) -> typing.Any: ...
        def sorted(self, ord: scala.math.Ordering) -> typing.Any: ...
        def span(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.Tuple2[typing.List[str], typing.List[str]]: ...
        def splitAt(self, n: int) -> scala.Tuple2[typing.List[str], typing.List[str]]: ...
        _startsWith_0__B = typing.TypeVar('_startsWith_0__B')  # <B>
        _startsWith_1__B = typing.TypeVar('_startsWith_1__B')  # <B>
        @typing.overload
        def startsWith(self, that: scala.collection.GenSeq[_startsWith_0__B]) -> bool: ...
        @typing.overload
        def startsWith(self, that: scala.collection.GenSeq[_startsWith_1__B], offset: int) -> bool: ...
        def stringPrefix(self) -> str: ...
        _sum__B = typing.TypeVar('_sum__B')  # <B>
        def sum(self, num: scala.math.Numeric[_sum__B]) -> _sum__B: ...
        def tail(self) -> typing.Any: ...
        def tails(self) -> scala.collection.Iterator[typing.List[str]]: ...
        def take(self, n: int) -> typing.Any: ...
        def takeRight(self, n: int) -> typing.Any: ...
        def takeWhile(self, p: scala.Function1) -> typing.Any: ...
        def thisCollection(self) -> 'WrappedArray'[typing.Any]: ...
        _to__Col = typing.TypeVar('_to__Col')  # <Col>
        def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., typing.Any, _to__Col]) -> _to__Col: ...
        _toArray__U = typing.TypeVar('_toArray__U')  # <U>
        def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__U]) -> typing.Any: ...
        _toBuffer__A1 = typing.TypeVar('_toBuffer__A1')  # <A1>
        def toBuffer(self) -> Buffer[_toBuffer__A1]: ...
        def toCollection(self, repr: typing.List[str]) -> 'WrappedArray'[typing.Any]: ...
        def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq[typing.Any]: ...
        def toIterable(self) -> scala.collection.Iterable[typing.Any]: ...
        def toIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def toList(self) -> scala.collection.immutable.List[typing.Any]: ...
        _toMap__T = typing.TypeVar('_toMap__T')  # <T>
        _toMap__U = typing.TypeVar('_toMap__U')  # <U>
        def toMap(self, ev: scala.Predef..less.colon.less[typing.Any, scala.Tuple2[_toMap__T, _toMap__U]]) -> scala.collection.immutable.Map[_toMap__T, _toMap__U]: ...
        def toSeq(self) -> scala.collection.Seq[typing.Any]: ...
        _toSet__B = typing.TypeVar('_toSet__B')  # <B>
        def toSet(self) -> scala.collection.immutable.Set[_toSet__B]: ...
        def toStream(self) -> scala.collection.immutable.Stream[typing.Any]: ...
        def toString(self) -> str: ...
        def toTraversable(self) -> scala.collection.Traversable[typing.Any]: ...
        def toVector(self) -> scala.collection.immutable.Vector[typing.Any]: ...
        _transpose__U = typing.TypeVar('_transpose__U')  # <U>
        def transpose(self, asArray: scala.Function1[typing.Any, typing.Any]) -> typing.List[typing.Any]: ...
        _union__B = typing.TypeVar('_union__B')  # <B>
        _union__That = typing.TypeVar('_union__That')  # <That>
        def union(self, that: scala.collection.GenSeq[_union__B], bf: scala.collection.generic.CanBuildFrom[typing.List[str], _union__B, _union__That]) -> _union__That: ...
        _unzip__T1 = typing.TypeVar('_unzip__T1')  # <T1>
        _unzip__T2 = typing.TypeVar('_unzip__T2')  # <T2>
        def unzip(self, asPair: scala.Function1[typing.Any, scala.Tuple2[_unzip__T1, _unzip__T2]], ct1: scala.reflect.ClassTag[_unzip__T1], ct2: scala.reflect.ClassTag[_unzip__T2]) -> scala.Tuple2[typing.Any, typing.Any]: ...
        _unzip3__T1 = typing.TypeVar('_unzip3__T1')  # <T1>
        _unzip3__T2 = typing.TypeVar('_unzip3__T2')  # <T2>
        _unzip3__T3 = typing.TypeVar('_unzip3__T3')  # <T3>
        def unzip3(self, asTriple: scala.Function1[typing.Any, scala.Tuple3[_unzip3__T1, _unzip3__T2, _unzip3__T3]], ct1: scala.reflect.ClassTag[_unzip3__T1], ct2: scala.reflect.ClassTag[_unzip3__T2], ct3: scala.reflect.ClassTag[_unzip3__T3]) -> scala.Tuple3[typing.Any, typing.Any, typing.Any]: ...
        def update(self, index: int, elem: str) -> None: ...
        _updated__B = typing.TypeVar('_updated__B')  # <B>
        _updated__That = typing.TypeVar('_updated__That')  # <That>
        def updated(self, index: int, elem: _updated__B, bf: scala.collection.generic.CanBuildFrom[typing.List[str], _updated__B, _updated__That]) -> _updated__That: ...
        @typing.overload
        def view(self) -> 'IndexedSeqView'[typing.Any, typing.List[str]]: ...
        @typing.overload
        def view(self, from_: int, until: int) -> 'IndexedSeqView'[typing.Any, typing.List[str]]: ...
        def withFilter(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.collection.generic.FilterMonadic[typing.Any, typing.List[str]]: ...
        _zip__A1 = typing.TypeVar('_zip__A1')  # <A1>
        _zip__B = typing.TypeVar('_zip__B')  # <B>
        _zip__That = typing.TypeVar('_zip__That')  # <That>
        def zip(self, that: scala.collection.GenIterable[_zip__B], bf: scala.collection.generic.CanBuildFrom[typing.List[str], scala.Tuple2[_zip__A1, _zip__B], _zip__That]) -> _zip__That: ...
        _zipAll__B = typing.TypeVar('_zipAll__B')  # <B>
        _zipAll__A1 = typing.TypeVar('_zipAll__A1')  # <A1>
        _zipAll__That = typing.TypeVar('_zipAll__That')  # <That>
        def zipAll(self, that: scala.collection.GenIterable[_zipAll__B], thisElem: _zipAll__A1, thatElem: _zipAll__B, bf: scala.collection.generic.CanBuildFrom[typing.List[str], scala.Tuple2[_zipAll__A1, _zipAll__B], _zipAll__That]) -> _zipAll__That: ...
        _zipWithIndex__A1 = typing.TypeVar('_zipWithIndex__A1')  # <A1>
        _zipWithIndex__That = typing.TypeVar('_zipWithIndex__That')  # <That>
        def zipWithIndex(self, bf: scala.collection.generic.CanBuildFrom[typing.List[str], scala.Tuple2[_zipWithIndex__A1, typing.Any], _zipWithIndex__That]) -> _zipWithIndex__That: ...
    class ofChar$:
        MODULE$: typing.ClassVar['ArrayOps.ofChar.'] = ...
        def __init__(self): ...
        def apply$extension(self, $this: typing.List[str], index: int) -> str: ...
        def equals$extension(self, $this: typing.List[str], x$1: typing.Any) -> bool: ...
        def hashCode$extension(self, $this: typing.List[str]) -> int: ...
        def length$extension(self, $this: typing.List[str]) -> int: ...
        def newBuilder$extension(self, $this: typing.List[str]) -> ArrayBuilder.ofChar: ...
        def thisCollection$extension(self, $this: typing.List[str]) -> 'WrappedArray'[typing.Any]: ...
        def toCollection$extension(self, $this: typing.List[str], repr: typing.List[str]) -> 'WrappedArray'[typing.Any]: ...
        def update$extension(self, $this: typing.List[str], index: int, elem: str) -> None: ...
    class ofDouble(scala.collection.mutable.ArrayOps[typing.Any]):
        def __init__(self, repr: typing.List[float]): ...
        _$colon$bslash__B = typing.TypeVar('_$colon$bslash__B')  # <B>
        def $colon$bslash(self, z: _.colon.bslash__B, op: scala.Function2[typing.Any, _.colon.bslash__B, _.colon.bslash__B]) -> _.colon.bslash__B: ...
        _$colon$plus_0__B = typing.TypeVar('_$colon$plus_0__B')  # <B>
        _$colon$plus_0__That = typing.TypeVar('_$colon$plus_0__That')  # <That>
        _$colon$plus_1__B = typing.TypeVar('_$colon$plus_1__B')  # <B>
        @typing.overload
        def $colon$plus(self, elem: _.colon.plus_0__B, bf: scala.collection.generic.CanBuildFrom[typing.List[float], _.colon.plus_0__B, _.colon.plus_0__That]) -> _.colon.plus_0__That: ...
        @typing.overload
        def $colon$plus(self, elem: _.colon.plus_1__B, evidence$2: scala.reflect.ClassTag[_.colon.plus_1__B]) -> typing.Any: ...
        _$div$colon__B = typing.TypeVar('_$div$colon__B')  # <B>
        def $div$colon(self, z: _.div.colon__B, op: scala.Function2[_.div.colon__B, typing.Any, _.div.colon__B]) -> _.div.colon__B: ...
        _$plus$colon_0__B = typing.TypeVar('_$plus$colon_0__B')  # <B>
        _$plus$colon_0__That = typing.TypeVar('_$plus$colon_0__That')  # <That>
        _$plus$colon_1__B = typing.TypeVar('_$plus$colon_1__B')  # <B>
        @typing.overload
        def $plus$colon(self, elem: _.plus.colon_0__B, bf: scala.collection.generic.CanBuildFrom[typing.List[float], _.plus.colon_0__B, _.plus.colon_0__That]) -> _.plus.colon_0__That: ...
        @typing.overload
        def $plus$colon(self, elem: _.plus.colon_1__B, evidence$3: scala.reflect.ClassTag[_.plus.colon_1__B]) -> typing.Any: ...
        _$plus$plus__B = typing.TypeVar('_$plus$plus__B')  # <B>
        _$plus$plus__That = typing.TypeVar('_$plus$plus__That')  # <That>
        def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus__B], bf: scala.collection.generic.CanBuildFrom[typing.List[float], _.plus.plus__B, _.plus.plus__That]) -> _.plus.plus__That: ...
        _$plus$plus$colon_0__B = typing.TypeVar('_$plus$plus$colon_0__B')  # <B>
        _$plus$plus$colon_0__That = typing.TypeVar('_$plus$plus$colon_0__That')  # <That>
        _$plus$plus$colon_1__B = typing.TypeVar('_$plus$plus$colon_1__B')  # <B>
        _$plus$plus$colon_1__That = typing.TypeVar('_$plus$plus$colon_1__That')  # <That>
        @typing.overload
        def $plus$plus$colon(self, that: scala.collection.Traversable[_.plus.plus.colon_0__B], bf: scala.collection.generic.CanBuildFrom[typing.List[float], _.plus.plus.colon_0__B, _.plus.plus.colon_0__That]) -> _.plus.plus.colon_0__That: ...
        @typing.overload
        def $plus$plus$colon(self, that: scala.collection.TraversableOnce[_.plus.plus.colon_1__B], bf: scala.collection.generic.CanBuildFrom[typing.List[float], _.plus.plus.colon_1__B, _.plus.plus.colon_1__That]) -> _.plus.plus.colon_1__That: ...
        @typing.overload
        def addString(self, b: StringBuilder) -> StringBuilder: ...
        @typing.overload
        def addString(self, b: StringBuilder, sep: str) -> StringBuilder: ...
        @typing.overload
        def addString(self, b: StringBuilder, start: str, sep: str, end: str) -> StringBuilder: ...
        _aggregate__B = typing.TypeVar('_aggregate__B')  # <B>
        def aggregate(self, z: scala.Function0[_aggregate__B], seqop: scala.Function2[_aggregate__B, typing.Any, _aggregate__B], combop: scala.Function2[_aggregate__B, _aggregate__B, _aggregate__B]) -> _aggregate__B: ...
        def apply(self, index: int) -> float: ...
        def canEqual(self, that: typing.Any) -> bool: ...
        _collect__B = typing.TypeVar('_collect__B')  # <B>
        _collect__That = typing.TypeVar('_collect__That')  # <That>
        def collect(self, pf: scala.PartialFunction[typing.Any, _collect__B], bf: scala.collection.generic.CanBuildFrom[typing.List[float], _collect__B, _collect__That]) -> _collect__That: ...
        _collectFirst__B = typing.TypeVar('_collectFirst__B')  # <B>
        def collectFirst(self, pf: scala.PartialFunction[typing.Any, _collectFirst__B]) -> scala.Option[_collectFirst__B]: ...
        def combinations(self, n: int) -> scala.collection.Iterator[typing.List[float]]: ...
        _contains__A1 = typing.TypeVar('_contains__A1')  # <A1>
        def contains(self, elem: _contains__A1) -> bool: ...
        _containsSlice__B = typing.TypeVar('_containsSlice__B')  # <B>
        def containsSlice(self, that: scala.collection.GenSeq[_containsSlice__B]) -> bool: ...
        _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
        _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
        _copyToArray_2__U = typing.TypeVar('_copyToArray_2__U')  # <U>
        @typing.overload
        def copyToArray(self, xs: typing.Any) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
        _copyToBuffer__B = typing.TypeVar('_copyToBuffer__B')  # <B>
        def copyToBuffer(self, dest: Buffer[_copyToBuffer__B]) -> None: ...
        _corresponds__B = typing.TypeVar('_corresponds__B')  # <B>
        def corresponds(self, that: scala.collection.GenSeq[_corresponds__B], p: scala.Function2[typing.Any, _corresponds__B, typing.Any]) -> bool: ...
        def count(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        def deep(self) -> scala.collection.IndexedSeq[typing.Any]: ...
        def diff(self, that: scala.collection.GenSeq) -> typing.Any: ...
        def distinct(self) -> typing.Any: ...
        def drop(self, n: int) -> typing.Any: ...
        def dropRight(self, n: int) -> typing.Any: ...
        def dropWhile(self, p: scala.Function1) -> typing.Any: ...
        _endsWith__B = typing.TypeVar('_endsWith__B')  # <B>
        def endsWith(self, that: scala.collection.GenSeq[_endsWith__B]) -> bool: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def exists(self, p: scala.Function1[typing.Any, typing.Any]) -> bool: ...
        def filter(self, p: scala.Function1) -> typing.Any: ...
        def filterImpl(self, p: scala.Function1, isFlipped: bool) -> typing.Any: ...
        def filterNot(self, p: scala.Function1) -> typing.Any: ...
        def find(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.Option[typing.Any]: ...
        _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
        _flatMap__That = typing.TypeVar('_flatMap__That')  # <That>
        def flatMap(self, f: scala.Function1[typing.Any, scala.collection.GenTraversableOnce[_flatMap__B]], bf: scala.collection.generic.CanBuildFrom[typing.List[float], _flatMap__B, _flatMap__That]) -> _flatMap__That: ...
        _flatten__U = typing.TypeVar('_flatten__U')  # <U>
        def flatten(self, asTrav: scala.Function1[typing.Any, scala.collection.Traversable[_flatten__U]], m: scala.reflect.ClassTag[_flatten__U]) -> typing.Any: ...
        _fold__A1 = typing.TypeVar('_fold__A1')  # <A1>
        def fold(self, z: _fold__A1, op: scala.Function2[_fold__A1, _fold__A1, _fold__A1]) -> _fold__A1: ...
        _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
        def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, typing.Any, _foldLeft__B]) -> _foldLeft__B: ...
        _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
        def foldRight(self, z: _foldRight__B, op: scala.Function2[typing.Any, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
        def forall(self, p: scala.Function1[typing.Any, typing.Any]) -> bool: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[typing.Any, _foreach__U]) -> None: ...
        _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
        def groupBy(self, f: scala.Function1[typing.Any, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, typing.List[float]]: ...
        def grouped(self, size: int) -> scala.collection.Iterator[typing.List[float]]: ...
        def hasDefiniteSize(self) -> bool: ...
        def hashCode(self) -> int: ...
        def head(self) -> typing.Any: ...
        def headOption(self) -> scala.Option[typing.Any]: ...
        _indexOf_0__B = typing.TypeVar('_indexOf_0__B')  # <B>
        _indexOf_1__B = typing.TypeVar('_indexOf_1__B')  # <B>
        @typing.overload
        def indexOf(self, elem: _indexOf_0__B) -> int: ...
        @typing.overload
        def indexOf(self, elem: _indexOf_1__B, from_: int) -> int: ...
        _indexOfSlice_0__B = typing.TypeVar('_indexOfSlice_0__B')  # <B>
        _indexOfSlice_1__B = typing.TypeVar('_indexOfSlice_1__B')  # <B>
        @typing.overload
        def indexOfSlice(self, that: scala.collection.GenSeq[_indexOfSlice_0__B]) -> int: ...
        @typing.overload
        def indexOfSlice(self, that: scala.collection.GenSeq[_indexOfSlice_1__B], from_: int) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[typing.Any, typing.Any], from_: int) -> int: ...
        def indices(self) -> scala.collection.immutable.Range: ...
        def init(self) -> typing.Any: ...
        def inits(self) -> scala.collection.Iterator[typing.List[float]]: ...
        def intersect(self, that: scala.collection.GenSeq) -> typing.Any: ...
        def isDefinedAt(self, idx: int) -> bool: ...
        def isEmpty(self) -> bool: ...
        def isTraversableAgain(self) -> bool: ...
        def iterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def last(self) -> typing.Any: ...
        _lastIndexOf_0__B = typing.TypeVar('_lastIndexOf_0__B')  # <B>
        _lastIndexOf_1__B = typing.TypeVar('_lastIndexOf_1__B')  # <B>
        @typing.overload
        def lastIndexOf(self, elem: _lastIndexOf_0__B) -> int: ...
        @typing.overload
        def lastIndexOf(self, elem: _lastIndexOf_1__B, end: int) -> int: ...
        _lastIndexOfSlice_0__B = typing.TypeVar('_lastIndexOfSlice_0__B')  # <B>
        _lastIndexOfSlice_1__B = typing.TypeVar('_lastIndexOfSlice_1__B')  # <B>
        @typing.overload
        def lastIndexOfSlice(self, that: scala.collection.GenSeq[_lastIndexOfSlice_0__B]) -> int: ...
        @typing.overload
        def lastIndexOfSlice(self, that: scala.collection.GenSeq[_lastIndexOfSlice_1__B], end: int) -> int: ...
        @typing.overload
        def lastIndexWhere(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        @typing.overload
        def lastIndexWhere(self, p: scala.Function1[typing.Any, typing.Any], end: int) -> int: ...
        def lastOption(self) -> scala.Option[typing.Any]: ...
        def length(self) -> int: ...
        def lengthCompare(self, len: int) -> int: ...
        _map__B = typing.TypeVar('_map__B')  # <B>
        _map__That = typing.TypeVar('_map__That')  # <That>
        def map(self, f: scala.Function1[typing.Any, _map__B], bf: scala.collection.generic.CanBuildFrom[typing.List[float], _map__B, _map__That]) -> _map__That: ...
        def max(self, cmp: scala.math.Ordering) -> typing.Any: ...
        def maxBy(self, f: scala.Function1, cmp: scala.math.Ordering) -> typing.Any: ...
        def min(self, cmp: scala.math.Ordering) -> typing.Any: ...
        def minBy(self, f: scala.Function1, cmp: scala.math.Ordering) -> typing.Any: ...
        @typing.overload
        def mkString(self) -> str: ...
        @typing.overload
        def mkString(self, sep: str) -> str: ...
        @typing.overload
        def mkString(self, start: str, sep: str, end: str) -> str: ...
        def newBuilder(self) -> ArrayBuilder.ofDouble: ...
        def nonEmpty(self) -> bool: ...
        _padTo__B = typing.TypeVar('_padTo__B')  # <B>
        _padTo__That = typing.TypeVar('_padTo__That')  # <That>
        def padTo(self, len: int, elem: _padTo__B, bf: scala.collection.generic.CanBuildFrom[typing.List[float], _padTo__B, _padTo__That]) -> _padTo__That: ...
        def par(self) -> scala.collection.parallel.mutable.ParArray[typing.Any]: ...
        def parCombiner(self) -> scala.collection.parallel.Combiner[typing.Any, scala.collection.parallel.mutable.ParArray[typing.Any]]: ...
        def partition(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.Tuple2[typing.List[float], typing.List[float]]: ...
        _patch__B = typing.TypeVar('_patch__B')  # <B>
        _patch__That = typing.TypeVar('_patch__That')  # <That>
        def patch(self, from_: int, patch: scala.collection.GenSeq[_patch__B], replaced: int, bf: scala.collection.generic.CanBuildFrom[typing.List[float], _patch__B, _patch__That]) -> _patch__That: ...
        def permutations(self) -> scala.collection.Iterator[typing.List[float]]: ...
        def prefixLength(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        _product__B = typing.TypeVar('_product__B')  # <B>
        def product(self, num: scala.math.Numeric[_product__B]) -> _product__B: ...
        _reduce__A1 = typing.TypeVar('_reduce__A1')  # <A1>
        def reduce(self, op: scala.Function2[_reduce__A1, _reduce__A1, _reduce__A1]) -> _reduce__A1: ...
        _reduceLeft__B = typing.TypeVar('_reduceLeft__B')  # <B>
        def reduceLeft(self, op: scala.Function2[_reduceLeft__B, typing.Any, _reduceLeft__B]) -> _reduceLeft__B: ...
        _reduceLeftOption__B = typing.TypeVar('_reduceLeftOption__B')  # <B>
        def reduceLeftOption(self, op: scala.Function2[_reduceLeftOption__B, typing.Any, _reduceLeftOption__B]) -> scala.Option[_reduceLeftOption__B]: ...
        _reduceOption__A1 = typing.TypeVar('_reduceOption__A1')  # <A1>
        def reduceOption(self, op: scala.Function2[_reduceOption__A1, _reduceOption__A1, _reduceOption__A1]) -> scala.Option[_reduceOption__A1]: ...
        _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
        def reduceRight(self, op: scala.Function2[typing.Any, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
        _reduceRightOption__B = typing.TypeVar('_reduceRightOption__B')  # <B>
        def reduceRightOption(self, op: scala.Function2[typing.Any, _reduceRightOption__B, _reduceRightOption__B]) -> scala.Option[_reduceRightOption__B]: ...
        def repr(self) -> typing.List[float]: ...
        def reverse(self) -> typing.Any: ...
        def reverseIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        _reverseMap__B = typing.TypeVar('_reverseMap__B')  # <B>
        _reverseMap__That = typing.TypeVar('_reverseMap__That')  # <That>
        def reverseMap(self, f: scala.Function1[typing.Any, _reverseMap__B], bf: scala.collection.generic.CanBuildFrom[typing.List[float], _reverseMap__B, _reverseMap__That]) -> _reverseMap__That: ...
        def reversed(self) -> scala.collection.immutable.List[typing.Any]: ...
        _sameElements__B = typing.TypeVar('_sameElements__B')  # <B>
        def sameElements(self, that: scala.collection.GenIterable[_sameElements__B]) -> bool: ...
        _scan__B = typing.TypeVar('_scan__B')  # <B>
        _scan__That = typing.TypeVar('_scan__That')  # <That>
        def scan(self, z: _scan__B, op: scala.Function2[_scan__B, _scan__B, _scan__B], cbf: scala.collection.generic.CanBuildFrom[typing.List[float], _scan__B, _scan__That]) -> _scan__That: ...
        _scanLeft__B = typing.TypeVar('_scanLeft__B')  # <B>
        _scanLeft__That = typing.TypeVar('_scanLeft__That')  # <That>
        def scanLeft(self, z: _scanLeft__B, op: scala.Function2[_scanLeft__B, typing.Any, _scanLeft__B], bf: scala.collection.generic.CanBuildFrom[typing.List[float], _scanLeft__B, _scanLeft__That]) -> _scanLeft__That: ...
        _scanRight__B = typing.TypeVar('_scanRight__B')  # <B>
        _scanRight__That = typing.TypeVar('_scanRight__That')  # <That>
        def scanRight(self, z: _scanRight__B, op: scala.Function2[typing.Any, _scanRight__B, _scanRight__B], bf: scala.collection.generic.CanBuildFrom[typing.List[float], _scanRight__B, _scanRight__That]) -> _scanRight__That: ...
        def segmentLength(self, p: scala.Function1[typing.Any, typing.Any], from_: int) -> int: ...
        def seq(self) -> IndexedSeq[typing.Any]: ...
        def size(self) -> int: ...
        def sizeHintIfCheap(self) -> int: ...
        def slice(self, from_: int, until: int) -> typing.Any: ...
        def sliceWithKnownBound(self, from_: int, until: int) -> typing.Any: ...
        def sliceWithKnownDelta(self, from_: int, until: int, delta: int) -> typing.Any: ...
        @typing.overload
        def sliding(self, size: int) -> scala.collection.Iterator[typing.List[float]]: ...
        @typing.overload
        def sliding(self, size: int, step: int) -> scala.collection.Iterator[typing.List[float]]: ...
        def sortBy(self, f: scala.Function1, ord: scala.math.Ordering) -> typing.Any: ...
        def sortWith(self, lt: scala.Function2) -> typing.Any: ...
        def sorted(self, ord: scala.math.Ordering) -> typing.Any: ...
        def span(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.Tuple2[typing.List[float], typing.List[float]]: ...
        def splitAt(self, n: int) -> scala.Tuple2[typing.List[float], typing.List[float]]: ...
        _startsWith_0__B = typing.TypeVar('_startsWith_0__B')  # <B>
        _startsWith_1__B = typing.TypeVar('_startsWith_1__B')  # <B>
        @typing.overload
        def startsWith(self, that: scala.collection.GenSeq[_startsWith_0__B]) -> bool: ...
        @typing.overload
        def startsWith(self, that: scala.collection.GenSeq[_startsWith_1__B], offset: int) -> bool: ...
        def stringPrefix(self) -> str: ...
        _sum__B = typing.TypeVar('_sum__B')  # <B>
        def sum(self, num: scala.math.Numeric[_sum__B]) -> _sum__B: ...
        def tail(self) -> typing.Any: ...
        def tails(self) -> scala.collection.Iterator[typing.List[float]]: ...
        def take(self, n: int) -> typing.Any: ...
        def takeRight(self, n: int) -> typing.Any: ...
        def takeWhile(self, p: scala.Function1) -> typing.Any: ...
        def thisCollection(self) -> 'WrappedArray'[typing.Any]: ...
        _to__Col = typing.TypeVar('_to__Col')  # <Col>
        def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., typing.Any, _to__Col]) -> _to__Col: ...
        _toArray__U = typing.TypeVar('_toArray__U')  # <U>
        def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__U]) -> typing.Any: ...
        _toBuffer__A1 = typing.TypeVar('_toBuffer__A1')  # <A1>
        def toBuffer(self) -> Buffer[_toBuffer__A1]: ...
        def toCollection(self, repr: typing.List[float]) -> 'WrappedArray'[typing.Any]: ...
        def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq[typing.Any]: ...
        def toIterable(self) -> scala.collection.Iterable[typing.Any]: ...
        def toIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def toList(self) -> scala.collection.immutable.List[typing.Any]: ...
        _toMap__T = typing.TypeVar('_toMap__T')  # <T>
        _toMap__U = typing.TypeVar('_toMap__U')  # <U>
        def toMap(self, ev: scala.Predef..less.colon.less[typing.Any, scala.Tuple2[_toMap__T, _toMap__U]]) -> scala.collection.immutable.Map[_toMap__T, _toMap__U]: ...
        def toSeq(self) -> scala.collection.Seq[typing.Any]: ...
        _toSet__B = typing.TypeVar('_toSet__B')  # <B>
        def toSet(self) -> scala.collection.immutable.Set[_toSet__B]: ...
        def toStream(self) -> scala.collection.immutable.Stream[typing.Any]: ...
        def toString(self) -> str: ...
        def toTraversable(self) -> scala.collection.Traversable[typing.Any]: ...
        def toVector(self) -> scala.collection.immutable.Vector[typing.Any]: ...
        _transpose__U = typing.TypeVar('_transpose__U')  # <U>
        def transpose(self, asArray: scala.Function1[typing.Any, typing.Any]) -> typing.List[typing.Any]: ...
        _union__B = typing.TypeVar('_union__B')  # <B>
        _union__That = typing.TypeVar('_union__That')  # <That>
        def union(self, that: scala.collection.GenSeq[_union__B], bf: scala.collection.generic.CanBuildFrom[typing.List[float], _union__B, _union__That]) -> _union__That: ...
        _unzip__T1 = typing.TypeVar('_unzip__T1')  # <T1>
        _unzip__T2 = typing.TypeVar('_unzip__T2')  # <T2>
        def unzip(self, asPair: scala.Function1[typing.Any, scala.Tuple2[_unzip__T1, _unzip__T2]], ct1: scala.reflect.ClassTag[_unzip__T1], ct2: scala.reflect.ClassTag[_unzip__T2]) -> scala.Tuple2[typing.Any, typing.Any]: ...
        _unzip3__T1 = typing.TypeVar('_unzip3__T1')  # <T1>
        _unzip3__T2 = typing.TypeVar('_unzip3__T2')  # <T2>
        _unzip3__T3 = typing.TypeVar('_unzip3__T3')  # <T3>
        def unzip3(self, asTriple: scala.Function1[typing.Any, scala.Tuple3[_unzip3__T1, _unzip3__T2, _unzip3__T3]], ct1: scala.reflect.ClassTag[_unzip3__T1], ct2: scala.reflect.ClassTag[_unzip3__T2], ct3: scala.reflect.ClassTag[_unzip3__T3]) -> scala.Tuple3[typing.Any, typing.Any, typing.Any]: ...
        def update(self, index: int, elem: float) -> None: ...
        _updated__B = typing.TypeVar('_updated__B')  # <B>
        _updated__That = typing.TypeVar('_updated__That')  # <That>
        def updated(self, index: int, elem: _updated__B, bf: scala.collection.generic.CanBuildFrom[typing.List[float], _updated__B, _updated__That]) -> _updated__That: ...
        @typing.overload
        def view(self) -> 'IndexedSeqView'[typing.Any, typing.List[float]]: ...
        @typing.overload
        def view(self, from_: int, until: int) -> 'IndexedSeqView'[typing.Any, typing.List[float]]: ...
        def withFilter(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.collection.generic.FilterMonadic[typing.Any, typing.List[float]]: ...
        _zip__A1 = typing.TypeVar('_zip__A1')  # <A1>
        _zip__B = typing.TypeVar('_zip__B')  # <B>
        _zip__That = typing.TypeVar('_zip__That')  # <That>
        def zip(self, that: scala.collection.GenIterable[_zip__B], bf: scala.collection.generic.CanBuildFrom[typing.List[float], scala.Tuple2[_zip__A1, _zip__B], _zip__That]) -> _zip__That: ...
        _zipAll__B = typing.TypeVar('_zipAll__B')  # <B>
        _zipAll__A1 = typing.TypeVar('_zipAll__A1')  # <A1>
        _zipAll__That = typing.TypeVar('_zipAll__That')  # <That>
        def zipAll(self, that: scala.collection.GenIterable[_zipAll__B], thisElem: _zipAll__A1, thatElem: _zipAll__B, bf: scala.collection.generic.CanBuildFrom[typing.List[float], scala.Tuple2[_zipAll__A1, _zipAll__B], _zipAll__That]) -> _zipAll__That: ...
        _zipWithIndex__A1 = typing.TypeVar('_zipWithIndex__A1')  # <A1>
        _zipWithIndex__That = typing.TypeVar('_zipWithIndex__That')  # <That>
        def zipWithIndex(self, bf: scala.collection.generic.CanBuildFrom[typing.List[float], scala.Tuple2[_zipWithIndex__A1, typing.Any], _zipWithIndex__That]) -> _zipWithIndex__That: ...
    class ofDouble$:
        MODULE$: typing.ClassVar['ArrayOps.ofDouble.'] = ...
        def __init__(self): ...
        def apply$extension(self, $this: typing.List[float], index: int) -> float: ...
        def equals$extension(self, $this: typing.List[float], x$1: typing.Any) -> bool: ...
        def hashCode$extension(self, $this: typing.List[float]) -> int: ...
        def length$extension(self, $this: typing.List[float]) -> int: ...
        def newBuilder$extension(self, $this: typing.List[float]) -> ArrayBuilder.ofDouble: ...
        def thisCollection$extension(self, $this: typing.List[float]) -> 'WrappedArray'[typing.Any]: ...
        def toCollection$extension(self, $this: typing.List[float], repr: typing.List[float]) -> 'WrappedArray'[typing.Any]: ...
        def update$extension(self, $this: typing.List[float], index: int, elem: float) -> None: ...
    class ofFloat(scala.collection.mutable.ArrayOps[typing.Any]):
        def __init__(self, repr: typing.List[float]): ...
        _$colon$bslash__B = typing.TypeVar('_$colon$bslash__B')  # <B>
        def $colon$bslash(self, z: _.colon.bslash__B, op: scala.Function2[typing.Any, _.colon.bslash__B, _.colon.bslash__B]) -> _.colon.bslash__B: ...
        _$colon$plus_0__B = typing.TypeVar('_$colon$plus_0__B')  # <B>
        _$colon$plus_0__That = typing.TypeVar('_$colon$plus_0__That')  # <That>
        _$colon$plus_1__B = typing.TypeVar('_$colon$plus_1__B')  # <B>
        @typing.overload
        def $colon$plus(self, elem: _.colon.plus_0__B, bf: scala.collection.generic.CanBuildFrom[typing.List[float], _.colon.plus_0__B, _.colon.plus_0__That]) -> _.colon.plus_0__That: ...
        @typing.overload
        def $colon$plus(self, elem: _.colon.plus_1__B, evidence$2: scala.reflect.ClassTag[_.colon.plus_1__B]) -> typing.Any: ...
        _$div$colon__B = typing.TypeVar('_$div$colon__B')  # <B>
        def $div$colon(self, z: _.div.colon__B, op: scala.Function2[_.div.colon__B, typing.Any, _.div.colon__B]) -> _.div.colon__B: ...
        _$plus$colon_0__B = typing.TypeVar('_$plus$colon_0__B')  # <B>
        _$plus$colon_0__That = typing.TypeVar('_$plus$colon_0__That')  # <That>
        _$plus$colon_1__B = typing.TypeVar('_$plus$colon_1__B')  # <B>
        @typing.overload
        def $plus$colon(self, elem: _.plus.colon_0__B, bf: scala.collection.generic.CanBuildFrom[typing.List[float], _.plus.colon_0__B, _.plus.colon_0__That]) -> _.plus.colon_0__That: ...
        @typing.overload
        def $plus$colon(self, elem: _.plus.colon_1__B, evidence$3: scala.reflect.ClassTag[_.plus.colon_1__B]) -> typing.Any: ...
        _$plus$plus__B = typing.TypeVar('_$plus$plus__B')  # <B>
        _$plus$plus__That = typing.TypeVar('_$plus$plus__That')  # <That>
        def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus__B], bf: scala.collection.generic.CanBuildFrom[typing.List[float], _.plus.plus__B, _.plus.plus__That]) -> _.plus.plus__That: ...
        _$plus$plus$colon_0__B = typing.TypeVar('_$plus$plus$colon_0__B')  # <B>
        _$plus$plus$colon_0__That = typing.TypeVar('_$plus$plus$colon_0__That')  # <That>
        _$plus$plus$colon_1__B = typing.TypeVar('_$plus$plus$colon_1__B')  # <B>
        _$plus$plus$colon_1__That = typing.TypeVar('_$plus$plus$colon_1__That')  # <That>
        @typing.overload
        def $plus$plus$colon(self, that: scala.collection.Traversable[_.plus.plus.colon_0__B], bf: scala.collection.generic.CanBuildFrom[typing.List[float], _.plus.plus.colon_0__B, _.plus.plus.colon_0__That]) -> _.plus.plus.colon_0__That: ...
        @typing.overload
        def $plus$plus$colon(self, that: scala.collection.TraversableOnce[_.plus.plus.colon_1__B], bf: scala.collection.generic.CanBuildFrom[typing.List[float], _.plus.plus.colon_1__B, _.plus.plus.colon_1__That]) -> _.plus.plus.colon_1__That: ...
        @typing.overload
        def addString(self, b: StringBuilder) -> StringBuilder: ...
        @typing.overload
        def addString(self, b: StringBuilder, sep: str) -> StringBuilder: ...
        @typing.overload
        def addString(self, b: StringBuilder, start: str, sep: str, end: str) -> StringBuilder: ...
        _aggregate__B = typing.TypeVar('_aggregate__B')  # <B>
        def aggregate(self, z: scala.Function0[_aggregate__B], seqop: scala.Function2[_aggregate__B, typing.Any, _aggregate__B], combop: scala.Function2[_aggregate__B, _aggregate__B, _aggregate__B]) -> _aggregate__B: ...
        def apply(self, index: int) -> float: ...
        def canEqual(self, that: typing.Any) -> bool: ...
        _collect__B = typing.TypeVar('_collect__B')  # <B>
        _collect__That = typing.TypeVar('_collect__That')  # <That>
        def collect(self, pf: scala.PartialFunction[typing.Any, _collect__B], bf: scala.collection.generic.CanBuildFrom[typing.List[float], _collect__B, _collect__That]) -> _collect__That: ...
        _collectFirst__B = typing.TypeVar('_collectFirst__B')  # <B>
        def collectFirst(self, pf: scala.PartialFunction[typing.Any, _collectFirst__B]) -> scala.Option[_collectFirst__B]: ...
        def combinations(self, n: int) -> scala.collection.Iterator[typing.List[float]]: ...
        _contains__A1 = typing.TypeVar('_contains__A1')  # <A1>
        def contains(self, elem: _contains__A1) -> bool: ...
        _containsSlice__B = typing.TypeVar('_containsSlice__B')  # <B>
        def containsSlice(self, that: scala.collection.GenSeq[_containsSlice__B]) -> bool: ...
        _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
        _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
        _copyToArray_2__U = typing.TypeVar('_copyToArray_2__U')  # <U>
        @typing.overload
        def copyToArray(self, xs: typing.Any) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
        _copyToBuffer__B = typing.TypeVar('_copyToBuffer__B')  # <B>
        def copyToBuffer(self, dest: Buffer[_copyToBuffer__B]) -> None: ...
        _corresponds__B = typing.TypeVar('_corresponds__B')  # <B>
        def corresponds(self, that: scala.collection.GenSeq[_corresponds__B], p: scala.Function2[typing.Any, _corresponds__B, typing.Any]) -> bool: ...
        def count(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        def deep(self) -> scala.collection.IndexedSeq[typing.Any]: ...
        def diff(self, that: scala.collection.GenSeq) -> typing.Any: ...
        def distinct(self) -> typing.Any: ...
        def drop(self, n: int) -> typing.Any: ...
        def dropRight(self, n: int) -> typing.Any: ...
        def dropWhile(self, p: scala.Function1) -> typing.Any: ...
        _endsWith__B = typing.TypeVar('_endsWith__B')  # <B>
        def endsWith(self, that: scala.collection.GenSeq[_endsWith__B]) -> bool: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def exists(self, p: scala.Function1[typing.Any, typing.Any]) -> bool: ...
        def filter(self, p: scala.Function1) -> typing.Any: ...
        def filterImpl(self, p: scala.Function1, isFlipped: bool) -> typing.Any: ...
        def filterNot(self, p: scala.Function1) -> typing.Any: ...
        def find(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.Option[typing.Any]: ...
        _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
        _flatMap__That = typing.TypeVar('_flatMap__That')  # <That>
        def flatMap(self, f: scala.Function1[typing.Any, scala.collection.GenTraversableOnce[_flatMap__B]], bf: scala.collection.generic.CanBuildFrom[typing.List[float], _flatMap__B, _flatMap__That]) -> _flatMap__That: ...
        _flatten__U = typing.TypeVar('_flatten__U')  # <U>
        def flatten(self, asTrav: scala.Function1[typing.Any, scala.collection.Traversable[_flatten__U]], m: scala.reflect.ClassTag[_flatten__U]) -> typing.Any: ...
        _fold__A1 = typing.TypeVar('_fold__A1')  # <A1>
        def fold(self, z: _fold__A1, op: scala.Function2[_fold__A1, _fold__A1, _fold__A1]) -> _fold__A1: ...
        _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
        def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, typing.Any, _foldLeft__B]) -> _foldLeft__B: ...
        _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
        def foldRight(self, z: _foldRight__B, op: scala.Function2[typing.Any, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
        def forall(self, p: scala.Function1[typing.Any, typing.Any]) -> bool: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[typing.Any, _foreach__U]) -> None: ...
        _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
        def groupBy(self, f: scala.Function1[typing.Any, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, typing.List[float]]: ...
        def grouped(self, size: int) -> scala.collection.Iterator[typing.List[float]]: ...
        def hasDefiniteSize(self) -> bool: ...
        def hashCode(self) -> int: ...
        def head(self) -> typing.Any: ...
        def headOption(self) -> scala.Option[typing.Any]: ...
        _indexOf_0__B = typing.TypeVar('_indexOf_0__B')  # <B>
        _indexOf_1__B = typing.TypeVar('_indexOf_1__B')  # <B>
        @typing.overload
        def indexOf(self, elem: _indexOf_0__B) -> int: ...
        @typing.overload
        def indexOf(self, elem: _indexOf_1__B, from_: int) -> int: ...
        _indexOfSlice_0__B = typing.TypeVar('_indexOfSlice_0__B')  # <B>
        _indexOfSlice_1__B = typing.TypeVar('_indexOfSlice_1__B')  # <B>
        @typing.overload
        def indexOfSlice(self, that: scala.collection.GenSeq[_indexOfSlice_0__B]) -> int: ...
        @typing.overload
        def indexOfSlice(self, that: scala.collection.GenSeq[_indexOfSlice_1__B], from_: int) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[typing.Any, typing.Any], from_: int) -> int: ...
        def indices(self) -> scala.collection.immutable.Range: ...
        def init(self) -> typing.Any: ...
        def inits(self) -> scala.collection.Iterator[typing.List[float]]: ...
        def intersect(self, that: scala.collection.GenSeq) -> typing.Any: ...
        def isDefinedAt(self, idx: int) -> bool: ...
        def isEmpty(self) -> bool: ...
        def isTraversableAgain(self) -> bool: ...
        def iterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def last(self) -> typing.Any: ...
        _lastIndexOf_0__B = typing.TypeVar('_lastIndexOf_0__B')  # <B>
        _lastIndexOf_1__B = typing.TypeVar('_lastIndexOf_1__B')  # <B>
        @typing.overload
        def lastIndexOf(self, elem: _lastIndexOf_0__B) -> int: ...
        @typing.overload
        def lastIndexOf(self, elem: _lastIndexOf_1__B, end: int) -> int: ...
        _lastIndexOfSlice_0__B = typing.TypeVar('_lastIndexOfSlice_0__B')  # <B>
        _lastIndexOfSlice_1__B = typing.TypeVar('_lastIndexOfSlice_1__B')  # <B>
        @typing.overload
        def lastIndexOfSlice(self, that: scala.collection.GenSeq[_lastIndexOfSlice_0__B]) -> int: ...
        @typing.overload
        def lastIndexOfSlice(self, that: scala.collection.GenSeq[_lastIndexOfSlice_1__B], end: int) -> int: ...
        @typing.overload
        def lastIndexWhere(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        @typing.overload
        def lastIndexWhere(self, p: scala.Function1[typing.Any, typing.Any], end: int) -> int: ...
        def lastOption(self) -> scala.Option[typing.Any]: ...
        def length(self) -> int: ...
        def lengthCompare(self, len: int) -> int: ...
        _map__B = typing.TypeVar('_map__B')  # <B>
        _map__That = typing.TypeVar('_map__That')  # <That>
        def map(self, f: scala.Function1[typing.Any, _map__B], bf: scala.collection.generic.CanBuildFrom[typing.List[float], _map__B, _map__That]) -> _map__That: ...
        def max(self, cmp: scala.math.Ordering) -> typing.Any: ...
        def maxBy(self, f: scala.Function1, cmp: scala.math.Ordering) -> typing.Any: ...
        def min(self, cmp: scala.math.Ordering) -> typing.Any: ...
        def minBy(self, f: scala.Function1, cmp: scala.math.Ordering) -> typing.Any: ...
        @typing.overload
        def mkString(self) -> str: ...
        @typing.overload
        def mkString(self, sep: str) -> str: ...
        @typing.overload
        def mkString(self, start: str, sep: str, end: str) -> str: ...
        def newBuilder(self) -> ArrayBuilder.ofFloat: ...
        def nonEmpty(self) -> bool: ...
        _padTo__B = typing.TypeVar('_padTo__B')  # <B>
        _padTo__That = typing.TypeVar('_padTo__That')  # <That>
        def padTo(self, len: int, elem: _padTo__B, bf: scala.collection.generic.CanBuildFrom[typing.List[float], _padTo__B, _padTo__That]) -> _padTo__That: ...
        def par(self) -> scala.collection.parallel.mutable.ParArray[typing.Any]: ...
        def parCombiner(self) -> scala.collection.parallel.Combiner[typing.Any, scala.collection.parallel.mutable.ParArray[typing.Any]]: ...
        def partition(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.Tuple2[typing.List[float], typing.List[float]]: ...
        _patch__B = typing.TypeVar('_patch__B')  # <B>
        _patch__That = typing.TypeVar('_patch__That')  # <That>
        def patch(self, from_: int, patch: scala.collection.GenSeq[_patch__B], replaced: int, bf: scala.collection.generic.CanBuildFrom[typing.List[float], _patch__B, _patch__That]) -> _patch__That: ...
        def permutations(self) -> scala.collection.Iterator[typing.List[float]]: ...
        def prefixLength(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        _product__B = typing.TypeVar('_product__B')  # <B>
        def product(self, num: scala.math.Numeric[_product__B]) -> _product__B: ...
        _reduce__A1 = typing.TypeVar('_reduce__A1')  # <A1>
        def reduce(self, op: scala.Function2[_reduce__A1, _reduce__A1, _reduce__A1]) -> _reduce__A1: ...
        _reduceLeft__B = typing.TypeVar('_reduceLeft__B')  # <B>
        def reduceLeft(self, op: scala.Function2[_reduceLeft__B, typing.Any, _reduceLeft__B]) -> _reduceLeft__B: ...
        _reduceLeftOption__B = typing.TypeVar('_reduceLeftOption__B')  # <B>
        def reduceLeftOption(self, op: scala.Function2[_reduceLeftOption__B, typing.Any, _reduceLeftOption__B]) -> scala.Option[_reduceLeftOption__B]: ...
        _reduceOption__A1 = typing.TypeVar('_reduceOption__A1')  # <A1>
        def reduceOption(self, op: scala.Function2[_reduceOption__A1, _reduceOption__A1, _reduceOption__A1]) -> scala.Option[_reduceOption__A1]: ...
        _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
        def reduceRight(self, op: scala.Function2[typing.Any, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
        _reduceRightOption__B = typing.TypeVar('_reduceRightOption__B')  # <B>
        def reduceRightOption(self, op: scala.Function2[typing.Any, _reduceRightOption__B, _reduceRightOption__B]) -> scala.Option[_reduceRightOption__B]: ...
        def repr(self) -> typing.List[float]: ...
        def reverse(self) -> typing.Any: ...
        def reverseIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        _reverseMap__B = typing.TypeVar('_reverseMap__B')  # <B>
        _reverseMap__That = typing.TypeVar('_reverseMap__That')  # <That>
        def reverseMap(self, f: scala.Function1[typing.Any, _reverseMap__B], bf: scala.collection.generic.CanBuildFrom[typing.List[float], _reverseMap__B, _reverseMap__That]) -> _reverseMap__That: ...
        def reversed(self) -> scala.collection.immutable.List[typing.Any]: ...
        _sameElements__B = typing.TypeVar('_sameElements__B')  # <B>
        def sameElements(self, that: scala.collection.GenIterable[_sameElements__B]) -> bool: ...
        _scan__B = typing.TypeVar('_scan__B')  # <B>
        _scan__That = typing.TypeVar('_scan__That')  # <That>
        def scan(self, z: _scan__B, op: scala.Function2[_scan__B, _scan__B, _scan__B], cbf: scala.collection.generic.CanBuildFrom[typing.List[float], _scan__B, _scan__That]) -> _scan__That: ...
        _scanLeft__B = typing.TypeVar('_scanLeft__B')  # <B>
        _scanLeft__That = typing.TypeVar('_scanLeft__That')  # <That>
        def scanLeft(self, z: _scanLeft__B, op: scala.Function2[_scanLeft__B, typing.Any, _scanLeft__B], bf: scala.collection.generic.CanBuildFrom[typing.List[float], _scanLeft__B, _scanLeft__That]) -> _scanLeft__That: ...
        _scanRight__B = typing.TypeVar('_scanRight__B')  # <B>
        _scanRight__That = typing.TypeVar('_scanRight__That')  # <That>
        def scanRight(self, z: _scanRight__B, op: scala.Function2[typing.Any, _scanRight__B, _scanRight__B], bf: scala.collection.generic.CanBuildFrom[typing.List[float], _scanRight__B, _scanRight__That]) -> _scanRight__That: ...
        def segmentLength(self, p: scala.Function1[typing.Any, typing.Any], from_: int) -> int: ...
        def seq(self) -> IndexedSeq[typing.Any]: ...
        def size(self) -> int: ...
        def sizeHintIfCheap(self) -> int: ...
        def slice(self, from_: int, until: int) -> typing.Any: ...
        def sliceWithKnownBound(self, from_: int, until: int) -> typing.Any: ...
        def sliceWithKnownDelta(self, from_: int, until: int, delta: int) -> typing.Any: ...
        @typing.overload
        def sliding(self, size: int) -> scala.collection.Iterator[typing.List[float]]: ...
        @typing.overload
        def sliding(self, size: int, step: int) -> scala.collection.Iterator[typing.List[float]]: ...
        def sortBy(self, f: scala.Function1, ord: scala.math.Ordering) -> typing.Any: ...
        def sortWith(self, lt: scala.Function2) -> typing.Any: ...
        def sorted(self, ord: scala.math.Ordering) -> typing.Any: ...
        def span(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.Tuple2[typing.List[float], typing.List[float]]: ...
        def splitAt(self, n: int) -> scala.Tuple2[typing.List[float], typing.List[float]]: ...
        _startsWith_0__B = typing.TypeVar('_startsWith_0__B')  # <B>
        _startsWith_1__B = typing.TypeVar('_startsWith_1__B')  # <B>
        @typing.overload
        def startsWith(self, that: scala.collection.GenSeq[_startsWith_0__B]) -> bool: ...
        @typing.overload
        def startsWith(self, that: scala.collection.GenSeq[_startsWith_1__B], offset: int) -> bool: ...
        def stringPrefix(self) -> str: ...
        _sum__B = typing.TypeVar('_sum__B')  # <B>
        def sum(self, num: scala.math.Numeric[_sum__B]) -> _sum__B: ...
        def tail(self) -> typing.Any: ...
        def tails(self) -> scala.collection.Iterator[typing.List[float]]: ...
        def take(self, n: int) -> typing.Any: ...
        def takeRight(self, n: int) -> typing.Any: ...
        def takeWhile(self, p: scala.Function1) -> typing.Any: ...
        def thisCollection(self) -> 'WrappedArray'[typing.Any]: ...
        _to__Col = typing.TypeVar('_to__Col')  # <Col>
        def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., typing.Any, _to__Col]) -> _to__Col: ...
        _toArray__U = typing.TypeVar('_toArray__U')  # <U>
        def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__U]) -> typing.Any: ...
        _toBuffer__A1 = typing.TypeVar('_toBuffer__A1')  # <A1>
        def toBuffer(self) -> Buffer[_toBuffer__A1]: ...
        def toCollection(self, repr: typing.List[float]) -> 'WrappedArray'[typing.Any]: ...
        def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq[typing.Any]: ...
        def toIterable(self) -> scala.collection.Iterable[typing.Any]: ...
        def toIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def toList(self) -> scala.collection.immutable.List[typing.Any]: ...
        _toMap__T = typing.TypeVar('_toMap__T')  # <T>
        _toMap__U = typing.TypeVar('_toMap__U')  # <U>
        def toMap(self, ev: scala.Predef..less.colon.less[typing.Any, scala.Tuple2[_toMap__T, _toMap__U]]) -> scala.collection.immutable.Map[_toMap__T, _toMap__U]: ...
        def toSeq(self) -> scala.collection.Seq[typing.Any]: ...
        _toSet__B = typing.TypeVar('_toSet__B')  # <B>
        def toSet(self) -> scala.collection.immutable.Set[_toSet__B]: ...
        def toStream(self) -> scala.collection.immutable.Stream[typing.Any]: ...
        def toString(self) -> str: ...
        def toTraversable(self) -> scala.collection.Traversable[typing.Any]: ...
        def toVector(self) -> scala.collection.immutable.Vector[typing.Any]: ...
        _transpose__U = typing.TypeVar('_transpose__U')  # <U>
        def transpose(self, asArray: scala.Function1[typing.Any, typing.Any]) -> typing.List[typing.Any]: ...
        _union__B = typing.TypeVar('_union__B')  # <B>
        _union__That = typing.TypeVar('_union__That')  # <That>
        def union(self, that: scala.collection.GenSeq[_union__B], bf: scala.collection.generic.CanBuildFrom[typing.List[float], _union__B, _union__That]) -> _union__That: ...
        _unzip__T1 = typing.TypeVar('_unzip__T1')  # <T1>
        _unzip__T2 = typing.TypeVar('_unzip__T2')  # <T2>
        def unzip(self, asPair: scala.Function1[typing.Any, scala.Tuple2[_unzip__T1, _unzip__T2]], ct1: scala.reflect.ClassTag[_unzip__T1], ct2: scala.reflect.ClassTag[_unzip__T2]) -> scala.Tuple2[typing.Any, typing.Any]: ...
        _unzip3__T1 = typing.TypeVar('_unzip3__T1')  # <T1>
        _unzip3__T2 = typing.TypeVar('_unzip3__T2')  # <T2>
        _unzip3__T3 = typing.TypeVar('_unzip3__T3')  # <T3>
        def unzip3(self, asTriple: scala.Function1[typing.Any, scala.Tuple3[_unzip3__T1, _unzip3__T2, _unzip3__T3]], ct1: scala.reflect.ClassTag[_unzip3__T1], ct2: scala.reflect.ClassTag[_unzip3__T2], ct3: scala.reflect.ClassTag[_unzip3__T3]) -> scala.Tuple3[typing.Any, typing.Any, typing.Any]: ...
        def update(self, index: int, elem: float) -> None: ...
        _updated__B = typing.TypeVar('_updated__B')  # <B>
        _updated__That = typing.TypeVar('_updated__That')  # <That>
        def updated(self, index: int, elem: _updated__B, bf: scala.collection.generic.CanBuildFrom[typing.List[float], _updated__B, _updated__That]) -> _updated__That: ...
        @typing.overload
        def view(self) -> 'IndexedSeqView'[typing.Any, typing.List[float]]: ...
        @typing.overload
        def view(self, from_: int, until: int) -> 'IndexedSeqView'[typing.Any, typing.List[float]]: ...
        def withFilter(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.collection.generic.FilterMonadic[typing.Any, typing.List[float]]: ...
        _zip__A1 = typing.TypeVar('_zip__A1')  # <A1>
        _zip__B = typing.TypeVar('_zip__B')  # <B>
        _zip__That = typing.TypeVar('_zip__That')  # <That>
        def zip(self, that: scala.collection.GenIterable[_zip__B], bf: scala.collection.generic.CanBuildFrom[typing.List[float], scala.Tuple2[_zip__A1, _zip__B], _zip__That]) -> _zip__That: ...
        _zipAll__B = typing.TypeVar('_zipAll__B')  # <B>
        _zipAll__A1 = typing.TypeVar('_zipAll__A1')  # <A1>
        _zipAll__That = typing.TypeVar('_zipAll__That')  # <That>
        def zipAll(self, that: scala.collection.GenIterable[_zipAll__B], thisElem: _zipAll__A1, thatElem: _zipAll__B, bf: scala.collection.generic.CanBuildFrom[typing.List[float], scala.Tuple2[_zipAll__A1, _zipAll__B], _zipAll__That]) -> _zipAll__That: ...
        _zipWithIndex__A1 = typing.TypeVar('_zipWithIndex__A1')  # <A1>
        _zipWithIndex__That = typing.TypeVar('_zipWithIndex__That')  # <That>
        def zipWithIndex(self, bf: scala.collection.generic.CanBuildFrom[typing.List[float], scala.Tuple2[_zipWithIndex__A1, typing.Any], _zipWithIndex__That]) -> _zipWithIndex__That: ...
    class ofFloat$:
        MODULE$: typing.ClassVar['ArrayOps.ofFloat.'] = ...
        def __init__(self): ...
        def apply$extension(self, $this: typing.List[float], index: int) -> float: ...
        def equals$extension(self, $this: typing.List[float], x$1: typing.Any) -> bool: ...
        def hashCode$extension(self, $this: typing.List[float]) -> int: ...
        def length$extension(self, $this: typing.List[float]) -> int: ...
        def newBuilder$extension(self, $this: typing.List[float]) -> ArrayBuilder.ofFloat: ...
        def thisCollection$extension(self, $this: typing.List[float]) -> 'WrappedArray'[typing.Any]: ...
        def toCollection$extension(self, $this: typing.List[float], repr: typing.List[float]) -> 'WrappedArray'[typing.Any]: ...
        def update$extension(self, $this: typing.List[float], index: int, elem: float) -> None: ...
    class ofInt(scala.collection.mutable.ArrayOps[typing.Any]):
        def __init__(self, repr: typing.List[int]): ...
        _$colon$bslash__B = typing.TypeVar('_$colon$bslash__B')  # <B>
        def $colon$bslash(self, z: _.colon.bslash__B, op: scala.Function2[typing.Any, _.colon.bslash__B, _.colon.bslash__B]) -> _.colon.bslash__B: ...
        _$colon$plus_0__B = typing.TypeVar('_$colon$plus_0__B')  # <B>
        _$colon$plus_0__That = typing.TypeVar('_$colon$plus_0__That')  # <That>
        _$colon$plus_1__B = typing.TypeVar('_$colon$plus_1__B')  # <B>
        @typing.overload
        def $colon$plus(self, elem: _.colon.plus_0__B, bf: scala.collection.generic.CanBuildFrom[typing.List[int], _.colon.plus_0__B, _.colon.plus_0__That]) -> _.colon.plus_0__That: ...
        @typing.overload
        def $colon$plus(self, elem: _.colon.plus_1__B, evidence$2: scala.reflect.ClassTag[_.colon.plus_1__B]) -> typing.Any: ...
        _$div$colon__B = typing.TypeVar('_$div$colon__B')  # <B>
        def $div$colon(self, z: _.div.colon__B, op: scala.Function2[_.div.colon__B, typing.Any, _.div.colon__B]) -> _.div.colon__B: ...
        _$plus$colon_0__B = typing.TypeVar('_$plus$colon_0__B')  # <B>
        _$plus$colon_0__That = typing.TypeVar('_$plus$colon_0__That')  # <That>
        _$plus$colon_1__B = typing.TypeVar('_$plus$colon_1__B')  # <B>
        @typing.overload
        def $plus$colon(self, elem: _.plus.colon_0__B, bf: scala.collection.generic.CanBuildFrom[typing.List[int], _.plus.colon_0__B, _.plus.colon_0__That]) -> _.plus.colon_0__That: ...
        @typing.overload
        def $plus$colon(self, elem: _.plus.colon_1__B, evidence$3: scala.reflect.ClassTag[_.plus.colon_1__B]) -> typing.Any: ...
        _$plus$plus__B = typing.TypeVar('_$plus$plus__B')  # <B>
        _$plus$plus__That = typing.TypeVar('_$plus$plus__That')  # <That>
        def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _.plus.plus__B, _.plus.plus__That]) -> _.plus.plus__That: ...
        _$plus$plus$colon_0__B = typing.TypeVar('_$plus$plus$colon_0__B')  # <B>
        _$plus$plus$colon_0__That = typing.TypeVar('_$plus$plus$colon_0__That')  # <That>
        _$plus$plus$colon_1__B = typing.TypeVar('_$plus$plus$colon_1__B')  # <B>
        _$plus$plus$colon_1__That = typing.TypeVar('_$plus$plus$colon_1__That')  # <That>
        @typing.overload
        def $plus$plus$colon(self, that: scala.collection.Traversable[_.plus.plus.colon_0__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _.plus.plus.colon_0__B, _.plus.plus.colon_0__That]) -> _.plus.plus.colon_0__That: ...
        @typing.overload
        def $plus$plus$colon(self, that: scala.collection.TraversableOnce[_.plus.plus.colon_1__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _.plus.plus.colon_1__B, _.plus.plus.colon_1__That]) -> _.plus.plus.colon_1__That: ...
        @typing.overload
        def addString(self, b: StringBuilder) -> StringBuilder: ...
        @typing.overload
        def addString(self, b: StringBuilder, sep: str) -> StringBuilder: ...
        @typing.overload
        def addString(self, b: StringBuilder, start: str, sep: str, end: str) -> StringBuilder: ...
        _aggregate__B = typing.TypeVar('_aggregate__B')  # <B>
        def aggregate(self, z: scala.Function0[_aggregate__B], seqop: scala.Function2[_aggregate__B, typing.Any, _aggregate__B], combop: scala.Function2[_aggregate__B, _aggregate__B, _aggregate__B]) -> _aggregate__B: ...
        def apply(self, index: int) -> int: ...
        def canEqual(self, that: typing.Any) -> bool: ...
        _collect__B = typing.TypeVar('_collect__B')  # <B>
        _collect__That = typing.TypeVar('_collect__That')  # <That>
        def collect(self, pf: scala.PartialFunction[typing.Any, _collect__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _collect__B, _collect__That]) -> _collect__That: ...
        _collectFirst__B = typing.TypeVar('_collectFirst__B')  # <B>
        def collectFirst(self, pf: scala.PartialFunction[typing.Any, _collectFirst__B]) -> scala.Option[_collectFirst__B]: ...
        def combinations(self, n: int) -> scala.collection.Iterator[typing.List[int]]: ...
        _contains__A1 = typing.TypeVar('_contains__A1')  # <A1>
        def contains(self, elem: _contains__A1) -> bool: ...
        _containsSlice__B = typing.TypeVar('_containsSlice__B')  # <B>
        def containsSlice(self, that: scala.collection.GenSeq[_containsSlice__B]) -> bool: ...
        _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
        _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
        _copyToArray_2__U = typing.TypeVar('_copyToArray_2__U')  # <U>
        @typing.overload
        def copyToArray(self, xs: typing.Any) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
        _copyToBuffer__B = typing.TypeVar('_copyToBuffer__B')  # <B>
        def copyToBuffer(self, dest: Buffer[_copyToBuffer__B]) -> None: ...
        _corresponds__B = typing.TypeVar('_corresponds__B')  # <B>
        def corresponds(self, that: scala.collection.GenSeq[_corresponds__B], p: scala.Function2[typing.Any, _corresponds__B, typing.Any]) -> bool: ...
        def count(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        def deep(self) -> scala.collection.IndexedSeq[typing.Any]: ...
        def diff(self, that: scala.collection.GenSeq) -> typing.Any: ...
        def distinct(self) -> typing.Any: ...
        def drop(self, n: int) -> typing.Any: ...
        def dropRight(self, n: int) -> typing.Any: ...
        def dropWhile(self, p: scala.Function1) -> typing.Any: ...
        _endsWith__B = typing.TypeVar('_endsWith__B')  # <B>
        def endsWith(self, that: scala.collection.GenSeq[_endsWith__B]) -> bool: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def exists(self, p: scala.Function1[typing.Any, typing.Any]) -> bool: ...
        def filter(self, p: scala.Function1) -> typing.Any: ...
        def filterImpl(self, p: scala.Function1, isFlipped: bool) -> typing.Any: ...
        def filterNot(self, p: scala.Function1) -> typing.Any: ...
        def find(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.Option[typing.Any]: ...
        _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
        _flatMap__That = typing.TypeVar('_flatMap__That')  # <That>
        def flatMap(self, f: scala.Function1[typing.Any, scala.collection.GenTraversableOnce[_flatMap__B]], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _flatMap__B, _flatMap__That]) -> _flatMap__That: ...
        _flatten__U = typing.TypeVar('_flatten__U')  # <U>
        def flatten(self, asTrav: scala.Function1[typing.Any, scala.collection.Traversable[_flatten__U]], m: scala.reflect.ClassTag[_flatten__U]) -> typing.Any: ...
        _fold__A1 = typing.TypeVar('_fold__A1')  # <A1>
        def fold(self, z: _fold__A1, op: scala.Function2[_fold__A1, _fold__A1, _fold__A1]) -> _fold__A1: ...
        _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
        def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, typing.Any, _foldLeft__B]) -> _foldLeft__B: ...
        _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
        def foldRight(self, z: _foldRight__B, op: scala.Function2[typing.Any, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
        def forall(self, p: scala.Function1[typing.Any, typing.Any]) -> bool: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[typing.Any, _foreach__U]) -> None: ...
        _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
        def groupBy(self, f: scala.Function1[typing.Any, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, typing.List[int]]: ...
        def grouped(self, size: int) -> scala.collection.Iterator[typing.List[int]]: ...
        def hasDefiniteSize(self) -> bool: ...
        def hashCode(self) -> int: ...
        def head(self) -> typing.Any: ...
        def headOption(self) -> scala.Option[typing.Any]: ...
        _indexOf_0__B = typing.TypeVar('_indexOf_0__B')  # <B>
        _indexOf_1__B = typing.TypeVar('_indexOf_1__B')  # <B>
        @typing.overload
        def indexOf(self, elem: _indexOf_0__B) -> int: ...
        @typing.overload
        def indexOf(self, elem: _indexOf_1__B, from_: int) -> int: ...
        _indexOfSlice_0__B = typing.TypeVar('_indexOfSlice_0__B')  # <B>
        _indexOfSlice_1__B = typing.TypeVar('_indexOfSlice_1__B')  # <B>
        @typing.overload
        def indexOfSlice(self, that: scala.collection.GenSeq[_indexOfSlice_0__B]) -> int: ...
        @typing.overload
        def indexOfSlice(self, that: scala.collection.GenSeq[_indexOfSlice_1__B], from_: int) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[typing.Any, typing.Any], from_: int) -> int: ...
        def indices(self) -> scala.collection.immutable.Range: ...
        def init(self) -> typing.Any: ...
        def inits(self) -> scala.collection.Iterator[typing.List[int]]: ...
        def intersect(self, that: scala.collection.GenSeq) -> typing.Any: ...
        def isDefinedAt(self, idx: int) -> bool: ...
        def isEmpty(self) -> bool: ...
        def isTraversableAgain(self) -> bool: ...
        def iterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def last(self) -> typing.Any: ...
        _lastIndexOf_0__B = typing.TypeVar('_lastIndexOf_0__B')  # <B>
        _lastIndexOf_1__B = typing.TypeVar('_lastIndexOf_1__B')  # <B>
        @typing.overload
        def lastIndexOf(self, elem: _lastIndexOf_0__B) -> int: ...
        @typing.overload
        def lastIndexOf(self, elem: _lastIndexOf_1__B, end: int) -> int: ...
        _lastIndexOfSlice_0__B = typing.TypeVar('_lastIndexOfSlice_0__B')  # <B>
        _lastIndexOfSlice_1__B = typing.TypeVar('_lastIndexOfSlice_1__B')  # <B>
        @typing.overload
        def lastIndexOfSlice(self, that: scala.collection.GenSeq[_lastIndexOfSlice_0__B]) -> int: ...
        @typing.overload
        def lastIndexOfSlice(self, that: scala.collection.GenSeq[_lastIndexOfSlice_1__B], end: int) -> int: ...
        @typing.overload
        def lastIndexWhere(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        @typing.overload
        def lastIndexWhere(self, p: scala.Function1[typing.Any, typing.Any], end: int) -> int: ...
        def lastOption(self) -> scala.Option[typing.Any]: ...
        def length(self) -> int: ...
        def lengthCompare(self, len: int) -> int: ...
        _map__B = typing.TypeVar('_map__B')  # <B>
        _map__That = typing.TypeVar('_map__That')  # <That>
        def map(self, f: scala.Function1[typing.Any, _map__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _map__B, _map__That]) -> _map__That: ...
        def max(self, cmp: scala.math.Ordering) -> typing.Any: ...
        def maxBy(self, f: scala.Function1, cmp: scala.math.Ordering) -> typing.Any: ...
        def min(self, cmp: scala.math.Ordering) -> typing.Any: ...
        def minBy(self, f: scala.Function1, cmp: scala.math.Ordering) -> typing.Any: ...
        @typing.overload
        def mkString(self) -> str: ...
        @typing.overload
        def mkString(self, sep: str) -> str: ...
        @typing.overload
        def mkString(self, start: str, sep: str, end: str) -> str: ...
        def newBuilder(self) -> ArrayBuilder.ofInt: ...
        def nonEmpty(self) -> bool: ...
        _padTo__B = typing.TypeVar('_padTo__B')  # <B>
        _padTo__That = typing.TypeVar('_padTo__That')  # <That>
        def padTo(self, len: int, elem: _padTo__B, bf: scala.collection.generic.CanBuildFrom[typing.List[int], _padTo__B, _padTo__That]) -> _padTo__That: ...
        def par(self) -> scala.collection.parallel.mutable.ParArray[typing.Any]: ...
        def parCombiner(self) -> scala.collection.parallel.Combiner[typing.Any, scala.collection.parallel.mutable.ParArray[typing.Any]]: ...
        def partition(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.Tuple2[typing.List[int], typing.List[int]]: ...
        _patch__B = typing.TypeVar('_patch__B')  # <B>
        _patch__That = typing.TypeVar('_patch__That')  # <That>
        def patch(self, from_: int, patch: scala.collection.GenSeq[_patch__B], replaced: int, bf: scala.collection.generic.CanBuildFrom[typing.List[int], _patch__B, _patch__That]) -> _patch__That: ...
        def permutations(self) -> scala.collection.Iterator[typing.List[int]]: ...
        def prefixLength(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        _product__B = typing.TypeVar('_product__B')  # <B>
        def product(self, num: scala.math.Numeric[_product__B]) -> _product__B: ...
        _reduce__A1 = typing.TypeVar('_reduce__A1')  # <A1>
        def reduce(self, op: scala.Function2[_reduce__A1, _reduce__A1, _reduce__A1]) -> _reduce__A1: ...
        _reduceLeft__B = typing.TypeVar('_reduceLeft__B')  # <B>
        def reduceLeft(self, op: scala.Function2[_reduceLeft__B, typing.Any, _reduceLeft__B]) -> _reduceLeft__B: ...
        _reduceLeftOption__B = typing.TypeVar('_reduceLeftOption__B')  # <B>
        def reduceLeftOption(self, op: scala.Function2[_reduceLeftOption__B, typing.Any, _reduceLeftOption__B]) -> scala.Option[_reduceLeftOption__B]: ...
        _reduceOption__A1 = typing.TypeVar('_reduceOption__A1')  # <A1>
        def reduceOption(self, op: scala.Function2[_reduceOption__A1, _reduceOption__A1, _reduceOption__A1]) -> scala.Option[_reduceOption__A1]: ...
        _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
        def reduceRight(self, op: scala.Function2[typing.Any, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
        _reduceRightOption__B = typing.TypeVar('_reduceRightOption__B')  # <B>
        def reduceRightOption(self, op: scala.Function2[typing.Any, _reduceRightOption__B, _reduceRightOption__B]) -> scala.Option[_reduceRightOption__B]: ...
        def repr(self) -> typing.List[int]: ...
        def reverse(self) -> typing.Any: ...
        def reverseIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        _reverseMap__B = typing.TypeVar('_reverseMap__B')  # <B>
        _reverseMap__That = typing.TypeVar('_reverseMap__That')  # <That>
        def reverseMap(self, f: scala.Function1[typing.Any, _reverseMap__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _reverseMap__B, _reverseMap__That]) -> _reverseMap__That: ...
        def reversed(self) -> scala.collection.immutable.List[typing.Any]: ...
        _sameElements__B = typing.TypeVar('_sameElements__B')  # <B>
        def sameElements(self, that: scala.collection.GenIterable[_sameElements__B]) -> bool: ...
        _scan__B = typing.TypeVar('_scan__B')  # <B>
        _scan__That = typing.TypeVar('_scan__That')  # <That>
        def scan(self, z: _scan__B, op: scala.Function2[_scan__B, _scan__B, _scan__B], cbf: scala.collection.generic.CanBuildFrom[typing.List[int], _scan__B, _scan__That]) -> _scan__That: ...
        _scanLeft__B = typing.TypeVar('_scanLeft__B')  # <B>
        _scanLeft__That = typing.TypeVar('_scanLeft__That')  # <That>
        def scanLeft(self, z: _scanLeft__B, op: scala.Function2[_scanLeft__B, typing.Any, _scanLeft__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _scanLeft__B, _scanLeft__That]) -> _scanLeft__That: ...
        _scanRight__B = typing.TypeVar('_scanRight__B')  # <B>
        _scanRight__That = typing.TypeVar('_scanRight__That')  # <That>
        def scanRight(self, z: _scanRight__B, op: scala.Function2[typing.Any, _scanRight__B, _scanRight__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _scanRight__B, _scanRight__That]) -> _scanRight__That: ...
        def segmentLength(self, p: scala.Function1[typing.Any, typing.Any], from_: int) -> int: ...
        def seq(self) -> IndexedSeq[typing.Any]: ...
        def size(self) -> int: ...
        def sizeHintIfCheap(self) -> int: ...
        def slice(self, from_: int, until: int) -> typing.Any: ...
        def sliceWithKnownBound(self, from_: int, until: int) -> typing.Any: ...
        def sliceWithKnownDelta(self, from_: int, until: int, delta: int) -> typing.Any: ...
        @typing.overload
        def sliding(self, size: int) -> scala.collection.Iterator[typing.List[int]]: ...
        @typing.overload
        def sliding(self, size: int, step: int) -> scala.collection.Iterator[typing.List[int]]: ...
        def sortBy(self, f: scala.Function1, ord: scala.math.Ordering) -> typing.Any: ...
        def sortWith(self, lt: scala.Function2) -> typing.Any: ...
        def sorted(self, ord: scala.math.Ordering) -> typing.Any: ...
        def span(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.Tuple2[typing.List[int], typing.List[int]]: ...
        def splitAt(self, n: int) -> scala.Tuple2[typing.List[int], typing.List[int]]: ...
        _startsWith_0__B = typing.TypeVar('_startsWith_0__B')  # <B>
        _startsWith_1__B = typing.TypeVar('_startsWith_1__B')  # <B>
        @typing.overload
        def startsWith(self, that: scala.collection.GenSeq[_startsWith_0__B]) -> bool: ...
        @typing.overload
        def startsWith(self, that: scala.collection.GenSeq[_startsWith_1__B], offset: int) -> bool: ...
        def stringPrefix(self) -> str: ...
        _sum__B = typing.TypeVar('_sum__B')  # <B>
        def sum(self, num: scala.math.Numeric[_sum__B]) -> _sum__B: ...
        def tail(self) -> typing.Any: ...
        def tails(self) -> scala.collection.Iterator[typing.List[int]]: ...
        def take(self, n: int) -> typing.Any: ...
        def takeRight(self, n: int) -> typing.Any: ...
        def takeWhile(self, p: scala.Function1) -> typing.Any: ...
        def thisCollection(self) -> 'WrappedArray'[typing.Any]: ...
        _to__Col = typing.TypeVar('_to__Col')  # <Col>
        def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., typing.Any, _to__Col]) -> _to__Col: ...
        _toArray__U = typing.TypeVar('_toArray__U')  # <U>
        def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__U]) -> typing.Any: ...
        _toBuffer__A1 = typing.TypeVar('_toBuffer__A1')  # <A1>
        def toBuffer(self) -> Buffer[_toBuffer__A1]: ...
        def toCollection(self, repr: typing.List[int]) -> 'WrappedArray'[typing.Any]: ...
        def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq[typing.Any]: ...
        def toIterable(self) -> scala.collection.Iterable[typing.Any]: ...
        def toIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def toList(self) -> scala.collection.immutable.List[typing.Any]: ...
        _toMap__T = typing.TypeVar('_toMap__T')  # <T>
        _toMap__U = typing.TypeVar('_toMap__U')  # <U>
        def toMap(self, ev: scala.Predef..less.colon.less[typing.Any, scala.Tuple2[_toMap__T, _toMap__U]]) -> scala.collection.immutable.Map[_toMap__T, _toMap__U]: ...
        def toSeq(self) -> scala.collection.Seq[typing.Any]: ...
        _toSet__B = typing.TypeVar('_toSet__B')  # <B>
        def toSet(self) -> scala.collection.immutable.Set[_toSet__B]: ...
        def toStream(self) -> scala.collection.immutable.Stream[typing.Any]: ...
        def toString(self) -> str: ...
        def toTraversable(self) -> scala.collection.Traversable[typing.Any]: ...
        def toVector(self) -> scala.collection.immutable.Vector[typing.Any]: ...
        _transpose__U = typing.TypeVar('_transpose__U')  # <U>
        def transpose(self, asArray: scala.Function1[typing.Any, typing.Any]) -> typing.List[typing.Any]: ...
        _union__B = typing.TypeVar('_union__B')  # <B>
        _union__That = typing.TypeVar('_union__That')  # <That>
        def union(self, that: scala.collection.GenSeq[_union__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _union__B, _union__That]) -> _union__That: ...
        _unzip__T1 = typing.TypeVar('_unzip__T1')  # <T1>
        _unzip__T2 = typing.TypeVar('_unzip__T2')  # <T2>
        def unzip(self, asPair: scala.Function1[typing.Any, scala.Tuple2[_unzip__T1, _unzip__T2]], ct1: scala.reflect.ClassTag[_unzip__T1], ct2: scala.reflect.ClassTag[_unzip__T2]) -> scala.Tuple2[typing.Any, typing.Any]: ...
        _unzip3__T1 = typing.TypeVar('_unzip3__T1')  # <T1>
        _unzip3__T2 = typing.TypeVar('_unzip3__T2')  # <T2>
        _unzip3__T3 = typing.TypeVar('_unzip3__T3')  # <T3>
        def unzip3(self, asTriple: scala.Function1[typing.Any, scala.Tuple3[_unzip3__T1, _unzip3__T2, _unzip3__T3]], ct1: scala.reflect.ClassTag[_unzip3__T1], ct2: scala.reflect.ClassTag[_unzip3__T2], ct3: scala.reflect.ClassTag[_unzip3__T3]) -> scala.Tuple3[typing.Any, typing.Any, typing.Any]: ...
        def update(self, index: int, elem: int) -> None: ...
        _updated__B = typing.TypeVar('_updated__B')  # <B>
        _updated__That = typing.TypeVar('_updated__That')  # <That>
        def updated(self, index: int, elem: _updated__B, bf: scala.collection.generic.CanBuildFrom[typing.List[int], _updated__B, _updated__That]) -> _updated__That: ...
        @typing.overload
        def view(self) -> 'IndexedSeqView'[typing.Any, typing.List[int]]: ...
        @typing.overload
        def view(self, from_: int, until: int) -> 'IndexedSeqView'[typing.Any, typing.List[int]]: ...
        def withFilter(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.collection.generic.FilterMonadic[typing.Any, typing.List[int]]: ...
        _zip__A1 = typing.TypeVar('_zip__A1')  # <A1>
        _zip__B = typing.TypeVar('_zip__B')  # <B>
        _zip__That = typing.TypeVar('_zip__That')  # <That>
        def zip(self, that: scala.collection.GenIterable[_zip__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], scala.Tuple2[_zip__A1, _zip__B], _zip__That]) -> _zip__That: ...
        _zipAll__B = typing.TypeVar('_zipAll__B')  # <B>
        _zipAll__A1 = typing.TypeVar('_zipAll__A1')  # <A1>
        _zipAll__That = typing.TypeVar('_zipAll__That')  # <That>
        def zipAll(self, that: scala.collection.GenIterable[_zipAll__B], thisElem: _zipAll__A1, thatElem: _zipAll__B, bf: scala.collection.generic.CanBuildFrom[typing.List[int], scala.Tuple2[_zipAll__A1, _zipAll__B], _zipAll__That]) -> _zipAll__That: ...
        _zipWithIndex__A1 = typing.TypeVar('_zipWithIndex__A1')  # <A1>
        _zipWithIndex__That = typing.TypeVar('_zipWithIndex__That')  # <That>
        def zipWithIndex(self, bf: scala.collection.generic.CanBuildFrom[typing.List[int], scala.Tuple2[_zipWithIndex__A1, typing.Any], _zipWithIndex__That]) -> _zipWithIndex__That: ...
    class ofInt$:
        MODULE$: typing.ClassVar['ArrayOps.ofInt.'] = ...
        def __init__(self): ...
        def apply$extension(self, $this: typing.List[int], index: int) -> int: ...
        def equals$extension(self, $this: typing.List[int], x$1: typing.Any) -> bool: ...
        def hashCode$extension(self, $this: typing.List[int]) -> int: ...
        def length$extension(self, $this: typing.List[int]) -> int: ...
        def newBuilder$extension(self, $this: typing.List[int]) -> ArrayBuilder.ofInt: ...
        def thisCollection$extension(self, $this: typing.List[int]) -> 'WrappedArray'[typing.Any]: ...
        def toCollection$extension(self, $this: typing.List[int], repr: typing.List[int]) -> 'WrappedArray'[typing.Any]: ...
        def update$extension(self, $this: typing.List[int], index: int, elem: int) -> None: ...
    class ofLong(scala.collection.mutable.ArrayOps[typing.Any]):
        def __init__(self, repr: typing.List[int]): ...
        _$colon$bslash__B = typing.TypeVar('_$colon$bslash__B')  # <B>
        def $colon$bslash(self, z: _.colon.bslash__B, op: scala.Function2[typing.Any, _.colon.bslash__B, _.colon.bslash__B]) -> _.colon.bslash__B: ...
        _$colon$plus_0__B = typing.TypeVar('_$colon$plus_0__B')  # <B>
        _$colon$plus_0__That = typing.TypeVar('_$colon$plus_0__That')  # <That>
        _$colon$plus_1__B = typing.TypeVar('_$colon$plus_1__B')  # <B>
        @typing.overload
        def $colon$plus(self, elem: _.colon.plus_0__B, bf: scala.collection.generic.CanBuildFrom[typing.List[int], _.colon.plus_0__B, _.colon.plus_0__That]) -> _.colon.plus_0__That: ...
        @typing.overload
        def $colon$plus(self, elem: _.colon.plus_1__B, evidence$2: scala.reflect.ClassTag[_.colon.plus_1__B]) -> typing.Any: ...
        _$div$colon__B = typing.TypeVar('_$div$colon__B')  # <B>
        def $div$colon(self, z: _.div.colon__B, op: scala.Function2[_.div.colon__B, typing.Any, _.div.colon__B]) -> _.div.colon__B: ...
        _$plus$colon_0__B = typing.TypeVar('_$plus$colon_0__B')  # <B>
        _$plus$colon_0__That = typing.TypeVar('_$plus$colon_0__That')  # <That>
        _$plus$colon_1__B = typing.TypeVar('_$plus$colon_1__B')  # <B>
        @typing.overload
        def $plus$colon(self, elem: _.plus.colon_0__B, bf: scala.collection.generic.CanBuildFrom[typing.List[int], _.plus.colon_0__B, _.plus.colon_0__That]) -> _.plus.colon_0__That: ...
        @typing.overload
        def $plus$colon(self, elem: _.plus.colon_1__B, evidence$3: scala.reflect.ClassTag[_.plus.colon_1__B]) -> typing.Any: ...
        _$plus$plus__B = typing.TypeVar('_$plus$plus__B')  # <B>
        _$plus$plus__That = typing.TypeVar('_$plus$plus__That')  # <That>
        def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _.plus.plus__B, _.plus.plus__That]) -> _.plus.plus__That: ...
        _$plus$plus$colon_0__B = typing.TypeVar('_$plus$plus$colon_0__B')  # <B>
        _$plus$plus$colon_0__That = typing.TypeVar('_$plus$plus$colon_0__That')  # <That>
        _$plus$plus$colon_1__B = typing.TypeVar('_$plus$plus$colon_1__B')  # <B>
        _$plus$plus$colon_1__That = typing.TypeVar('_$plus$plus$colon_1__That')  # <That>
        @typing.overload
        def $plus$plus$colon(self, that: scala.collection.Traversable[_.plus.plus.colon_0__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _.plus.plus.colon_0__B, _.plus.plus.colon_0__That]) -> _.plus.plus.colon_0__That: ...
        @typing.overload
        def $plus$plus$colon(self, that: scala.collection.TraversableOnce[_.plus.plus.colon_1__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _.plus.plus.colon_1__B, _.plus.plus.colon_1__That]) -> _.plus.plus.colon_1__That: ...
        @typing.overload
        def addString(self, b: StringBuilder) -> StringBuilder: ...
        @typing.overload
        def addString(self, b: StringBuilder, sep: str) -> StringBuilder: ...
        @typing.overload
        def addString(self, b: StringBuilder, start: str, sep: str, end: str) -> StringBuilder: ...
        _aggregate__B = typing.TypeVar('_aggregate__B')  # <B>
        def aggregate(self, z: scala.Function0[_aggregate__B], seqop: scala.Function2[_aggregate__B, typing.Any, _aggregate__B], combop: scala.Function2[_aggregate__B, _aggregate__B, _aggregate__B]) -> _aggregate__B: ...
        def apply(self, index: int) -> int: ...
        def canEqual(self, that: typing.Any) -> bool: ...
        _collect__B = typing.TypeVar('_collect__B')  # <B>
        _collect__That = typing.TypeVar('_collect__That')  # <That>
        def collect(self, pf: scala.PartialFunction[typing.Any, _collect__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _collect__B, _collect__That]) -> _collect__That: ...
        _collectFirst__B = typing.TypeVar('_collectFirst__B')  # <B>
        def collectFirst(self, pf: scala.PartialFunction[typing.Any, _collectFirst__B]) -> scala.Option[_collectFirst__B]: ...
        def combinations(self, n: int) -> scala.collection.Iterator[typing.List[int]]: ...
        _contains__A1 = typing.TypeVar('_contains__A1')  # <A1>
        def contains(self, elem: _contains__A1) -> bool: ...
        _containsSlice__B = typing.TypeVar('_containsSlice__B')  # <B>
        def containsSlice(self, that: scala.collection.GenSeq[_containsSlice__B]) -> bool: ...
        _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
        _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
        _copyToArray_2__U = typing.TypeVar('_copyToArray_2__U')  # <U>
        @typing.overload
        def copyToArray(self, xs: typing.Any) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
        _copyToBuffer__B = typing.TypeVar('_copyToBuffer__B')  # <B>
        def copyToBuffer(self, dest: Buffer[_copyToBuffer__B]) -> None: ...
        _corresponds__B = typing.TypeVar('_corresponds__B')  # <B>
        def corresponds(self, that: scala.collection.GenSeq[_corresponds__B], p: scala.Function2[typing.Any, _corresponds__B, typing.Any]) -> bool: ...
        def count(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        def deep(self) -> scala.collection.IndexedSeq[typing.Any]: ...
        def diff(self, that: scala.collection.GenSeq) -> typing.Any: ...
        def distinct(self) -> typing.Any: ...
        def drop(self, n: int) -> typing.Any: ...
        def dropRight(self, n: int) -> typing.Any: ...
        def dropWhile(self, p: scala.Function1) -> typing.Any: ...
        _endsWith__B = typing.TypeVar('_endsWith__B')  # <B>
        def endsWith(self, that: scala.collection.GenSeq[_endsWith__B]) -> bool: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def exists(self, p: scala.Function1[typing.Any, typing.Any]) -> bool: ...
        def filter(self, p: scala.Function1) -> typing.Any: ...
        def filterImpl(self, p: scala.Function1, isFlipped: bool) -> typing.Any: ...
        def filterNot(self, p: scala.Function1) -> typing.Any: ...
        def find(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.Option[typing.Any]: ...
        _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
        _flatMap__That = typing.TypeVar('_flatMap__That')  # <That>
        def flatMap(self, f: scala.Function1[typing.Any, scala.collection.GenTraversableOnce[_flatMap__B]], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _flatMap__B, _flatMap__That]) -> _flatMap__That: ...
        _flatten__U = typing.TypeVar('_flatten__U')  # <U>
        def flatten(self, asTrav: scala.Function1[typing.Any, scala.collection.Traversable[_flatten__U]], m: scala.reflect.ClassTag[_flatten__U]) -> typing.Any: ...
        _fold__A1 = typing.TypeVar('_fold__A1')  # <A1>
        def fold(self, z: _fold__A1, op: scala.Function2[_fold__A1, _fold__A1, _fold__A1]) -> _fold__A1: ...
        _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
        def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, typing.Any, _foldLeft__B]) -> _foldLeft__B: ...
        _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
        def foldRight(self, z: _foldRight__B, op: scala.Function2[typing.Any, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
        def forall(self, p: scala.Function1[typing.Any, typing.Any]) -> bool: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[typing.Any, _foreach__U]) -> None: ...
        _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
        def groupBy(self, f: scala.Function1[typing.Any, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, typing.List[int]]: ...
        def grouped(self, size: int) -> scala.collection.Iterator[typing.List[int]]: ...
        def hasDefiniteSize(self) -> bool: ...
        def hashCode(self) -> int: ...
        def head(self) -> typing.Any: ...
        def headOption(self) -> scala.Option[typing.Any]: ...
        _indexOf_0__B = typing.TypeVar('_indexOf_0__B')  # <B>
        _indexOf_1__B = typing.TypeVar('_indexOf_1__B')  # <B>
        @typing.overload
        def indexOf(self, elem: _indexOf_0__B) -> int: ...
        @typing.overload
        def indexOf(self, elem: _indexOf_1__B, from_: int) -> int: ...
        _indexOfSlice_0__B = typing.TypeVar('_indexOfSlice_0__B')  # <B>
        _indexOfSlice_1__B = typing.TypeVar('_indexOfSlice_1__B')  # <B>
        @typing.overload
        def indexOfSlice(self, that: scala.collection.GenSeq[_indexOfSlice_0__B]) -> int: ...
        @typing.overload
        def indexOfSlice(self, that: scala.collection.GenSeq[_indexOfSlice_1__B], from_: int) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[typing.Any, typing.Any], from_: int) -> int: ...
        def indices(self) -> scala.collection.immutable.Range: ...
        def init(self) -> typing.Any: ...
        def inits(self) -> scala.collection.Iterator[typing.List[int]]: ...
        def intersect(self, that: scala.collection.GenSeq) -> typing.Any: ...
        def isDefinedAt(self, idx: int) -> bool: ...
        def isEmpty(self) -> bool: ...
        def isTraversableAgain(self) -> bool: ...
        def iterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def last(self) -> typing.Any: ...
        _lastIndexOf_0__B = typing.TypeVar('_lastIndexOf_0__B')  # <B>
        _lastIndexOf_1__B = typing.TypeVar('_lastIndexOf_1__B')  # <B>
        @typing.overload
        def lastIndexOf(self, elem: _lastIndexOf_0__B) -> int: ...
        @typing.overload
        def lastIndexOf(self, elem: _lastIndexOf_1__B, end: int) -> int: ...
        _lastIndexOfSlice_0__B = typing.TypeVar('_lastIndexOfSlice_0__B')  # <B>
        _lastIndexOfSlice_1__B = typing.TypeVar('_lastIndexOfSlice_1__B')  # <B>
        @typing.overload
        def lastIndexOfSlice(self, that: scala.collection.GenSeq[_lastIndexOfSlice_0__B]) -> int: ...
        @typing.overload
        def lastIndexOfSlice(self, that: scala.collection.GenSeq[_lastIndexOfSlice_1__B], end: int) -> int: ...
        @typing.overload
        def lastIndexWhere(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        @typing.overload
        def lastIndexWhere(self, p: scala.Function1[typing.Any, typing.Any], end: int) -> int: ...
        def lastOption(self) -> scala.Option[typing.Any]: ...
        def length(self) -> int: ...
        def lengthCompare(self, len: int) -> int: ...
        _map__B = typing.TypeVar('_map__B')  # <B>
        _map__That = typing.TypeVar('_map__That')  # <That>
        def map(self, f: scala.Function1[typing.Any, _map__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _map__B, _map__That]) -> _map__That: ...
        def max(self, cmp: scala.math.Ordering) -> typing.Any: ...
        def maxBy(self, f: scala.Function1, cmp: scala.math.Ordering) -> typing.Any: ...
        def min(self, cmp: scala.math.Ordering) -> typing.Any: ...
        def minBy(self, f: scala.Function1, cmp: scala.math.Ordering) -> typing.Any: ...
        @typing.overload
        def mkString(self) -> str: ...
        @typing.overload
        def mkString(self, sep: str) -> str: ...
        @typing.overload
        def mkString(self, start: str, sep: str, end: str) -> str: ...
        def newBuilder(self) -> ArrayBuilder.ofLong: ...
        def nonEmpty(self) -> bool: ...
        _padTo__B = typing.TypeVar('_padTo__B')  # <B>
        _padTo__That = typing.TypeVar('_padTo__That')  # <That>
        def padTo(self, len: int, elem: _padTo__B, bf: scala.collection.generic.CanBuildFrom[typing.List[int], _padTo__B, _padTo__That]) -> _padTo__That: ...
        def par(self) -> scala.collection.parallel.mutable.ParArray[typing.Any]: ...
        def parCombiner(self) -> scala.collection.parallel.Combiner[typing.Any, scala.collection.parallel.mutable.ParArray[typing.Any]]: ...
        def partition(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.Tuple2[typing.List[int], typing.List[int]]: ...
        _patch__B = typing.TypeVar('_patch__B')  # <B>
        _patch__That = typing.TypeVar('_patch__That')  # <That>
        def patch(self, from_: int, patch: scala.collection.GenSeq[_patch__B], replaced: int, bf: scala.collection.generic.CanBuildFrom[typing.List[int], _patch__B, _patch__That]) -> _patch__That: ...
        def permutations(self) -> scala.collection.Iterator[typing.List[int]]: ...
        def prefixLength(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        _product__B = typing.TypeVar('_product__B')  # <B>
        def product(self, num: scala.math.Numeric[_product__B]) -> _product__B: ...
        _reduce__A1 = typing.TypeVar('_reduce__A1')  # <A1>
        def reduce(self, op: scala.Function2[_reduce__A1, _reduce__A1, _reduce__A1]) -> _reduce__A1: ...
        _reduceLeft__B = typing.TypeVar('_reduceLeft__B')  # <B>
        def reduceLeft(self, op: scala.Function2[_reduceLeft__B, typing.Any, _reduceLeft__B]) -> _reduceLeft__B: ...
        _reduceLeftOption__B = typing.TypeVar('_reduceLeftOption__B')  # <B>
        def reduceLeftOption(self, op: scala.Function2[_reduceLeftOption__B, typing.Any, _reduceLeftOption__B]) -> scala.Option[_reduceLeftOption__B]: ...
        _reduceOption__A1 = typing.TypeVar('_reduceOption__A1')  # <A1>
        def reduceOption(self, op: scala.Function2[_reduceOption__A1, _reduceOption__A1, _reduceOption__A1]) -> scala.Option[_reduceOption__A1]: ...
        _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
        def reduceRight(self, op: scala.Function2[typing.Any, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
        _reduceRightOption__B = typing.TypeVar('_reduceRightOption__B')  # <B>
        def reduceRightOption(self, op: scala.Function2[typing.Any, _reduceRightOption__B, _reduceRightOption__B]) -> scala.Option[_reduceRightOption__B]: ...
        def repr(self) -> typing.List[int]: ...
        def reverse(self) -> typing.Any: ...
        def reverseIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        _reverseMap__B = typing.TypeVar('_reverseMap__B')  # <B>
        _reverseMap__That = typing.TypeVar('_reverseMap__That')  # <That>
        def reverseMap(self, f: scala.Function1[typing.Any, _reverseMap__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _reverseMap__B, _reverseMap__That]) -> _reverseMap__That: ...
        def reversed(self) -> scala.collection.immutable.List[typing.Any]: ...
        _sameElements__B = typing.TypeVar('_sameElements__B')  # <B>
        def sameElements(self, that: scala.collection.GenIterable[_sameElements__B]) -> bool: ...
        _scan__B = typing.TypeVar('_scan__B')  # <B>
        _scan__That = typing.TypeVar('_scan__That')  # <That>
        def scan(self, z: _scan__B, op: scala.Function2[_scan__B, _scan__B, _scan__B], cbf: scala.collection.generic.CanBuildFrom[typing.List[int], _scan__B, _scan__That]) -> _scan__That: ...
        _scanLeft__B = typing.TypeVar('_scanLeft__B')  # <B>
        _scanLeft__That = typing.TypeVar('_scanLeft__That')  # <That>
        def scanLeft(self, z: _scanLeft__B, op: scala.Function2[_scanLeft__B, typing.Any, _scanLeft__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _scanLeft__B, _scanLeft__That]) -> _scanLeft__That: ...
        _scanRight__B = typing.TypeVar('_scanRight__B')  # <B>
        _scanRight__That = typing.TypeVar('_scanRight__That')  # <That>
        def scanRight(self, z: _scanRight__B, op: scala.Function2[typing.Any, _scanRight__B, _scanRight__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _scanRight__B, _scanRight__That]) -> _scanRight__That: ...
        def segmentLength(self, p: scala.Function1[typing.Any, typing.Any], from_: int) -> int: ...
        def seq(self) -> IndexedSeq[typing.Any]: ...
        def size(self) -> int: ...
        def sizeHintIfCheap(self) -> int: ...
        def slice(self, from_: int, until: int) -> typing.Any: ...
        def sliceWithKnownBound(self, from_: int, until: int) -> typing.Any: ...
        def sliceWithKnownDelta(self, from_: int, until: int, delta: int) -> typing.Any: ...
        @typing.overload
        def sliding(self, size: int) -> scala.collection.Iterator[typing.List[int]]: ...
        @typing.overload
        def sliding(self, size: int, step: int) -> scala.collection.Iterator[typing.List[int]]: ...
        def sortBy(self, f: scala.Function1, ord: scala.math.Ordering) -> typing.Any: ...
        def sortWith(self, lt: scala.Function2) -> typing.Any: ...
        def sorted(self, ord: scala.math.Ordering) -> typing.Any: ...
        def span(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.Tuple2[typing.List[int], typing.List[int]]: ...
        def splitAt(self, n: int) -> scala.Tuple2[typing.List[int], typing.List[int]]: ...
        _startsWith_0__B = typing.TypeVar('_startsWith_0__B')  # <B>
        _startsWith_1__B = typing.TypeVar('_startsWith_1__B')  # <B>
        @typing.overload
        def startsWith(self, that: scala.collection.GenSeq[_startsWith_0__B]) -> bool: ...
        @typing.overload
        def startsWith(self, that: scala.collection.GenSeq[_startsWith_1__B], offset: int) -> bool: ...
        def stringPrefix(self) -> str: ...
        _sum__B = typing.TypeVar('_sum__B')  # <B>
        def sum(self, num: scala.math.Numeric[_sum__B]) -> _sum__B: ...
        def tail(self) -> typing.Any: ...
        def tails(self) -> scala.collection.Iterator[typing.List[int]]: ...
        def take(self, n: int) -> typing.Any: ...
        def takeRight(self, n: int) -> typing.Any: ...
        def takeWhile(self, p: scala.Function1) -> typing.Any: ...
        def thisCollection(self) -> 'WrappedArray'[typing.Any]: ...
        _to__Col = typing.TypeVar('_to__Col')  # <Col>
        def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., typing.Any, _to__Col]) -> _to__Col: ...
        _toArray__U = typing.TypeVar('_toArray__U')  # <U>
        def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__U]) -> typing.Any: ...
        _toBuffer__A1 = typing.TypeVar('_toBuffer__A1')  # <A1>
        def toBuffer(self) -> Buffer[_toBuffer__A1]: ...
        def toCollection(self, repr: typing.List[int]) -> 'WrappedArray'[typing.Any]: ...
        def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq[typing.Any]: ...
        def toIterable(self) -> scala.collection.Iterable[typing.Any]: ...
        def toIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def toList(self) -> scala.collection.immutable.List[typing.Any]: ...
        _toMap__T = typing.TypeVar('_toMap__T')  # <T>
        _toMap__U = typing.TypeVar('_toMap__U')  # <U>
        def toMap(self, ev: scala.Predef..less.colon.less[typing.Any, scala.Tuple2[_toMap__T, _toMap__U]]) -> scala.collection.immutable.Map[_toMap__T, _toMap__U]: ...
        def toSeq(self) -> scala.collection.Seq[typing.Any]: ...
        _toSet__B = typing.TypeVar('_toSet__B')  # <B>
        def toSet(self) -> scala.collection.immutable.Set[_toSet__B]: ...
        def toStream(self) -> scala.collection.immutable.Stream[typing.Any]: ...
        def toString(self) -> str: ...
        def toTraversable(self) -> scala.collection.Traversable[typing.Any]: ...
        def toVector(self) -> scala.collection.immutable.Vector[typing.Any]: ...
        _transpose__U = typing.TypeVar('_transpose__U')  # <U>
        def transpose(self, asArray: scala.Function1[typing.Any, typing.Any]) -> typing.List[typing.Any]: ...
        _union__B = typing.TypeVar('_union__B')  # <B>
        _union__That = typing.TypeVar('_union__That')  # <That>
        def union(self, that: scala.collection.GenSeq[_union__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _union__B, _union__That]) -> _union__That: ...
        _unzip__T1 = typing.TypeVar('_unzip__T1')  # <T1>
        _unzip__T2 = typing.TypeVar('_unzip__T2')  # <T2>
        def unzip(self, asPair: scala.Function1[typing.Any, scala.Tuple2[_unzip__T1, _unzip__T2]], ct1: scala.reflect.ClassTag[_unzip__T1], ct2: scala.reflect.ClassTag[_unzip__T2]) -> scala.Tuple2[typing.Any, typing.Any]: ...
        _unzip3__T1 = typing.TypeVar('_unzip3__T1')  # <T1>
        _unzip3__T2 = typing.TypeVar('_unzip3__T2')  # <T2>
        _unzip3__T3 = typing.TypeVar('_unzip3__T3')  # <T3>
        def unzip3(self, asTriple: scala.Function1[typing.Any, scala.Tuple3[_unzip3__T1, _unzip3__T2, _unzip3__T3]], ct1: scala.reflect.ClassTag[_unzip3__T1], ct2: scala.reflect.ClassTag[_unzip3__T2], ct3: scala.reflect.ClassTag[_unzip3__T3]) -> scala.Tuple3[typing.Any, typing.Any, typing.Any]: ...
        def update(self, index: int, elem: int) -> None: ...
        _updated__B = typing.TypeVar('_updated__B')  # <B>
        _updated__That = typing.TypeVar('_updated__That')  # <That>
        def updated(self, index: int, elem: _updated__B, bf: scala.collection.generic.CanBuildFrom[typing.List[int], _updated__B, _updated__That]) -> _updated__That: ...
        @typing.overload
        def view(self) -> 'IndexedSeqView'[typing.Any, typing.List[int]]: ...
        @typing.overload
        def view(self, from_: int, until: int) -> 'IndexedSeqView'[typing.Any, typing.List[int]]: ...
        def withFilter(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.collection.generic.FilterMonadic[typing.Any, typing.List[int]]: ...
        _zip__A1 = typing.TypeVar('_zip__A1')  # <A1>
        _zip__B = typing.TypeVar('_zip__B')  # <B>
        _zip__That = typing.TypeVar('_zip__That')  # <That>
        def zip(self, that: scala.collection.GenIterable[_zip__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], scala.Tuple2[_zip__A1, _zip__B], _zip__That]) -> _zip__That: ...
        _zipAll__B = typing.TypeVar('_zipAll__B')  # <B>
        _zipAll__A1 = typing.TypeVar('_zipAll__A1')  # <A1>
        _zipAll__That = typing.TypeVar('_zipAll__That')  # <That>
        def zipAll(self, that: scala.collection.GenIterable[_zipAll__B], thisElem: _zipAll__A1, thatElem: _zipAll__B, bf: scala.collection.generic.CanBuildFrom[typing.List[int], scala.Tuple2[_zipAll__A1, _zipAll__B], _zipAll__That]) -> _zipAll__That: ...
        _zipWithIndex__A1 = typing.TypeVar('_zipWithIndex__A1')  # <A1>
        _zipWithIndex__That = typing.TypeVar('_zipWithIndex__That')  # <That>
        def zipWithIndex(self, bf: scala.collection.generic.CanBuildFrom[typing.List[int], scala.Tuple2[_zipWithIndex__A1, typing.Any], _zipWithIndex__That]) -> _zipWithIndex__That: ...
    class ofLong$:
        MODULE$: typing.ClassVar['ArrayOps.ofLong.'] = ...
        def __init__(self): ...
        def apply$extension(self, $this: typing.List[int], index: int) -> int: ...
        def equals$extension(self, $this: typing.List[int], x$1: typing.Any) -> bool: ...
        def hashCode$extension(self, $this: typing.List[int]) -> int: ...
        def length$extension(self, $this: typing.List[int]) -> int: ...
        def newBuilder$extension(self, $this: typing.List[int]) -> ArrayBuilder.ofLong: ...
        def thisCollection$extension(self, $this: typing.List[int]) -> 'WrappedArray'[typing.Any]: ...
        def toCollection$extension(self, $this: typing.List[int], repr: typing.List[int]) -> 'WrappedArray'[typing.Any]: ...
        def update$extension(self, $this: typing.List[int], index: int, elem: int) -> None: ...
    class ofRef(scala.collection.mutable.ArrayOps[_ArrayOps__ofRef__T], typing.Generic[_ArrayOps__ofRef__T]):
        def __init__(self, repr: typing.List[_ArrayOps__ofRef__T]): ...
        _$colon$bslash__B = typing.TypeVar('_$colon$bslash__B')  # <B>
        def $colon$bslash(self, z: _.colon.bslash__B, op: scala.Function2[_ArrayOps__ofRef__T, _.colon.bslash__B, _.colon.bslash__B]) -> _.colon.bslash__B: ...
        _$colon$plus_0__B = typing.TypeVar('_$colon$plus_0__B')  # <B>
        _$colon$plus_0__That = typing.TypeVar('_$colon$plus_0__That')  # <That>
        _$colon$plus_1__B = typing.TypeVar('_$colon$plus_1__B')  # <B>
        @typing.overload
        def $colon$plus(self, elem: _.colon.plus_0__B, bf: scala.collection.generic.CanBuildFrom[typing.List[_ArrayOps__ofRef__T], _.colon.plus_0__B, _.colon.plus_0__That]) -> _.colon.plus_0__That: ...
        @typing.overload
        def $colon$plus(self, elem: _.colon.plus_1__B, evidence$2: scala.reflect.ClassTag[_.colon.plus_1__B]) -> typing.Any: ...
        _$div$colon__B = typing.TypeVar('_$div$colon__B')  # <B>
        def $div$colon(self, z: _.div.colon__B, op: scala.Function2[_.div.colon__B, _ArrayOps__ofRef__T, _.div.colon__B]) -> _.div.colon__B: ...
        _$plus$colon_0__B = typing.TypeVar('_$plus$colon_0__B')  # <B>
        _$plus$colon_0__That = typing.TypeVar('_$plus$colon_0__That')  # <That>
        _$plus$colon_1__B = typing.TypeVar('_$plus$colon_1__B')  # <B>
        @typing.overload
        def $plus$colon(self, elem: _.plus.colon_0__B, bf: scala.collection.generic.CanBuildFrom[typing.List[_ArrayOps__ofRef__T], _.plus.colon_0__B, _.plus.colon_0__That]) -> _.plus.colon_0__That: ...
        @typing.overload
        def $plus$colon(self, elem: _.plus.colon_1__B, evidence$3: scala.reflect.ClassTag[_.plus.colon_1__B]) -> typing.Any: ...
        _$plus$plus__B = typing.TypeVar('_$plus$plus__B')  # <B>
        _$plus$plus__That = typing.TypeVar('_$plus$plus__That')  # <That>
        def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus__B], bf: scala.collection.generic.CanBuildFrom[typing.List[_ArrayOps__ofRef__T], _.plus.plus__B, _.plus.plus__That]) -> _.plus.plus__That: ...
        _$plus$plus$colon_0__B = typing.TypeVar('_$plus$plus$colon_0__B')  # <B>
        _$plus$plus$colon_0__That = typing.TypeVar('_$plus$plus$colon_0__That')  # <That>
        _$plus$plus$colon_1__B = typing.TypeVar('_$plus$plus$colon_1__B')  # <B>
        _$plus$plus$colon_1__That = typing.TypeVar('_$plus$plus$colon_1__That')  # <That>
        @typing.overload
        def $plus$plus$colon(self, that: scala.collection.Traversable[_.plus.plus.colon_0__B], bf: scala.collection.generic.CanBuildFrom[typing.List[_ArrayOps__ofRef__T], _.plus.plus.colon_0__B, _.plus.plus.colon_0__That]) -> _.plus.plus.colon_0__That: ...
        @typing.overload
        def $plus$plus$colon(self, that: scala.collection.TraversableOnce[_.plus.plus.colon_1__B], bf: scala.collection.generic.CanBuildFrom[typing.List[_ArrayOps__ofRef__T], _.plus.plus.colon_1__B, _.plus.plus.colon_1__That]) -> _.plus.plus.colon_1__That: ...
        @typing.overload
        def addString(self, b: StringBuilder) -> StringBuilder: ...
        @typing.overload
        def addString(self, b: StringBuilder, sep: str) -> StringBuilder: ...
        @typing.overload
        def addString(self, b: StringBuilder, start: str, sep: str, end: str) -> StringBuilder: ...
        _aggregate__B = typing.TypeVar('_aggregate__B')  # <B>
        def aggregate(self, z: scala.Function0[_aggregate__B], seqop: scala.Function2[_aggregate__B, _ArrayOps__ofRef__T, _aggregate__B], combop: scala.Function2[_aggregate__B, _aggregate__B, _aggregate__B]) -> _aggregate__B: ...
        def apply(self, index: int) -> _ArrayOps__ofRef__T: ...
        def canEqual(self, that: typing.Any) -> bool: ...
        _collect__B = typing.TypeVar('_collect__B')  # <B>
        _collect__That = typing.TypeVar('_collect__That')  # <That>
        def collect(self, pf: scala.PartialFunction[_ArrayOps__ofRef__T, _collect__B], bf: scala.collection.generic.CanBuildFrom[typing.List[_ArrayOps__ofRef__T], _collect__B, _collect__That]) -> _collect__That: ...
        _collectFirst__B = typing.TypeVar('_collectFirst__B')  # <B>
        def collectFirst(self, pf: scala.PartialFunction[_ArrayOps__ofRef__T, _collectFirst__B]) -> scala.Option[_collectFirst__B]: ...
        def combinations(self, n: int) -> scala.collection.Iterator[typing.List[_ArrayOps__ofRef__T]]: ...
        _contains__A1 = typing.TypeVar('_contains__A1')  # <A1>
        def contains(self, elem: _contains__A1) -> bool: ...
        _containsSlice__B = typing.TypeVar('_containsSlice__B')  # <B>
        def containsSlice(self, that: scala.collection.GenSeq[_containsSlice__B]) -> bool: ...
        _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
        _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
        _copyToArray_2__U = typing.TypeVar('_copyToArray_2__U')  # <U>
        @typing.overload
        def copyToArray(self, xs: typing.Any) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
        _copyToBuffer__B = typing.TypeVar('_copyToBuffer__B')  # <B>
        def copyToBuffer(self, dest: Buffer[_copyToBuffer__B]) -> None: ...
        _corresponds__B = typing.TypeVar('_corresponds__B')  # <B>
        def corresponds(self, that: scala.collection.GenSeq[_corresponds__B], p: scala.Function2[_ArrayOps__ofRef__T, _corresponds__B, typing.Any]) -> bool: ...
        def count(self, p: scala.Function1[_ArrayOps__ofRef__T, typing.Any]) -> int: ...
        def deep(self) -> scala.collection.IndexedSeq[typing.Any]: ...
        def diff(self, that: scala.collection.GenSeq) -> typing.Any: ...
        def distinct(self) -> typing.Any: ...
        def drop(self, n: int) -> typing.Any: ...
        def dropRight(self, n: int) -> typing.Any: ...
        def dropWhile(self, p: scala.Function1) -> typing.Any: ...
        _endsWith__B = typing.TypeVar('_endsWith__B')  # <B>
        def endsWith(self, that: scala.collection.GenSeq[_endsWith__B]) -> bool: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def exists(self, p: scala.Function1[_ArrayOps__ofRef__T, typing.Any]) -> bool: ...
        def filter(self, p: scala.Function1) -> typing.Any: ...
        def filterImpl(self, p: scala.Function1, isFlipped: bool) -> typing.Any: ...
        def filterNot(self, p: scala.Function1) -> typing.Any: ...
        def find(self, p: scala.Function1[_ArrayOps__ofRef__T, typing.Any]) -> scala.Option[_ArrayOps__ofRef__T]: ...
        _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
        _flatMap__That = typing.TypeVar('_flatMap__That')  # <That>
        def flatMap(self, f: scala.Function1[_ArrayOps__ofRef__T, scala.collection.GenTraversableOnce[_flatMap__B]], bf: scala.collection.generic.CanBuildFrom[typing.List[_ArrayOps__ofRef__T], _flatMap__B, _flatMap__That]) -> _flatMap__That: ...
        _flatten__U = typing.TypeVar('_flatten__U')  # <U>
        def flatten(self, asTrav: scala.Function1[_ArrayOps__ofRef__T, scala.collection.Traversable[_flatten__U]], m: scala.reflect.ClassTag[_flatten__U]) -> typing.Any: ...
        _fold__A1 = typing.TypeVar('_fold__A1')  # <A1>
        def fold(self, z: _fold__A1, op: scala.Function2[_fold__A1, _fold__A1, _fold__A1]) -> _fold__A1: ...
        _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
        def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, _ArrayOps__ofRef__T, _foldLeft__B]) -> _foldLeft__B: ...
        _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
        def foldRight(self, z: _foldRight__B, op: scala.Function2[_ArrayOps__ofRef__T, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
        def forall(self, p: scala.Function1[_ArrayOps__ofRef__T, typing.Any]) -> bool: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[_ArrayOps__ofRef__T, _foreach__U]) -> None: ...
        _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
        def groupBy(self, f: scala.Function1[_ArrayOps__ofRef__T, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, typing.List[_ArrayOps__ofRef__T]]: ...
        def grouped(self, size: int) -> scala.collection.Iterator[typing.List[_ArrayOps__ofRef__T]]: ...
        def hasDefiniteSize(self) -> bool: ...
        def hashCode(self) -> int: ...
        def head(self) -> _ArrayOps__ofRef__T: ...
        def headOption(self) -> scala.Option[_ArrayOps__ofRef__T]: ...
        _indexOf_0__B = typing.TypeVar('_indexOf_0__B')  # <B>
        _indexOf_1__B = typing.TypeVar('_indexOf_1__B')  # <B>
        @typing.overload
        def indexOf(self, elem: _indexOf_0__B) -> int: ...
        @typing.overload
        def indexOf(self, elem: _indexOf_1__B, from_: int) -> int: ...
        _indexOfSlice_0__B = typing.TypeVar('_indexOfSlice_0__B')  # <B>
        _indexOfSlice_1__B = typing.TypeVar('_indexOfSlice_1__B')  # <B>
        @typing.overload
        def indexOfSlice(self, that: scala.collection.GenSeq[_indexOfSlice_0__B]) -> int: ...
        @typing.overload
        def indexOfSlice(self, that: scala.collection.GenSeq[_indexOfSlice_1__B], from_: int) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[_ArrayOps__ofRef__T, typing.Any]) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[_ArrayOps__ofRef__T, typing.Any], from_: int) -> int: ...
        def indices(self) -> scala.collection.immutable.Range: ...
        def init(self) -> typing.Any: ...
        def inits(self) -> scala.collection.Iterator[typing.List[_ArrayOps__ofRef__T]]: ...
        def intersect(self, that: scala.collection.GenSeq) -> typing.Any: ...
        def isDefinedAt(self, idx: int) -> bool: ...
        def isEmpty(self) -> bool: ...
        def isTraversableAgain(self) -> bool: ...
        def iterator(self) -> scala.collection.Iterator[_ArrayOps__ofRef__T]: ...
        def last(self) -> _ArrayOps__ofRef__T: ...
        _lastIndexOf_0__B = typing.TypeVar('_lastIndexOf_0__B')  # <B>
        _lastIndexOf_1__B = typing.TypeVar('_lastIndexOf_1__B')  # <B>
        @typing.overload
        def lastIndexOf(self, elem: _lastIndexOf_0__B) -> int: ...
        @typing.overload
        def lastIndexOf(self, elem: _lastIndexOf_1__B, end: int) -> int: ...
        _lastIndexOfSlice_0__B = typing.TypeVar('_lastIndexOfSlice_0__B')  # <B>
        _lastIndexOfSlice_1__B = typing.TypeVar('_lastIndexOfSlice_1__B')  # <B>
        @typing.overload
        def lastIndexOfSlice(self, that: scala.collection.GenSeq[_lastIndexOfSlice_0__B]) -> int: ...
        @typing.overload
        def lastIndexOfSlice(self, that: scala.collection.GenSeq[_lastIndexOfSlice_1__B], end: int) -> int: ...
        @typing.overload
        def lastIndexWhere(self, p: scala.Function1[_ArrayOps__ofRef__T, typing.Any]) -> int: ...
        @typing.overload
        def lastIndexWhere(self, p: scala.Function1[_ArrayOps__ofRef__T, typing.Any], end: int) -> int: ...
        def lastOption(self) -> scala.Option[_ArrayOps__ofRef__T]: ...
        def length(self) -> int: ...
        def lengthCompare(self, len: int) -> int: ...
        _map__B = typing.TypeVar('_map__B')  # <B>
        _map__That = typing.TypeVar('_map__That')  # <That>
        def map(self, f: scala.Function1[_ArrayOps__ofRef__T, _map__B], bf: scala.collection.generic.CanBuildFrom[typing.List[_ArrayOps__ofRef__T], _map__B, _map__That]) -> _map__That: ...
        _max__B = typing.TypeVar('_max__B')  # <B>
        def max(self, cmp: scala.math.Ordering[_max__B]) -> _ArrayOps__ofRef__T: ...
        _maxBy__B = typing.TypeVar('_maxBy__B')  # <B>
        def maxBy(self, f: scala.Function1[_ArrayOps__ofRef__T, _maxBy__B], cmp: scala.math.Ordering[_maxBy__B]) -> _ArrayOps__ofRef__T: ...
        _min__B = typing.TypeVar('_min__B')  # <B>
        def min(self, cmp: scala.math.Ordering[_min__B]) -> _ArrayOps__ofRef__T: ...
        _minBy__B = typing.TypeVar('_minBy__B')  # <B>
        def minBy(self, f: scala.Function1[_ArrayOps__ofRef__T, _minBy__B], cmp: scala.math.Ordering[_minBy__B]) -> _ArrayOps__ofRef__T: ...
        @typing.overload
        def mkString(self) -> str: ...
        @typing.overload
        def mkString(self, sep: str) -> str: ...
        @typing.overload
        def mkString(self, start: str, sep: str, end: str) -> str: ...
        def newBuilder(self) -> ArrayBuilder.ofRef[_ArrayOps__ofRef__T]: ...
        def nonEmpty(self) -> bool: ...
        _padTo__B = typing.TypeVar('_padTo__B')  # <B>
        _padTo__That = typing.TypeVar('_padTo__That')  # <That>
        def padTo(self, len: int, elem: _padTo__B, bf: scala.collection.generic.CanBuildFrom[typing.List[_ArrayOps__ofRef__T], _padTo__B, _padTo__That]) -> _padTo__That: ...
        def par(self) -> scala.collection.parallel.mutable.ParArray[_ArrayOps__ofRef__T]: ...
        def parCombiner(self) -> scala.collection.parallel.Combiner[_ArrayOps__ofRef__T, scala.collection.parallel.mutable.ParArray[_ArrayOps__ofRef__T]]: ...
        def partition(self, p: scala.Function1[_ArrayOps__ofRef__T, typing.Any]) -> scala.Tuple2[typing.List[_ArrayOps__ofRef__T], typing.List[_ArrayOps__ofRef__T]]: ...
        _patch__B = typing.TypeVar('_patch__B')  # <B>
        _patch__That = typing.TypeVar('_patch__That')  # <That>
        def patch(self, from_: int, patch: scala.collection.GenSeq[_patch__B], replaced: int, bf: scala.collection.generic.CanBuildFrom[typing.List[_ArrayOps__ofRef__T], _patch__B, _patch__That]) -> _patch__That: ...
        def permutations(self) -> scala.collection.Iterator[typing.List[_ArrayOps__ofRef__T]]: ...
        def prefixLength(self, p: scala.Function1[_ArrayOps__ofRef__T, typing.Any]) -> int: ...
        _product__B = typing.TypeVar('_product__B')  # <B>
        def product(self, num: scala.math.Numeric[_product__B]) -> _product__B: ...
        _reduce__A1 = typing.TypeVar('_reduce__A1')  # <A1>
        def reduce(self, op: scala.Function2[_reduce__A1, _reduce__A1, _reduce__A1]) -> _reduce__A1: ...
        _reduceLeft__B = typing.TypeVar('_reduceLeft__B')  # <B>
        def reduceLeft(self, op: scala.Function2[_reduceLeft__B, _ArrayOps__ofRef__T, _reduceLeft__B]) -> _reduceLeft__B: ...
        _reduceLeftOption__B = typing.TypeVar('_reduceLeftOption__B')  # <B>
        def reduceLeftOption(self, op: scala.Function2[_reduceLeftOption__B, _ArrayOps__ofRef__T, _reduceLeftOption__B]) -> scala.Option[_reduceLeftOption__B]: ...
        _reduceOption__A1 = typing.TypeVar('_reduceOption__A1')  # <A1>
        def reduceOption(self, op: scala.Function2[_reduceOption__A1, _reduceOption__A1, _reduceOption__A1]) -> scala.Option[_reduceOption__A1]: ...
        _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
        def reduceRight(self, op: scala.Function2[_ArrayOps__ofRef__T, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
        _reduceRightOption__B = typing.TypeVar('_reduceRightOption__B')  # <B>
        def reduceRightOption(self, op: scala.Function2[_ArrayOps__ofRef__T, _reduceRightOption__B, _reduceRightOption__B]) -> scala.Option[_reduceRightOption__B]: ...
        def repr(self) -> typing.List[_ArrayOps__ofRef__T]: ...
        def reverse(self) -> typing.Any: ...
        def reverseIterator(self) -> scala.collection.Iterator[_ArrayOps__ofRef__T]: ...
        _reverseMap__B = typing.TypeVar('_reverseMap__B')  # <B>
        _reverseMap__That = typing.TypeVar('_reverseMap__That')  # <That>
        def reverseMap(self, f: scala.Function1[_ArrayOps__ofRef__T, _reverseMap__B], bf: scala.collection.generic.CanBuildFrom[typing.List[_ArrayOps__ofRef__T], _reverseMap__B, _reverseMap__That]) -> _reverseMap__That: ...
        def reversed(self) -> scala.collection.immutable.List[_ArrayOps__ofRef__T]: ...
        _sameElements__B = typing.TypeVar('_sameElements__B')  # <B>
        def sameElements(self, that: scala.collection.GenIterable[_sameElements__B]) -> bool: ...
        _scan__B = typing.TypeVar('_scan__B')  # <B>
        _scan__That = typing.TypeVar('_scan__That')  # <That>
        def scan(self, z: _scan__B, op: scala.Function2[_scan__B, _scan__B, _scan__B], cbf: scala.collection.generic.CanBuildFrom[typing.List[_ArrayOps__ofRef__T], _scan__B, _scan__That]) -> _scan__That: ...
        _scanLeft__B = typing.TypeVar('_scanLeft__B')  # <B>
        _scanLeft__That = typing.TypeVar('_scanLeft__That')  # <That>
        def scanLeft(self, z: _scanLeft__B, op: scala.Function2[_scanLeft__B, _ArrayOps__ofRef__T, _scanLeft__B], bf: scala.collection.generic.CanBuildFrom[typing.List[_ArrayOps__ofRef__T], _scanLeft__B, _scanLeft__That]) -> _scanLeft__That: ...
        _scanRight__B = typing.TypeVar('_scanRight__B')  # <B>
        _scanRight__That = typing.TypeVar('_scanRight__That')  # <That>
        def scanRight(self, z: _scanRight__B, op: scala.Function2[_ArrayOps__ofRef__T, _scanRight__B, _scanRight__B], bf: scala.collection.generic.CanBuildFrom[typing.List[_ArrayOps__ofRef__T], _scanRight__B, _scanRight__That]) -> _scanRight__That: ...
        def segmentLength(self, p: scala.Function1[_ArrayOps__ofRef__T, typing.Any], from_: int) -> int: ...
        def seq(self) -> IndexedSeq[_ArrayOps__ofRef__T]: ...
        def size(self) -> int: ...
        def sizeHintIfCheap(self) -> int: ...
        def slice(self, from_: int, until: int) -> typing.Any: ...
        def sliceWithKnownBound(self, from_: int, until: int) -> typing.Any: ...
        def sliceWithKnownDelta(self, from_: int, until: int, delta: int) -> typing.Any: ...
        @typing.overload
        def sliding(self, size: int) -> scala.collection.Iterator[typing.List[_ArrayOps__ofRef__T]]: ...
        @typing.overload
        def sliding(self, size: int, step: int) -> scala.collection.Iterator[typing.List[_ArrayOps__ofRef__T]]: ...
        def sortBy(self, f: scala.Function1, ord: scala.math.Ordering) -> typing.Any: ...
        def sortWith(self, lt: scala.Function2) -> typing.Any: ...
        def sorted(self, ord: scala.math.Ordering) -> typing.Any: ...
        def span(self, p: scala.Function1[_ArrayOps__ofRef__T, typing.Any]) -> scala.Tuple2[typing.List[_ArrayOps__ofRef__T], typing.List[_ArrayOps__ofRef__T]]: ...
        def splitAt(self, n: int) -> scala.Tuple2[typing.List[_ArrayOps__ofRef__T], typing.List[_ArrayOps__ofRef__T]]: ...
        _startsWith_0__B = typing.TypeVar('_startsWith_0__B')  # <B>
        _startsWith_1__B = typing.TypeVar('_startsWith_1__B')  # <B>
        @typing.overload
        def startsWith(self, that: scala.collection.GenSeq[_startsWith_0__B]) -> bool: ...
        @typing.overload
        def startsWith(self, that: scala.collection.GenSeq[_startsWith_1__B], offset: int) -> bool: ...
        def stringPrefix(self) -> str: ...
        _sum__B = typing.TypeVar('_sum__B')  # <B>
        def sum(self, num: scala.math.Numeric[_sum__B]) -> _sum__B: ...
        def tail(self) -> typing.Any: ...
        def tails(self) -> scala.collection.Iterator[typing.List[_ArrayOps__ofRef__T]]: ...
        def take(self, n: int) -> typing.Any: ...
        def takeRight(self, n: int) -> typing.Any: ...
        def takeWhile(self, p: scala.Function1) -> typing.Any: ...
        def thisCollection(self) -> 'WrappedArray'[_ArrayOps__ofRef__T]: ...
        _to__Col = typing.TypeVar('_to__Col')  # <Col>
        def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., _ArrayOps__ofRef__T, _to__Col]) -> _to__Col: ...
        _toArray__U = typing.TypeVar('_toArray__U')  # <U>
        def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__U]) -> typing.Any: ...
        _toBuffer__A1 = typing.TypeVar('_toBuffer__A1')  # <A1>
        def toBuffer(self) -> Buffer[_toBuffer__A1]: ...
        def toCollection(self, repr: typing.List[_ArrayOps__ofRef__T]) -> 'WrappedArray'[_ArrayOps__ofRef__T]: ...
        def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq[_ArrayOps__ofRef__T]: ...
        def toIterable(self) -> scala.collection.Iterable[_ArrayOps__ofRef__T]: ...
        def toIterator(self) -> scala.collection.Iterator[_ArrayOps__ofRef__T]: ...
        def toList(self) -> scala.collection.immutable.List[_ArrayOps__ofRef__T]: ...
        _toMap__T = typing.TypeVar('_toMap__T')  # <T>
        _toMap__U = typing.TypeVar('_toMap__U')  # <U>
        def toMap(self, ev: scala.Predef..less.colon.less[typing.Any, scala.Tuple2[typing.Any, _toMap__U]]) -> scala.collection.immutable.Map[typing.Any, _toMap__U]: ...
        def toSeq(self) -> scala.collection.Seq[_ArrayOps__ofRef__T]: ...
        _toSet__B = typing.TypeVar('_toSet__B')  # <B>
        def toSet(self) -> scala.collection.immutable.Set[_toSet__B]: ...
        def toStream(self) -> scala.collection.immutable.Stream[_ArrayOps__ofRef__T]: ...
        def toString(self) -> str: ...
        def toTraversable(self) -> scala.collection.Traversable[_ArrayOps__ofRef__T]: ...
        def toVector(self) -> scala.collection.immutable.Vector[_ArrayOps__ofRef__T]: ...
        _transpose__U = typing.TypeVar('_transpose__U')  # <U>
        def transpose(self, asArray: scala.Function1[_ArrayOps__ofRef__T, typing.Any]) -> typing.List[typing.Any]: ...
        _union__B = typing.TypeVar('_union__B')  # <B>
        _union__That = typing.TypeVar('_union__That')  # <That>
        def union(self, that: scala.collection.GenSeq[_union__B], bf: scala.collection.generic.CanBuildFrom[typing.List[_ArrayOps__ofRef__T], _union__B, _union__That]) -> _union__That: ...
        _unzip__T1 = typing.TypeVar('_unzip__T1')  # <T1>
        _unzip__T2 = typing.TypeVar('_unzip__T2')  # <T2>
        def unzip(self, asPair: scala.Function1[_ArrayOps__ofRef__T, scala.Tuple2[_unzip__T1, _unzip__T2]], ct1: scala.reflect.ClassTag[_unzip__T1], ct2: scala.reflect.ClassTag[_unzip__T2]) -> scala.Tuple2[typing.Any, typing.Any]: ...
        _unzip3__T1 = typing.TypeVar('_unzip3__T1')  # <T1>
        _unzip3__T2 = typing.TypeVar('_unzip3__T2')  # <T2>
        _unzip3__T3 = typing.TypeVar('_unzip3__T3')  # <T3>
        def unzip3(self, asTriple: scala.Function1[_ArrayOps__ofRef__T, scala.Tuple3[_unzip3__T1, _unzip3__T2, _unzip3__T3]], ct1: scala.reflect.ClassTag[_unzip3__T1], ct2: scala.reflect.ClassTag[_unzip3__T2], ct3: scala.reflect.ClassTag[_unzip3__T3]) -> scala.Tuple3[typing.Any, typing.Any, typing.Any]: ...
        def update(self, index: int, elem: _ArrayOps__ofRef__T) -> None: ...
        _updated__B = typing.TypeVar('_updated__B')  # <B>
        _updated__That = typing.TypeVar('_updated__That')  # <That>
        def updated(self, index: int, elem: _updated__B, bf: scala.collection.generic.CanBuildFrom[typing.List[_ArrayOps__ofRef__T], _updated__B, _updated__That]) -> _updated__That: ...
        @typing.overload
        def view(self) -> 'IndexedSeqView'[_ArrayOps__ofRef__T, typing.List[_ArrayOps__ofRef__T]]: ...
        @typing.overload
        def view(self, from_: int, until: int) -> 'IndexedSeqView'[_ArrayOps__ofRef__T, typing.List[_ArrayOps__ofRef__T]]: ...
        def withFilter(self, p: scala.Function1[_ArrayOps__ofRef__T, typing.Any]) -> scala.collection.generic.FilterMonadic[_ArrayOps__ofRef__T, typing.List[_ArrayOps__ofRef__T]]: ...
        _zip__A1 = typing.TypeVar('_zip__A1')  # <A1>
        _zip__B = typing.TypeVar('_zip__B')  # <B>
        _zip__That = typing.TypeVar('_zip__That')  # <That>
        def zip(self, that: scala.collection.GenIterable[_zip__B], bf: scala.collection.generic.CanBuildFrom[typing.List[_ArrayOps__ofRef__T], scala.Tuple2[_zip__A1, _zip__B], _zip__That]) -> _zip__That: ...
        _zipAll__B = typing.TypeVar('_zipAll__B')  # <B>
        _zipAll__A1 = typing.TypeVar('_zipAll__A1')  # <A1>
        _zipAll__That = typing.TypeVar('_zipAll__That')  # <That>
        def zipAll(self, that: scala.collection.GenIterable[_zipAll__B], thisElem: _zipAll__A1, thatElem: _zipAll__B, bf: scala.collection.generic.CanBuildFrom[typing.List[_ArrayOps__ofRef__T], scala.Tuple2[_zipAll__A1, _zipAll__B], _zipAll__That]) -> _zipAll__That: ...
        _zipWithIndex__A1 = typing.TypeVar('_zipWithIndex__A1')  # <A1>
        _zipWithIndex__That = typing.TypeVar('_zipWithIndex__That')  # <That>
        def zipWithIndex(self, bf: scala.collection.generic.CanBuildFrom[typing.List[_ArrayOps__ofRef__T], scala.Tuple2[_zipWithIndex__A1, typing.Any], _zipWithIndex__That]) -> _zipWithIndex__That: ...
    class ofRef$:
        MODULE$: typing.ClassVar['ArrayOps.ofRef.'] = ...
        def __init__(self): ...
        _apply$extension__T = typing.TypeVar('_apply$extension__T')  # <T>
        def apply$extension(self, $this: typing.List[_apply.extension__T], index: int) -> _apply.extension__T: ...
        _equals$extension__T = typing.TypeVar('_equals$extension__T')  # <T>
        def equals$extension(self, $this: typing.List[_equals.extension__T], x$1: typing.Any) -> bool: ...
        _hashCode$extension__T = typing.TypeVar('_hashCode$extension__T')  # <T>
        def hashCode$extension(self, $this: typing.List[_hashCode.extension__T]) -> int: ...
        _length$extension__T = typing.TypeVar('_length$extension__T')  # <T>
        def length$extension(self, $this: typing.List[_length.extension__T]) -> int: ...
        _newBuilder$extension__T = typing.TypeVar('_newBuilder$extension__T')  # <T>
        def newBuilder$extension(self, $this: typing.List[_newBuilder.extension__T]) -> ArrayBuilder.ofRef[_newBuilder.extension__T]: ...
        _thisCollection$extension__T = typing.TypeVar('_thisCollection$extension__T')  # <T>
        def thisCollection$extension(self, $this: typing.List[_thisCollection.extension__T]) -> 'WrappedArray'[_thisCollection.extension__T]: ...
        _toCollection$extension__T = typing.TypeVar('_toCollection$extension__T')  # <T>
        def toCollection$extension(self, $this: typing.List[_toCollection.extension__T], repr: typing.List[_toCollection.extension__T]) -> 'WrappedArray'[_toCollection.extension__T]: ...
        _update$extension__T = typing.TypeVar('_update$extension__T')  # <T>
        def update$extension(self, $this: typing.List[_update.extension__T], index: int, elem: _update.extension__T) -> None: ...
    class ofShort(scala.collection.mutable.ArrayOps[typing.Any]):
        def __init__(self, repr: typing.List[int]): ...
        _$colon$bslash__B = typing.TypeVar('_$colon$bslash__B')  # <B>
        def $colon$bslash(self, z: _.colon.bslash__B, op: scala.Function2[typing.Any, _.colon.bslash__B, _.colon.bslash__B]) -> _.colon.bslash__B: ...
        _$colon$plus_0__B = typing.TypeVar('_$colon$plus_0__B')  # <B>
        _$colon$plus_0__That = typing.TypeVar('_$colon$plus_0__That')  # <That>
        _$colon$plus_1__B = typing.TypeVar('_$colon$plus_1__B')  # <B>
        @typing.overload
        def $colon$plus(self, elem: _.colon.plus_0__B, bf: scala.collection.generic.CanBuildFrom[typing.List[int], _.colon.plus_0__B, _.colon.plus_0__That]) -> _.colon.plus_0__That: ...
        @typing.overload
        def $colon$plus(self, elem: _.colon.plus_1__B, evidence$2: scala.reflect.ClassTag[_.colon.plus_1__B]) -> typing.Any: ...
        _$div$colon__B = typing.TypeVar('_$div$colon__B')  # <B>
        def $div$colon(self, z: _.div.colon__B, op: scala.Function2[_.div.colon__B, typing.Any, _.div.colon__B]) -> _.div.colon__B: ...
        _$plus$colon_0__B = typing.TypeVar('_$plus$colon_0__B')  # <B>
        _$plus$colon_0__That = typing.TypeVar('_$plus$colon_0__That')  # <That>
        _$plus$colon_1__B = typing.TypeVar('_$plus$colon_1__B')  # <B>
        @typing.overload
        def $plus$colon(self, elem: _.plus.colon_0__B, bf: scala.collection.generic.CanBuildFrom[typing.List[int], _.plus.colon_0__B, _.plus.colon_0__That]) -> _.plus.colon_0__That: ...
        @typing.overload
        def $plus$colon(self, elem: _.plus.colon_1__B, evidence$3: scala.reflect.ClassTag[_.plus.colon_1__B]) -> typing.Any: ...
        _$plus$plus__B = typing.TypeVar('_$plus$plus__B')  # <B>
        _$plus$plus__That = typing.TypeVar('_$plus$plus__That')  # <That>
        def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _.plus.plus__B, _.plus.plus__That]) -> _.plus.plus__That: ...
        _$plus$plus$colon_0__B = typing.TypeVar('_$plus$plus$colon_0__B')  # <B>
        _$plus$plus$colon_0__That = typing.TypeVar('_$plus$plus$colon_0__That')  # <That>
        _$plus$plus$colon_1__B = typing.TypeVar('_$plus$plus$colon_1__B')  # <B>
        _$plus$plus$colon_1__That = typing.TypeVar('_$plus$plus$colon_1__That')  # <That>
        @typing.overload
        def $plus$plus$colon(self, that: scala.collection.Traversable[_.plus.plus.colon_0__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _.plus.plus.colon_0__B, _.plus.plus.colon_0__That]) -> _.plus.plus.colon_0__That: ...
        @typing.overload
        def $plus$plus$colon(self, that: scala.collection.TraversableOnce[_.plus.plus.colon_1__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _.plus.plus.colon_1__B, _.plus.plus.colon_1__That]) -> _.plus.plus.colon_1__That: ...
        @typing.overload
        def addString(self, b: StringBuilder) -> StringBuilder: ...
        @typing.overload
        def addString(self, b: StringBuilder, sep: str) -> StringBuilder: ...
        @typing.overload
        def addString(self, b: StringBuilder, start: str, sep: str, end: str) -> StringBuilder: ...
        _aggregate__B = typing.TypeVar('_aggregate__B')  # <B>
        def aggregate(self, z: scala.Function0[_aggregate__B], seqop: scala.Function2[_aggregate__B, typing.Any, _aggregate__B], combop: scala.Function2[_aggregate__B, _aggregate__B, _aggregate__B]) -> _aggregate__B: ...
        def apply(self, index: int) -> int: ...
        def canEqual(self, that: typing.Any) -> bool: ...
        _collect__B = typing.TypeVar('_collect__B')  # <B>
        _collect__That = typing.TypeVar('_collect__That')  # <That>
        def collect(self, pf: scala.PartialFunction[typing.Any, _collect__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _collect__B, _collect__That]) -> _collect__That: ...
        _collectFirst__B = typing.TypeVar('_collectFirst__B')  # <B>
        def collectFirst(self, pf: scala.PartialFunction[typing.Any, _collectFirst__B]) -> scala.Option[_collectFirst__B]: ...
        def combinations(self, n: int) -> scala.collection.Iterator[typing.List[int]]: ...
        _contains__A1 = typing.TypeVar('_contains__A1')  # <A1>
        def contains(self, elem: _contains__A1) -> bool: ...
        _containsSlice__B = typing.TypeVar('_containsSlice__B')  # <B>
        def containsSlice(self, that: scala.collection.GenSeq[_containsSlice__B]) -> bool: ...
        _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
        _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
        _copyToArray_2__U = typing.TypeVar('_copyToArray_2__U')  # <U>
        @typing.overload
        def copyToArray(self, xs: typing.Any) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
        _copyToBuffer__B = typing.TypeVar('_copyToBuffer__B')  # <B>
        def copyToBuffer(self, dest: Buffer[_copyToBuffer__B]) -> None: ...
        _corresponds__B = typing.TypeVar('_corresponds__B')  # <B>
        def corresponds(self, that: scala.collection.GenSeq[_corresponds__B], p: scala.Function2[typing.Any, _corresponds__B, typing.Any]) -> bool: ...
        def count(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        def deep(self) -> scala.collection.IndexedSeq[typing.Any]: ...
        def diff(self, that: scala.collection.GenSeq) -> typing.Any: ...
        def distinct(self) -> typing.Any: ...
        def drop(self, n: int) -> typing.Any: ...
        def dropRight(self, n: int) -> typing.Any: ...
        def dropWhile(self, p: scala.Function1) -> typing.Any: ...
        _endsWith__B = typing.TypeVar('_endsWith__B')  # <B>
        def endsWith(self, that: scala.collection.GenSeq[_endsWith__B]) -> bool: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def exists(self, p: scala.Function1[typing.Any, typing.Any]) -> bool: ...
        def filter(self, p: scala.Function1) -> typing.Any: ...
        def filterImpl(self, p: scala.Function1, isFlipped: bool) -> typing.Any: ...
        def filterNot(self, p: scala.Function1) -> typing.Any: ...
        def find(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.Option[typing.Any]: ...
        _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
        _flatMap__That = typing.TypeVar('_flatMap__That')  # <That>
        def flatMap(self, f: scala.Function1[typing.Any, scala.collection.GenTraversableOnce[_flatMap__B]], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _flatMap__B, _flatMap__That]) -> _flatMap__That: ...
        _flatten__U = typing.TypeVar('_flatten__U')  # <U>
        def flatten(self, asTrav: scala.Function1[typing.Any, scala.collection.Traversable[_flatten__U]], m: scala.reflect.ClassTag[_flatten__U]) -> typing.Any: ...
        _fold__A1 = typing.TypeVar('_fold__A1')  # <A1>
        def fold(self, z: _fold__A1, op: scala.Function2[_fold__A1, _fold__A1, _fold__A1]) -> _fold__A1: ...
        _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
        def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, typing.Any, _foldLeft__B]) -> _foldLeft__B: ...
        _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
        def foldRight(self, z: _foldRight__B, op: scala.Function2[typing.Any, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
        def forall(self, p: scala.Function1[typing.Any, typing.Any]) -> bool: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[typing.Any, _foreach__U]) -> None: ...
        _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
        def groupBy(self, f: scala.Function1[typing.Any, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, typing.List[int]]: ...
        def grouped(self, size: int) -> scala.collection.Iterator[typing.List[int]]: ...
        def hasDefiniteSize(self) -> bool: ...
        def hashCode(self) -> int: ...
        def head(self) -> typing.Any: ...
        def headOption(self) -> scala.Option[typing.Any]: ...
        _indexOf_0__B = typing.TypeVar('_indexOf_0__B')  # <B>
        _indexOf_1__B = typing.TypeVar('_indexOf_1__B')  # <B>
        @typing.overload
        def indexOf(self, elem: _indexOf_0__B) -> int: ...
        @typing.overload
        def indexOf(self, elem: _indexOf_1__B, from_: int) -> int: ...
        _indexOfSlice_0__B = typing.TypeVar('_indexOfSlice_0__B')  # <B>
        _indexOfSlice_1__B = typing.TypeVar('_indexOfSlice_1__B')  # <B>
        @typing.overload
        def indexOfSlice(self, that: scala.collection.GenSeq[_indexOfSlice_0__B]) -> int: ...
        @typing.overload
        def indexOfSlice(self, that: scala.collection.GenSeq[_indexOfSlice_1__B], from_: int) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[typing.Any, typing.Any], from_: int) -> int: ...
        def indices(self) -> scala.collection.immutable.Range: ...
        def init(self) -> typing.Any: ...
        def inits(self) -> scala.collection.Iterator[typing.List[int]]: ...
        def intersect(self, that: scala.collection.GenSeq) -> typing.Any: ...
        def isDefinedAt(self, idx: int) -> bool: ...
        def isEmpty(self) -> bool: ...
        def isTraversableAgain(self) -> bool: ...
        def iterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def last(self) -> typing.Any: ...
        _lastIndexOf_0__B = typing.TypeVar('_lastIndexOf_0__B')  # <B>
        _lastIndexOf_1__B = typing.TypeVar('_lastIndexOf_1__B')  # <B>
        @typing.overload
        def lastIndexOf(self, elem: _lastIndexOf_0__B) -> int: ...
        @typing.overload
        def lastIndexOf(self, elem: _lastIndexOf_1__B, end: int) -> int: ...
        _lastIndexOfSlice_0__B = typing.TypeVar('_lastIndexOfSlice_0__B')  # <B>
        _lastIndexOfSlice_1__B = typing.TypeVar('_lastIndexOfSlice_1__B')  # <B>
        @typing.overload
        def lastIndexOfSlice(self, that: scala.collection.GenSeq[_lastIndexOfSlice_0__B]) -> int: ...
        @typing.overload
        def lastIndexOfSlice(self, that: scala.collection.GenSeq[_lastIndexOfSlice_1__B], end: int) -> int: ...
        @typing.overload
        def lastIndexWhere(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        @typing.overload
        def lastIndexWhere(self, p: scala.Function1[typing.Any, typing.Any], end: int) -> int: ...
        def lastOption(self) -> scala.Option[typing.Any]: ...
        def length(self) -> int: ...
        def lengthCompare(self, len: int) -> int: ...
        _map__B = typing.TypeVar('_map__B')  # <B>
        _map__That = typing.TypeVar('_map__That')  # <That>
        def map(self, f: scala.Function1[typing.Any, _map__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _map__B, _map__That]) -> _map__That: ...
        def max(self, cmp: scala.math.Ordering) -> typing.Any: ...
        def maxBy(self, f: scala.Function1, cmp: scala.math.Ordering) -> typing.Any: ...
        def min(self, cmp: scala.math.Ordering) -> typing.Any: ...
        def minBy(self, f: scala.Function1, cmp: scala.math.Ordering) -> typing.Any: ...
        @typing.overload
        def mkString(self) -> str: ...
        @typing.overload
        def mkString(self, sep: str) -> str: ...
        @typing.overload
        def mkString(self, start: str, sep: str, end: str) -> str: ...
        def newBuilder(self) -> ArrayBuilder.ofShort: ...
        def nonEmpty(self) -> bool: ...
        _padTo__B = typing.TypeVar('_padTo__B')  # <B>
        _padTo__That = typing.TypeVar('_padTo__That')  # <That>
        def padTo(self, len: int, elem: _padTo__B, bf: scala.collection.generic.CanBuildFrom[typing.List[int], _padTo__B, _padTo__That]) -> _padTo__That: ...
        def par(self) -> scala.collection.parallel.mutable.ParArray[typing.Any]: ...
        def parCombiner(self) -> scala.collection.parallel.Combiner[typing.Any, scala.collection.parallel.mutable.ParArray[typing.Any]]: ...
        def partition(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.Tuple2[typing.List[int], typing.List[int]]: ...
        _patch__B = typing.TypeVar('_patch__B')  # <B>
        _patch__That = typing.TypeVar('_patch__That')  # <That>
        def patch(self, from_: int, patch: scala.collection.GenSeq[_patch__B], replaced: int, bf: scala.collection.generic.CanBuildFrom[typing.List[int], _patch__B, _patch__That]) -> _patch__That: ...
        def permutations(self) -> scala.collection.Iterator[typing.List[int]]: ...
        def prefixLength(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
        _product__B = typing.TypeVar('_product__B')  # <B>
        def product(self, num: scala.math.Numeric[_product__B]) -> _product__B: ...
        _reduce__A1 = typing.TypeVar('_reduce__A1')  # <A1>
        def reduce(self, op: scala.Function2[_reduce__A1, _reduce__A1, _reduce__A1]) -> _reduce__A1: ...
        _reduceLeft__B = typing.TypeVar('_reduceLeft__B')  # <B>
        def reduceLeft(self, op: scala.Function2[_reduceLeft__B, typing.Any, _reduceLeft__B]) -> _reduceLeft__B: ...
        _reduceLeftOption__B = typing.TypeVar('_reduceLeftOption__B')  # <B>
        def reduceLeftOption(self, op: scala.Function2[_reduceLeftOption__B, typing.Any, _reduceLeftOption__B]) -> scala.Option[_reduceLeftOption__B]: ...
        _reduceOption__A1 = typing.TypeVar('_reduceOption__A1')  # <A1>
        def reduceOption(self, op: scala.Function2[_reduceOption__A1, _reduceOption__A1, _reduceOption__A1]) -> scala.Option[_reduceOption__A1]: ...
        _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
        def reduceRight(self, op: scala.Function2[typing.Any, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
        _reduceRightOption__B = typing.TypeVar('_reduceRightOption__B')  # <B>
        def reduceRightOption(self, op: scala.Function2[typing.Any, _reduceRightOption__B, _reduceRightOption__B]) -> scala.Option[_reduceRightOption__B]: ...
        def repr(self) -> typing.List[int]: ...
        def reverse(self) -> typing.Any: ...
        def reverseIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        _reverseMap__B = typing.TypeVar('_reverseMap__B')  # <B>
        _reverseMap__That = typing.TypeVar('_reverseMap__That')  # <That>
        def reverseMap(self, f: scala.Function1[typing.Any, _reverseMap__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _reverseMap__B, _reverseMap__That]) -> _reverseMap__That: ...
        def reversed(self) -> scala.collection.immutable.List[typing.Any]: ...
        _sameElements__B = typing.TypeVar('_sameElements__B')  # <B>
        def sameElements(self, that: scala.collection.GenIterable[_sameElements__B]) -> bool: ...
        _scan__B = typing.TypeVar('_scan__B')  # <B>
        _scan__That = typing.TypeVar('_scan__That')  # <That>
        def scan(self, z: _scan__B, op: scala.Function2[_scan__B, _scan__B, _scan__B], cbf: scala.collection.generic.CanBuildFrom[typing.List[int], _scan__B, _scan__That]) -> _scan__That: ...
        _scanLeft__B = typing.TypeVar('_scanLeft__B')  # <B>
        _scanLeft__That = typing.TypeVar('_scanLeft__That')  # <That>
        def scanLeft(self, z: _scanLeft__B, op: scala.Function2[_scanLeft__B, typing.Any, _scanLeft__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _scanLeft__B, _scanLeft__That]) -> _scanLeft__That: ...
        _scanRight__B = typing.TypeVar('_scanRight__B')  # <B>
        _scanRight__That = typing.TypeVar('_scanRight__That')  # <That>
        def scanRight(self, z: _scanRight__B, op: scala.Function2[typing.Any, _scanRight__B, _scanRight__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _scanRight__B, _scanRight__That]) -> _scanRight__That: ...
        def segmentLength(self, p: scala.Function1[typing.Any, typing.Any], from_: int) -> int: ...
        def seq(self) -> IndexedSeq[typing.Any]: ...
        def size(self) -> int: ...
        def sizeHintIfCheap(self) -> int: ...
        def slice(self, from_: int, until: int) -> typing.Any: ...
        def sliceWithKnownBound(self, from_: int, until: int) -> typing.Any: ...
        def sliceWithKnownDelta(self, from_: int, until: int, delta: int) -> typing.Any: ...
        @typing.overload
        def sliding(self, size: int) -> scala.collection.Iterator[typing.List[int]]: ...
        @typing.overload
        def sliding(self, size: int, step: int) -> scala.collection.Iterator[typing.List[int]]: ...
        def sortBy(self, f: scala.Function1, ord: scala.math.Ordering) -> typing.Any: ...
        def sortWith(self, lt: scala.Function2) -> typing.Any: ...
        def sorted(self, ord: scala.math.Ordering) -> typing.Any: ...
        def span(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.Tuple2[typing.List[int], typing.List[int]]: ...
        def splitAt(self, n: int) -> scala.Tuple2[typing.List[int], typing.List[int]]: ...
        _startsWith_0__B = typing.TypeVar('_startsWith_0__B')  # <B>
        _startsWith_1__B = typing.TypeVar('_startsWith_1__B')  # <B>
        @typing.overload
        def startsWith(self, that: scala.collection.GenSeq[_startsWith_0__B]) -> bool: ...
        @typing.overload
        def startsWith(self, that: scala.collection.GenSeq[_startsWith_1__B], offset: int) -> bool: ...
        def stringPrefix(self) -> str: ...
        _sum__B = typing.TypeVar('_sum__B')  # <B>
        def sum(self, num: scala.math.Numeric[_sum__B]) -> _sum__B: ...
        def tail(self) -> typing.Any: ...
        def tails(self) -> scala.collection.Iterator[typing.List[int]]: ...
        def take(self, n: int) -> typing.Any: ...
        def takeRight(self, n: int) -> typing.Any: ...
        def takeWhile(self, p: scala.Function1) -> typing.Any: ...
        def thisCollection(self) -> 'WrappedArray'[typing.Any]: ...
        _to__Col = typing.TypeVar('_to__Col')  # <Col>
        def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., typing.Any, _to__Col]) -> _to__Col: ...
        _toArray__U = typing.TypeVar('_toArray__U')  # <U>
        def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__U]) -> typing.Any: ...
        _toBuffer__A1 = typing.TypeVar('_toBuffer__A1')  # <A1>
        def toBuffer(self) -> Buffer[_toBuffer__A1]: ...
        def toCollection(self, repr: typing.List[int]) -> 'WrappedArray'[typing.Any]: ...
        def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq[typing.Any]: ...
        def toIterable(self) -> scala.collection.Iterable[typing.Any]: ...
        def toIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def toList(self) -> scala.collection.immutable.List[typing.Any]: ...
        _toMap__T = typing.TypeVar('_toMap__T')  # <T>
        _toMap__U = typing.TypeVar('_toMap__U')  # <U>
        def toMap(self, ev: scala.Predef..less.colon.less[typing.Any, scala.Tuple2[_toMap__T, _toMap__U]]) -> scala.collection.immutable.Map[_toMap__T, _toMap__U]: ...
        def toSeq(self) -> scala.collection.Seq[typing.Any]: ...
        _toSet__B = typing.TypeVar('_toSet__B')  # <B>
        def toSet(self) -> scala.collection.immutable.Set[_toSet__B]: ...
        def toStream(self) -> scala.collection.immutable.Stream[typing.Any]: ...
        def toString(self) -> str: ...
        def toTraversable(self) -> scala.collection.Traversable[typing.Any]: ...
        def toVector(self) -> scala.collection.immutable.Vector[typing.Any]: ...
        _transpose__U = typing.TypeVar('_transpose__U')  # <U>
        def transpose(self, asArray: scala.Function1[typing.Any, typing.Any]) -> typing.List[typing.Any]: ...
        _union__B = typing.TypeVar('_union__B')  # <B>
        _union__That = typing.TypeVar('_union__That')  # <That>
        def union(self, that: scala.collection.GenSeq[_union__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], _union__B, _union__That]) -> _union__That: ...
        _unzip__T1 = typing.TypeVar('_unzip__T1')  # <T1>
        _unzip__T2 = typing.TypeVar('_unzip__T2')  # <T2>
        def unzip(self, asPair: scala.Function1[typing.Any, scala.Tuple2[_unzip__T1, _unzip__T2]], ct1: scala.reflect.ClassTag[_unzip__T1], ct2: scala.reflect.ClassTag[_unzip__T2]) -> scala.Tuple2[typing.Any, typing.Any]: ...
        _unzip3__T1 = typing.TypeVar('_unzip3__T1')  # <T1>
        _unzip3__T2 = typing.TypeVar('_unzip3__T2')  # <T2>
        _unzip3__T3 = typing.TypeVar('_unzip3__T3')  # <T3>
        def unzip3(self, asTriple: scala.Function1[typing.Any, scala.Tuple3[_unzip3__T1, _unzip3__T2, _unzip3__T3]], ct1: scala.reflect.ClassTag[_unzip3__T1], ct2: scala.reflect.ClassTag[_unzip3__T2], ct3: scala.reflect.ClassTag[_unzip3__T3]) -> scala.Tuple3[typing.Any, typing.Any, typing.Any]: ...
        def update(self, index: int, elem: int) -> None: ...
        _updated__B = typing.TypeVar('_updated__B')  # <B>
        _updated__That = typing.TypeVar('_updated__That')  # <That>
        def updated(self, index: int, elem: _updated__B, bf: scala.collection.generic.CanBuildFrom[typing.List[int], _updated__B, _updated__That]) -> _updated__That: ...
        @typing.overload
        def view(self) -> 'IndexedSeqView'[typing.Any, typing.List[int]]: ...
        @typing.overload
        def view(self, from_: int, until: int) -> 'IndexedSeqView'[typing.Any, typing.List[int]]: ...
        def withFilter(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.collection.generic.FilterMonadic[typing.Any, typing.List[int]]: ...
        _zip__A1 = typing.TypeVar('_zip__A1')  # <A1>
        _zip__B = typing.TypeVar('_zip__B')  # <B>
        _zip__That = typing.TypeVar('_zip__That')  # <That>
        def zip(self, that: scala.collection.GenIterable[_zip__B], bf: scala.collection.generic.CanBuildFrom[typing.List[int], scala.Tuple2[_zip__A1, _zip__B], _zip__That]) -> _zip__That: ...
        _zipAll__B = typing.TypeVar('_zipAll__B')  # <B>
        _zipAll__A1 = typing.TypeVar('_zipAll__A1')  # <A1>
        _zipAll__That = typing.TypeVar('_zipAll__That')  # <That>
        def zipAll(self, that: scala.collection.GenIterable[_zipAll__B], thisElem: _zipAll__A1, thatElem: _zipAll__B, bf: scala.collection.generic.CanBuildFrom[typing.List[int], scala.Tuple2[_zipAll__A1, _zipAll__B], _zipAll__That]) -> _zipAll__That: ...
        _zipWithIndex__A1 = typing.TypeVar('_zipWithIndex__A1')  # <A1>
        _zipWithIndex__That = typing.TypeVar('_zipWithIndex__That')  # <That>
        def zipWithIndex(self, bf: scala.collection.generic.CanBuildFrom[typing.List[int], scala.Tuple2[_zipWithIndex__A1, typing.Any], _zipWithIndex__That]) -> _zipWithIndex__That: ...
    class ofShort$:
        MODULE$: typing.ClassVar['ArrayOps.ofShort.'] = ...
        def __init__(self): ...
        def apply$extension(self, $this: typing.List[int], index: int) -> int: ...
        def equals$extension(self, $this: typing.List[int], x$1: typing.Any) -> bool: ...
        def hashCode$extension(self, $this: typing.List[int]) -> int: ...
        def length$extension(self, $this: typing.List[int]) -> int: ...
        def newBuilder$extension(self, $this: typing.List[int]) -> ArrayBuilder.ofShort: ...
        def thisCollection$extension(self, $this: typing.List[int]) -> 'WrappedArray'[typing.Any]: ...
        def toCollection$extension(self, $this: typing.List[int], repr: typing.List[int]) -> 'WrappedArray'[typing.Any]: ...
        def update$extension(self, $this: typing.List[int], index: int, elem: int) -> None: ...
    class ofUnit(scala.collection.mutable.ArrayOps[scala.runtime.BoxedUnit]):
        def __init__(self, repr: typing.List[scala.runtime.BoxedUnit]): ...
        _$colon$bslash__B = typing.TypeVar('_$colon$bslash__B')  # <B>
        def $colon$bslash(self, z: _.colon.bslash__B, op: scala.Function2[scala.runtime.BoxedUnit, _.colon.bslash__B, _.colon.bslash__B]) -> _.colon.bslash__B: ...
        _$colon$plus_0__B = typing.TypeVar('_$colon$plus_0__B')  # <B>
        _$colon$plus_0__That = typing.TypeVar('_$colon$plus_0__That')  # <That>
        _$colon$plus_1__B = typing.TypeVar('_$colon$plus_1__B')  # <B>
        @typing.overload
        def $colon$plus(self, elem: _.colon.plus_0__B, bf: scala.collection.generic.CanBuildFrom[typing.List[scala.runtime.BoxedUnit], _.colon.plus_0__B, _.colon.plus_0__That]) -> _.colon.plus_0__That: ...
        @typing.overload
        def $colon$plus(self, elem: _.colon.plus_1__B, evidence$2: scala.reflect.ClassTag[_.colon.plus_1__B]) -> typing.Any: ...
        _$div$colon__B = typing.TypeVar('_$div$colon__B')  # <B>
        def $div$colon(self, z: _.div.colon__B, op: scala.Function2[_.div.colon__B, scala.runtime.BoxedUnit, _.div.colon__B]) -> _.div.colon__B: ...
        _$plus$colon_0__B = typing.TypeVar('_$plus$colon_0__B')  # <B>
        _$plus$colon_0__That = typing.TypeVar('_$plus$colon_0__That')  # <That>
        _$plus$colon_1__B = typing.TypeVar('_$plus$colon_1__B')  # <B>
        @typing.overload
        def $plus$colon(self, elem: _.plus.colon_0__B, bf: scala.collection.generic.CanBuildFrom[typing.List[scala.runtime.BoxedUnit], _.plus.colon_0__B, _.plus.colon_0__That]) -> _.plus.colon_0__That: ...
        @typing.overload
        def $plus$colon(self, elem: _.plus.colon_1__B, evidence$3: scala.reflect.ClassTag[_.plus.colon_1__B]) -> typing.Any: ...
        _$plus$plus__B = typing.TypeVar('_$plus$plus__B')  # <B>
        _$plus$plus__That = typing.TypeVar('_$plus$plus__That')  # <That>
        def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus__B], bf: scala.collection.generic.CanBuildFrom[typing.List[scala.runtime.BoxedUnit], _.plus.plus__B, _.plus.plus__That]) -> _.plus.plus__That: ...
        _$plus$plus$colon_0__B = typing.TypeVar('_$plus$plus$colon_0__B')  # <B>
        _$plus$plus$colon_0__That = typing.TypeVar('_$plus$plus$colon_0__That')  # <That>
        _$plus$plus$colon_1__B = typing.TypeVar('_$plus$plus$colon_1__B')  # <B>
        _$plus$plus$colon_1__That = typing.TypeVar('_$plus$plus$colon_1__That')  # <That>
        @typing.overload
        def $plus$plus$colon(self, that: scala.collection.Traversable[_.plus.plus.colon_0__B], bf: scala.collection.generic.CanBuildFrom[typing.List[scala.runtime.BoxedUnit], _.plus.plus.colon_0__B, _.plus.plus.colon_0__That]) -> _.plus.plus.colon_0__That: ...
        @typing.overload
        def $plus$plus$colon(self, that: scala.collection.TraversableOnce[_.plus.plus.colon_1__B], bf: scala.collection.generic.CanBuildFrom[typing.List[scala.runtime.BoxedUnit], _.plus.plus.colon_1__B, _.plus.plus.colon_1__That]) -> _.plus.plus.colon_1__That: ...
        @typing.overload
        def addString(self, b: StringBuilder) -> StringBuilder: ...
        @typing.overload
        def addString(self, b: StringBuilder, sep: str) -> StringBuilder: ...
        @typing.overload
        def addString(self, b: StringBuilder, start: str, sep: str, end: str) -> StringBuilder: ...
        _aggregate__B = typing.TypeVar('_aggregate__B')  # <B>
        def aggregate(self, z: scala.Function0[_aggregate__B], seqop: scala.Function2[_aggregate__B, scala.runtime.BoxedUnit, _aggregate__B], combop: scala.Function2[_aggregate__B, _aggregate__B, _aggregate__B]) -> _aggregate__B: ...
        def apply(self, index: int) -> None: ...
        def canEqual(self, that: typing.Any) -> bool: ...
        _collect__B = typing.TypeVar('_collect__B')  # <B>
        _collect__That = typing.TypeVar('_collect__That')  # <That>
        def collect(self, pf: scala.PartialFunction[scala.runtime.BoxedUnit, _collect__B], bf: scala.collection.generic.CanBuildFrom[typing.List[scala.runtime.BoxedUnit], _collect__B, _collect__That]) -> _collect__That: ...
        _collectFirst__B = typing.TypeVar('_collectFirst__B')  # <B>
        def collectFirst(self, pf: scala.PartialFunction[scala.runtime.BoxedUnit, _collectFirst__B]) -> scala.Option[_collectFirst__B]: ...
        def combinations(self, n: int) -> scala.collection.Iterator[typing.List[scala.runtime.BoxedUnit]]: ...
        _contains__A1 = typing.TypeVar('_contains__A1')  # <A1>
        def contains(self, elem: _contains__A1) -> bool: ...
        _containsSlice__B = typing.TypeVar('_containsSlice__B')  # <B>
        def containsSlice(self, that: scala.collection.GenSeq[_containsSlice__B]) -> bool: ...
        _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
        _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
        _copyToArray_2__U = typing.TypeVar('_copyToArray_2__U')  # <U>
        @typing.overload
        def copyToArray(self, xs: typing.Any) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
        _copyToBuffer__B = typing.TypeVar('_copyToBuffer__B')  # <B>
        def copyToBuffer(self, dest: Buffer[_copyToBuffer__B]) -> None: ...
        _corresponds__B = typing.TypeVar('_corresponds__B')  # <B>
        def corresponds(self, that: scala.collection.GenSeq[_corresponds__B], p: scala.Function2[scala.runtime.BoxedUnit, _corresponds__B, typing.Any]) -> bool: ...
        def count(self, p: scala.Function1[scala.runtime.BoxedUnit, typing.Any]) -> int: ...
        def deep(self) -> scala.collection.IndexedSeq[typing.Any]: ...
        def diff(self, that: scala.collection.GenSeq) -> typing.Any: ...
        def distinct(self) -> typing.Any: ...
        def drop(self, n: int) -> typing.Any: ...
        def dropRight(self, n: int) -> typing.Any: ...
        def dropWhile(self, p: scala.Function1) -> typing.Any: ...
        _endsWith__B = typing.TypeVar('_endsWith__B')  # <B>
        def endsWith(self, that: scala.collection.GenSeq[_endsWith__B]) -> bool: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def exists(self, p: scala.Function1[scala.runtime.BoxedUnit, typing.Any]) -> bool: ...
        def filter(self, p: scala.Function1) -> typing.Any: ...
        def filterImpl(self, p: scala.Function1, isFlipped: bool) -> typing.Any: ...
        def filterNot(self, p: scala.Function1) -> typing.Any: ...
        def find(self, p: scala.Function1[scala.runtime.BoxedUnit, typing.Any]) -> scala.Option[scala.runtime.BoxedUnit]: ...
        _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
        _flatMap__That = typing.TypeVar('_flatMap__That')  # <That>
        def flatMap(self, f: scala.Function1[scala.runtime.BoxedUnit, scala.collection.GenTraversableOnce[_flatMap__B]], bf: scala.collection.generic.CanBuildFrom[typing.List[scala.runtime.BoxedUnit], _flatMap__B, _flatMap__That]) -> _flatMap__That: ...
        _flatten__U = typing.TypeVar('_flatten__U')  # <U>
        def flatten(self, asTrav: scala.Function1[scala.runtime.BoxedUnit, scala.collection.Traversable[_flatten__U]], m: scala.reflect.ClassTag[_flatten__U]) -> typing.Any: ...
        _fold__A1 = typing.TypeVar('_fold__A1')  # <A1>
        def fold(self, z: _fold__A1, op: scala.Function2[_fold__A1, _fold__A1, _fold__A1]) -> _fold__A1: ...
        _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
        def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, scala.runtime.BoxedUnit, _foldLeft__B]) -> _foldLeft__B: ...
        _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
        def foldRight(self, z: _foldRight__B, op: scala.Function2[scala.runtime.BoxedUnit, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
        def forall(self, p: scala.Function1[scala.runtime.BoxedUnit, typing.Any]) -> bool: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[scala.runtime.BoxedUnit, _foreach__U]) -> None: ...
        _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
        def groupBy(self, f: scala.Function1[scala.runtime.BoxedUnit, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, typing.List[scala.runtime.BoxedUnit]]: ...
        def grouped(self, size: int) -> scala.collection.Iterator[typing.List[scala.runtime.BoxedUnit]]: ...
        def hasDefiniteSize(self) -> bool: ...
        def hashCode(self) -> int: ...
        def head(self) -> typing.Any: ...
        def headOption(self) -> scala.Option[scala.runtime.BoxedUnit]: ...
        _indexOf_0__B = typing.TypeVar('_indexOf_0__B')  # <B>
        _indexOf_1__B = typing.TypeVar('_indexOf_1__B')  # <B>
        @typing.overload
        def indexOf(self, elem: _indexOf_0__B) -> int: ...
        @typing.overload
        def indexOf(self, elem: _indexOf_1__B, from_: int) -> int: ...
        _indexOfSlice_0__B = typing.TypeVar('_indexOfSlice_0__B')  # <B>
        _indexOfSlice_1__B = typing.TypeVar('_indexOfSlice_1__B')  # <B>
        @typing.overload
        def indexOfSlice(self, that: scala.collection.GenSeq[_indexOfSlice_0__B]) -> int: ...
        @typing.overload
        def indexOfSlice(self, that: scala.collection.GenSeq[_indexOfSlice_1__B], from_: int) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[scala.runtime.BoxedUnit, typing.Any]) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[scala.runtime.BoxedUnit, typing.Any], from_: int) -> int: ...
        def indices(self) -> scala.collection.immutable.Range: ...
        def init(self) -> typing.Any: ...
        def inits(self) -> scala.collection.Iterator[typing.List[scala.runtime.BoxedUnit]]: ...
        def intersect(self, that: scala.collection.GenSeq) -> typing.Any: ...
        def isDefinedAt(self, idx: int) -> bool: ...
        def isEmpty(self) -> bool: ...
        def isTraversableAgain(self) -> bool: ...
        def iterator(self) -> scala.collection.Iterator[scala.runtime.BoxedUnit]: ...
        def last(self) -> typing.Any: ...
        _lastIndexOf_0__B = typing.TypeVar('_lastIndexOf_0__B')  # <B>
        _lastIndexOf_1__B = typing.TypeVar('_lastIndexOf_1__B')  # <B>
        @typing.overload
        def lastIndexOf(self, elem: _lastIndexOf_0__B) -> int: ...
        @typing.overload
        def lastIndexOf(self, elem: _lastIndexOf_1__B, end: int) -> int: ...
        _lastIndexOfSlice_0__B = typing.TypeVar('_lastIndexOfSlice_0__B')  # <B>
        _lastIndexOfSlice_1__B = typing.TypeVar('_lastIndexOfSlice_1__B')  # <B>
        @typing.overload
        def lastIndexOfSlice(self, that: scala.collection.GenSeq[_lastIndexOfSlice_0__B]) -> int: ...
        @typing.overload
        def lastIndexOfSlice(self, that: scala.collection.GenSeq[_lastIndexOfSlice_1__B], end: int) -> int: ...
        @typing.overload
        def lastIndexWhere(self, p: scala.Function1[scala.runtime.BoxedUnit, typing.Any]) -> int: ...
        @typing.overload
        def lastIndexWhere(self, p: scala.Function1[scala.runtime.BoxedUnit, typing.Any], end: int) -> int: ...
        def lastOption(self) -> scala.Option[scala.runtime.BoxedUnit]: ...
        def length(self) -> int: ...
        def lengthCompare(self, len: int) -> int: ...
        _map__B = typing.TypeVar('_map__B')  # <B>
        _map__That = typing.TypeVar('_map__That')  # <That>
        def map(self, f: scala.Function1[scala.runtime.BoxedUnit, _map__B], bf: scala.collection.generic.CanBuildFrom[typing.List[scala.runtime.BoxedUnit], _map__B, _map__That]) -> _map__That: ...
        def max(self, cmp: scala.math.Ordering) -> typing.Any: ...
        def maxBy(self, f: scala.Function1, cmp: scala.math.Ordering) -> typing.Any: ...
        def min(self, cmp: scala.math.Ordering) -> typing.Any: ...
        def minBy(self, f: scala.Function1, cmp: scala.math.Ordering) -> typing.Any: ...
        @typing.overload
        def mkString(self) -> str: ...
        @typing.overload
        def mkString(self, sep: str) -> str: ...
        @typing.overload
        def mkString(self, start: str, sep: str, end: str) -> str: ...
        def newBuilder(self) -> ArrayBuilder.ofUnit: ...
        def nonEmpty(self) -> bool: ...
        _padTo__B = typing.TypeVar('_padTo__B')  # <B>
        _padTo__That = typing.TypeVar('_padTo__That')  # <That>
        def padTo(self, len: int, elem: _padTo__B, bf: scala.collection.generic.CanBuildFrom[typing.List[scala.runtime.BoxedUnit], _padTo__B, _padTo__That]) -> _padTo__That: ...
        def par(self) -> scala.collection.parallel.mutable.ParArray[scala.runtime.BoxedUnit]: ...
        def parCombiner(self) -> scala.collection.parallel.Combiner[scala.runtime.BoxedUnit, scala.collection.parallel.mutable.ParArray[scala.runtime.BoxedUnit]]: ...
        def partition(self, p: scala.Function1[scala.runtime.BoxedUnit, typing.Any]) -> scala.Tuple2[typing.List[scala.runtime.BoxedUnit], typing.List[scala.runtime.BoxedUnit]]: ...
        _patch__B = typing.TypeVar('_patch__B')  # <B>
        _patch__That = typing.TypeVar('_patch__That')  # <That>
        def patch(self, from_: int, patch: scala.collection.GenSeq[_patch__B], replaced: int, bf: scala.collection.generic.CanBuildFrom[typing.List[scala.runtime.BoxedUnit], _patch__B, _patch__That]) -> _patch__That: ...
        def permutations(self) -> scala.collection.Iterator[typing.List[scala.runtime.BoxedUnit]]: ...
        def prefixLength(self, p: scala.Function1[scala.runtime.BoxedUnit, typing.Any]) -> int: ...
        _product__B = typing.TypeVar('_product__B')  # <B>
        def product(self, num: scala.math.Numeric[_product__B]) -> _product__B: ...
        _reduce__A1 = typing.TypeVar('_reduce__A1')  # <A1>
        def reduce(self, op: scala.Function2[_reduce__A1, _reduce__A1, _reduce__A1]) -> _reduce__A1: ...
        _reduceLeft__B = typing.TypeVar('_reduceLeft__B')  # <B>
        def reduceLeft(self, op: scala.Function2[_reduceLeft__B, scala.runtime.BoxedUnit, _reduceLeft__B]) -> _reduceLeft__B: ...
        _reduceLeftOption__B = typing.TypeVar('_reduceLeftOption__B')  # <B>
        def reduceLeftOption(self, op: scala.Function2[_reduceLeftOption__B, scala.runtime.BoxedUnit, _reduceLeftOption__B]) -> scala.Option[_reduceLeftOption__B]: ...
        _reduceOption__A1 = typing.TypeVar('_reduceOption__A1')  # <A1>
        def reduceOption(self, op: scala.Function2[_reduceOption__A1, _reduceOption__A1, _reduceOption__A1]) -> scala.Option[_reduceOption__A1]: ...
        _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
        def reduceRight(self, op: scala.Function2[scala.runtime.BoxedUnit, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
        _reduceRightOption__B = typing.TypeVar('_reduceRightOption__B')  # <B>
        def reduceRightOption(self, op: scala.Function2[scala.runtime.BoxedUnit, _reduceRightOption__B, _reduceRightOption__B]) -> scala.Option[_reduceRightOption__B]: ...
        def repr(self) -> typing.List[scala.runtime.BoxedUnit]: ...
        def reverse(self) -> typing.Any: ...
        def reverseIterator(self) -> scala.collection.Iterator[scala.runtime.BoxedUnit]: ...
        _reverseMap__B = typing.TypeVar('_reverseMap__B')  # <B>
        _reverseMap__That = typing.TypeVar('_reverseMap__That')  # <That>
        def reverseMap(self, f: scala.Function1[scala.runtime.BoxedUnit, _reverseMap__B], bf: scala.collection.generic.CanBuildFrom[typing.List[scala.runtime.BoxedUnit], _reverseMap__B, _reverseMap__That]) -> _reverseMap__That: ...
        def reversed(self) -> scala.collection.immutable.List[scala.runtime.BoxedUnit]: ...
        _sameElements__B = typing.TypeVar('_sameElements__B')  # <B>
        def sameElements(self, that: scala.collection.GenIterable[_sameElements__B]) -> bool: ...
        _scan__B = typing.TypeVar('_scan__B')  # <B>
        _scan__That = typing.TypeVar('_scan__That')  # <That>
        def scan(self, z: _scan__B, op: scala.Function2[_scan__B, _scan__B, _scan__B], cbf: scala.collection.generic.CanBuildFrom[typing.List[scala.runtime.BoxedUnit], _scan__B, _scan__That]) -> _scan__That: ...
        _scanLeft__B = typing.TypeVar('_scanLeft__B')  # <B>
        _scanLeft__That = typing.TypeVar('_scanLeft__That')  # <That>
        def scanLeft(self, z: _scanLeft__B, op: scala.Function2[_scanLeft__B, scala.runtime.BoxedUnit, _scanLeft__B], bf: scala.collection.generic.CanBuildFrom[typing.List[scala.runtime.BoxedUnit], _scanLeft__B, _scanLeft__That]) -> _scanLeft__That: ...
        _scanRight__B = typing.TypeVar('_scanRight__B')  # <B>
        _scanRight__That = typing.TypeVar('_scanRight__That')  # <That>
        def scanRight(self, z: _scanRight__B, op: scala.Function2[scala.runtime.BoxedUnit, _scanRight__B, _scanRight__B], bf: scala.collection.generic.CanBuildFrom[typing.List[scala.runtime.BoxedUnit], _scanRight__B, _scanRight__That]) -> _scanRight__That: ...
        def segmentLength(self, p: scala.Function1[scala.runtime.BoxedUnit, typing.Any], from_: int) -> int: ...
        def seq(self) -> IndexedSeq[scala.runtime.BoxedUnit]: ...
        def size(self) -> int: ...
        def sizeHintIfCheap(self) -> int: ...
        def slice(self, from_: int, until: int) -> typing.Any: ...
        def sliceWithKnownBound(self, from_: int, until: int) -> typing.Any: ...
        def sliceWithKnownDelta(self, from_: int, until: int, delta: int) -> typing.Any: ...
        @typing.overload
        def sliding(self, size: int) -> scala.collection.Iterator[typing.List[scala.runtime.BoxedUnit]]: ...
        @typing.overload
        def sliding(self, size: int, step: int) -> scala.collection.Iterator[typing.List[scala.runtime.BoxedUnit]]: ...
        def sortBy(self, f: scala.Function1, ord: scala.math.Ordering) -> typing.Any: ...
        def sortWith(self, lt: scala.Function2) -> typing.Any: ...
        def sorted(self, ord: scala.math.Ordering) -> typing.Any: ...
        def span(self, p: scala.Function1[scala.runtime.BoxedUnit, typing.Any]) -> scala.Tuple2[typing.List[scala.runtime.BoxedUnit], typing.List[scala.runtime.BoxedUnit]]: ...
        def splitAt(self, n: int) -> scala.Tuple2[typing.List[scala.runtime.BoxedUnit], typing.List[scala.runtime.BoxedUnit]]: ...
        _startsWith_0__B = typing.TypeVar('_startsWith_0__B')  # <B>
        _startsWith_1__B = typing.TypeVar('_startsWith_1__B')  # <B>
        @typing.overload
        def startsWith(self, that: scala.collection.GenSeq[_startsWith_0__B]) -> bool: ...
        @typing.overload
        def startsWith(self, that: scala.collection.GenSeq[_startsWith_1__B], offset: int) -> bool: ...
        def stringPrefix(self) -> str: ...
        _sum__B = typing.TypeVar('_sum__B')  # <B>
        def sum(self, num: scala.math.Numeric[_sum__B]) -> _sum__B: ...
        def tail(self) -> typing.Any: ...
        def tails(self) -> scala.collection.Iterator[typing.List[scala.runtime.BoxedUnit]]: ...
        def take(self, n: int) -> typing.Any: ...
        def takeRight(self, n: int) -> typing.Any: ...
        def takeWhile(self, p: scala.Function1) -> typing.Any: ...
        def thisCollection(self) -> 'WrappedArray'[scala.runtime.BoxedUnit]: ...
        _to__Col = typing.TypeVar('_to__Col')  # <Col>
        def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., scala.runtime.BoxedUnit, _to__Col]) -> _to__Col: ...
        _toArray__U = typing.TypeVar('_toArray__U')  # <U>
        def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__U]) -> typing.Any: ...
        _toBuffer__A1 = typing.TypeVar('_toBuffer__A1')  # <A1>
        def toBuffer(self) -> Buffer[_toBuffer__A1]: ...
        def toCollection(self, repr: typing.List[scala.runtime.BoxedUnit]) -> 'WrappedArray'[scala.runtime.BoxedUnit]: ...
        def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq[scala.runtime.BoxedUnit]: ...
        def toIterable(self) -> scala.collection.Iterable[scala.runtime.BoxedUnit]: ...
        def toIterator(self) -> scala.collection.Iterator[scala.runtime.BoxedUnit]: ...
        def toList(self) -> scala.collection.immutable.List[scala.runtime.BoxedUnit]: ...
        _toMap__T = typing.TypeVar('_toMap__T')  # <T>
        _toMap__U = typing.TypeVar('_toMap__U')  # <U>
        def toMap(self, ev: scala.Predef..less.colon.less[scala.runtime.BoxedUnit, scala.Tuple2[_toMap__T, _toMap__U]]) -> scala.collection.immutable.Map[_toMap__T, _toMap__U]: ...
        def toSeq(self) -> scala.collection.Seq[scala.runtime.BoxedUnit]: ...
        _toSet__B = typing.TypeVar('_toSet__B')  # <B>
        def toSet(self) -> scala.collection.immutable.Set[_toSet__B]: ...
        def toStream(self) -> scala.collection.immutable.Stream[scala.runtime.BoxedUnit]: ...
        def toString(self) -> str: ...
        def toTraversable(self) -> scala.collection.Traversable[scala.runtime.BoxedUnit]: ...
        def toVector(self) -> scala.collection.immutable.Vector[scala.runtime.BoxedUnit]: ...
        _transpose__U = typing.TypeVar('_transpose__U')  # <U>
        def transpose(self, asArray: scala.Function1[scala.runtime.BoxedUnit, typing.Any]) -> typing.List[typing.Any]: ...
        _union__B = typing.TypeVar('_union__B')  # <B>
        _union__That = typing.TypeVar('_union__That')  # <That>
        def union(self, that: scala.collection.GenSeq[_union__B], bf: scala.collection.generic.CanBuildFrom[typing.List[scala.runtime.BoxedUnit], _union__B, _union__That]) -> _union__That: ...
        _unzip__T1 = typing.TypeVar('_unzip__T1')  # <T1>
        _unzip__T2 = typing.TypeVar('_unzip__T2')  # <T2>
        def unzip(self, asPair: scala.Function1[scala.runtime.BoxedUnit, scala.Tuple2[_unzip__T1, _unzip__T2]], ct1: scala.reflect.ClassTag[_unzip__T1], ct2: scala.reflect.ClassTag[_unzip__T2]) -> scala.Tuple2[typing.Any, typing.Any]: ...
        _unzip3__T1 = typing.TypeVar('_unzip3__T1')  # <T1>
        _unzip3__T2 = typing.TypeVar('_unzip3__T2')  # <T2>
        _unzip3__T3 = typing.TypeVar('_unzip3__T3')  # <T3>
        def unzip3(self, asTriple: scala.Function1[scala.runtime.BoxedUnit, scala.Tuple3[_unzip3__T1, _unzip3__T2, _unzip3__T3]], ct1: scala.reflect.ClassTag[_unzip3__T1], ct2: scala.reflect.ClassTag[_unzip3__T2], ct3: scala.reflect.ClassTag[_unzip3__T3]) -> scala.Tuple3[typing.Any, typing.Any, typing.Any]: ...
        def update(self, index: int, elem: scala.runtime.BoxedUnit) -> None: ...
        _updated__B = typing.TypeVar('_updated__B')  # <B>
        _updated__That = typing.TypeVar('_updated__That')  # <That>
        def updated(self, index: int, elem: _updated__B, bf: scala.collection.generic.CanBuildFrom[typing.List[scala.runtime.BoxedUnit], _updated__B, _updated__That]) -> _updated__That: ...
        @typing.overload
        def view(self) -> 'IndexedSeqView'[scala.runtime.BoxedUnit, typing.List[scala.runtime.BoxedUnit]]: ...
        @typing.overload
        def view(self, from_: int, until: int) -> 'IndexedSeqView'[scala.runtime.BoxedUnit, typing.List[scala.runtime.BoxedUnit]]: ...
        def withFilter(self, p: scala.Function1[scala.runtime.BoxedUnit, typing.Any]) -> scala.collection.generic.FilterMonadic[scala.runtime.BoxedUnit, typing.List[scala.runtime.BoxedUnit]]: ...
        _zip__A1 = typing.TypeVar('_zip__A1')  # <A1>
        _zip__B = typing.TypeVar('_zip__B')  # <B>
        _zip__That = typing.TypeVar('_zip__That')  # <That>
        def zip(self, that: scala.collection.GenIterable[_zip__B], bf: scala.collection.generic.CanBuildFrom[typing.List[scala.runtime.BoxedUnit], scala.Tuple2[_zip__A1, _zip__B], _zip__That]) -> _zip__That: ...
        _zipAll__B = typing.TypeVar('_zipAll__B')  # <B>
        _zipAll__A1 = typing.TypeVar('_zipAll__A1')  # <A1>
        _zipAll__That = typing.TypeVar('_zipAll__That')  # <That>
        def zipAll(self, that: scala.collection.GenIterable[_zipAll__B], thisElem: _zipAll__A1, thatElem: _zipAll__B, bf: scala.collection.generic.CanBuildFrom[typing.List[scala.runtime.BoxedUnit], scala.Tuple2[_zipAll__A1, _zipAll__B], _zipAll__That]) -> _zipAll__That: ...
        _zipWithIndex__A1 = typing.TypeVar('_zipWithIndex__A1')  # <A1>
        _zipWithIndex__That = typing.TypeVar('_zipWithIndex__That')  # <That>
        def zipWithIndex(self, bf: scala.collection.generic.CanBuildFrom[typing.List[scala.runtime.BoxedUnit], scala.Tuple2[_zipWithIndex__A1, typing.Any], _zipWithIndex__That]) -> _zipWithIndex__That: ...
    class ofUnit$:
        MODULE$: typing.ClassVar['ArrayOps.ofUnit.'] = ...
        def __init__(self): ...
        def apply$extension(self, $this: typing.List[scala.runtime.BoxedUnit], index: int) -> None: ...
        def equals$extension(self, $this: typing.List[scala.runtime.BoxedUnit], x$1: typing.Any) -> bool: ...
        def hashCode$extension(self, $this: typing.List[scala.runtime.BoxedUnit]) -> int: ...
        def length$extension(self, $this: typing.List[scala.runtime.BoxedUnit]) -> int: ...
        def newBuilder$extension(self, $this: typing.List[scala.runtime.BoxedUnit]) -> ArrayBuilder.ofUnit: ...
        def thisCollection$extension(self, $this: typing.List[scala.runtime.BoxedUnit]) -> 'WrappedArray'[scala.runtime.BoxedUnit]: ...
        def toCollection$extension(self, $this: typing.List[scala.runtime.BoxedUnit], repr: typing.List[scala.runtime.BoxedUnit]) -> 'WrappedArray'[scala.runtime.BoxedUnit]: ...
        def update$extension(self, $this: typing.List[scala.runtime.BoxedUnit], index: int, elem: scala.runtime.BoxedUnit) -> None: ...

_DefaultMapModel__A = typing.TypeVar('_DefaultMapModel__A')  # <A>
_DefaultMapModel__B = typing.TypeVar('_DefaultMapModel__B')  # <B>
class DefaultMapModel(scala.collection.mutable.Map[_DefaultMapModel__A, _DefaultMapModel__B], typing.Generic[_DefaultMapModel__A, _DefaultMapModel__B]):
    @staticmethod
    def $init$($this: 'DefaultMapModel') -> None: ...
    @typing.overload
    def $plus$eq(self, elem: _DefaultMapModel__A) -> scala.collection.generic.Growable[_DefaultMapModel__A]: ...
    @typing.overload
    def $plus$eq(self, elem: typing.Any) -> Builder[typing.Any, typing.Any]: ...
    @typing.overload
    def $plus$eq(self, kv: scala.Tuple2[typing.Any, typing.Any]) -> MapLike[typing.Any, typing.Any, MapLike]: ...
    @typing.overload
    def $plus$eq(self, elem1: _DefaultMapModel__A, elem2: _DefaultMapModel__A, elems: scala.collection.Seq[_DefaultMapModel__A]) -> scala.collection.generic.Growable[_DefaultMapModel__A]: ...
    @typing.overload
    def $plus$eq(self, kv: scala.Tuple2[_DefaultMapModel__A, _DefaultMapModel__B]) -> 'DefaultMapModel'[_DefaultMapModel__A, _DefaultMapModel__B]: ...
    def addEntry(self, e: DefaultEntry[_DefaultMapModel__A, _DefaultMapModel__B]) -> None: ...
    def entries(self) -> scala.collection.Iterator[DefaultEntry[_DefaultMapModel__A, _DefaultMapModel__B]]: ...
    def equals(self, that: typing.Any) -> bool: ...
    def findEntry(self, key: _DefaultMapModel__A) -> DefaultEntry[_DefaultMapModel__A, _DefaultMapModel__B]: ...
    def get(self, key: _DefaultMapModel__A) -> scala.Option[_DefaultMapModel__B]: ...
    def hashCode(self) -> int: ...
    def iterator(self) -> scala.collection.Iterator[scala.Tuple2[_DefaultMapModel__A, _DefaultMapModel__B]]: ...
    def put(self, key: _DefaultMapModel__A, value: _DefaultMapModel__B) -> scala.Option[_DefaultMapModel__B]: ...
    def toString(self) -> str: ...

_FlatHashTable__Contents__A = typing.TypeVar('_FlatHashTable__Contents__A')  # <A>
_FlatHashTable__HashUtils__A = typing.TypeVar('_FlatHashTable__HashUtils__A')  # <A>
_FlatHashTable__A = typing.TypeVar('_FlatHashTable__A')  # <A>
class FlatHashTable(scala.collection.mutable.FlatHashTable.HashUtils[_FlatHashTable__A], typing.Generic[_FlatHashTable__A]):
    @staticmethod
    def $init$($this: 'FlatHashTable') -> None: ...
    def _loadFactor(self) -> int: ...
    def _loadFactor_$eq(self, x$1: int) -> None: ...
    def addElem(self, elem: _FlatHashTable__A) -> bool: ...
    def addEntry(self, newEntry: typing.Any) -> bool: ...
    def alwaysInitSizeMap(self) -> bool: ...
    def calcSizeMapSize(self, tableLength: int) -> int: ...
    def capacity(self, expectedSize: int) -> int: ...
    def clearTable(self) -> None: ...
    def containsElem(self, elem: _FlatHashTable__A) -> bool: ...
    @staticmethod
    def defaultLoadFactor() -> int: ...
    def findEntry(self, elem: _FlatHashTable__A) -> scala.Option[_FlatHashTable__A]: ...
    def hashTableContents(self) -> 'FlatHashTable.Contents'[_FlatHashTable__A]: ...
    def index(self, hcode: int) -> int: ...
    def init(self, in_: java.io.ObjectInputStream, f: scala.Function1[_FlatHashTable__A, scala.runtime.BoxedUnit]) -> None: ...
    def initWithContents(self, c: 'FlatHashTable.Contents'[_FlatHashTable__A]) -> None: ...
    def initialSize(self) -> int: ...
    def isSizeMapDefined(self) -> bool: ...
    def iterator(self) -> scala.collection.Iterator[_FlatHashTable__A]: ...
    @staticmethod
    def loadFactorDenum() -> int: ...
    @staticmethod
    def newThreshold(_loadFactor: int, size: int) -> int: ...
    def nnSizeMapAdd(self, h: int) -> None: ...
    def nnSizeMapRemove(self, h: int) -> None: ...
    def nnSizeMapReset(self, tableLength: int) -> None: ...
    def printContents(self) -> None: ...
    def printSizeMap(self) -> None: ...
    def randomSeed(self) -> int: ...
    def removeElem(self, elem: _FlatHashTable__A) -> bool: ...
    @staticmethod
    def seedGenerator() -> java.lang.ThreadLocal[scala.util.Random]: ...
    def seedvalue(self) -> int: ...
    def seedvalue_$eq(self, x$1: int) -> None: ...
    def serializeTo(self, out: java.io.ObjectOutputStream) -> None: ...
    @staticmethod
    def sizeForThreshold(size: int, _loadFactor: int) -> int: ...
    def sizeMapDisable(self) -> None: ...
    def sizeMapInit(self, tableLength: int) -> None: ...
    def sizeMapInitAndRebuild(self) -> None: ...
    def sizemap(self) -> typing.List[int]: ...
    def sizemap_$eq(self, x$1: typing.List[int]) -> None: ...
    def table(self) -> typing.List[typing.Any]: ...
    def tableSize(self) -> int: ...
    def tableSizeSeed(self) -> int: ...
    def tableSize_$eq(self, x$1: int) -> None: ...
    def table_$eq(self, x$1: typing.List[typing.Any]) -> None: ...
    def threshold(self) -> int: ...
    def threshold_$eq(self, x$1: int) -> None: ...
    def totalSizeMapBuckets(self) -> int: ...
    class Contents(typing.Generic[_FlatHashTable__Contents__A]):
        def __init__(self, loadFactor: int, table: typing.List[typing.Any], tableSize: int, threshold: int, seedvalue: int, sizemap: typing.List[int]): ...
        def loadFactor(self) -> int: ...
        def seedvalue(self) -> int: ...
        def sizemap(self) -> typing.List[int]: ...
        def table(self) -> typing.List[typing.Any]: ...
        def tableSize(self) -> int: ...
        def threshold(self) -> int: ...
    class HashUtils(typing.Generic[_FlatHashTable__HashUtils__A]):
        @staticmethod
        def $init$($this: 'FlatHashTable.HashUtils') -> None: ...
        def elemToEntry(self, elem: _FlatHashTable__HashUtils__A) -> typing.Any: ...
        def entryToElem(self, entry: typing.Any) -> _FlatHashTable__HashUtils__A: ...
        def improve(self, hcode: int, seed: int) -> int: ...
        def sizeMapBucketBitSize(self) -> int: ...
        def sizeMapBucketSize(self) -> int: ...
    class NullSentinel$:
        MODULE$: typing.ClassVar['FlatHashTable.NullSentinel.'] = ...
        def __init__(self): ...
        def hashCode(self) -> int: ...
        def toString(self) -> str: ...

_HashMap__A = typing.TypeVar('_HashMap__A')  # <A>
_HashMap__B = typing.TypeVar('_HashMap__B')  # <B>
class HashMap(AbstractMap[_HashMap__A, _HashMap__B], scala.collection.mutable.HashTable[_HashMap__A, DefaultEntry[_HashMap__A, _HashMap__B]], scala.collection.CustomParallelizable[scala.Tuple2[_HashMap__A, _HashMap__B], scala.collection.parallel.mutable.ParHashMap[_HashMap__A, _HashMap__B]], scala.Serializable, typing.Generic[_HashMap__A, _HashMap__B]):
    serialVersionUID: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, contents: 'HashTable.Contents'[_HashMap__A, DefaultEntry[_HashMap__A, _HashMap__B]]): ...
    @typing.overload
    def $minus(self, key: typing.Any) -> 'Map'[typing.Any, typing.Any]: ...
    @typing.overload
    def $minus(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> 'Map'[typing.Any, typing.Any]: ...
    @typing.overload
    def $minus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> scala.collection.generic.Shrinkable[typing.Any]: ...
    @typing.overload
    def $minus$eq(self, key: _HashMap__A) -> 'HashMap'[_HashMap__A, _HashMap__B]: ...
    def $minus$minus(self, xs: scala.collection.GenTraversableOnce[typing.Any]) -> 'Map'[typing.Any, typing.Any]: ...
    _$plus_0__V1 = typing.TypeVar('_$plus_0__V1')  # <V1>
    _$plus_1__V1 = typing.TypeVar('_$plus_1__V1')  # <V1>
    @typing.overload
    def $plus(self, kv: scala.Tuple2[typing.Any, _.plus_0__V1]) -> 'Map'[typing.Any, _.plus_0__V1]: ...
    @typing.overload
    def $plus(self, elem1: scala.Tuple2[typing.Any, _.plus_1__V1], elem2: scala.Tuple2[typing.Any, _.plus_1__V1], elems: scala.collection.Seq[scala.Tuple2[typing.Any, _.plus_1__V1]]) -> 'Map'[typing.Any, _.plus_1__V1]: ...
    @typing.overload
    def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq) -> scala.collection.generic.Growable: ...
    @typing.overload
    def $plus$eq(self, kv: scala.Tuple2[_HashMap__A, _HashMap__B]) -> 'HashMap'[_HashMap__A, _HashMap__B]: ...
    _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
    _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
    _$plus$plus_1__V1 = typing.TypeVar('_$plus$plus_1__V1')  # <V1>
    @typing.overload
    def $plus$plus(self, that: scala.collection.GenTraversableOnce[typing.Any], bf: scala.collection.generic.CanBuildFrom[scala.collection.Traversable[_HashMap__A], typing.Any, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
    @typing.overload
    def $plus$plus(self, xs: scala.collection.GenTraversableOnce[scala.Tuple2[typing.Any, _.plus.plus_1__V1]]) -> 'Map'[typing.Any, _.plus.plus_1__V1]: ...
    def _loadFactor(self) -> int: ...
    def _loadFactor_$eq(self, x$1: int) -> None: ...
    def addEntry(self, e: HashEntry) -> None: ...
    def alwaysInitSizeMap(self) -> bool: ...
    def apply(self, key: _HashMap__A) -> _HashMap__B: ...
    def calcSizeMapSize(self, tableLength: int) -> int: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    _canBuildFrom__B = typing.TypeVar('_canBuildFrom__B')  # <B>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['HashMap'[typing.Any, typing.Any], scala.Tuple2[_canBuildFrom__A, _canBuildFrom__B], 'HashMap'[_canBuildFrom__A, _canBuildFrom__B]]: ...
    def clear(self) -> None: ...
    def clearTable(self) -> None: ...
    def clone(self) -> 'Map'[typing.Any, typing.Any]: ...
    def contains(self, key: _HashMap__A) -> bool: ...
    _createNewEntry__B1 = typing.TypeVar('_createNewEntry__B1')  # <B1>
    def createNewEntry(self, key: _HashMap__A, value: _createNewEntry__B1) -> DefaultEntry[_HashMap__A, _HashMap__B]: ...
    def elemEquals(self, key1: _HashMap__A, key2: _HashMap__A) -> bool: ...
    def elemHashCode(self, key: _HashMap__A) -> int: ...
    def empty(self) -> 'HashMap'[_HashMap__A, _HashMap__B]: ...
    def entriesIterator(self) -> scala.collection.Iterator[DefaultEntry[_HashMap__A, _HashMap__B]]: ...
    def filterKeys(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.collection.Map[typing.Any, typing.Any]: ...
    def filterNot(self, p: scala.Function1[scala.Tuple2[typing.Any, typing.Any], typing.Any]) -> scala.collection.Map[typing.Any, typing.Any]: ...
    def findEntry(self, key: typing.Any) -> HashEntry: ...
    def findOrAddEntry(self, key: typing.Any, value: typing.Any) -> HashEntry: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[scala.Tuple2[_HashMap__A, _HashMap__B], _foreach__U]) -> None: ...
    _foreachEntry__U = typing.TypeVar('_foreachEntry__U')  # <U>
    def foreachEntry(self, f: scala.Function1[DefaultEntry[_HashMap__A, _HashMap__B], _foreachEntry__U]) -> None: ...
    def get(self, key: _HashMap__A) -> scala.Option[_HashMap__B]: ...
    def getOrElseUpdate(self, key: _HashMap__A, defaultValue: scala.Function0[_HashMap__B]) -> _HashMap__B: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[_HashMap__A, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[_HashMap__A]]: ...
    def hashTableContents(self) -> 'HashTable.Contents'[_HashMap__A, DefaultEntry[_HashMap__A, _HashMap__B]]: ...
    def improve(self, hcode: int, seed: int) -> int: ...
    def index(self, hcode: int) -> int: ...
    @typing.overload
    def init(self) -> typing.Any: ...
    @typing.overload
    def init(self, in_: java.io.ObjectInputStream, readEntry: scala.Function0[DefaultEntry[_HashMap__A, _HashMap__B]]) -> None: ...
    def initWithContents(self, c: 'HashTable.Contents'[_HashMap__A, DefaultEntry[_HashMap__A, _HashMap__B]]) -> None: ...
    def initialSize(self) -> int: ...
    def isSizeMapDefined(self) -> bool: ...
    def iterator(self) -> scala.collection.Iterator[scala.Tuple2[_HashMap__A, _HashMap__B]]: ...
    def keySet(self) -> scala.collection.Set[_HashMap__A]: ...
    def keys(self) -> scala.collection.Iterable[typing.Any]: ...
    def keysIterator(self) -> scala.collection.Iterator[_HashMap__A]: ...
    _mapValues__W = typing.TypeVar('_mapValues__W')  # <W>
    def mapValues(self, f: scala.Function1[typing.Any, _mapValues__W]) -> scala.collection.Map[typing.Any, _mapValues__W]: ...
    def nnSizeMapAdd(self, h: int) -> None: ...
    def nnSizeMapRemove(self, h: int) -> None: ...
    def nnSizeMapReset(self, tableLength: int) -> None: ...
    def par(self) -> scala.collection.parallel.mutable.ParHashMap[_HashMap__A, _HashMap__B]: ...
    def parCombiner(self) -> scala.collection.parallel.Combiner[scala.Tuple2[_HashMap__A, _HashMap__B], scala.collection.parallel.mutable.ParHashMap[_HashMap__A, _HashMap__B]]: ...
    def printSizeMap(self) -> None: ...
    def put(self, key: _HashMap__A, value: _HashMap__B) -> scala.Option[_HashMap__B]: ...
    def remove(self, key: _HashMap__A) -> scala.Option[_HashMap__B]: ...
    def removeEntry(self, key: typing.Any) -> HashEntry: ...
    def repr(self) -> typing.Any: ...
    def result(self) -> 'Map'[typing.Any, typing.Any]: ...
    def seedvalue(self) -> int: ...
    def seedvalue_$eq(self, x$1: int) -> None: ...
    def seq(self) -> 'Map'[typing.Any, typing.Any]: ...
    def serializeTo(self, out: java.io.ObjectOutputStream, writeEntry: scala.Function1[DefaultEntry[_HashMap__A, _HashMap__B], scala.runtime.BoxedUnit]) -> None: ...
    def size(self) -> int: ...
    def sizeMapBucketBitSize(self) -> int: ...
    def sizeMapBucketSize(self) -> int: ...
    def sizeMapDisable(self) -> None: ...
    def sizeMapInit(self, tableLength: int) -> None: ...
    def sizeMapInitAndRebuild(self) -> None: ...
    def sizemap(self) -> typing.List[int]: ...
    def sizemap_$eq(self, x$1: typing.List[int]) -> None: ...
    def table(self) -> typing.List[HashEntry[_HashMap__A, DefaultEntry[_HashMap__A, _HashMap__B]]]: ...
    def tableSize(self) -> int: ...
    def tableSizeSeed(self) -> int: ...
    def tableSize_$eq(self, x$1: int) -> None: ...
    def table_$eq(self, x$1: typing.List[HashEntry[_HashMap__A, DefaultEntry[_HashMap__A, _HashMap__B]]]) -> None: ...
    def thisCollection(self) -> scala.collection.Iterable[_HashMap__A]: ...
    def threshold(self) -> int: ...
    def threshold_$eq(self, x$1: int) -> None: ...
    def toCollection(self, repr: typing.Any) -> scala.collection.Iterable: ...
    def toIterable(self) -> scala.collection.Iterable[_HashMap__A]: ...
    def toSeq(self) -> scala.collection.Seq[scala.Tuple2[typing.Any, typing.Any]]: ...
    def toTraversable(self) -> scala.collection.Traversable[_HashMap__A]: ...
    def totalSizeMapBuckets(self) -> int: ...
    def update(self, key: _HashMap__A, value: _HashMap__B) -> None: ...
    _updated__V1 = typing.TypeVar('_updated__V1')  # <V1>
    def updated(self, key: typing.Any, value: _updated__V1) -> 'Map'[typing.Any, _updated__V1]: ...
    def useSizeMap(self, t: bool) -> None: ...
    def values(self) -> scala.collection.Iterable[_HashMap__B]: ...
    def valuesIterator(self) -> scala.collection.Iterator[_HashMap__B]: ...
    @typing.overload
    def view(self) -> scala.collection.IterableView[_HashMap__A, scala.collection.Iterable[_HashMap__A]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> scala.collection.IterableView[_HashMap__A, scala.collection.Iterable[_HashMap__A]]: ...

_HashSet__A = typing.TypeVar('_HashSet__A')  # <A>
class HashSet(AbstractSet[_HashSet__A], FlatHashTable[_HashSet__A], scala.collection.CustomParallelizable[_HashSet__A, scala.collection.parallel.mutable.ParHashSet[_HashSet__A]], scala.Serializable, typing.Generic[_HashSet__A]):
    serialVersionUID: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, contents: FlatHashTable.Contents[_HashSet__A]): ...
    @typing.overload
    def $minus(self, elem: _HashSet__A) -> Set[_HashSet__A]: ...
    @typing.overload
    def $minus(self, elem1: _HashSet__A, elem2: _HashSet__A, elems: scala.collection.Seq[_HashSet__A]) -> Set[_HashSet__A]: ...
    @typing.overload
    def $minus$eq(self, elem1: _HashSet__A, elem2: _HashSet__A, elems: scala.collection.Seq[_HashSet__A]) -> scala.collection.generic.Shrinkable[_HashSet__A]: ...
    @typing.overload
    def $minus$eq(self, elem: _HashSet__A) -> 'HashSet'[_HashSet__A]: ...
    def $minus$minus(self, xs: scala.collection.GenTraversableOnce[_HashSet__A]) -> Set[_HashSet__A]: ...
    @typing.overload
    def $plus(self, elem: _HashSet__A) -> Set[_HashSet__A]: ...
    @typing.overload
    def $plus(self, elem1: _HashSet__A, elem2: _HashSet__A, elems: scala.collection.Seq[_HashSet__A]) -> Set[_HashSet__A]: ...
    @typing.overload
    def $plus$eq(self, elem1: _HashSet__A, elem2: _HashSet__A, elems: scala.collection.Seq[_HashSet__A]) -> scala.collection.generic.Growable[_HashSet__A]: ...
    @typing.overload
    def $plus$eq(self, elem: _HashSet__A) -> 'HashSet'[_HashSet__A]: ...
    _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
    _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
    @typing.overload
    def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus_0__B], bf: scala.collection.generic.CanBuildFrom[scala.collection.Traversable[_HashSet__A], _.plus.plus_0__B, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
    @typing.overload
    def $plus$plus(self, xs: scala.collection.GenTraversableOnce[_HashSet__A]) -> Set[_HashSet__A]: ...
    def _loadFactor(self) -> int: ...
    def _loadFactor_$eq(self, x$1: int) -> None: ...
    def add(self, elem: _HashSet__A) -> bool: ...
    def addElem(self, elem: _HashSet__A) -> bool: ...
    def addEntry(self, newEntry: typing.Any) -> bool: ...
    def alwaysInitSizeMap(self) -> bool: ...
    def apply(self, elem: _HashSet__A) -> bool: ...
    def calcSizeMapSize(self, tableLength: int) -> int: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['HashSet'[typing.Any], _canBuildFrom__A, 'HashSet'[_canBuildFrom__A]]: ...
    def capacity(self, expectedSize: int) -> int: ...
    def clear(self) -> None: ...
    def clearTable(self) -> None: ...
    def clone(self) -> 'HashSet'[_HashSet__A]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['HashSet']: ...
    def contains(self, elem: _HashSet__A) -> bool: ...
    def containsElem(self, elem: _HashSet__A) -> bool: ...
    def diff(self, that: scala.collection.GenSet) -> scala.collection.Set: ...
    def elemToEntry(self, elem: _HashSet__A) -> typing.Any: ...
    def empty(self) -> scala.collection.GenSet: ...
    def entryToElem(self, entry: typing.Any) -> _HashSet__A: ...
    def findEntry(self, elem: _HashSet__A) -> scala.Option[_HashSet__A]: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_HashSet__A, _foreach__U]) -> None: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[_HashSet__A, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[_HashSet__A]]: ...
    def hashTableContents(self) -> FlatHashTable.Contents[_HashSet__A]: ...
    def improve(self, hcode: int, seed: int) -> int: ...
    def index(self, hcode: int) -> int: ...
    @typing.overload
    def init(self) -> typing.Any: ...
    @typing.overload
    def init(self, in_: java.io.ObjectInputStream, f: scala.Function1[_HashSet__A, scala.runtime.BoxedUnit]) -> None: ...
    def initWithContents(self, c: FlatHashTable.Contents[_HashSet__A]) -> None: ...
    def initialSize(self) -> int: ...
    def isSizeMapDefined(self) -> bool: ...
    def iterator(self) -> scala.collection.Iterator[_HashSet__A]: ...
    def nnSizeMapAdd(self, h: int) -> None: ...
    def nnSizeMapRemove(self, h: int) -> None: ...
    def nnSizeMapReset(self, tableLength: int) -> None: ...
    def par(self) -> scala.collection.parallel.mutable.ParHashSet[_HashSet__A]: ...
    def parCombiner(self) -> scala.collection.parallel.Combiner[_HashSet__A, scala.collection.parallel.mutable.ParHashSet[_HashSet__A]]: ...
    def printContents(self) -> None: ...
    def printSizeMap(self) -> None: ...
    def randomSeed(self) -> int: ...
    def remove(self, elem: _HashSet__A) -> bool: ...
    def removeElem(self, elem: _HashSet__A) -> bool: ...
    def repr(self) -> typing.Any: ...
    def result(self) -> Set[_HashSet__A]: ...
    def seedvalue(self) -> int: ...
    def seedvalue_$eq(self, x$1: int) -> None: ...
    def seq(self) -> Set[_HashSet__A]: ...
    def serializeTo(self, out: java.io.ObjectOutputStream) -> None: ...
    _setCanBuildFrom__A = typing.TypeVar('_setCanBuildFrom__A')  # <A>
    @staticmethod
    def setCanBuildFrom() -> scala.collection.generic.CanBuildFrom['HashSet'[typing.Any], _setCanBuildFrom__A, 'HashSet'[_setCanBuildFrom__A]]: ...
    def size(self) -> int: ...
    def sizeMapBucketBitSize(self) -> int: ...
    def sizeMapBucketSize(self) -> int: ...
    def sizeMapDisable(self) -> None: ...
    def sizeMapInit(self, tableLength: int) -> None: ...
    def sizeMapInitAndRebuild(self) -> None: ...
    def sizemap(self) -> typing.List[int]: ...
    def sizemap_$eq(self, x$1: typing.List[int]) -> None: ...
    def table(self) -> typing.List[typing.Any]: ...
    def tableSize(self) -> int: ...
    def tableSizeSeed(self) -> int: ...
    def tableSize_$eq(self, x$1: int) -> None: ...
    def table_$eq(self, x$1: typing.List[typing.Any]) -> None: ...
    def thisCollection(self) -> scala.collection.Iterable[_HashSet__A]: ...
    def threshold(self) -> int: ...
    def threshold_$eq(self, x$1: int) -> None: ...
    def toCollection(self, repr: typing.Any) -> scala.collection.Iterable: ...
    def toIterable(self) -> scala.collection.Iterable[_HashSet__A]: ...
    def toSeq(self) -> scala.collection.Seq[_HashSet__A]: ...
    def toTraversable(self) -> scala.collection.Traversable[_HashSet__A]: ...
    def totalSizeMapBuckets(self) -> int: ...
    def union(self, that: scala.collection.GenSet) -> scala.collection.Set: ...
    def useSizeMap(self, t: bool) -> None: ...
    @typing.overload
    def view(self) -> scala.collection.IterableView[_HashSet__A, scala.collection.Iterable[_HashSet__A]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> scala.collection.IterableView[_HashSet__A, scala.collection.Iterable[_HashSet__A]]: ...

_HashTable__Contents__A = typing.TypeVar('_HashTable__Contents__A')  # <A>
_HashTable__Contents__Entry = typing.TypeVar('_HashTable__Contents__Entry', bound=HashEntry)  # <Entry>
_HashTable__HashUtils__KeyType = typing.TypeVar('_HashTable__HashUtils__KeyType')  # <KeyType>
_HashTable__A = typing.TypeVar('_HashTable__A')  # <A>
_HashTable__Entry = typing.TypeVar('_HashTable__Entry', bound=HashEntry)  # <Entry>
class HashTable(scala.collection.mutable.HashTable.HashUtils[_HashTable__A], typing.Generic[_HashTable__A, _HashTable__Entry]):
    @staticmethod
    def $init$($this: 'HashTable') -> None: ...
    def _loadFactor(self) -> int: ...
    def _loadFactor_$eq(self, x$1: int) -> None: ...
    def addEntry(self, e: _HashTable__Entry) -> None: ...
    def alwaysInitSizeMap(self) -> bool: ...
    def calcSizeMapSize(self, tableLength: int) -> int: ...
    def clearTable(self) -> None: ...
    _createNewEntry__B = typing.TypeVar('_createNewEntry__B')  # <B>
    def createNewEntry(self, key: _HashTable__A, value: _createNewEntry__B) -> _HashTable__Entry: ...
    def elemEquals(self, key1: _HashTable__A, key2: _HashTable__A) -> bool: ...
    def entriesIterator(self) -> scala.collection.Iterator[_HashTable__Entry]: ...
    def findEntry(self, key: _HashTable__A) -> _HashTable__Entry: ...
    _findOrAddEntry__B = typing.TypeVar('_findOrAddEntry__B')  # <B>
    def findOrAddEntry(self, key: _HashTable__A, value: _findOrAddEntry__B) -> _HashTable__Entry: ...
    _foreachEntry__U = typing.TypeVar('_foreachEntry__U')  # <U>
    def foreachEntry(self, f: scala.Function1[_HashTable__Entry, _foreachEntry__U]) -> None: ...
    def hashTableContents(self) -> 'HashTable.Contents'[_HashTable__A, _HashTable__Entry]: ...
    def index(self, hcode: int) -> int: ...
    def init(self, in_: java.io.ObjectInputStream, readEntry: scala.Function0[_HashTable__Entry]) -> None: ...
    def initWithContents(self, c: 'HashTable.Contents'[_HashTable__A, _HashTable__Entry]) -> None: ...
    def initialSize(self) -> int: ...
    def isSizeMapDefined(self) -> bool: ...
    def nnSizeMapAdd(self, h: int) -> None: ...
    def nnSizeMapRemove(self, h: int) -> None: ...
    def nnSizeMapReset(self, tableLength: int) -> None: ...
    def printSizeMap(self) -> None: ...
    def removeEntry(self, key: _HashTable__A) -> _HashTable__Entry: ...
    def scala$collection$mutable$HashTable$$lastPopulatedIndex(self) -> int: ...
    def seedvalue(self) -> int: ...
    def seedvalue_$eq(self, x$1: int) -> None: ...
    def serializeTo(self, out: java.io.ObjectOutputStream, writeEntry: scala.Function1[_HashTable__Entry, scala.runtime.BoxedUnit]) -> None: ...
    def sizeMapDisable(self) -> None: ...
    def sizeMapInit(self, tableLength: int) -> None: ...
    def sizeMapInitAndRebuild(self) -> None: ...
    def sizemap(self) -> typing.List[int]: ...
    def sizemap_$eq(self, x$1: typing.List[int]) -> None: ...
    def table(self) -> typing.List[HashEntry[_HashTable__A, _HashTable__Entry]]: ...
    def tableSize(self) -> int: ...
    def tableSizeSeed(self) -> int: ...
    def tableSize_$eq(self, x$1: int) -> None: ...
    def table_$eq(self, x$1: typing.List[HashEntry[_HashTable__A, _HashTable__Entry]]) -> None: ...
    def threshold(self) -> int: ...
    def threshold_$eq(self, x$1: int) -> None: ...
    def totalSizeMapBuckets(self) -> int: ...
    class Contents(typing.Generic[_HashTable__Contents__A, _HashTable__Contents__Entry]):
        def __init__(self, loadFactor: int, table: typing.List[HashEntry[_HashTable__Contents__A, _HashTable__Contents__Entry]], tableSize: int, threshold: int, seedvalue: int, sizemap: typing.List[int]): ...
        def debugInformation(self) -> str: ...
        def loadFactor(self) -> int: ...
        def seedvalue(self) -> int: ...
        def sizemap(self) -> typing.List[int]: ...
        def table(self) -> typing.List[HashEntry[_HashTable__Contents__A, _HashTable__Contents__Entry]]: ...
        def tableSize(self) -> int: ...
        def threshold(self) -> int: ...
    class HashUtils(typing.Generic[_HashTable__HashUtils__KeyType]):
        @staticmethod
        def $init$($this: 'HashTable.HashUtils') -> None: ...
        def elemHashCode(self, key: _HashTable__HashUtils__KeyType) -> int: ...
        def improve(self, hcode: int, seed: int) -> int: ...
        def sizeMapBucketBitSize(self) -> int: ...
        def sizeMapBucketSize(self) -> int: ...

_ImmutableMapAdaptor__A = typing.TypeVar('_ImmutableMapAdaptor__A')  # <A>
_ImmutableMapAdaptor__B = typing.TypeVar('_ImmutableMapAdaptor__B')  # <B>
class ImmutableMapAdaptor(AbstractMap[_ImmutableMapAdaptor__A, _ImmutableMapAdaptor__B], scala.Serializable, typing.Generic[_ImmutableMapAdaptor__A, _ImmutableMapAdaptor__B]):
    def __init__(self, imap: scala.collection.immutable.Map[_ImmutableMapAdaptor__A, _ImmutableMapAdaptor__B]): ...
    @typing.overload
    def $minus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> scala.collection.generic.Shrinkable[typing.Any]: ...
    @typing.overload
    def $minus$eq(self, key: _ImmutableMapAdaptor__A) -> 'ImmutableMapAdaptor'[_ImmutableMapAdaptor__A, _ImmutableMapAdaptor__B]: ...
    @typing.overload
    def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq) -> scala.collection.generic.Growable: ...
    @typing.overload
    def $plus$eq(self, kv: scala.Tuple2[_ImmutableMapAdaptor__A, _ImmutableMapAdaptor__B]) -> 'ImmutableMapAdaptor'[_ImmutableMapAdaptor__A, _ImmutableMapAdaptor__B]: ...
    def apply(self, key: _ImmutableMapAdaptor__A) -> _ImmutableMapAdaptor__B: ...
    def clear(self) -> None: ...
    def contains(self, key: _ImmutableMapAdaptor__A) -> bool: ...
    def get(self, key: _ImmutableMapAdaptor__A) -> scala.Option[_ImmutableMapAdaptor__B]: ...
    def imap(self) -> scala.collection.immutable.Map[_ImmutableMapAdaptor__A, _ImmutableMapAdaptor__B]: ...
    def imap_$eq(self, x$1: scala.collection.immutable.Map[_ImmutableMapAdaptor__A, _ImmutableMapAdaptor__B]) -> None: ...
    def isDefinedAt(self, key: _ImmutableMapAdaptor__A) -> bool: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> scala.collection.Iterator[scala.Tuple2[_ImmutableMapAdaptor__A, _ImmutableMapAdaptor__B]]: ...
    def keySet(self) -> scala.collection.Set[_ImmutableMapAdaptor__A]: ...
    def keys(self) -> scala.collection.Iterable[_ImmutableMapAdaptor__A]: ...
    def keysIterator(self) -> scala.collection.Iterator[_ImmutableMapAdaptor__A]: ...
    def retain(self, p: scala.Function2[_ImmutableMapAdaptor__A, _ImmutableMapAdaptor__B, typing.Any]) -> 'ImmutableMapAdaptor'[_ImmutableMapAdaptor__A, _ImmutableMapAdaptor__B]: ...
    def size(self) -> int: ...
    def toList(self) -> scala.collection.immutable.List[scala.Tuple2[_ImmutableMapAdaptor__A, _ImmutableMapAdaptor__B]]: ...
    def toString(self) -> str: ...
    def transform(self, f: scala.Function2[_ImmutableMapAdaptor__A, _ImmutableMapAdaptor__B, _ImmutableMapAdaptor__B]) -> 'ImmutableMapAdaptor'[_ImmutableMapAdaptor__A, _ImmutableMapAdaptor__B]: ...
    def update(self, key: _ImmutableMapAdaptor__A, value: _ImmutableMapAdaptor__B) -> None: ...
    def values(self) -> scala.collection.Iterable[_ImmutableMapAdaptor__B]: ...
    def valuesIterator(self) -> scala.collection.Iterator[_ImmutableMapAdaptor__B]: ...

_LinkedHashMap__MappedValues__C = typing.TypeVar('_LinkedHashMap__MappedValues__C')  # <C>
_LinkedHashMap__A = typing.TypeVar('_LinkedHashMap__A')  # <A>
_LinkedHashMap__B = typing.TypeVar('_LinkedHashMap__B')  # <B>
class LinkedHashMap(AbstractMap[_LinkedHashMap__A, _LinkedHashMap__B], HashTable[_LinkedHashMap__A, LinkedEntry[_LinkedHashMap__A, _LinkedHashMap__B]], scala.Serializable, typing.Generic[_LinkedHashMap__A, _LinkedHashMap__B]):
    serialVersionUID: typing.ClassVar[int] = ...
    def __init__(self): ...
    @typing.overload
    def $minus(self, key: typing.Any) -> 'Map'[typing.Any, typing.Any]: ...
    @typing.overload
    def $minus(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> 'Map'[typing.Any, typing.Any]: ...
    @typing.overload
    def $minus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> scala.collection.generic.Shrinkable[typing.Any]: ...
    @typing.overload
    def $minus$eq(self, key: _LinkedHashMap__A) -> 'LinkedHashMap'[_LinkedHashMap__A, _LinkedHashMap__B]: ...
    def $minus$minus(self, xs: scala.collection.GenTraversableOnce[typing.Any]) -> 'Map'[typing.Any, typing.Any]: ...
    _$plus_0__V1 = typing.TypeVar('_$plus_0__V1')  # <V1>
    _$plus_1__V1 = typing.TypeVar('_$plus_1__V1')  # <V1>
    @typing.overload
    def $plus(self, kv: scala.Tuple2[typing.Any, _.plus_0__V1]) -> 'Map'[typing.Any, _.plus_0__V1]: ...
    @typing.overload
    def $plus(self, elem1: scala.Tuple2[typing.Any, _.plus_1__V1], elem2: scala.Tuple2[typing.Any, _.plus_1__V1], elems: scala.collection.Seq[scala.Tuple2[typing.Any, _.plus_1__V1]]) -> 'Map'[typing.Any, _.plus_1__V1]: ...
    @typing.overload
    def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq) -> scala.collection.generic.Growable: ...
    @typing.overload
    def $plus$eq(self, kv: scala.Tuple2[_LinkedHashMap__A, _LinkedHashMap__B]) -> 'LinkedHashMap'[_LinkedHashMap__A, _LinkedHashMap__B]: ...
    _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
    _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
    _$plus$plus_1__V1 = typing.TypeVar('_$plus$plus_1__V1')  # <V1>
    @typing.overload
    def $plus$plus(self, that: scala.collection.GenTraversableOnce[typing.Any], bf: scala.collection.generic.CanBuildFrom[scala.collection.Traversable[_LinkedHashMap__A], typing.Any, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
    @typing.overload
    def $plus$plus(self, xs: scala.collection.GenTraversableOnce[scala.Tuple2[typing.Any, _.plus.plus_1__V1]]) -> 'Map'[typing.Any, _.plus.plus_1__V1]: ...
    def _loadFactor(self) -> int: ...
    def _loadFactor_$eq(self, x$1: int) -> None: ...
    def addEntry(self, e: HashEntry) -> None: ...
    def alwaysInitSizeMap(self) -> bool: ...
    def calcSizeMapSize(self, tableLength: int) -> int: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    _canBuildFrom__B = typing.TypeVar('_canBuildFrom__B')  # <B>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['LinkedHashMap'[typing.Any, typing.Any], scala.Tuple2[_canBuildFrom__A, _canBuildFrom__B], 'LinkedHashMap'[_canBuildFrom__A, _canBuildFrom__B]]: ...
    def clear(self) -> None: ...
    def clearTable(self) -> None: ...
    def clone(self) -> 'Map'[typing.Any, typing.Any]: ...
    _createNewEntry__B1 = typing.TypeVar('_createNewEntry__B1')  # <B1>
    def createNewEntry(self, key: _LinkedHashMap__A, value: _createNewEntry__B1) -> LinkedEntry[_LinkedHashMap__A, _LinkedHashMap__B]: ...
    def elemEquals(self, key1: _LinkedHashMap__A, key2: _LinkedHashMap__A) -> bool: ...
    def elemHashCode(self, key: _LinkedHashMap__A) -> int: ...
    def empty(self) -> 'LinkedHashMap'[_LinkedHashMap__A, _LinkedHashMap__B]: ...
    def entriesIterator(self) -> scala.collection.Iterator[LinkedEntry[_LinkedHashMap__A, _LinkedHashMap__B]]: ...
    def filterKeys(self, p: scala.Function1[_LinkedHashMap__A, typing.Any]) -> scala.collection.Map[_LinkedHashMap__A, _LinkedHashMap__B]: ...
    def filterNot(self, p: scala.Function1[scala.Tuple2[typing.Any, typing.Any], typing.Any]) -> scala.collection.Map[typing.Any, typing.Any]: ...
    def findEntry(self, key: typing.Any) -> HashEntry: ...
    def findOrAddEntry(self, key: typing.Any, value: typing.Any) -> HashEntry: ...
    def firstEntry(self) -> LinkedEntry[_LinkedHashMap__A, _LinkedHashMap__B]: ...
    def firstEntry_$eq(self, x$1: LinkedEntry[_LinkedHashMap__A, _LinkedHashMap__B]) -> None: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[scala.Tuple2[_LinkedHashMap__A, _LinkedHashMap__B], _foreach__U]) -> None: ...
    _foreachEntry__U = typing.TypeVar('_foreachEntry__U')  # <U>
    def foreachEntry(self, f: scala.Function1[LinkedEntry[_LinkedHashMap__A, _LinkedHashMap__B], _foreachEntry__U]) -> None: ...
    def get(self, key: _LinkedHashMap__A) -> scala.Option[_LinkedHashMap__B]: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[_LinkedHashMap__A, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[_LinkedHashMap__A]]: ...
    def hashTableContents(self) -> HashTable.Contents[_LinkedHashMap__A, LinkedEntry[_LinkedHashMap__A, _LinkedHashMap__B]]: ...
    def improve(self, hcode: int, seed: int) -> int: ...
    def index(self, hcode: int) -> int: ...
    @typing.overload
    def init(self) -> typing.Any: ...
    @typing.overload
    def init(self, in_: java.io.ObjectInputStream, readEntry: scala.Function0[LinkedEntry[_LinkedHashMap__A, _LinkedHashMap__B]]) -> None: ...
    def initWithContents(self, c: HashTable.Contents[_LinkedHashMap__A, LinkedEntry[_LinkedHashMap__A, _LinkedHashMap__B]]) -> None: ...
    def initialSize(self) -> int: ...
    def isSizeMapDefined(self) -> bool: ...
    def iterator(self) -> scala.collection.Iterator[scala.Tuple2[_LinkedHashMap__A, _LinkedHashMap__B]]: ...
    def keySet(self) -> scala.collection.Set[_LinkedHashMap__A]: ...
    def keys(self) -> scala.collection.Iterable[typing.Any]: ...
    def keysIterator(self) -> scala.collection.Iterator[_LinkedHashMap__A]: ...
    def lastEntry(self) -> LinkedEntry[_LinkedHashMap__A, _LinkedHashMap__B]: ...
    def lastEntry_$eq(self, x$1: LinkedEntry[_LinkedHashMap__A, _LinkedHashMap__B]) -> None: ...
    _mapValues__C = typing.TypeVar('_mapValues__C')  # <C>
    def mapValues(self, f: scala.Function1[_LinkedHashMap__B, _mapValues__C]) -> scala.collection.Map[_LinkedHashMap__A, _mapValues__C]: ...
    def nnSizeMapAdd(self, h: int) -> None: ...
    def nnSizeMapRemove(self, h: int) -> None: ...
    def nnSizeMapReset(self, tableLength: int) -> None: ...
    def printSizeMap(self) -> None: ...
    def put(self, key: _LinkedHashMap__A, value: _LinkedHashMap__B) -> scala.Option[_LinkedHashMap__B]: ...
    def remove(self, key: _LinkedHashMap__A) -> scala.Option[_LinkedHashMap__B]: ...
    def removeEntry(self, key: typing.Any) -> HashEntry: ...
    def repr(self) -> typing.Any: ...
    def result(self) -> 'Map'[typing.Any, typing.Any]: ...
    def seedvalue(self) -> int: ...
    def seedvalue_$eq(self, x$1: int) -> None: ...
    def seq(self) -> 'Map'[typing.Any, typing.Any]: ...
    def serializeTo(self, out: java.io.ObjectOutputStream, writeEntry: scala.Function1[LinkedEntry[_LinkedHashMap__A, _LinkedHashMap__B], scala.runtime.BoxedUnit]) -> None: ...
    def size(self) -> int: ...
    def sizeMapBucketBitSize(self) -> int: ...
    def sizeMapBucketSize(self) -> int: ...
    def sizeMapDisable(self) -> None: ...
    def sizeMapInit(self, tableLength: int) -> None: ...
    def sizeMapInitAndRebuild(self) -> None: ...
    def sizemap(self) -> typing.List[int]: ...
    def sizemap_$eq(self, x$1: typing.List[int]) -> None: ...
    def table(self) -> typing.List[HashEntry[_LinkedHashMap__A, LinkedEntry[_LinkedHashMap__A, _LinkedHashMap__B]]]: ...
    def tableSize(self) -> int: ...
    def tableSizeSeed(self) -> int: ...
    def tableSize_$eq(self, x$1: int) -> None: ...
    def table_$eq(self, x$1: typing.List[HashEntry[_LinkedHashMap__A, LinkedEntry[_LinkedHashMap__A, _LinkedHashMap__B]]]) -> None: ...
    def thisCollection(self) -> scala.collection.Iterable[_LinkedHashMap__A]: ...
    def threshold(self) -> int: ...
    def threshold_$eq(self, x$1: int) -> None: ...
    def toCollection(self, repr: typing.Any) -> scala.collection.Iterable: ...
    def toIterable(self) -> scala.collection.Iterable[_LinkedHashMap__A]: ...
    def toSeq(self) -> scala.collection.Seq[scala.Tuple2[typing.Any, typing.Any]]: ...
    def toTraversable(self) -> scala.collection.Traversable[_LinkedHashMap__A]: ...
    def totalSizeMapBuckets(self) -> int: ...
    _updated__V1 = typing.TypeVar('_updated__V1')  # <V1>
    def updated(self, key: typing.Any, value: _updated__V1) -> 'Map'[typing.Any, _updated__V1]: ...
    def values(self) -> scala.collection.Iterable[typing.Any]: ...
    def valuesIterator(self) -> scala.collection.Iterator[_LinkedHashMap__B]: ...
    @typing.overload
    def view(self) -> scala.collection.IterableView[_LinkedHashMap__A, scala.collection.Iterable[_LinkedHashMap__A]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> scala.collection.IterableView[_LinkedHashMap__A, scala.collection.Iterable[_LinkedHashMap__A]]: ...
    class DefaultKeySet(scala.collection.MapLike.DefaultKeySet):
        def __init__(self, $outer: 'LinkedHashMap'): ...
        def empty(self) -> 'LinkedHashSet'[_LinkedHashMap__A]: ...
    class FilteredKeys(scala.collection.MapLike.FilteredKeys):
        def __init__(self, $outer: 'LinkedHashMap', p: scala.Function1[_LinkedHashMap__A, typing.Any]): ...
        def empty(self) -> 'LinkedHashMap'[_LinkedHashMap__A, scala.runtime.Nothing.]: ...
    class MappedValues(scala.collection.MapLike.MappedValues[_LinkedHashMap__MappedValues__C], typing.Generic[_LinkedHashMap__MappedValues__C]):
        def __init__(self, $outer: 'LinkedHashMap', f: scala.Function1[_LinkedHashMap__B, _LinkedHashMap__MappedValues__C]): ...
        def empty(self) -> 'LinkedHashMap'[_LinkedHashMap__A, scala.runtime.Nothing.]: ...

_LinkedHashSet__Entry__A = typing.TypeVar('_LinkedHashSet__Entry__A')  # <A>
_LinkedHashSet__A = typing.TypeVar('_LinkedHashSet__A')  # <A>
class LinkedHashSet(AbstractSet[_LinkedHashSet__A], HashTable[_LinkedHashSet__A, 'LinkedHashSet.Entry'[_LinkedHashSet__A]], scala.Serializable, typing.Generic[_LinkedHashSet__A]):
    serialVersionUID: typing.ClassVar[int] = ...
    def __init__(self): ...
    @typing.overload
    def $minus(self, elem: _LinkedHashSet__A) -> Set[_LinkedHashSet__A]: ...
    @typing.overload
    def $minus(self, elem1: _LinkedHashSet__A, elem2: _LinkedHashSet__A, elems: scala.collection.Seq[_LinkedHashSet__A]) -> Set[_LinkedHashSet__A]: ...
    @typing.overload
    def $minus$eq(self, elem1: _LinkedHashSet__A, elem2: _LinkedHashSet__A, elems: scala.collection.Seq[_LinkedHashSet__A]) -> scala.collection.generic.Shrinkable[_LinkedHashSet__A]: ...
    @typing.overload
    def $minus$eq(self, elem: _LinkedHashSet__A) -> 'LinkedHashSet'[_LinkedHashSet__A]: ...
    def $minus$minus(self, xs: scala.collection.GenTraversableOnce[_LinkedHashSet__A]) -> Set[_LinkedHashSet__A]: ...
    @typing.overload
    def $plus(self, elem: _LinkedHashSet__A) -> Set[_LinkedHashSet__A]: ...
    @typing.overload
    def $plus(self, elem1: _LinkedHashSet__A, elem2: _LinkedHashSet__A, elems: scala.collection.Seq[_LinkedHashSet__A]) -> Set[_LinkedHashSet__A]: ...
    @typing.overload
    def $plus$eq(self, elem1: _LinkedHashSet__A, elem2: _LinkedHashSet__A, elems: scala.collection.Seq[_LinkedHashSet__A]) -> scala.collection.generic.Growable[_LinkedHashSet__A]: ...
    @typing.overload
    def $plus$eq(self, elem: _LinkedHashSet__A) -> 'LinkedHashSet'[_LinkedHashSet__A]: ...
    _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
    _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
    @typing.overload
    def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus_0__B], bf: scala.collection.generic.CanBuildFrom[scala.collection.Traversable[_LinkedHashSet__A], _.plus.plus_0__B, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
    @typing.overload
    def $plus$plus(self, xs: scala.collection.GenTraversableOnce[_LinkedHashSet__A]) -> Set[_LinkedHashSet__A]: ...
    def _loadFactor(self) -> int: ...
    def _loadFactor_$eq(self, x$1: int) -> None: ...
    def add(self, elem: _LinkedHashSet__A) -> bool: ...
    def addEntry(self, e: HashEntry) -> None: ...
    def alwaysInitSizeMap(self) -> bool: ...
    def apply(self, elem: _LinkedHashSet__A) -> bool: ...
    def calcSizeMapSize(self, tableLength: int) -> int: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['LinkedHashSet'[typing.Any], _canBuildFrom__A, 'LinkedHashSet'[_canBuildFrom__A]]: ...
    def clear(self) -> None: ...
    def clearTable(self) -> None: ...
    def clone(self) -> Set[_LinkedHashSet__A]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['LinkedHashSet']: ...
    def contains(self, elem: _LinkedHashSet__A) -> bool: ...
    _createNewEntry__B = typing.TypeVar('_createNewEntry__B')  # <B>
    def createNewEntry(self, key: _LinkedHashSet__A, dummy: _createNewEntry__B) -> 'LinkedHashSet.Entry'[_LinkedHashSet__A]: ...
    def diff(self, that: scala.collection.GenSet) -> scala.collection.Set: ...
    def elemEquals(self, key1: _LinkedHashSet__A, key2: _LinkedHashSet__A) -> bool: ...
    def elemHashCode(self, key: _LinkedHashSet__A) -> int: ...
    def empty(self) -> scala.collection.GenSet: ...
    def entriesIterator(self) -> scala.collection.Iterator['LinkedHashSet.Entry'[_LinkedHashSet__A]]: ...
    def findEntry(self, key: typing.Any) -> HashEntry: ...
    def findOrAddEntry(self, key: typing.Any, value: typing.Any) -> HashEntry: ...
    def firstEntry(self) -> 'LinkedHashSet.Entry'[_LinkedHashSet__A]: ...
    def firstEntry_$eq(self, x$1: 'LinkedHashSet.Entry'[_LinkedHashSet__A]) -> None: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_LinkedHashSet__A, _foreach__U]) -> None: ...
    _foreachEntry__U = typing.TypeVar('_foreachEntry__U')  # <U>
    def foreachEntry(self, f: scala.Function1['LinkedHashSet.Entry'[_LinkedHashSet__A], _foreachEntry__U]) -> None: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[_LinkedHashSet__A, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[_LinkedHashSet__A]]: ...
    def hashTableContents(self) -> HashTable.Contents[_LinkedHashSet__A, 'LinkedHashSet.Entry'[_LinkedHashSet__A]]: ...
    def improve(self, hcode: int, seed: int) -> int: ...
    def index(self, hcode: int) -> int: ...
    @typing.overload
    def init(self) -> typing.Any: ...
    @typing.overload
    def init(self, in_: java.io.ObjectInputStream, readEntry: scala.Function0['LinkedHashSet.Entry'[_LinkedHashSet__A]]) -> None: ...
    def initWithContents(self, c: HashTable.Contents[_LinkedHashSet__A, 'LinkedHashSet.Entry'[_LinkedHashSet__A]]) -> None: ...
    def initialSize(self) -> int: ...
    def isSizeMapDefined(self) -> bool: ...
    def iterator(self) -> scala.collection.Iterator[_LinkedHashSet__A]: ...
    def lastEntry(self) -> 'LinkedHashSet.Entry'[_LinkedHashSet__A]: ...
    def lastEntry_$eq(self, x$1: 'LinkedHashSet.Entry'[_LinkedHashSet__A]) -> None: ...
    def nnSizeMapAdd(self, h: int) -> None: ...
    def nnSizeMapRemove(self, h: int) -> None: ...
    def nnSizeMapReset(self, tableLength: int) -> None: ...
    def printSizeMap(self) -> None: ...
    def remove(self, elem: _LinkedHashSet__A) -> bool: ...
    def removeEntry(self, key: typing.Any) -> HashEntry: ...
    def repr(self) -> typing.Any: ...
    def result(self) -> Set[_LinkedHashSet__A]: ...
    def seedvalue(self) -> int: ...
    def seedvalue_$eq(self, x$1: int) -> None: ...
    def seq(self) -> Set[_LinkedHashSet__A]: ...
    def serializeTo(self, out: java.io.ObjectOutputStream, writeEntry: scala.Function1['LinkedHashSet.Entry'[_LinkedHashSet__A], scala.runtime.BoxedUnit]) -> None: ...
    _setCanBuildFrom__A = typing.TypeVar('_setCanBuildFrom__A')  # <A>
    @staticmethod
    def setCanBuildFrom() -> scala.collection.generic.CanBuildFrom['LinkedHashSet'[typing.Any], _setCanBuildFrom__A, 'LinkedHashSet'[_setCanBuildFrom__A]]: ...
    def size(self) -> int: ...
    def sizeMapBucketBitSize(self) -> int: ...
    def sizeMapBucketSize(self) -> int: ...
    def sizeMapDisable(self) -> None: ...
    def sizeMapInit(self, tableLength: int) -> None: ...
    def sizeMapInitAndRebuild(self) -> None: ...
    def sizemap(self) -> typing.List[int]: ...
    def sizemap_$eq(self, x$1: typing.List[int]) -> None: ...
    def table(self) -> typing.List[HashEntry[_LinkedHashSet__A, 'LinkedHashSet.Entry'[_LinkedHashSet__A]]]: ...
    def tableSize(self) -> int: ...
    def tableSizeSeed(self) -> int: ...
    def tableSize_$eq(self, x$1: int) -> None: ...
    def table_$eq(self, x$1: typing.List[HashEntry[_LinkedHashSet__A, 'LinkedHashSet.Entry'[_LinkedHashSet__A]]]) -> None: ...
    def thisCollection(self) -> scala.collection.Iterable[_LinkedHashSet__A]: ...
    def threshold(self) -> int: ...
    def threshold_$eq(self, x$1: int) -> None: ...
    def toCollection(self, repr: typing.Any) -> scala.collection.Iterable: ...
    def toIterable(self) -> scala.collection.Iterable[_LinkedHashSet__A]: ...
    def toSeq(self) -> scala.collection.Seq[_LinkedHashSet__A]: ...
    def toTraversable(self) -> scala.collection.Traversable[_LinkedHashSet__A]: ...
    def totalSizeMapBuckets(self) -> int: ...
    def union(self, that: scala.collection.GenSet) -> scala.collection.Set: ...
    @typing.overload
    def view(self) -> scala.collection.IterableView[_LinkedHashSet__A, scala.collection.Iterable[_LinkedHashSet__A]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> scala.collection.IterableView[_LinkedHashSet__A, scala.collection.Iterable[_LinkedHashSet__A]]: ...
    class Entry(HashEntry[_LinkedHashSet__Entry__A, 'LinkedHashSet.Entry'[_LinkedHashSet__Entry__A]], scala.Serializable, typing.Generic[_LinkedHashSet__Entry__A]):
        def __init__(self, key: _LinkedHashSet__Entry__A): ...
        def earlier(self) -> 'LinkedHashSet.Entry'[_LinkedHashSet__Entry__A]: ...
        def earlier_$eq(self, x$1: 'LinkedHashSet.Entry'[_LinkedHashSet__Entry__A]) -> None: ...
        def key(self) -> _LinkedHashSet__Entry__A: ...
        def later(self) -> 'LinkedHashSet.Entry'[_LinkedHashSet__Entry__A]: ...
        def later_$eq(self, x$1: 'LinkedHashSet.Entry'[_LinkedHashSet__Entry__A]) -> None: ...
        def next(self) -> 'LinkedHashSet.Entry'[_LinkedHashSet__Entry__A]: ...
        def next_$eq(self, x$1: 'LinkedHashSet.Entry'[_LinkedHashSet__Entry__A]) -> None: ...

_ListMap__A = typing.TypeVar('_ListMap__A')  # <A>
_ListMap__B = typing.TypeVar('_ListMap__B')  # <B>
class ListMap(AbstractMap[_ListMap__A, _ListMap__B], scala.Serializable, typing.Generic[_ListMap__A, _ListMap__B]):
    def __init__(self): ...
    @typing.overload
    def $minus(self, key: typing.Any) -> 'Map'[typing.Any, typing.Any]: ...
    @typing.overload
    def $minus(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> 'Map'[typing.Any, typing.Any]: ...
    @typing.overload
    def $minus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> scala.collection.generic.Shrinkable[typing.Any]: ...
    @typing.overload
    def $minus$eq(self, key: _ListMap__A) -> 'ListMap'[_ListMap__A, _ListMap__B]: ...
    def $minus$minus(self, xs: scala.collection.GenTraversableOnce[typing.Any]) -> 'Map'[typing.Any, typing.Any]: ...
    _$plus_0__V1 = typing.TypeVar('_$plus_0__V1')  # <V1>
    _$plus_1__V1 = typing.TypeVar('_$plus_1__V1')  # <V1>
    @typing.overload
    def $plus(self, kv: scala.Tuple2[typing.Any, _.plus_0__V1]) -> 'Map'[typing.Any, _.plus_0__V1]: ...
    @typing.overload
    def $plus(self, elem1: scala.Tuple2[typing.Any, _.plus_1__V1], elem2: scala.Tuple2[typing.Any, _.plus_1__V1], elems: scala.collection.Seq[scala.Tuple2[typing.Any, _.plus_1__V1]]) -> 'Map'[typing.Any, _.plus_1__V1]: ...
    @typing.overload
    def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq) -> scala.collection.generic.Growable: ...
    @typing.overload
    def $plus$eq(self, kv: scala.Tuple2[_ListMap__A, _ListMap__B]) -> 'ListMap'[_ListMap__A, _ListMap__B]: ...
    _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
    _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
    _$plus$plus_1__V1 = typing.TypeVar('_$plus$plus_1__V1')  # <V1>
    @typing.overload
    def $plus$plus(self, that: scala.collection.GenTraversableOnce[typing.Any], bf: scala.collection.generic.CanBuildFrom[scala.collection.Traversable[_ListMap__A], typing.Any, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
    @typing.overload
    def $plus$plus(self, xs: scala.collection.GenTraversableOnce[scala.Tuple2[typing.Any, _.plus.plus_1__V1]]) -> 'Map'[typing.Any, _.plus.plus_1__V1]: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    _canBuildFrom__B = typing.TypeVar('_canBuildFrom__B')  # <B>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['ListMap'[typing.Any, typing.Any], scala.Tuple2[_canBuildFrom__A, _canBuildFrom__B], 'ListMap'[_canBuildFrom__A, _canBuildFrom__B]]: ...
    def clear(self) -> None: ...
    def clone(self) -> 'Map'[typing.Any, typing.Any]: ...
    def empty(self) -> 'ListMap'[_ListMap__A, _ListMap__B]: ...
    def filterKeys(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.collection.Map[typing.Any, typing.Any]: ...
    def filterNot(self, p: scala.Function1[scala.Tuple2[typing.Any, typing.Any], typing.Any]) -> scala.collection.Map[typing.Any, typing.Any]: ...
    def get(self, key: _ListMap__A) -> scala.Option[_ListMap__B]: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[_ListMap__A, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[_ListMap__A]]: ...
    def iterator(self) -> scala.collection.Iterator[scala.Tuple2[_ListMap__A, _ListMap__B]]: ...
    def keySet(self) -> scala.collection.Set[typing.Any]: ...
    def keys(self) -> scala.collection.Iterable[typing.Any]: ...
    _mapValues__W = typing.TypeVar('_mapValues__W')  # <W>
    def mapValues(self, f: scala.Function1[typing.Any, _mapValues__W]) -> scala.collection.Map[typing.Any, _mapValues__W]: ...
    def repr(self) -> typing.Any: ...
    def result(self) -> 'Map'[typing.Any, typing.Any]: ...
    def seq(self) -> 'Map'[typing.Any, typing.Any]: ...
    def size(self) -> int: ...
    def thisCollection(self) -> scala.collection.Iterable[_ListMap__A]: ...
    def toCollection(self, repr: typing.Any) -> scala.collection.Iterable: ...
    def toIterable(self) -> scala.collection.Iterable[_ListMap__A]: ...
    def toSeq(self) -> scala.collection.Seq[scala.Tuple2[typing.Any, typing.Any]]: ...
    def toTraversable(self) -> scala.collection.Traversable[_ListMap__A]: ...
    _updated__V1 = typing.TypeVar('_updated__V1')  # <V1>
    def updated(self, key: typing.Any, value: _updated__V1) -> 'Map'[typing.Any, _updated__V1]: ...
    def values(self) -> scala.collection.Iterable[typing.Any]: ...
    @typing.overload
    def view(self) -> scala.collection.IterableView[_ListMap__A, scala.collection.Iterable[_ListMap__A]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> scala.collection.IterableView[_ListMap__A, scala.collection.Iterable[_ListMap__A]]: ...

_LongMap__LongMapBuilder__V = typing.TypeVar('_LongMap__LongMapBuilder__V')  # <V>
_LongMap__V = typing.TypeVar('_LongMap__V')  # <V>
class LongMap(AbstractMap[typing.Any, _LongMap__V], scala.Serializable, typing.Generic[_LongMap__V]):
    scala$collection$mutable$LongMap$$extraKeys: int = ...
    scala$collection$mutable$LongMap$$zeroValue: typing.Any = ...
    scala$collection$mutable$LongMap$$minValue: typing.Any = ...
    scala$collection$mutable$LongMap$$_keys: typing.List[int] = ...
    scala$collection$mutable$LongMap$$_values: typing.List[typing.Any] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, initialBufferSize: int): ...
    @typing.overload
    def __init__(self, defaultEntry: scala.Function1[typing.Any, _LongMap__V]): ...
    @typing.overload
    def __init__(self, defaultEntry: scala.Function1[typing.Any, _LongMap__V], initialBufferSize: int): ...
    @typing.overload
    def __init__(self, defaultEntry: scala.Function1[typing.Any, _LongMap__V], initialBufferSize: int, initBlank: bool): ...
    @typing.overload
    def $minus(self, key: typing.Any) -> 'Map'[typing.Any, _LongMap__V]: ...
    @typing.overload
    def $minus(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> 'Map'[typing.Any, _LongMap__V]: ...
    @typing.overload
    def $minus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> scala.collection.generic.Shrinkable[typing.Any]: ...
    @typing.overload
    def $minus$eq(self, key: int) -> 'LongMap'[_LongMap__V]: ...
    def $minus$minus(self, xs: scala.collection.GenTraversableOnce[typing.Any]) -> 'Map'[typing.Any, _LongMap__V]: ...
    _$plus_0__V1 = typing.TypeVar('_$plus_0__V1')  # <V1>
    _$plus_1__V1 = typing.TypeVar('_$plus_1__V1')  # <V1>
    @typing.overload
    def $plus(self, kv: scala.Tuple2[typing.Any, _.plus_0__V1]) -> 'LongMap'[_.plus_0__V1]: ...
    @typing.overload
    def $plus(self, elem1: scala.Tuple2[typing.Any, _.plus_1__V1], elem2: scala.Tuple2[typing.Any, _.plus_1__V1], elems: scala.collection.Seq[scala.Tuple2[typing.Any, _.plus_1__V1]]) -> 'Map'[typing.Any, _.plus_1__V1]: ...
    @typing.overload
    def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq) -> scala.collection.generic.Growable: ...
    @typing.overload
    def $plus$eq(self, key: int, value: _LongMap__V) -> 'LongMap'[_LongMap__V]: ...
    @typing.overload
    def $plus$eq(self, kv: scala.Tuple2[typing.Any, _LongMap__V]) -> 'LongMap'[_LongMap__V]: ...
    _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
    _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
    _$plus$plus_1__V1 = typing.TypeVar('_$plus$plus_1__V1')  # <V1>
    @typing.overload
    def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus_0__B], bf: scala.collection.generic.CanBuildFrom[scala.collection.Traversable[typing.Any], _.plus.plus_0__B, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
    @typing.overload
    def $plus$plus(self, xs: scala.collection.GenTraversableOnce[scala.Tuple2[typing.Any, _.plus.plus_1__V1]]) -> 'LongMap'[_.plus.plus_1__V1]: ...
    def apply(self, key: int) -> _LongMap__V: ...
    _canBuildFrom__V = typing.TypeVar('_canBuildFrom__V')  # <V>
    _canBuildFrom__U = typing.TypeVar('_canBuildFrom__U')  # <U>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['LongMap'[_canBuildFrom__V], scala.Tuple2[typing.Any, _canBuildFrom__U], 'LongMap'[_canBuildFrom__U]]: ...
    def clone(self) -> 'LongMap'[_LongMap__V]: ...
    def contains(self, key: int) -> bool: ...
    def default(self, key: int) -> _LongMap__V: ...
    def empty(self) -> 'LongMap'[_LongMap__V]: ...
    def filterKeys(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.collection.Map[typing.Any, _LongMap__V]: ...
    def filterNot(self, p: scala.Function1[scala.Tuple2[typing.Any, _LongMap__V], typing.Any]) -> scala.collection.Map[typing.Any, _LongMap__V]: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[scala.Tuple2[typing.Any, _LongMap__V], _foreach__U]) -> None: ...
    _foreachKey__A = typing.TypeVar('_foreachKey__A')  # <A>
    def foreachKey(self, f: scala.Function1[typing.Any, _foreachKey__A]) -> None: ...
    _foreachValue__A = typing.TypeVar('_foreachValue__A')  # <A>
    def foreachValue(self, f: scala.Function1[_LongMap__V, _foreachValue__A]) -> None: ...
    _fromZip_0__V = typing.TypeVar('_fromZip_0__V')  # <V>
    _fromZip_1__V = typing.TypeVar('_fromZip_1__V')  # <V>
    @typing.overload
    @staticmethod
    def fromZip(keys: typing.List[int], values: typing.Any) -> 'LongMap'[_fromZip_0__V]: ...
    @typing.overload
    @staticmethod
    def fromZip(keys: scala.collection.Iterable[typing.Any], values: scala.collection.Iterable[_fromZip_1__V]) -> 'LongMap'[_fromZip_1__V]: ...
    def get(self, key: int) -> scala.Option[_LongMap__V]: ...
    _getOrElse__V1 = typing.TypeVar('_getOrElse__V1')  # <V1>
    def getOrElse(self, key: int, default: scala.Function0[_getOrElse__V1]) -> _getOrElse__V1: ...
    def getOrElseUpdate(self, key: int, defaultValue: scala.Function0[_LongMap__V]) -> _LongMap__V: ...
    def getOrNull(self, key: int) -> _LongMap__V: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[typing.Any, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[typing.Any]]: ...
    def initializeTo(self, m: int, ek: int, zv: typing.Any, mv: typing.Any, sz: int, vc: int, kz: typing.List[int], vz: typing.List[typing.Any]) -> None: ...
    def iterator(self) -> scala.collection.Iterator[scala.Tuple2[typing.Any, _LongMap__V]]: ...
    def keySet(self) -> scala.collection.Set[typing.Any]: ...
    def keys(self) -> scala.collection.Iterable[typing.Any]: ...
    _mapValues__W = typing.TypeVar('_mapValues__W')  # <W>
    def mapValues(self, f: scala.Function1[_LongMap__V, _mapValues__W]) -> scala.collection.Map[typing.Any, _mapValues__W]: ...
    _mapValuesNow__V1 = typing.TypeVar('_mapValuesNow__V1')  # <V1>
    def mapValuesNow(self, f: scala.Function1[_LongMap__V, _mapValuesNow__V1]) -> 'LongMap'[_mapValuesNow__V1]: ...
    def put(self, key: int, value: _LongMap__V) -> scala.Option[_LongMap__V]: ...
    def repack(self) -> None: ...
    def repr(self) -> typing.Any: ...
    def result(self) -> 'Map'[typing.Any, _LongMap__V]: ...
    def seq(self) -> 'Map'[typing.Any, _LongMap__V]: ...
    def size(self) -> int: ...
    def thisCollection(self) -> scala.collection.Iterable[typing.Any]: ...
    def toCollection(self, repr: typing.Any) -> scala.collection.Iterable: ...
    def toIterable(self) -> scala.collection.Iterable[typing.Any]: ...
    def toSeq(self) -> scala.collection.Seq[scala.Tuple2[typing.Any, _LongMap__V]]: ...
    def toTraversable(self) -> scala.collection.Traversable[typing.Any]: ...
    def transformValues(self, f: scala.Function1[_LongMap__V, _LongMap__V]) -> 'LongMap'[_LongMap__V]: ...
    def update(self, key: int, value: _LongMap__V) -> None: ...
    _updated__V1 = typing.TypeVar('_updated__V1')  # <V1>
    def updated(self, key: int, value: _updated__V1) -> 'LongMap'[_updated__V1]: ...
    def values(self) -> scala.collection.Iterable[_LongMap__V]: ...
    @typing.overload
    def view(self) -> scala.collection.IterableView[typing.Any, scala.collection.Iterable[typing.Any]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> scala.collection.IterableView[typing.Any, scala.collection.Iterable[typing.Any]]: ...
    class LongMapBuilder(ReusableBuilder[scala.Tuple2[typing.Any, _LongMap__LongMapBuilder__V], 'LongMap'[_LongMap__LongMapBuilder__V]], typing.Generic[_LongMap__LongMapBuilder__V]):
        def __init__(self): ...
        @typing.overload
        def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq) -> scala.collection.generic.Growable: ...
        @typing.overload
        def $plus$eq(self, entry: scala.Tuple2[typing.Any, _LongMap__LongMapBuilder__V]) -> 'LongMap.LongMapBuilder'[_LongMap__LongMapBuilder__V]: ...
        def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[scala.Tuple2[typing.Any, _LongMap__LongMapBuilder__V]]) -> scala.collection.generic.Growable[scala.Tuple2[typing.Any, _LongMap__LongMapBuilder__V]]: ...
        def clear(self) -> None: ...
        def elems(self) -> 'LongMap'[_LongMap__LongMapBuilder__V]: ...
        def elems_$eq(self, x$1: 'LongMap'[_LongMap__LongMapBuilder__V]) -> None: ...
        _mapResult__NewTo = typing.TypeVar('_mapResult__NewTo')  # <NewTo>
        def mapResult(self, f: scala.Function1['LongMap'[_LongMap__LongMapBuilder__V], _mapResult__NewTo]) -> Builder[scala.Tuple2[typing.Any, _LongMap__LongMapBuilder__V], _mapResult__NewTo]: ...
        def result(self) -> 'LongMap'[_LongMap__LongMapBuilder__V]: ...
        @typing.overload
        def sizeHint(self, size: int) -> None: ...
        @typing.overload
        def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
        @typing.overload
        def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any], delta: int) -> None: ...
        def sizeHintBounded(self, size: int, boundingColl: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...

_Map__WithDefault__K = typing.TypeVar('_Map__WithDefault__K')  # <K>
_Map__WithDefault__V = typing.TypeVar('_Map__WithDefault__V')  # <V>
_Map__K = typing.TypeVar('_Map__K')  # <K>
_Map__V = typing.TypeVar('_Map__V')  # <V>
class Map(Iterable[scala.Tuple2[_Map__K, _Map__V]], scala.collection.Map[_Map__K, _Map__V], MapLike[_Map__K, _Map__V, 'Map'[_Map__K, _Map__V]], typing.Generic[_Map__K, _Map__V]):
    @staticmethod
    def $init$($this: 'Map') -> None: ...
    _canBuildFrom__K = typing.TypeVar('_canBuildFrom__K')  # <K>
    _canBuildFrom__V = typing.TypeVar('_canBuildFrom__V')  # <V>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['Map'[typing.Any, typing.Any], scala.Tuple2[_canBuildFrom__K, _canBuildFrom__V], 'Map'[_canBuildFrom__K, _canBuildFrom__V]]: ...
    @typing.overload
    def empty(self) -> scala.collection.Map[_Map__K, _Map__V]: ...
    @typing.overload
    def empty(self) -> 'Map'[_Map__K, _Map__V]: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def seq(self) -> scala.collection.TraversableOnce[typing.Any]: ...
    @typing.overload
    def seq(self) -> scala.collection.TraversableOnce[typing.Any]: ...
    @typing.overload
    def seq(self) -> scala.collection.Iterable[typing.Any]: ...
    @typing.overload
    def seq(self) -> scala.collection.Map[_Map__K, _Map__V]: ...
    @typing.overload
    def seq(self) -> scala.collection.Traversable[typing.Any]: ...
    @typing.overload
    def seq(self) -> Iterable[typing.Any]: ...
    @typing.overload
    def seq(self) -> 'Map'[_Map__K, _Map__V]: ...
    @typing.overload
    def seq(self) -> Traversable[typing.Any]: ...
    def toString(self) -> str: ...
    def withDefault(self, d: scala.Function1[_Map__K, _Map__V]) -> 'Map'[_Map__K, _Map__V]: ...
    def withDefaultValue(self, d: _Map__V) -> 'Map'[_Map__K, _Map__V]: ...
    class WithDefault(scala.collection.Map.WithDefault[_Map__WithDefault__K, _Map__WithDefault__V], scala.collection.mutable.Map[_Map__WithDefault__K, _Map__WithDefault__V], typing.Generic[_Map__WithDefault__K, _Map__WithDefault__V]):
        def __init__(self, underlying: 'Map'[_Map__WithDefault__K, _Map__WithDefault__V], d: scala.Function1[_Map__WithDefault__K, _Map__WithDefault__V]): ...
        @typing.overload
        def $minus(self, elem1: _Map__WithDefault__K, elem2: _Map__WithDefault__K, elems: scala.collection.Seq[_Map__WithDefault__K]) -> 'Map'[_Map__WithDefault__K, _Map__WithDefault__V]: ...
        @typing.overload
        def $minus(self, key: _Map__WithDefault__K) -> 'Map.WithDefault'[_Map__WithDefault__K, _Map__WithDefault__V]: ...
        @typing.overload
        def $minus$eq(self, elem1: _Map__WithDefault__K, elem2: _Map__WithDefault__K, elems: scala.collection.Seq[_Map__WithDefault__K]) -> scala.collection.generic.Shrinkable[_Map__WithDefault__K]: ...
        @typing.overload
        def $minus$eq(self, key: _Map__WithDefault__K) -> 'Map.WithDefault'[_Map__WithDefault__K, _Map__WithDefault__V]: ...
        def $minus$minus(self, xs: scala.collection.GenTraversableOnce[_Map__WithDefault__K]) -> 'Map'[_Map__WithDefault__K, _Map__WithDefault__V]: ...
        def $minus$minus$eq(self, xs: scala.collection.TraversableOnce[_Map__WithDefault__K]) -> scala.collection.generic.Shrinkable[_Map__WithDefault__K]: ...
        _$plus_0__V1 = typing.TypeVar('_$plus_0__V1')  # <V1>
        _$plus_1__V1 = typing.TypeVar('_$plus_1__V1')  # <V1>
        @typing.overload
        def $plus(self, elem1: scala.Tuple2[_Map__WithDefault__K, _.plus_0__V1], elem2: scala.Tuple2[_Map__WithDefault__K, _.plus_0__V1], elems: scala.collection.Seq[scala.Tuple2[_Map__WithDefault__K, _.plus_0__V1]]) -> 'Map'[_Map__WithDefault__K, _.plus_0__V1]: ...
        @typing.overload
        def $plus(self, kv: scala.Tuple2[_Map__WithDefault__K, _.plus_1__V1]) -> 'Map.WithDefault'[_Map__WithDefault__K, _.plus_1__V1]: ...
        @typing.overload
        def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq) -> scala.collection.generic.Growable: ...
        @typing.overload
        def $plus$eq(self, kv: scala.Tuple2[_Map__WithDefault__K, _Map__WithDefault__V]) -> 'Map.WithDefault'[_Map__WithDefault__K, _Map__WithDefault__V]: ...
        _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
        _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
        _$plus$plus_1__V1 = typing.TypeVar('_$plus$plus_1__V1')  # <V1>
        @typing.overload
        def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus_0__B], bf: scala.collection.generic.CanBuildFrom[scala.collection.Traversable[typing.Any], _.plus.plus_0__B, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
        @typing.overload
        def $plus$plus(self, xs: scala.collection.GenTraversableOnce[scala.Tuple2[_Map__WithDefault__K, _.plus.plus_1__V1]]) -> 'Map'[_Map__WithDefault__K, _.plus.plus_1__V1]: ...
        def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[scala.Tuple2[_Map__WithDefault__K, _Map__WithDefault__V]]) -> scala.collection.generic.Growable[scala.Tuple2[_Map__WithDefault__K, _Map__WithDefault__V]]: ...
        def clear(self) -> None: ...
        def clone(self) -> 'Map'[_Map__WithDefault__K, _Map__WithDefault__V]: ...
        def companion(self) -> scala.collection.generic.GenericCompanion[Iterable]: ...
        def empty(self) -> 'Map.WithDefault'[_Map__WithDefault__K, _Map__WithDefault__V]: ...
        def filterKeys(self, p: scala.Function1[_Map__WithDefault__K, typing.Any]) -> scala.collection.Map[_Map__WithDefault__K, _Map__WithDefault__V]: ...
        def filterNot(self, p: scala.Function1[scala.Tuple2[_Map__WithDefault__K, _Map__WithDefault__V], typing.Any]) -> scala.collection.Map[_Map__WithDefault__K, _Map__WithDefault__V]: ...
        def getOrElseUpdate(self, key: _Map__WithDefault__K, op: scala.Function0[_Map__WithDefault__V]) -> _Map__WithDefault__V: ...
        _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
        def groupBy(self, f: scala.Function1[typing.Any, typing.Any]) -> scala.collection.immutable.Map[typing.Any, scala.collection.Traversable[typing.Any]]: ...
        def keySet(self) -> scala.collection.Set[_Map__WithDefault__K]: ...
        def keys(self) -> scala.collection.Iterable[_Map__WithDefault__K]: ...
        _mapResult__NewTo = typing.TypeVar('_mapResult__NewTo')  # <NewTo>
        def mapResult(self, f: scala.Function1['Map'[_Map__WithDefault__K, _Map__WithDefault__V], _mapResult__NewTo]) -> Builder[scala.Tuple2[_Map__WithDefault__K, _Map__WithDefault__V], _mapResult__NewTo]: ...
        _mapValues__W = typing.TypeVar('_mapValues__W')  # <W>
        def mapValues(self, f: scala.Function1[_Map__WithDefault__V, _mapValues__W]) -> scala.collection.Map[_Map__WithDefault__K, _mapValues__W]: ...
        def newBuilder(self) -> Builder[scala.Tuple2[_Map__WithDefault__K, _Map__WithDefault__V], 'Map'[_Map__WithDefault__K, _Map__WithDefault__V]]: ...
        def parCombiner(self) -> scala.collection.parallel.Combiner[scala.Tuple2[_Map__WithDefault__K, _Map__WithDefault__V], scala.collection.parallel.mutable.ParMap[_Map__WithDefault__K, _Map__WithDefault__V]]: ...
        def put(self, key: _Map__WithDefault__K, value: _Map__WithDefault__V) -> scala.Option[_Map__WithDefault__V]: ...
        def remove(self, key: _Map__WithDefault__K) -> scala.Option[_Map__WithDefault__V]: ...
        def repr(self) -> typing.Any: ...
        def result(self) -> 'Map'[_Map__WithDefault__K, _Map__WithDefault__V]: ...
        def retain(self, p: scala.Function2[_Map__WithDefault__K, _Map__WithDefault__V, typing.Any]) -> MapLike[_Map__WithDefault__K, _Map__WithDefault__V, 'Map'[_Map__WithDefault__K, _Map__WithDefault__V]]: ...
        def seq(self) -> 'Map'[_Map__WithDefault__K, _Map__WithDefault__V]: ...
        @typing.overload
        def sizeHint(self, size: int) -> None: ...
        @typing.overload
        def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
        @typing.overload
        def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any], delta: int) -> None: ...
        def sizeHintBounded(self, size: int, boundingColl: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
        def thisCollection(self) -> scala.collection.Iterable[typing.Any]: ...
        def toCollection(self, repr: typing.Any) -> scala.collection.Iterable: ...
        def toIterable(self) -> scala.collection.Iterable[typing.Any]: ...
        def toSeq(self) -> scala.collection.Seq[scala.Tuple2[_Map__WithDefault__K, _Map__WithDefault__V]]: ...
        def toTraversable(self) -> scala.collection.Traversable[typing.Any]: ...
        def transform(self, f: scala.Function2[_Map__WithDefault__K, _Map__WithDefault__V, _Map__WithDefault__V]) -> MapLike[_Map__WithDefault__K, _Map__WithDefault__V, 'Map'[_Map__WithDefault__K, _Map__WithDefault__V]]: ...
        def update(self, key: _Map__WithDefault__K, value: _Map__WithDefault__V) -> None: ...
        _updated__V1 = typing.TypeVar('_updated__V1')  # <V1>
        def updated(self, key: _Map__WithDefault__K, value: _updated__V1) -> 'Map.WithDefault'[_Map__WithDefault__K, _updated__V1]: ...
        def values(self) -> scala.collection.Iterable[_Map__WithDefault__V]: ...
        @typing.overload
        def view(self) -> scala.collection.IterableView[typing.Any, scala.collection.Iterable[typing.Any]]: ...
        @typing.overload
        def view(self, from_: int, until: int) -> scala.collection.IterableView[typing.Any, scala.collection.Iterable[typing.Any]]: ...
        def withDefault(self, d: scala.Function1[_Map__WithDefault__K, _Map__WithDefault__V]) -> 'Map'[_Map__WithDefault__K, _Map__WithDefault__V]: ...
        def withDefaultValue(self, d: _Map__WithDefault__V) -> 'Map'[_Map__WithDefault__K, _Map__WithDefault__V]: ...

_MapProxy__A = typing.TypeVar('_MapProxy__A')  # <A>
_MapProxy__B = typing.TypeVar('_MapProxy__B')  # <B>
class MapProxy(Map[_MapProxy__A, _MapProxy__B], scala.collection.MapProxyLike[_MapProxy__A, _MapProxy__B, Map[_MapProxy__A, _MapProxy__B]], typing.Generic[_MapProxy__A, _MapProxy__B]):
    @staticmethod
    def $init$($this: 'MapProxy') -> None: ...
    @typing.overload
    def $minus(self, key: typing.Any) -> typing.Any: ...
    @typing.overload
    def $minus(self, elem: _MapProxy__A) -> scala.collection.generic.Subtractable: ...
    @typing.overload
    def $minus(self, key: _MapProxy__A) -> scala.collection.MapLike: ...
    @typing.overload
    def $minus(self, elem1: _MapProxy__A, elem2: _MapProxy__A, elems: scala.collection.Seq[_MapProxy__A]) -> scala.collection.generic.Subtractable: ...
    @typing.overload
    def $minus(self, key: typing.Any) -> MapLike: ...
    @typing.overload
    def $minus(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> MapLike: ...
    @typing.overload
    def $minus(self, key: _MapProxy__A) -> 'MapProxy'[_MapProxy__A, _MapProxy__B]: ...
    @typing.overload
    def $minus$eq(self, elem: _MapProxy__A) -> scala.collection.generic.Shrinkable[_MapProxy__A]: ...
    @typing.overload
    def $minus$eq(self, key: typing.Any) -> MapLike[typing.Any, typing.Any, MapLike]: ...
    @typing.overload
    def $minus$eq(self, elem1: _MapProxy__A, elem2: _MapProxy__A, elems: scala.collection.Seq[_MapProxy__A]) -> scala.collection.generic.Shrinkable[_MapProxy__A]: ...
    @typing.overload
    def $minus$eq(self, key: _MapProxy__A) -> 'MapProxy'[_MapProxy__A, _MapProxy__B]: ...
    _$plus_0__V1 = typing.TypeVar('_$plus_0__V1')  # <V1>
    _$plus_1__B1 = typing.TypeVar('_$plus_1__B1')  # <B1>
    _$plus_2__B1 = typing.TypeVar('_$plus_2__B1')  # <B1>
    _$plus_3__V1 = typing.TypeVar('_$plus_3__V1')  # <V1>
    _$plus_4__B1 = typing.TypeVar('_$plus_4__B1')  # <B1>
    _$plus_5__B1 = typing.TypeVar('_$plus_5__B1')  # <B1>
    @typing.overload
    def $plus(self, kv: scala.Tuple2[typing.Any, _.plus_0__V1]) -> scala.collection.GenMap[typing.Any, _.plus_0__V1]: ...
    @typing.overload
    def $plus(self, kv: scala.Tuple2[_MapProxy__A, _.plus_1__B1]) -> scala.collection.Map[_MapProxy__A, _.plus_1__B1]: ...
    @typing.overload
    def $plus(self, kv1: scala.Tuple2[_MapProxy__A, _.plus_2__B1], kv2: scala.Tuple2[_MapProxy__A, _.plus_2__B1], kvs: scala.collection.Seq[scala.Tuple2[_MapProxy__A, _.plus_2__B1]]) -> scala.collection.Map[_MapProxy__A, _.plus_2__B1]: ...
    @typing.overload
    def $plus(self, elem1: scala.Tuple2[typing.Any, _.plus_3__V1], elem2: scala.Tuple2[typing.Any, _.plus_3__V1], elems: scala.collection.Seq[scala.Tuple2[typing.Any, _.plus_3__V1]]) -> Map[typing.Any, _.plus_3__V1]: ...
    @typing.overload
    def $plus(self, kv: scala.Tuple2[_MapProxy__A, _.plus_4__B1]) -> Map[_MapProxy__A, _.plus_4__B1]: ...
    @typing.overload
    def $plus(self, elem1: scala.Tuple2[_MapProxy__A, _.plus_5__B1], elem2: scala.Tuple2[_MapProxy__A, _.plus_5__B1], elems: scala.collection.Seq[scala.Tuple2[_MapProxy__A, _.plus_5__B1]]) -> 'MapProxy'[_MapProxy__A, _.plus_5__B1]: ...
    @typing.overload
    def $plus$eq(self, elem: _MapProxy__A) -> scala.collection.generic.Growable[_MapProxy__A]: ...
    @typing.overload
    def $plus$eq(self, elem: typing.Any) -> Builder[typing.Any, typing.Any]: ...
    @typing.overload
    def $plus$eq(self, kv: scala.Tuple2[typing.Any, typing.Any]) -> MapLike[typing.Any, typing.Any, MapLike]: ...
    @typing.overload
    def $plus$eq(self, elem1: _MapProxy__A, elem2: _MapProxy__A, elems: scala.collection.Seq[_MapProxy__A]) -> scala.collection.generic.Growable[_MapProxy__A]: ...
    @typing.overload
    def $plus$eq(self, kv: scala.Tuple2[_MapProxy__A, _MapProxy__B]) -> 'MapProxy'[_MapProxy__A, _MapProxy__B]: ...
    _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
    _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
    _$plus$plus_1__B1 = typing.TypeVar('_$plus$plus_1__B1')  # <B1>
    _$plus$plus_2__V1 = typing.TypeVar('_$plus$plus_2__V1')  # <V1>
    _$plus$plus_3__B1 = typing.TypeVar('_$plus$plus_3__B1')  # <B1>
    @typing.overload
    def $plus$plus(self, xs: scala.collection.GenTraversableOnce[typing.Any], bf: scala.collection.generic.CanBuildFrom[scala.collection.TraversableLike, typing.Any, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
    @typing.overload
    def $plus$plus(self, xs: scala.collection.GenTraversableOnce[scala.Tuple2[_MapProxy__A, _.plus.plus_1__B1]]) -> scala.collection.Map[_MapProxy__A, _.plus.plus_1__B1]: ...
    @typing.overload
    def $plus$plus(self, xs: scala.collection.GenTraversableOnce[scala.Tuple2[typing.Any, _.plus.plus_2__V1]]) -> Map[typing.Any, _.plus.plus_2__V1]: ...
    @typing.overload
    def $plus$plus(self, xs: scala.collection.GenTraversableOnce[scala.Tuple2[_MapProxy__A, _.plus.plus_3__B1]]) -> 'MapProxy'[_MapProxy__A, _.plus.plus_3__B1]: ...
    @typing.overload
    def empty(self) -> scala.collection.Map[typing.Any, typing.Any]: ...
    @typing.overload
    def empty(self) -> Map[typing.Any, typing.Any]: ...
    @typing.overload
    def empty(self) -> 'MapProxy'[_MapProxy__A, _MapProxy__B]: ...
    @typing.overload
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @typing.overload
    def repr(self) -> scala.collection.generic.Subtractable: ...
    @typing.overload
    def repr(self) -> typing.Any: ...
    @typing.overload
    def repr(self) -> 'MapProxy'[_MapProxy__A, _MapProxy__B]: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self) -> str: ...
    _updated_0__V1 = typing.TypeVar('_updated_0__V1')  # <V1>
    _updated_1__B1 = typing.TypeVar('_updated_1__B1')  # <B1>
    _updated_2__V1 = typing.TypeVar('_updated_2__V1')  # <V1>
    _updated_3__B1 = typing.TypeVar('_updated_3__B1')  # <B1>
    @typing.overload
    def updated(self, key: typing.Any, value: _updated_0__V1) -> scala.collection.GenMap[typing.Any, _updated_0__V1]: ...
    @typing.overload
    def updated(self, key: _MapProxy__A, value: _updated_1__B1) -> scala.collection.Map[_MapProxy__A, _updated_1__B1]: ...
    @typing.overload
    def updated(self, key: typing.Any, value: _updated_2__V1) -> Map[typing.Any, _updated_2__V1]: ...
    @typing.overload
    def updated(self, key: _MapProxy__A, value: _updated_3__B1) -> 'MapProxy'[_MapProxy__A, _updated_3__B1]: ...

_MultiMap__A = typing.TypeVar('_MultiMap__A')  # <A>
_MultiMap__B = typing.TypeVar('_MultiMap__B')  # <B>
class MultiMap(Map[_MultiMap__A, Set[_MultiMap__B]], typing.Generic[_MultiMap__A, _MultiMap__B]):
    @staticmethod
    def $init$($this: 'MultiMap') -> None: ...
    def addBinding(self, key: _MultiMap__A, value: _MultiMap__B) -> 'MultiMap'[_MultiMap__A, _MultiMap__B]: ...
    def entryExists(self, key: _MultiMap__A, p: scala.Function1[_MultiMap__B, typing.Any]) -> bool: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def makeSet(self) -> Set[_MultiMap__B]: ...
    def removeBinding(self, key: _MultiMap__A, value: _MultiMap__B) -> 'MultiMap'[_MultiMap__A, _MultiMap__B]: ...
    def toString(self) -> str: ...

_ObservableMap__A = typing.TypeVar('_ObservableMap__A')  # <A>
_ObservableMap__B = typing.TypeVar('_ObservableMap__B')  # <B>
class ObservableMap(Map[_ObservableMap__A, _ObservableMap__B], Publisher[scala.collection.script.Message[scala.Tuple2[_ObservableMap__A, _ObservableMap__B]]], typing.Generic[_ObservableMap__A, _ObservableMap__B]):
    @staticmethod
    def $init$($this: 'ObservableMap') -> None: ...
    @typing.overload
    def $minus$eq(self, elem: _ObservableMap__A) -> scala.collection.generic.Shrinkable[_ObservableMap__A]: ...
    @typing.overload
    def $minus$eq(self, key: typing.Any) -> MapLike[typing.Any, typing.Any, MapLike]: ...
    @typing.overload
    def $minus$eq(self, elem1: _ObservableMap__A, elem2: _ObservableMap__A, elems: scala.collection.Seq[_ObservableMap__A]) -> scala.collection.generic.Shrinkable[_ObservableMap__A]: ...
    @typing.overload
    def $minus$eq(self, key: _ObservableMap__A) -> 'ObservableMap'[_ObservableMap__A, _ObservableMap__B]: ...
    @typing.overload
    def $plus$eq(self, elem: _ObservableMap__A) -> scala.collection.generic.Growable[_ObservableMap__A]: ...
    @typing.overload
    def $plus$eq(self, elem: typing.Any) -> Builder[typing.Any, typing.Any]: ...
    @typing.overload
    def $plus$eq(self, kv: scala.Tuple2[typing.Any, typing.Any]) -> MapLike[typing.Any, typing.Any, MapLike]: ...
    @typing.overload
    def $plus$eq(self, elem1: _ObservableMap__A, elem2: _ObservableMap__A, elems: scala.collection.Seq[_ObservableMap__A]) -> scala.collection.generic.Growable[_ObservableMap__A]: ...
    @typing.overload
    def $plus$eq(self, kv: scala.Tuple2[_ObservableMap__A, _ObservableMap__B]) -> 'ObservableMap'[_ObservableMap__A, _ObservableMap__B]: ...
    def clear(self) -> None: ...
    @typing.overload
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    def equals(self, obj: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...

_OpenHashMap__OpenEntry__Key = typing.TypeVar('_OpenHashMap__OpenEntry__Key')  # <Key>
_OpenHashMap__OpenEntry__Value = typing.TypeVar('_OpenHashMap__OpenEntry__Value')  # <Value>
_OpenHashMap__Key = typing.TypeVar('_OpenHashMap__Key')  # <Key>
_OpenHashMap__Value = typing.TypeVar('_OpenHashMap__Value')  # <Value>
class OpenHashMap(AbstractMap[_OpenHashMap__Key, _OpenHashMap__Value], typing.Generic[_OpenHashMap__Key, _OpenHashMap__Value]):
    scala$collection$mutable$OpenHashMap$$table: typing.List['OpenHashMap.OpenEntry'] = ...
    scala$collection$mutable$OpenHashMap$$modCount: int = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, initialSize: int): ...
    @typing.overload
    def $minus(self, key: typing.Any) -> Map[typing.Any, typing.Any]: ...
    @typing.overload
    def $minus(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> Map[typing.Any, typing.Any]: ...
    @typing.overload
    def $minus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> scala.collection.generic.Shrinkable[typing.Any]: ...
    @typing.overload
    def $minus$eq(self, key: _OpenHashMap__Key) -> 'OpenHashMap'[_OpenHashMap__Key, _OpenHashMap__Value]: ...
    def $minus$minus(self, xs: scala.collection.GenTraversableOnce[typing.Any]) -> Map[typing.Any, typing.Any]: ...
    _$plus_0__V1 = typing.TypeVar('_$plus_0__V1')  # <V1>
    _$plus_1__V1 = typing.TypeVar('_$plus_1__V1')  # <V1>
    @typing.overload
    def $plus(self, kv: scala.Tuple2[typing.Any, _.plus_0__V1]) -> Map[typing.Any, _.plus_0__V1]: ...
    @typing.overload
    def $plus(self, elem1: scala.Tuple2[typing.Any, _.plus_1__V1], elem2: scala.Tuple2[typing.Any, _.plus_1__V1], elems: scala.collection.Seq[scala.Tuple2[typing.Any, _.plus_1__V1]]) -> Map[typing.Any, _.plus_1__V1]: ...
    @typing.overload
    def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq) -> scala.collection.generic.Growable: ...
    @typing.overload
    def $plus$eq(self, kv: scala.Tuple2[_OpenHashMap__Key, _OpenHashMap__Value]) -> 'OpenHashMap'[_OpenHashMap__Key, _OpenHashMap__Value]: ...
    _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
    _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
    _$plus$plus_1__V1 = typing.TypeVar('_$plus$plus_1__V1')  # <V1>
    @typing.overload
    def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus_0__B], bf: scala.collection.generic.CanBuildFrom[scala.collection.Traversable[typing.Any], _.plus.plus_0__B, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
    @typing.overload
    def $plus$plus(self, xs: scala.collection.GenTraversableOnce[scala.Tuple2[typing.Any, _.plus.plus_1__V1]]) -> Map[typing.Any, _.plus.plus_1__V1]: ...
    def clone(self) -> 'OpenHashMap'[_OpenHashMap__Key, _OpenHashMap__Value]: ...
    def empty(self) -> 'OpenHashMap'[_OpenHashMap__Key, _OpenHashMap__Value]: ...
    def filterKeys(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.collection.Map[typing.Any, typing.Any]: ...
    def filterNot(self, p: scala.Function1[scala.Tuple2[typing.Any, typing.Any], typing.Any]) -> scala.collection.Map[typing.Any, typing.Any]: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[scala.Tuple2[_OpenHashMap__Key, _OpenHashMap__Value], _foreach__U]) -> None: ...
    def get(self, key: _OpenHashMap__Key) -> scala.Option[_OpenHashMap__Value]: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[typing.Any, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[typing.Any]]: ...
    def hashOf(self, key: _OpenHashMap__Key) -> int: ...
    def iterator(self) -> scala.collection.Iterator[scala.Tuple2[_OpenHashMap__Key, _OpenHashMap__Value]]: ...
    def keySet(self) -> scala.collection.Set[typing.Any]: ...
    def keys(self) -> scala.collection.Iterable[typing.Any]: ...
    _mapValues__W = typing.TypeVar('_mapValues__W')  # <W>
    def mapValues(self, f: scala.Function1[typing.Any, _mapValues__W]) -> scala.collection.Map[typing.Any, _mapValues__W]: ...
    def put(self, key: _OpenHashMap__Key, value: _OpenHashMap__Value) -> scala.Option[_OpenHashMap__Value]: ...
    def remove(self, key: _OpenHashMap__Key) -> scala.Option[_OpenHashMap__Value]: ...
    def repr(self) -> typing.Any: ...
    def result(self) -> Map[typing.Any, typing.Any]: ...
    def retain(self, f: scala.Function2[_OpenHashMap__Key, _OpenHashMap__Value, typing.Any]) -> 'OpenHashMap'[_OpenHashMap__Key, _OpenHashMap__Value]: ...
    def scala$collection$mutable$OpenHashMap$$deleted(self) -> int: ...
    def scala$collection$mutable$OpenHashMap$$deleted_$eq(self, x$1: int) -> None: ...
    def scala$collection$mutable$OpenHashMap$$mask(self) -> int: ...
    def scala$collection$mutable$OpenHashMap$$size_$eq(self, s: int) -> None: ...
    def seq(self) -> Map[typing.Any, typing.Any]: ...
    def size(self) -> int: ...
    def stringPrefix(self) -> str: ...
    def thisCollection(self) -> scala.collection.Iterable[typing.Any]: ...
    def toCollection(self, repr: typing.Any) -> scala.collection.Iterable: ...
    def toIterable(self) -> scala.collection.Iterable[typing.Any]: ...
    def toSeq(self) -> scala.collection.Seq[scala.Tuple2[typing.Any, typing.Any]]: ...
    def toTraversable(self) -> scala.collection.Traversable[typing.Any]: ...
    def transform(self, f: scala.Function2[_OpenHashMap__Key, _OpenHashMap__Value, _OpenHashMap__Value]) -> 'OpenHashMap'[_OpenHashMap__Key, _OpenHashMap__Value]: ...
    def update(self, key: _OpenHashMap__Key, value: _OpenHashMap__Value) -> None: ...
    _updated__V1 = typing.TypeVar('_updated__V1')  # <V1>
    def updated(self, key: typing.Any, value: _updated__V1) -> Map[typing.Any, _updated__V1]: ...
    def values(self) -> scala.collection.Iterable[typing.Any]: ...
    @typing.overload
    def view(self) -> scala.collection.IterableView[typing.Any, scala.collection.Iterable[typing.Any]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> scala.collection.IterableView[typing.Any, scala.collection.Iterable[typing.Any]]: ...
    class OpenEntry(typing.Generic[_OpenHashMap__OpenEntry__Key, _OpenHashMap__OpenEntry__Value]):
        def __init__(self, key: _OpenHashMap__OpenEntry__Key, hash: int, value: scala.Option[_OpenHashMap__OpenEntry__Value]): ...
        def hash(self) -> int: ...
        def hash_$eq(self, x$1: int) -> None: ...
        def key(self) -> _OpenHashMap__OpenEntry__Key: ...
        def key_$eq(self, x$1: _OpenHashMap__OpenEntry__Key) -> None: ...
        def value(self) -> scala.Option[_OpenHashMap__OpenEntry__Value]: ...
        def value_$eq(self, x$1: scala.Option[_OpenHashMap__OpenEntry__Value]) -> None: ...

_RedBlackTree__EntriesIterator__A = typing.TypeVar('_RedBlackTree__EntriesIterator__A')  # <A>
_RedBlackTree__EntriesIterator__B = typing.TypeVar('_RedBlackTree__EntriesIterator__B')  # <B>
_RedBlackTree__KeysIterator__A = typing.TypeVar('_RedBlackTree__KeysIterator__A')  # <A>
_RedBlackTree__KeysIterator__B = typing.TypeVar('_RedBlackTree__KeysIterator__B')  # <B>
_RedBlackTree__Node__A = typing.TypeVar('_RedBlackTree__Node__A')  # <A>
_RedBlackTree__Node__B = typing.TypeVar('_RedBlackTree__Node__B')  # <B>
_RedBlackTree__Tree__A = typing.TypeVar('_RedBlackTree__Tree__A')  # <A>
_RedBlackTree__Tree__B = typing.TypeVar('_RedBlackTree__Tree__B')  # <B>
_RedBlackTree__TreeIterator__A = typing.TypeVar('_RedBlackTree__TreeIterator__A')  # <A>
_RedBlackTree__TreeIterator__B = typing.TypeVar('_RedBlackTree__TreeIterator__B')  # <B>
_RedBlackTree__TreeIterator__R = typing.TypeVar('_RedBlackTree__TreeIterator__R')  # <R>
_RedBlackTree__ValuesIterator__A = typing.TypeVar('_RedBlackTree__ValuesIterator__A')  # <A>
_RedBlackTree__ValuesIterator__B = typing.TypeVar('_RedBlackTree__ValuesIterator__B')  # <B>
class RedBlackTree:
    @staticmethod
    def clear(tree: 'RedBlackTree.Tree'[typing.Any, typing.Any]) -> None: ...
    _contains__A = typing.TypeVar('_contains__A')  # <A>
    @staticmethod
    def contains(tree: 'RedBlackTree.Tree'[_contains__A, typing.Any], key: _contains__A, evidence$2: scala.math.Ordering[_contains__A]) -> bool: ...
    _delete__A = typing.TypeVar('_delete__A')  # <A>
    _delete__B = typing.TypeVar('_delete__B')  # <B>
    @staticmethod
    def delete(tree: 'RedBlackTree.Tree'[_delete__A, _delete__B], key: _delete__A, ord: scala.math.Ordering[_delete__A]) -> None: ...
    _foreach__A = typing.TypeVar('_foreach__A')  # <A>
    _foreach__B = typing.TypeVar('_foreach__B')  # <B>
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    @staticmethod
    def foreach(tree: 'RedBlackTree.Tree'[_foreach__A, _foreach__B], f: scala.Function1[scala.Tuple2[_foreach__A, _foreach__B], _foreach__U]) -> None: ...
    _foreachKey__A = typing.TypeVar('_foreachKey__A')  # <A>
    _foreachKey__U = typing.TypeVar('_foreachKey__U')  # <U>
    @staticmethod
    def foreachKey(tree: 'RedBlackTree.Tree'[_foreachKey__A, typing.Any], f: scala.Function1[_foreachKey__A, _foreachKey__U]) -> None: ...
    _get__A = typing.TypeVar('_get__A')  # <A>
    _get__B = typing.TypeVar('_get__B')  # <B>
    @staticmethod
    def get(tree: 'RedBlackTree.Tree'[_get__A, _get__B], key: _get__A, evidence$1: scala.math.Ordering[_get__A]) -> scala.Option[_get__B]: ...
    _insert__A = typing.TypeVar('_insert__A')  # <A>
    _insert__B = typing.TypeVar('_insert__B')  # <B>
    @staticmethod
    def insert(tree: 'RedBlackTree.Tree'[_insert__A, _insert__B], key: _insert__A, value: _insert__B, ord: scala.math.Ordering[_insert__A]) -> None: ...
    @staticmethod
    def isBlack(node: 'RedBlackTree.Node'[typing.Any, typing.Any]) -> bool: ...
    @staticmethod
    def isEmpty(tree: 'RedBlackTree.Tree'[typing.Any, typing.Any]) -> bool: ...
    @staticmethod
    def isRed(node: 'RedBlackTree.Node'[typing.Any, typing.Any]) -> bool: ...
    _isValid__A = typing.TypeVar('_isValid__A')  # <A>
    _isValid__B = typing.TypeVar('_isValid__B')  # <B>
    @staticmethod
    def isValid(tree: 'RedBlackTree.Tree'[_isValid__A, _isValid__B], evidence$9: scala.math.Ordering[_isValid__A]) -> bool: ...
    _iterator__A = typing.TypeVar('_iterator__A')  # <A>
    _iterator__B = typing.TypeVar('_iterator__B')  # <B>
    @staticmethod
    def iterator(tree: 'RedBlackTree.Tree'[_iterator__A, _iterator__B], start: scala.Option[_iterator__A], end: scala.Option[_iterator__A], evidence$3: scala.math.Ordering[_iterator__A]) -> scala.collection.Iterator[scala.Tuple2[_iterator__A, _iterator__B]]: ...
    _iterator$default$2__A = typing.TypeVar('_iterator$default$2__A')  # <A>
    _iterator$default$2__B = typing.TypeVar('_iterator$default$2__B')  # <B>
    @staticmethod
    def iterator$default$2() -> scala.None.: ...
    _iterator$default$3__A = typing.TypeVar('_iterator$default$3__A')  # <A>
    _iterator$default$3__B = typing.TypeVar('_iterator$default$3__B')  # <B>
    @staticmethod
    def iterator$default$3() -> scala.None.: ...
    _keysIterator__A = typing.TypeVar('_keysIterator__A')  # <A>
    @staticmethod
    def keysIterator(tree: 'RedBlackTree.Tree'[_keysIterator__A, typing.Any], start: scala.Option[_keysIterator__A], end: scala.Option[_keysIterator__A], evidence$4: scala.math.Ordering[_keysIterator__A]) -> scala.collection.Iterator[_keysIterator__A]: ...
    _keysIterator$default$2__A = typing.TypeVar('_keysIterator$default$2__A')  # <A>
    @staticmethod
    def keysIterator$default$2() -> scala.None.: ...
    _keysIterator$default$3__A = typing.TypeVar('_keysIterator$default$3__A')  # <A>
    @staticmethod
    def keysIterator$default$3() -> scala.None.: ...
    _max__A = typing.TypeVar('_max__A')  # <A>
    _max__B = typing.TypeVar('_max__B')  # <B>
    @staticmethod
    def max(tree: 'RedBlackTree.Tree'[_max__A, _max__B]) -> scala.Option[scala.Tuple2[_max__A, _max__B]]: ...
    _maxBefore__A = typing.TypeVar('_maxBefore__A')  # <A>
    _maxBefore__B = typing.TypeVar('_maxBefore__B')  # <B>
    @staticmethod
    def maxBefore(tree: 'RedBlackTree.Tree'[_maxBefore__A, _maxBefore__B], key: _maxBefore__A, ord: scala.math.Ordering[_maxBefore__A]) -> scala.Option[scala.Tuple2[_maxBefore__A, _maxBefore__B]]: ...
    _maxKey__A = typing.TypeVar('_maxKey__A')  # <A>
    @staticmethod
    def maxKey(tree: 'RedBlackTree.Tree'[_maxKey__A, typing.Any]) -> scala.Option[_maxKey__A]: ...
    _maxKeyBefore__A = typing.TypeVar('_maxKeyBefore__A')  # <A>
    @staticmethod
    def maxKeyBefore(tree: 'RedBlackTree.Tree'[_maxKeyBefore__A, typing.Any], key: _maxKeyBefore__A, ord: scala.math.Ordering[_maxKeyBefore__A]) -> scala.Option[_maxKeyBefore__A]: ...
    _maxNodeNonNull__A = typing.TypeVar('_maxNodeNonNull__A')  # <A>
    _maxNodeNonNull__B = typing.TypeVar('_maxNodeNonNull__B')  # <B>
    @staticmethod
    def maxNodeNonNull(node: 'RedBlackTree.Node'[_maxNodeNonNull__A, _maxNodeNonNull__B]) -> 'RedBlackTree.Node'[_maxNodeNonNull__A, _maxNodeNonNull__B]: ...
    _min__A = typing.TypeVar('_min__A')  # <A>
    _min__B = typing.TypeVar('_min__B')  # <B>
    @staticmethod
    def min(tree: 'RedBlackTree.Tree'[_min__A, _min__B]) -> scala.Option[scala.Tuple2[_min__A, _min__B]]: ...
    _minAfter__A = typing.TypeVar('_minAfter__A')  # <A>
    _minAfter__B = typing.TypeVar('_minAfter__B')  # <B>
    @staticmethod
    def minAfter(tree: 'RedBlackTree.Tree'[_minAfter__A, _minAfter__B], key: _minAfter__A, ord: scala.math.Ordering[_minAfter__A]) -> scala.Option[scala.Tuple2[_minAfter__A, _minAfter__B]]: ...
    _minKey__A = typing.TypeVar('_minKey__A')  # <A>
    @staticmethod
    def minKey(tree: 'RedBlackTree.Tree'[_minKey__A, typing.Any]) -> scala.Option[_minKey__A]: ...
    _minKeyAfter__A = typing.TypeVar('_minKeyAfter__A')  # <A>
    @staticmethod
    def minKeyAfter(tree: 'RedBlackTree.Tree'[_minKeyAfter__A, typing.Any], key: _minKeyAfter__A, ord: scala.math.Ordering[_minKeyAfter__A]) -> scala.Option[_minKeyAfter__A]: ...
    _minNodeNonNull__A = typing.TypeVar('_minNodeNonNull__A')  # <A>
    _minNodeNonNull__B = typing.TypeVar('_minNodeNonNull__B')  # <B>
    @staticmethod
    def minNodeNonNull(node: 'RedBlackTree.Node'[_minNodeNonNull__A, _minNodeNonNull__B]) -> 'RedBlackTree.Node'[_minNodeNonNull__A, _minNodeNonNull__B]: ...
    @typing.overload
    @staticmethod
    def size(node: 'RedBlackTree.Node'[typing.Any, typing.Any]) -> int: ...
    @typing.overload
    @staticmethod
    def size(tree: 'RedBlackTree.Tree'[typing.Any, typing.Any]) -> int: ...
    _transform__A = typing.TypeVar('_transform__A')  # <A>
    _transform__B = typing.TypeVar('_transform__B')  # <B>
    @staticmethod
    def transform(tree: 'RedBlackTree.Tree'[_transform__A, _transform__B], f: scala.Function2[_transform__A, _transform__B, _transform__B]) -> None: ...
    _valuesIterator__A = typing.TypeVar('_valuesIterator__A')  # <A>
    _valuesIterator__B = typing.TypeVar('_valuesIterator__B')  # <B>
    @staticmethod
    def valuesIterator(tree: 'RedBlackTree.Tree'[_valuesIterator__A, _valuesIterator__B], start: scala.Option[_valuesIterator__A], end: scala.Option[_valuesIterator__A], evidence$5: scala.math.Ordering[_valuesIterator__A]) -> scala.collection.Iterator[_valuesIterator__B]: ...
    _valuesIterator$default$2__A = typing.TypeVar('_valuesIterator$default$2__A')  # <A>
    _valuesIterator$default$2__B = typing.TypeVar('_valuesIterator$default$2__B')  # <B>
    @staticmethod
    def valuesIterator$default$2() -> scala.None.: ...
    _valuesIterator$default$3__A = typing.TypeVar('_valuesIterator$default$3__A')  # <A>
    _valuesIterator$default$3__B = typing.TypeVar('_valuesIterator$default$3__B')  # <B>
    @staticmethod
    def valuesIterator$default$3() -> scala.None.: ...
    class EntriesIterator(scala.collection.mutable.RedBlackTree.TreeIterator[_RedBlackTree__EntriesIterator__A, _RedBlackTree__EntriesIterator__B, scala.Tuple2[_RedBlackTree__EntriesIterator__A, _RedBlackTree__EntriesIterator__B]], typing.Generic[_RedBlackTree__EntriesIterator__A, _RedBlackTree__EntriesIterator__B]):
        def __init__(self, tree: 'RedBlackTree.Tree'[_RedBlackTree__EntriesIterator__A, _RedBlackTree__EntriesIterator__B], start: scala.Option[_RedBlackTree__EntriesIterator__A], end: scala.Option[_RedBlackTree__EntriesIterator__A], evidence$6: scala.math.Ordering[_RedBlackTree__EntriesIterator__A]): ...
        def nextResult(self, node: 'RedBlackTree.Node'[_RedBlackTree__EntriesIterator__A, _RedBlackTree__EntriesIterator__B]) -> scala.Tuple2[_RedBlackTree__EntriesIterator__A, _RedBlackTree__EntriesIterator__B]: ...
    class KeysIterator(scala.collection.mutable.RedBlackTree.TreeIterator[_RedBlackTree__KeysIterator__A, _RedBlackTree__KeysIterator__B, _RedBlackTree__KeysIterator__A], typing.Generic[_RedBlackTree__KeysIterator__A, _RedBlackTree__KeysIterator__B]):
        def __init__(self, tree: 'RedBlackTree.Tree'[_RedBlackTree__KeysIterator__A, _RedBlackTree__KeysIterator__B], start: scala.Option[_RedBlackTree__KeysIterator__A], end: scala.Option[_RedBlackTree__KeysIterator__A], evidence$7: scala.math.Ordering[_RedBlackTree__KeysIterator__A]): ...
        def nextResult(self, node: 'RedBlackTree.Node'[_RedBlackTree__KeysIterator__A, _RedBlackTree__KeysIterator__B]) -> _RedBlackTree__KeysIterator__A: ...
    class Node(scala.Serializable, typing.Generic[_RedBlackTree__Node__A, _RedBlackTree__Node__B]):
        serialVersionUID: typing.ClassVar[int] = ...
        def __init__(self, key: _RedBlackTree__Node__A, value: _RedBlackTree__Node__B, red: bool, left: 'RedBlackTree.Node'[_RedBlackTree__Node__A, _RedBlackTree__Node__B], right: 'RedBlackTree.Node'[_RedBlackTree__Node__A, _RedBlackTree__Node__B], parent: 'RedBlackTree.Node'[_RedBlackTree__Node__A, _RedBlackTree__Node__B]): ...
        def key(self) -> _RedBlackTree__Node__A: ...
        def key_$eq(self, x$1: _RedBlackTree__Node__A) -> None: ...
        def left(self) -> 'RedBlackTree.Node'[_RedBlackTree__Node__A, _RedBlackTree__Node__B]: ...
        def left_$eq(self, x$1: 'RedBlackTree.Node'[_RedBlackTree__Node__A, _RedBlackTree__Node__B]) -> None: ...
        def parent(self) -> 'RedBlackTree.Node'[_RedBlackTree__Node__A, _RedBlackTree__Node__B]: ...
        def parent_$eq(self, x$1: 'RedBlackTree.Node'[_RedBlackTree__Node__A, _RedBlackTree__Node__B]) -> None: ...
        def red(self) -> bool: ...
        def red_$eq(self, x$1: bool) -> None: ...
        def right(self) -> 'RedBlackTree.Node'[_RedBlackTree__Node__A, _RedBlackTree__Node__B]: ...
        def right_$eq(self, x$1: 'RedBlackTree.Node'[_RedBlackTree__Node__A, _RedBlackTree__Node__B]) -> None: ...
        def toString(self) -> str: ...
        def value(self) -> _RedBlackTree__Node__B: ...
        def value_$eq(self, x$1: _RedBlackTree__Node__B) -> None: ...
    class Node$(scala.Serializable):
        MODULE$: typing.ClassVar['RedBlackTree.Node.'] = ...
        def __init__(self): ...
        _apply__A = typing.TypeVar('_apply__A')  # <A>
        _apply__B = typing.TypeVar('_apply__B')  # <B>
        def apply(self, key: _apply__A, value: _apply__B, red: bool, left: 'RedBlackTree.Node'[_apply__A, _apply__B], right: 'RedBlackTree.Node'[_apply__A, _apply__B], parent: 'RedBlackTree.Node'[_apply__A, _apply__B]) -> 'RedBlackTree.Node'[_apply__A, _apply__B]: ...
        _leaf__A = typing.TypeVar('_leaf__A')  # <A>
        _leaf__B = typing.TypeVar('_leaf__B')  # <B>
        def leaf(self, key: _leaf__A, value: _leaf__B, red: bool, parent: 'RedBlackTree.Node'[_leaf__A, _leaf__B]) -> 'RedBlackTree.Node'[_leaf__A, _leaf__B]: ...
        _unapply__A = typing.TypeVar('_unapply__A')  # <A>
        _unapply__B = typing.TypeVar('_unapply__B')  # <B>
        def unapply(self, t: 'RedBlackTree.Node'[_unapply__A, _unapply__B]) -> scala.Some[scala.Tuple5[_unapply__A, _unapply__B, 'RedBlackTree.Node'[_unapply__A, _unapply__B], 'RedBlackTree.Node'[_unapply__A, _unapply__B], 'RedBlackTree.Node'[_unapply__A, _unapply__B]]]: ...
    class Tree(scala.Serializable, typing.Generic[_RedBlackTree__Tree__A, _RedBlackTree__Tree__B]):
        serialVersionUID: typing.ClassVar[int] = ...
        def __init__(self, root: 'RedBlackTree.Node'[_RedBlackTree__Tree__A, _RedBlackTree__Tree__B], size: int): ...
        def root(self) -> 'RedBlackTree.Node'[_RedBlackTree__Tree__A, _RedBlackTree__Tree__B]: ...
        def root_$eq(self, x$1: 'RedBlackTree.Node'[_RedBlackTree__Tree__A, _RedBlackTree__Tree__B]) -> None: ...
        def size(self) -> int: ...
        def size_$eq(self, x$1: int) -> None: ...
    class Tree$(scala.Serializable):
        MODULE$: typing.ClassVar['RedBlackTree.Tree.'] = ...
        def __init__(self): ...
        _empty__A = typing.TypeVar('_empty__A')  # <A>
        _empty__B = typing.TypeVar('_empty__B')  # <B>
        def empty(self) -> 'RedBlackTree.Tree'[_empty__A, _empty__B]: ...
    class TreeIterator(scala.collection.Iterator[_RedBlackTree__TreeIterator__R], typing.Generic[_RedBlackTree__TreeIterator__A, _RedBlackTree__TreeIterator__B, _RedBlackTree__TreeIterator__R]):
        def __init__(self, tree: 'RedBlackTree.Tree'[_RedBlackTree__TreeIterator__A, _RedBlackTree__TreeIterator__B], start: scala.Option[_RedBlackTree__TreeIterator__A], end: scala.Option[_RedBlackTree__TreeIterator__A], ord: scala.math.Ordering[_RedBlackTree__TreeIterator__A]): ...
        _$colon$bslash__B = typing.TypeVar('_$colon$bslash__B')  # <B>
        def $colon$bslash(self, z: typing.Any, op: scala.Function2[_RedBlackTree__TreeIterator__R, typing.Any, typing.Any]) -> typing.Any: ...
        _$div$colon__B = typing.TypeVar('_$div$colon__B')  # <B>
        def $div$colon(self, z: typing.Any, op: scala.Function2[typing.Any, _RedBlackTree__TreeIterator__R, typing.Any]) -> typing.Any: ...
        _$plus$plus__B = typing.TypeVar('_$plus$plus__B')  # <B>
        def $plus$plus(self, that: scala.Function0[scala.collection.GenTraversableOnce[typing.Any]]) -> scala.collection.Iterator[typing.Any]: ...
        @typing.overload
        def addString(self, b: StringBuilder) -> StringBuilder: ...
        @typing.overload
        def addString(self, b: StringBuilder, sep: str) -> StringBuilder: ...
        @typing.overload
        def addString(self, b: StringBuilder, start: str, sep: str, end: str) -> StringBuilder: ...
        _aggregate__B = typing.TypeVar('_aggregate__B')  # <B>
        def aggregate(self, z: scala.Function0[typing.Any], seqop: scala.Function2[typing.Any, _RedBlackTree__TreeIterator__R, typing.Any], combop: scala.Function2[typing.Any, typing.Any, typing.Any]) -> typing.Any: ...
        def buffered(self) -> scala.collection.BufferedIterator[_RedBlackTree__TreeIterator__R]: ...
        _collect__B = typing.TypeVar('_collect__B')  # <B>
        def collect(self, pf: scala.PartialFunction[_RedBlackTree__TreeIterator__R, typing.Any]) -> scala.collection.Iterator[typing.Any]: ...
        _collectFirst__B = typing.TypeVar('_collectFirst__B')  # <B>
        def collectFirst(self, pf: scala.PartialFunction[_RedBlackTree__TreeIterator__R, typing.Any]) -> scala.Option[typing.Any]: ...
        def contains(self, elem: typing.Any) -> bool: ...
        _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
        _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
        _copyToArray_2__B = typing.TypeVar('_copyToArray_2__B')  # <B>
        @typing.overload
        def copyToArray(self, xs: typing.Any) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
        _copyToBuffer__B = typing.TypeVar('_copyToBuffer__B')  # <B>
        def copyToBuffer(self, dest: Buffer[typing.Any]) -> None: ...
        _corresponds__B = typing.TypeVar('_corresponds__B')  # <B>
        def corresponds(self, that: scala.collection.GenTraversableOnce[typing.Any], p: scala.Function2[_RedBlackTree__TreeIterator__R, typing.Any, typing.Any]) -> bool: ...
        def count(self, p: scala.Function1[_RedBlackTree__TreeIterator__R, typing.Any]) -> int: ...
        def drop(self, n: int) -> scala.collection.Iterator[_RedBlackTree__TreeIterator__R]: ...
        def dropWhile(self, p: scala.Function1[_RedBlackTree__TreeIterator__R, typing.Any]) -> scala.collection.Iterator[_RedBlackTree__TreeIterator__R]: ...
        def duplicate(self) -> scala.Tuple2[scala.collection.Iterator[_RedBlackTree__TreeIterator__R], scala.collection.Iterator[_RedBlackTree__TreeIterator__R]]: ...
        def exists(self, p: scala.Function1[_RedBlackTree__TreeIterator__R, typing.Any]) -> bool: ...
        def filter(self, p: scala.Function1[_RedBlackTree__TreeIterator__R, typing.Any]) -> scala.collection.Iterator[_RedBlackTree__TreeIterator__R]: ...
        def filterNot(self, p: scala.Function1[_RedBlackTree__TreeIterator__R, typing.Any]) -> scala.collection.Iterator[_RedBlackTree__TreeIterator__R]: ...
        def find(self, p: scala.Function1[_RedBlackTree__TreeIterator__R, typing.Any]) -> scala.Option[_RedBlackTree__TreeIterator__R]: ...
        _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
        def flatMap(self, f: scala.Function1[_RedBlackTree__TreeIterator__R, scala.collection.GenTraversableOnce[typing.Any]]) -> scala.collection.Iterator[typing.Any]: ...
        _fold__A1 = typing.TypeVar('_fold__A1')  # <A1>
        def fold(self, z: _fold__A1, op: scala.Function2[_fold__A1, _fold__A1, _fold__A1]) -> _fold__A1: ...
        _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
        def foldLeft(self, z: typing.Any, op: scala.Function2[typing.Any, _RedBlackTree__TreeIterator__R, typing.Any]) -> typing.Any: ...
        _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
        def foldRight(self, z: typing.Any, op: scala.Function2[_RedBlackTree__TreeIterator__R, typing.Any, typing.Any]) -> typing.Any: ...
        def forall(self, p: scala.Function1[_RedBlackTree__TreeIterator__R, typing.Any]) -> bool: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[_RedBlackTree__TreeIterator__R, _foreach__U]) -> None: ...
        _grouped__B = typing.TypeVar('_grouped__B')  # <B>
        def grouped(self, size: int) -> scala.collection.Iterator.GroupedIterator[typing.Any]: ...
        def hasDefiniteSize(self) -> bool: ...
        def hasNext(self) -> bool: ...
        _indexOf_0__B = typing.TypeVar('_indexOf_0__B')  # <B>
        _indexOf_1__B = typing.TypeVar('_indexOf_1__B')  # <B>
        @typing.overload
        def indexOf(self, elem: typing.Any) -> int: ...
        @typing.overload
        def indexOf(self, elem: typing.Any, from_: int) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[_RedBlackTree__TreeIterator__R, typing.Any]) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[_RedBlackTree__TreeIterator__R, typing.Any], from_: int) -> int: ...
        def isEmpty(self) -> bool: ...
        def isTraversableAgain(self) -> bool: ...
        def length(self) -> int: ...
        _map__B = typing.TypeVar('_map__B')  # <B>
        def map(self, f: scala.Function1[_RedBlackTree__TreeIterator__R, typing.Any]) -> scala.collection.Iterator[typing.Any]: ...
        _max__B = typing.TypeVar('_max__B')  # <B>
        def max(self, cmp: scala.math.Ordering[typing.Any]) -> _RedBlackTree__TreeIterator__R: ...
        _maxBy__B = typing.TypeVar('_maxBy__B')  # <B>
        def maxBy(self, f: scala.Function1[_RedBlackTree__TreeIterator__R, typing.Any], cmp: scala.math.Ordering[typing.Any]) -> _RedBlackTree__TreeIterator__R: ...
        _min__B = typing.TypeVar('_min__B')  # <B>
        def min(self, cmp: scala.math.Ordering[typing.Any]) -> _RedBlackTree__TreeIterator__R: ...
        _minBy__B = typing.TypeVar('_minBy__B')  # <B>
        def minBy(self, f: scala.Function1[_RedBlackTree__TreeIterator__R, typing.Any], cmp: scala.math.Ordering[typing.Any]) -> _RedBlackTree__TreeIterator__R: ...
        @typing.overload
        def mkString(self) -> str: ...
        @typing.overload
        def mkString(self, sep: str) -> str: ...
        @typing.overload
        def mkString(self, start: str, sep: str, end: str) -> str: ...
        def next(self) -> _RedBlackTree__TreeIterator__R: ...
        def nextResult(self, node: 'RedBlackTree.Node'[_RedBlackTree__TreeIterator__A, _RedBlackTree__TreeIterator__B]) -> _RedBlackTree__TreeIterator__R: ...
        def nonEmpty(self) -> bool: ...
        _padTo__A1 = typing.TypeVar('_padTo__A1')  # <A1>
        def padTo(self, len: int, elem: _padTo__A1) -> scala.collection.Iterator[_padTo__A1]: ...
        def partition(self, p: scala.Function1[_RedBlackTree__TreeIterator__R, typing.Any]) -> scala.Tuple2[scala.collection.Iterator[_RedBlackTree__TreeIterator__R], scala.collection.Iterator[_RedBlackTree__TreeIterator__R]]: ...
        _patch__B = typing.TypeVar('_patch__B')  # <B>
        def patch(self, from_: int, patchElems: scala.collection.Iterator[typing.Any], replaced: int) -> scala.collection.Iterator[typing.Any]: ...
        _product__B = typing.TypeVar('_product__B')  # <B>
        def product(self, num: scala.math.Numeric[typing.Any]) -> typing.Any: ...
        _reduce__A1 = typing.TypeVar('_reduce__A1')  # <A1>
        def reduce(self, op: scala.Function2[_reduce__A1, _reduce__A1, _reduce__A1]) -> _reduce__A1: ...
        _reduceLeft__B = typing.TypeVar('_reduceLeft__B')  # <B>
        def reduceLeft(self, op: scala.Function2[typing.Any, _RedBlackTree__TreeIterator__R, typing.Any]) -> typing.Any: ...
        _reduceLeftOption__B = typing.TypeVar('_reduceLeftOption__B')  # <B>
        def reduceLeftOption(self, op: scala.Function2[typing.Any, _RedBlackTree__TreeIterator__R, typing.Any]) -> scala.Option[typing.Any]: ...
        _reduceOption__A1 = typing.TypeVar('_reduceOption__A1')  # <A1>
        def reduceOption(self, op: scala.Function2[_reduceOption__A1, _reduceOption__A1, _reduceOption__A1]) -> scala.Option[_reduceOption__A1]: ...
        _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
        def reduceRight(self, op: scala.Function2[_RedBlackTree__TreeIterator__R, typing.Any, typing.Any]) -> typing.Any: ...
        _reduceRightOption__B = typing.TypeVar('_reduceRightOption__B')  # <B>
        def reduceRightOption(self, op: scala.Function2[_RedBlackTree__TreeIterator__R, typing.Any, typing.Any]) -> scala.Option[typing.Any]: ...
        def reversed(self) -> scala.collection.immutable.List[_RedBlackTree__TreeIterator__R]: ...
        def sameElements(self, that: scala.collection.Iterator[typing.Any]) -> bool: ...
        _scanLeft__B = typing.TypeVar('_scanLeft__B')  # <B>
        def scanLeft(self, z: typing.Any, op: scala.Function2[typing.Any, _RedBlackTree__TreeIterator__R, typing.Any]) -> scala.collection.Iterator[typing.Any]: ...
        _scanRight__B = typing.TypeVar('_scanRight__B')  # <B>
        def scanRight(self, z: typing.Any, op: scala.Function2[_RedBlackTree__TreeIterator__R, typing.Any, typing.Any]) -> scala.collection.Iterator[typing.Any]: ...
        def seq(self) -> scala.collection.Iterator[_RedBlackTree__TreeIterator__R]: ...
        def size(self) -> int: ...
        def sizeHintIfCheap(self) -> int: ...
        def slice(self, from_: int, until: int) -> scala.collection.Iterator[_RedBlackTree__TreeIterator__R]: ...
        def sliceIterator(self, from_: int, until: int) -> scala.collection.Iterator[_RedBlackTree__TreeIterator__R]: ...
        _sliding__B = typing.TypeVar('_sliding__B')  # <B>
        def sliding(self, size: int, step: int) -> scala.collection.Iterator.GroupedIterator[typing.Any]: ...
        _sliding$default$2__B = typing.TypeVar('_sliding$default$2__B')  # <B>
        def sliding$default$2(self) -> int: ...
        def span(self, p: scala.Function1[_RedBlackTree__TreeIterator__R, typing.Any]) -> scala.Tuple2[scala.collection.Iterator[_RedBlackTree__TreeIterator__R], scala.collection.Iterator[_RedBlackTree__TreeIterator__R]]: ...
        _sum__B = typing.TypeVar('_sum__B')  # <B>
        def sum(self, num: scala.math.Numeric[typing.Any]) -> typing.Any: ...
        def take(self, n: int) -> scala.collection.Iterator[_RedBlackTree__TreeIterator__R]: ...
        def takeWhile(self, p: scala.Function1[_RedBlackTree__TreeIterator__R, typing.Any]) -> scala.collection.Iterator[_RedBlackTree__TreeIterator__R]: ...
        _to__Col = typing.TypeVar('_to__Col')  # <Col>
        def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., _RedBlackTree__TreeIterator__R, _to__Col]) -> _to__Col: ...
        _toArray__B = typing.TypeVar('_toArray__B')  # <B>
        def toArray(self, evidence$1: scala.reflect.ClassTag[typing.Any]) -> typing.Any: ...
        _toBuffer__B = typing.TypeVar('_toBuffer__B')  # <B>
        def toBuffer(self) -> Buffer[typing.Any]: ...
        def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq[_RedBlackTree__TreeIterator__R]: ...
        def toIterable(self) -> scala.collection.Iterable[_RedBlackTree__TreeIterator__R]: ...
        def toIterator(self) -> scala.collection.Iterator[_RedBlackTree__TreeIterator__R]: ...
        def toList(self) -> scala.collection.immutable.List[_RedBlackTree__TreeIterator__R]: ...
        _toMap__T = typing.TypeVar('_toMap__T')  # <T>
        _toMap__U = typing.TypeVar('_toMap__U')  # <U>
        def toMap(self, ev: scala.Predef..less.colon.less[_RedBlackTree__TreeIterator__R, scala.Tuple2[_toMap__T, _toMap__U]]) -> scala.collection.immutable.Map[_toMap__T, _toMap__U]: ...
        def toSeq(self) -> scala.collection.Seq[_RedBlackTree__TreeIterator__R]: ...
        _toSet__B = typing.TypeVar('_toSet__B')  # <B>
        def toSet(self) -> scala.collection.immutable.Set[typing.Any]: ...
        def toStream(self) -> scala.collection.immutable.Stream[_RedBlackTree__TreeIterator__R]: ...
        def toString(self) -> str: ...
        def toTraversable(self) -> scala.collection.Traversable[_RedBlackTree__TreeIterator__R]: ...
        def toVector(self) -> scala.collection.immutable.Vector[_RedBlackTree__TreeIterator__R]: ...
        def withFilter(self, p: scala.Function1[_RedBlackTree__TreeIterator__R, typing.Any]) -> scala.collection.Iterator[_RedBlackTree__TreeIterator__R]: ...
        _zip__B = typing.TypeVar('_zip__B')  # <B>
        def zip(self, that: scala.collection.Iterator[typing.Any]) -> scala.collection.Iterator[scala.Tuple2[_RedBlackTree__TreeIterator__R, typing.Any]]: ...
        _zipAll__B = typing.TypeVar('_zipAll__B')  # <B>
        _zipAll__A1 = typing.TypeVar('_zipAll__A1')  # <A1>
        _zipAll__B1 = typing.TypeVar('_zipAll__B1')  # <B1>
        def zipAll(self, that: scala.collection.Iterator[typing.Any], thisElem: _zipAll__A1, thatElem: _zipAll__B1) -> scala.collection.Iterator[scala.Tuple2[_zipAll__A1, _zipAll__B1]]: ...
        def zipWithIndex(self) -> scala.collection.Iterator[scala.Tuple2[_RedBlackTree__TreeIterator__R, typing.Any]]: ...
    class ValuesIterator(scala.collection.mutable.RedBlackTree.TreeIterator[_RedBlackTree__ValuesIterator__A, _RedBlackTree__ValuesIterator__B, _RedBlackTree__ValuesIterator__B], typing.Generic[_RedBlackTree__ValuesIterator__A, _RedBlackTree__ValuesIterator__B]):
        def __init__(self, tree: 'RedBlackTree.Tree'[_RedBlackTree__ValuesIterator__A, _RedBlackTree__ValuesIterator__B], start: scala.Option[_RedBlackTree__ValuesIterator__A], end: scala.Option[_RedBlackTree__ValuesIterator__A], evidence$8: scala.math.Ordering[_RedBlackTree__ValuesIterator__A]): ...
        def nextResult(self, node: 'RedBlackTree.Node'[_RedBlackTree__ValuesIterator__A, _RedBlackTree__ValuesIterator__B]) -> _RedBlackTree__ValuesIterator__B: ...

_SortedMap__A = typing.TypeVar('_SortedMap__A')  # <A>
_SortedMap__B = typing.TypeVar('_SortedMap__B')  # <B>
class SortedMap(Map[_SortedMap__A, _SortedMap__B], scala.collection.SortedMap[_SortedMap__A, _SortedMap__B], typing.Generic[_SortedMap__A, _SortedMap__B]):
    @staticmethod
    def $init$($this: 'SortedMap') -> None: ...
    _$plus_0__V1 = typing.TypeVar('_$plus_0__V1')  # <V1>
    _$plus_1__V1 = typing.TypeVar('_$plus_1__V1')  # <V1>
    _$plus_2__B1 = typing.TypeVar('_$plus_2__B1')  # <B1>
    _$plus_3__V1 = typing.TypeVar('_$plus_3__V1')  # <V1>
    _$plus_4__B1 = typing.TypeVar('_$plus_4__B1')  # <B1>
    _$plus_5__V1 = typing.TypeVar('_$plus_5__V1')  # <V1>
    _$plus_6__V1 = typing.TypeVar('_$plus_6__V1')  # <V1>
    _$plus_7__B1 = typing.TypeVar('_$plus_7__B1')  # <B1>
    _$plus_8__B1 = typing.TypeVar('_$plus_8__B1')  # <B1>
    @typing.overload
    def $plus(self, kv: scala.Tuple2[typing.Any, _.plus_0__V1]) -> scala.collection.GenMap[typing.Any, _.plus_0__V1]: ...
    @typing.overload
    def $plus(self, kv: scala.Tuple2[typing.Any, _.plus_1__V1]) -> scala.collection.Map[typing.Any, _.plus_1__V1]: ...
    @typing.overload
    def $plus(self, kv: scala.Tuple2[_SortedMap__A, _.plus_2__B1]) -> scala.collection.SortedMap[_SortedMap__A, _.plus_2__B1]: ...
    @typing.overload
    def $plus(self, kv1: scala.Tuple2[typing.Any, _.plus_3__V1], kv2: scala.Tuple2[typing.Any, _.plus_3__V1], kvs: scala.collection.Seq[scala.Tuple2[typing.Any, _.plus_3__V1]]) -> scala.collection.Map[typing.Any, _.plus_3__V1]: ...
    @typing.overload
    def $plus(self, elem1: scala.Tuple2[_SortedMap__A, _.plus_4__B1], elem2: scala.Tuple2[_SortedMap__A, _.plus_4__B1], elems: scala.collection.Seq[scala.Tuple2[_SortedMap__A, _.plus_4__B1]]) -> scala.collection.SortedMap[_SortedMap__A, _.plus_4__B1]: ...
    @typing.overload
    def $plus(self, kv: scala.Tuple2[typing.Any, _.plus_5__V1]) -> Map[typing.Any, _.plus_5__V1]: ...
    @typing.overload
    def $plus(self, elem1: scala.Tuple2[typing.Any, _.plus_6__V1], elem2: scala.Tuple2[typing.Any, _.plus_6__V1], elems: scala.collection.Seq[scala.Tuple2[typing.Any, _.plus_6__V1]]) -> Map[typing.Any, _.plus_6__V1]: ...
    @typing.overload
    def $plus(self, kv: scala.Tuple2[_SortedMap__A, _.plus_7__B1]) -> 'SortedMap'[_SortedMap__A, _.plus_7__B1]: ...
    @typing.overload
    def $plus(self, elem1: scala.Tuple2[_SortedMap__A, _.plus_8__B1], elem2: scala.Tuple2[_SortedMap__A, _.plus_8__B1], elems: scala.collection.Seq[scala.Tuple2[_SortedMap__A, _.plus_8__B1]]) -> 'SortedMap'[_SortedMap__A, _.plus_8__B1]: ...
    _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
    _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
    _$plus$plus_1__V1 = typing.TypeVar('_$plus$plus_1__V1')  # <V1>
    _$plus$plus_2__B1 = typing.TypeVar('_$plus$plus_2__B1')  # <B1>
    _$plus$plus_3__V1 = typing.TypeVar('_$plus$plus_3__V1')  # <V1>
    _$plus$plus_4__B1 = typing.TypeVar('_$plus$plus_4__B1')  # <B1>
    @typing.overload
    def $plus$plus(self, that: scala.collection.GenTraversableOnce[typing.Any], bf: scala.collection.generic.CanBuildFrom[typing.Any, typing.Any, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
    @typing.overload
    def $plus$plus(self, xs: scala.collection.GenTraversableOnce[scala.Tuple2[typing.Any, _.plus.plus_1__V1]]) -> scala.collection.Map[typing.Any, _.plus.plus_1__V1]: ...
    @typing.overload
    def $plus$plus(self, xs: scala.collection.GenTraversableOnce[scala.Tuple2[_SortedMap__A, _.plus.plus_2__B1]]) -> scala.collection.SortedMap[_SortedMap__A, _.plus.plus_2__B1]: ...
    @typing.overload
    def $plus$plus(self, xs: scala.collection.GenTraversableOnce[scala.Tuple2[typing.Any, _.plus.plus_3__V1]]) -> Map[typing.Any, _.plus.plus_3__V1]: ...
    @typing.overload
    def $plus$plus(self, xs: scala.collection.GenTraversableOnce[scala.Tuple2[_SortedMap__A, _.plus.plus_4__B1]]) -> 'SortedMap'[_SortedMap__A, _.plus.plus_4__B1]: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    _canBuildFrom__B = typing.TypeVar('_canBuildFrom__B')  # <B>
    @staticmethod
    def canBuildFrom(ord: scala.math.Ordering[_canBuildFrom__A]) -> scala.collection.generic.CanBuildFrom['SortedMap'[typing.Any, typing.Any], scala.Tuple2[_canBuildFrom__A, _canBuildFrom__B], 'SortedMap'[_canBuildFrom__A, _canBuildFrom__B]]: ...
    @typing.overload
    def empty(self) -> scala.collection.Map[typing.Any, typing.Any]: ...
    @typing.overload
    def empty(self) -> scala.collection.SortedMap[_SortedMap__A, _SortedMap__B]: ...
    @typing.overload
    def empty(self) -> Map[typing.Any, typing.Any]: ...
    @typing.overload
    def empty(self) -> 'SortedMap'[_SortedMap__A, _SortedMap__B]: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def newBuilder(self) -> Builder[scala.Tuple2[_SortedMap__A, _SortedMap__B], 'SortedMap'[_SortedMap__A, _SortedMap__B]]: ...
    def toString(self) -> str: ...
    _updated_0__V1 = typing.TypeVar('_updated_0__V1')  # <V1>
    _updated_1__V1 = typing.TypeVar('_updated_1__V1')  # <V1>
    _updated_2__B1 = typing.TypeVar('_updated_2__B1')  # <B1>
    _updated_3__V1 = typing.TypeVar('_updated_3__V1')  # <V1>
    _updated_4__B1 = typing.TypeVar('_updated_4__B1')  # <B1>
    @typing.overload
    def updated(self, key: typing.Any, value: _updated_0__V1) -> scala.collection.GenMap[typing.Any, _updated_0__V1]: ...
    @typing.overload
    def updated(self, key: typing.Any, value: _updated_1__V1) -> scala.collection.Map[typing.Any, _updated_1__V1]: ...
    @typing.overload
    def updated(self, key: _SortedMap__A, value: _updated_2__B1) -> scala.collection.SortedMap[_SortedMap__A, _updated_2__B1]: ...
    @typing.overload
    def updated(self, key: typing.Any, value: _updated_3__V1) -> Map[typing.Any, _updated_3__V1]: ...
    @typing.overload
    def updated(self, key: _SortedMap__A, value: _updated_4__B1) -> 'SortedMap'[_SortedMap__A, _updated_4__B1]: ...

_SynchronizedMap__A = typing.TypeVar('_SynchronizedMap__A')  # <A>
_SynchronizedMap__B = typing.TypeVar('_SynchronizedMap__B')  # <B>
class SynchronizedMap(Map[_SynchronizedMap__A, _SynchronizedMap__B], typing.Generic[_SynchronizedMap__A, _SynchronizedMap__B]):
    @staticmethod
    def $init$($this: 'SynchronizedMap') -> None: ...
    @typing.overload
    def $minus$eq(self, elem: _SynchronizedMap__A) -> scala.collection.generic.Shrinkable[_SynchronizedMap__A]: ...
    @typing.overload
    def $minus$eq(self, key: typing.Any) -> MapLike[typing.Any, typing.Any, MapLike]: ...
    @typing.overload
    def $minus$eq(self, elem1: _SynchronizedMap__A, elem2: _SynchronizedMap__A, elems: scala.collection.Seq[_SynchronizedMap__A]) -> scala.collection.generic.Shrinkable[_SynchronizedMap__A]: ...
    @typing.overload
    def $minus$eq(self, key: _SynchronizedMap__A) -> 'SynchronizedMap'[_SynchronizedMap__A, _SynchronizedMap__B]: ...
    @typing.overload
    def $plus$eq(self, elem: _SynchronizedMap__A) -> scala.collection.generic.Growable[_SynchronizedMap__A]: ...
    @typing.overload
    def $plus$eq(self, elem: typing.Any) -> Builder[typing.Any, typing.Any]: ...
    @typing.overload
    def $plus$eq(self, kv: scala.Tuple2[typing.Any, typing.Any]) -> MapLike[typing.Any, typing.Any, MapLike]: ...
    @typing.overload
    def $plus$eq(self, elem1: _SynchronizedMap__A, elem2: _SynchronizedMap__A, elems: scala.collection.Seq[_SynchronizedMap__A]) -> scala.collection.generic.Growable[_SynchronizedMap__A]: ...
    @typing.overload
    def $plus$eq(self, kv: scala.Tuple2[_SynchronizedMap__A, _SynchronizedMap__B]) -> 'SynchronizedMap'[_SynchronizedMap__A, _SynchronizedMap__B]: ...
    def apply(self, key: _SynchronizedMap__A) -> _SynchronizedMap__B: ...
    def clear(self) -> None: ...
    @typing.overload
    def clone(self) -> _SynchronizedMap__A: ...
    @typing.overload
    def clone(self) -> Map[_SynchronizedMap__A, _SynchronizedMap__B]: ...
    def contains(self, key: _SynchronizedMap__A) -> bool: ...
    def equals(self, that: typing.Any) -> bool: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[scala.Tuple2[_SynchronizedMap__A, _SynchronizedMap__B], _foreach__U]) -> None: ...
    def get(self, key: _SynchronizedMap__A) -> scala.Option[_SynchronizedMap__B]: ...
    def getOrElseUpdate(self, key: _SynchronizedMap__A, default: scala.Function0[_SynchronizedMap__B]) -> _SynchronizedMap__B: ...
    def hashCode(self) -> int: ...
    def isDefinedAt(self, key: _SynchronizedMap__A) -> bool: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> scala.collection.Iterator[scala.Tuple2[_SynchronizedMap__A, _SynchronizedMap__B]]: ...
    @typing.overload
    def keySet(self) -> scala.collection.GenSet[typing.Any]: ...
    @typing.overload
    def keySet(self) -> scala.collection.Set[_SynchronizedMap__A]: ...
    @typing.overload
    def keys(self) -> scala.collection.GenIterable[typing.Any]: ...
    @typing.overload
    def keys(self) -> scala.collection.Iterable[_SynchronizedMap__A]: ...
    def keysIterator(self) -> scala.collection.Iterator[_SynchronizedMap__A]: ...
    def put(self, key: _SynchronizedMap__A, value: _SynchronizedMap__B) -> scala.Option[_SynchronizedMap__B]: ...
    def remove(self, key: _SynchronizedMap__A) -> scala.Option[_SynchronizedMap__B]: ...
    @typing.overload
    def retain(self, p: scala.Function2[typing.Any, typing.Any, typing.Any]) -> MapLike[typing.Any, typing.Any, MapLike]: ...
    @typing.overload
    def retain(self, p: scala.Function2[_SynchronizedMap__A, _SynchronizedMap__B, typing.Any]) -> 'SynchronizedMap'[_SynchronizedMap__A, _SynchronizedMap__B]: ...
    def size(self) -> int: ...
    def toString(self) -> str: ...
    @typing.overload
    def transform(self, f: scala.Function2[typing.Any, typing.Any, typing.Any]) -> MapLike[typing.Any, typing.Any, MapLike]: ...
    @typing.overload
    def transform(self, f: scala.Function2[_SynchronizedMap__A, _SynchronizedMap__B, _SynchronizedMap__B]) -> 'SynchronizedMap'[_SynchronizedMap__A, _SynchronizedMap__B]: ...
    def update(self, key: _SynchronizedMap__A, value: _SynchronizedMap__B) -> None: ...
    @typing.overload
    def values(self) -> scala.collection.GenIterable[typing.Any]: ...
    @typing.overload
    def values(self) -> scala.collection.Iterable[_SynchronizedMap__B]: ...
    def valuesIterator(self) -> scala.collection.Iterator[_SynchronizedMap__B]: ...

_TreeMap__A = typing.TypeVar('_TreeMap__A')  # <A>
_TreeMap__B = typing.TypeVar('_TreeMap__B')  # <B>
class TreeMap(AbstractSortedMap[_TreeMap__A, _TreeMap__B], scala.Serializable, typing.Generic[_TreeMap__A, _TreeMap__B]):
    serialVersionUID: typing.ClassVar[int] = ...
    scala$collection$mutable$TreeMap$$tree: RedBlackTree.Tree = ...
    @typing.overload
    def __init__(self, tree: RedBlackTree.Tree[_TreeMap__A, _TreeMap__B], ordering: scala.math.Ordering[_TreeMap__A]): ...
    @typing.overload
    def __init__(self, ord: scala.math.Ordering[_TreeMap__A]): ...
    @typing.overload
    def $minus(self, key: typing.Any) -> Map[typing.Any, typing.Any]: ...
    @typing.overload
    def $minus(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> Map[typing.Any, typing.Any]: ...
    @typing.overload
    def $minus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> scala.collection.generic.Shrinkable[typing.Any]: ...
    @typing.overload
    def $minus$eq(self, key: _TreeMap__A) -> 'TreeMap'[_TreeMap__A, _TreeMap__B]: ...
    def $minus$minus(self, xs: scala.collection.GenTraversableOnce[typing.Any]) -> Map[typing.Any, typing.Any]: ...
    _$plus_0__B1 = typing.TypeVar('_$plus_0__B1')  # <B1>
    _$plus_1__B1 = typing.TypeVar('_$plus_1__B1')  # <B1>
    @typing.overload
    def $plus(self, kv: scala.Tuple2[_TreeMap__A, _.plus_0__B1]) -> SortedMap[_TreeMap__A, _.plus_0__B1]: ...
    @typing.overload
    def $plus(self, elem1: scala.Tuple2[_TreeMap__A, _.plus_1__B1], elem2: scala.Tuple2[_TreeMap__A, _.plus_1__B1], elems: scala.collection.Seq[scala.Tuple2[_TreeMap__A, _.plus_1__B1]]) -> SortedMap[_TreeMap__A, _.plus_1__B1]: ...
    @typing.overload
    def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq) -> scala.collection.generic.Growable: ...
    @typing.overload
    def $plus$eq(self, kv: scala.Tuple2[_TreeMap__A, _TreeMap__B]) -> 'TreeMap'[_TreeMap__A, _TreeMap__B]: ...
    _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
    _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
    _$plus$plus_1__B1 = typing.TypeVar('_$plus$plus_1__B1')  # <B1>
    @typing.overload
    def $plus$plus(self, that: scala.collection.GenTraversableOnce[typing.Any], bf: scala.collection.generic.CanBuildFrom[scala.collection.Traversable[_TreeMap__A], typing.Any, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
    @typing.overload
    def $plus$plus(self, xs: scala.collection.GenTraversableOnce[scala.Tuple2[_TreeMap__A, _.plus.plus_1__B1]]) -> SortedMap[_TreeMap__A, _.plus.plus_1__B1]: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    _canBuildFrom__B = typing.TypeVar('_canBuildFrom__B')  # <B>
    @staticmethod
    def canBuildFrom(ord: scala.math.Ordering[_canBuildFrom__A]) -> scala.collection.generic.CanBuildFrom['TreeMap'[typing.Any, typing.Any], scala.Tuple2[_canBuildFrom__A, _canBuildFrom__B], 'TreeMap'[_canBuildFrom__A, _canBuildFrom__B]]: ...
    def clear(self) -> None: ...
    def clone(self) -> Map[typing.Any, typing.Any]: ...
    def contains(self, key: _TreeMap__A) -> bool: ...
    def empty(self) -> 'TreeMap'[_TreeMap__A, _TreeMap__B]: ...
    def filterKeys(self, p: scala.Function1[_TreeMap__A, typing.Any]) -> scala.collection.SortedMap[_TreeMap__A, _TreeMap__B]: ...
    def filterNot(self, p: scala.Function1[scala.Tuple2[typing.Any, typing.Any], typing.Any]) -> scala.collection.Map[typing.Any, typing.Any]: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[scala.Tuple2[_TreeMap__A, _TreeMap__B], _foreach__U]) -> None: ...
    def get(self, key: _TreeMap__A) -> scala.Option[_TreeMap__B]: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[_TreeMap__A, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[_TreeMap__A]]: ...
    def head(self) -> scala.Tuple2[_TreeMap__A, _TreeMap__B]: ...
    def headOption(self) -> scala.Option[scala.Tuple2[_TreeMap__A, _TreeMap__B]]: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> scala.collection.Iterator[scala.Tuple2[_TreeMap__A, _TreeMap__B]]: ...
    def iteratorFrom(self, start: _TreeMap__A) -> scala.collection.Iterator[scala.Tuple2[_TreeMap__A, _TreeMap__B]]: ...
    def keySet(self) -> scala.collection.SortedSet[_TreeMap__A]: ...
    def keys(self) -> scala.collection.Iterable[typing.Any]: ...
    def keysIterator(self) -> scala.collection.Iterator[_TreeMap__A]: ...
    def keysIteratorFrom(self, start: _TreeMap__A) -> scala.collection.Iterator[_TreeMap__A]: ...
    def last(self) -> scala.Tuple2[_TreeMap__A, _TreeMap__B]: ...
    def lastOption(self) -> scala.Option[scala.Tuple2[_TreeMap__A, _TreeMap__B]]: ...
    _mapValues__C = typing.TypeVar('_mapValues__C')  # <C>
    def mapValues(self, f: scala.Function1[_TreeMap__B, _mapValues__C]) -> scala.collection.SortedMap[_TreeMap__A, _mapValues__C]: ...
    def newBuilder(self) -> Builder[scala.Tuple2[_TreeMap__A, _TreeMap__B], 'TreeMap'[_TreeMap__A, _TreeMap__B]]: ...
    def ordering(self) -> scala.math.Ordering[_TreeMap__A]: ...
    def rangeImpl(self, from_: scala.Option[_TreeMap__A], until: scala.Option[_TreeMap__A]) -> 'TreeMap'[_TreeMap__A, _TreeMap__B]: ...
    def repr(self) -> typing.Any: ...
    def result(self) -> Map[typing.Any, typing.Any]: ...
    def seq(self) -> Map[typing.Any, typing.Any]: ...
    def size(self) -> int: ...
    def stringPrefix(self) -> str: ...
    def thisCollection(self) -> scala.collection.Iterable[_TreeMap__A]: ...
    def toCollection(self, repr: typing.Any) -> scala.collection.Iterable: ...
    def toIterable(self) -> scala.collection.Iterable[_TreeMap__A]: ...
    def toSeq(self) -> scala.collection.Seq[scala.Tuple2[typing.Any, typing.Any]]: ...
    def toTraversable(self) -> scala.collection.Traversable[_TreeMap__A]: ...
    def transform(self, f: scala.Function2[_TreeMap__A, _TreeMap__B, _TreeMap__B]) -> 'TreeMap'[_TreeMap__A, _TreeMap__B]: ...
    _updated__B1 = typing.TypeVar('_updated__B1')  # <B1>
    def updated(self, key: _TreeMap__A, value: _updated__B1) -> SortedMap[_TreeMap__A, _updated__B1]: ...
    def values(self) -> scala.collection.Iterable[typing.Any]: ...
    def valuesIterator(self) -> scala.collection.Iterator[_TreeMap__B]: ...
    def valuesIteratorFrom(self, start: _TreeMap__A) -> scala.collection.Iterator[_TreeMap__B]: ...
    @typing.overload
    def view(self) -> scala.collection.IterableView[_TreeMap__A, scala.collection.Iterable[_TreeMap__A]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> scala.collection.IterableView[_TreeMap__A, scala.collection.Iterable[_TreeMap__A]]: ...
    class TreeMapView(scala.collection.mutable.TreeMap[_TreeMap__A, _TreeMap__B]):
        serialVersionUID: typing.ClassVar[int] = ...
        def __init__(self, $outer: 'TreeMap', from_: scala.Option[_TreeMap__A], until: scala.Option[_TreeMap__A]): ...
        def clone(self) -> 'TreeMap'[_TreeMap__A, _TreeMap__B]: ...
        def contains(self, key: _TreeMap__A) -> bool: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[scala.Tuple2[_TreeMap__A, _TreeMap__B], _foreach__U]) -> None: ...
        def get(self, key: _TreeMap__A) -> scala.Option[_TreeMap__B]: ...
        def head(self) -> scala.Tuple2[_TreeMap__A, _TreeMap__B]: ...
        def headOption(self) -> scala.Option[scala.Tuple2[_TreeMap__A, _TreeMap__B]]: ...
        def isEmpty(self) -> bool: ...
        def iterator(self) -> scala.collection.Iterator[scala.Tuple2[_TreeMap__A, _TreeMap__B]]: ...
        def iteratorFrom(self, start: _TreeMap__A) -> scala.collection.Iterator[scala.Tuple2[_TreeMap__A, _TreeMap__B]]: ...
        def keysIterator(self) -> scala.collection.Iterator[_TreeMap__A]: ...
        def keysIteratorFrom(self, start: _TreeMap__A) -> scala.collection.Iterator[_TreeMap__A]: ...
        def last(self) -> scala.Tuple2[_TreeMap__A, _TreeMap__B]: ...
        def lastOption(self) -> scala.Option[scala.Tuple2[_TreeMap__A, _TreeMap__B]]: ...
        def rangeImpl(self, from_: scala.Option[_TreeMap__A], until: scala.Option[_TreeMap__A]) -> 'TreeMap'[_TreeMap__A, _TreeMap__B]: ...
        def size(self) -> int: ...
        def transform(self, f: scala.Function2[_TreeMap__A, _TreeMap__B, _TreeMap__B]) -> 'TreeMap.TreeMapView': ...
        def valuesIterator(self) -> scala.collection.Iterator[_TreeMap__B]: ...
        def valuesIteratorFrom(self, start: _TreeMap__A) -> scala.collection.Iterator[_TreeMap__B]: ...

_TreeSet__A = typing.TypeVar('_TreeSet__A')  # <A>
class TreeSet(AbstractSortedSet[_TreeSet__A], scala.Serializable, typing.Generic[_TreeSet__A]):
    serialVersionUID: typing.ClassVar[int] = ...
    scala$collection$mutable$TreeSet$$tree: RedBlackTree.Tree = ...
    @typing.overload
    def __init__(self, tree: RedBlackTree.Tree[_TreeSet__A, scala.runtime.Null.], ordering: scala.math.Ordering[_TreeSet__A]): ...
    @typing.overload
    def __init__(self, ord: scala.math.Ordering[_TreeSet__A]): ...
    @typing.overload
    def $minus(self, elem: _TreeSet__A) -> Set[_TreeSet__A]: ...
    @typing.overload
    def $minus(self, elem1: _TreeSet__A, elem2: _TreeSet__A, elems: scala.collection.Seq[_TreeSet__A]) -> Set[_TreeSet__A]: ...
    @typing.overload
    def $minus$eq(self, elem1: _TreeSet__A, elem2: _TreeSet__A, elems: scala.collection.Seq[_TreeSet__A]) -> scala.collection.generic.Shrinkable[_TreeSet__A]: ...
    @typing.overload
    def $minus$eq(self, key: _TreeSet__A) -> 'TreeSet'[_TreeSet__A]: ...
    def $minus$minus(self, xs: scala.collection.GenTraversableOnce[_TreeSet__A]) -> Set[_TreeSet__A]: ...
    @typing.overload
    def $plus(self, elem: _TreeSet__A) -> Set[_TreeSet__A]: ...
    @typing.overload
    def $plus(self, elem1: _TreeSet__A, elem2: _TreeSet__A, elems: scala.collection.Seq[_TreeSet__A]) -> Set[_TreeSet__A]: ...
    @typing.overload
    def $plus$eq(self, elem1: _TreeSet__A, elem2: _TreeSet__A, elems: scala.collection.Seq[_TreeSet__A]) -> scala.collection.generic.Growable[_TreeSet__A]: ...
    @typing.overload
    def $plus$eq(self, elem: _TreeSet__A) -> 'TreeSet'[_TreeSet__A]: ...
    _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
    _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
    @typing.overload
    def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus_0__B], bf: scala.collection.generic.CanBuildFrom[scala.collection.Traversable[_TreeSet__A], _.plus.plus_0__B, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
    @typing.overload
    def $plus$plus(self, xs: scala.collection.GenTraversableOnce[_TreeSet__A]) -> Set[_TreeSet__A]: ...
    def apply(self, elem: _TreeSet__A) -> bool: ...
    _canBuildFrom__A = typing.TypeVar('_canBuildFrom__A')  # <A>
    @staticmethod
    def canBuildFrom(ord: scala.math.Ordering[_canBuildFrom__A]) -> scala.collection.generic.CanBuildFrom['TreeSet'[typing.Any], _canBuildFrom__A, 'TreeSet'[_canBuildFrom__A]]: ...
    def clear(self) -> None: ...
    def clone(self) -> Set[_TreeSet__A]: ...
    def contains(self, elem: _TreeSet__A) -> bool: ...
    def diff(self, that: scala.collection.GenSet) -> scala.collection.Set: ...
    def empty(self) -> 'TreeSet'[_TreeSet__A]: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_TreeSet__A, _foreach__U]) -> None: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[_TreeSet__A, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[_TreeSet__A]]: ...
    def head(self) -> _TreeSet__A: ...
    def headOption(self) -> scala.Option[_TreeSet__A]: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> scala.collection.Iterator[_TreeSet__A]: ...
    def iteratorFrom(self, start: _TreeSet__A) -> scala.collection.Iterator[_TreeSet__A]: ...
    def keysIteratorFrom(self, start: _TreeSet__A) -> scala.collection.Iterator[_TreeSet__A]: ...
    def last(self) -> _TreeSet__A: ...
    def lastOption(self) -> scala.Option[_TreeSet__A]: ...
    def newBuilder(self) -> Builder[_TreeSet__A, 'TreeSet'[_TreeSet__A]]: ...
    _newCanBuildFrom__A = typing.TypeVar('_newCanBuildFrom__A')  # <A>
    @staticmethod
    def newCanBuildFrom(ord: scala.math.Ordering[_newCanBuildFrom__A]) -> scala.collection.generic.CanBuildFrom['TreeSet'[typing.Any], _newCanBuildFrom__A, 'TreeSet'[_newCanBuildFrom__A]]: ...
    def ordering(self) -> scala.math.Ordering[_TreeSet__A]: ...
    def range(self, from_: typing.Any, until: typing.Any) -> scala.collection.SortedSet: ...
    def rangeImpl(self, from_: scala.Option[_TreeSet__A], until: scala.Option[_TreeSet__A]) -> 'TreeSet'[_TreeSet__A]: ...
    def repr(self) -> typing.Any: ...
    def result(self) -> Set[_TreeSet__A]: ...
    def seq(self) -> Set[_TreeSet__A]: ...
    def size(self) -> int: ...
    def stringPrefix(self) -> str: ...
    def thisCollection(self) -> scala.collection.Iterable[_TreeSet__A]: ...
    def toCollection(self, repr: typing.Any) -> scala.collection.Iterable: ...
    def toIterable(self) -> scala.collection.Iterable[_TreeSet__A]: ...
    def toSeq(self) -> scala.collection.Seq[_TreeSet__A]: ...
    def toTraversable(self) -> scala.collection.Traversable[_TreeSet__A]: ...
    def union(self, that: scala.collection.GenSet) -> scala.collection.Set: ...
    def until(self, until: typing.Any) -> scala.collection.SortedSet: ...
    @typing.overload
    def view(self) -> scala.collection.IterableView[_TreeSet__A, scala.collection.Iterable[_TreeSet__A]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> scala.collection.IterableView[_TreeSet__A, scala.collection.Iterable[_TreeSet__A]]: ...
    class TreeSetView(scala.collection.mutable.TreeSet[_TreeSet__A]):
        serialVersionUID: typing.ClassVar[int] = ...
        def __init__(self, $outer: 'TreeSet', from_: scala.Option[_TreeSet__A], until: scala.Option[_TreeSet__A]): ...
        def clone(self) -> 'TreeSet'[_TreeSet__A]: ...
        def contains(self, key: _TreeSet__A) -> bool: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[_TreeSet__A, _foreach__U]) -> None: ...
        def head(self) -> _TreeSet__A: ...
        def headOption(self) -> scala.Option[_TreeSet__A]: ...
        def isEmpty(self) -> bool: ...
        def iterator(self) -> scala.collection.Iterator[_TreeSet__A]: ...
        def iteratorFrom(self, start: _TreeSet__A) -> scala.collection.Iterator[_TreeSet__A]: ...
        def keysIteratorFrom(self, start: _TreeSet__A) -> scala.collection.Iterator[_TreeSet__A]: ...
        def last(self) -> _TreeSet__A: ...
        def lastOption(self) -> scala.Option[_TreeSet__A]: ...
        def rangeImpl(self, from_: scala.Option[_TreeSet__A], until: scala.Option[_TreeSet__A]) -> 'TreeSet'[_TreeSet__A]: ...
        def size(self) -> int: ...

_WrappedArray__ofRef__T = typing.TypeVar('_WrappedArray__ofRef__T')  # <T>
_WrappedArray__T = typing.TypeVar('_WrappedArray__T')  # <T>
class WrappedArray(AbstractSeq[_WrappedArray__T], IndexedSeq[_WrappedArray__T], ArrayLike[_WrappedArray__T, 'WrappedArray'[_WrappedArray__T]], scala.collection.CustomParallelizable[_WrappedArray__T, scala.collection.parallel.mutable.ParArray[_WrappedArray__T]], typing.Generic[_WrappedArray__T]):
    def __init__(self): ...
    @typing.overload
    def apply(self, v1: typing.Any) -> typing.Any: ...
    @typing.overload
    def apply(self, index: int) -> _WrappedArray__T: ...
    def array(self) -> typing.Any: ...
    _canBuildFrom__T = typing.TypeVar('_canBuildFrom__T')  # <T>
    @staticmethod
    def canBuildFrom(m: scala.reflect.ClassTag[_canBuildFrom__T]) -> scala.collection.generic.CanBuildFrom['WrappedArray'[typing.Any], _canBuildFrom__T, 'WrappedArray'[_canBuildFrom__T]]: ...
    def clone(self) -> 'WrappedArray'[_WrappedArray__T]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion[IndexedSeq]: ...
    _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
    _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
    _copyToArray_2__B = typing.TypeVar('_copyToArray_2__B')  # <B>
    @typing.overload
    def copyToArray(self, xs: typing.Any) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
    def deep(self) -> scala.collection.IndexedSeq[typing.Any]: ...
    def drop(self, n: int) -> typing.Any: ...
    def dropRight(self, n: int) -> typing.Any: ...
    def dropWhile(self, p: scala.Function1) -> typing.Any: ...
    def elemManifest(self) -> scala.reflect.ClassTag[_WrappedArray__T]: ...
    def elemTag(self) -> scala.reflect.ClassTag[_WrappedArray__T]: ...
    _empty__T = typing.TypeVar('_empty__T')  # <T>
    @staticmethod
    def empty() -> 'WrappedArray'[_empty__T]: ...
    _endsWith__B = typing.TypeVar('_endsWith__B')  # <B>
    def endsWith(self, that: scala.collection.GenSeq[_endsWith__B]) -> bool: ...
    def exists(self, p: scala.Function1[_WrappedArray__T, typing.Any]) -> bool: ...
    def find(self, p: scala.Function1[_WrappedArray__T, typing.Any]) -> scala.Option[_WrappedArray__T]: ...
    _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
    def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, _WrappedArray__T, _foldLeft__B]) -> _foldLeft__B: ...
    _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
    def foldRight(self, z: _foldRight__B, op: scala.Function2[_WrappedArray__T, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
    def forall(self, p: scala.Function1[_WrappedArray__T, typing.Any]) -> bool: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_WrappedArray__T, _foreach__U]) -> None: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[typing.Any, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[typing.Any]]: ...
    def hashCode(self) -> int: ...
    def head(self) -> _WrappedArray__T: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[_WrappedArray__T, typing.Any], from_: int) -> int: ...
    def init(self) -> typing.Any: ...
    def isDefinedAt(self, idx: int) -> bool: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> scala.collection.Iterator[_WrappedArray__T]: ...
    def last(self) -> _WrappedArray__T: ...
    @typing.overload
    def lastIndexWhere(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
    @typing.overload
    def lastIndexWhere(self, p: scala.Function1[_WrappedArray__T, typing.Any], end: int) -> int: ...
    def length(self) -> int: ...
    def lengthCompare(self, len: int) -> int: ...
    _make__T = typing.TypeVar('_make__T')  # <T>
    @staticmethod
    def make(x: typing.Any) -> 'WrappedArray'[_make__T]: ...
    def newBuilder(self) -> Builder[_WrappedArray__T, 'WrappedArray'[_WrappedArray__T]]: ...
    def par(self) -> scala.collection.parallel.mutable.ParArray[_WrappedArray__T]: ...
    def parCombiner(self) -> scala.collection.parallel.Combiner[_WrappedArray__T, scala.collection.parallel.mutable.ParArray[_WrappedArray__T]]: ...
    _reduceLeft__B = typing.TypeVar('_reduceLeft__B')  # <B>
    def reduceLeft(self, op: scala.Function2[_reduceLeft__B, _WrappedArray__T, _reduceLeft__B]) -> _reduceLeft__B: ...
    _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
    def reduceRight(self, op: scala.Function2[_WrappedArray__T, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
    def reverse(self) -> typing.Any: ...
    def reverseIterator(self) -> scala.collection.Iterator[_WrappedArray__T]: ...
    _sameElements__B = typing.TypeVar('_sameElements__B')  # <B>
    def sameElements(self, that: scala.collection.GenIterable[_sameElements__B]) -> bool: ...
    def segmentLength(self, p: scala.Function1[_WrappedArray__T, typing.Any], from_: int) -> int: ...
    def seq(self) -> IndexedSeq[_WrappedArray__T]: ...
    def sizeHintIfCheap(self) -> int: ...
    def slice(self, from_: int, until: int) -> typing.Any: ...
    def span(self, p: scala.Function1[_WrappedArray__T, typing.Any]) -> scala.Tuple2['WrappedArray'[_WrappedArray__T], 'WrappedArray'[_WrappedArray__T]]: ...
    def splitAt(self, n: int) -> scala.Tuple2['WrappedArray'[_WrappedArray__T], 'WrappedArray'[_WrappedArray__T]]: ...
    _startsWith_0__B = typing.TypeVar('_startsWith_0__B')  # <B>
    _startsWith_1__B = typing.TypeVar('_startsWith_1__B')  # <B>
    @typing.overload
    def startsWith(self, that: scala.collection.GenSeq[_startsWith_0__B]) -> bool: ...
    @typing.overload
    def startsWith(self, that: scala.collection.GenSeq[_startsWith_1__B], offset: int) -> bool: ...
    def stringPrefix(self) -> str: ...
    def tail(self) -> typing.Any: ...
    def take(self, n: int) -> typing.Any: ...
    def takeRight(self, n: int) -> typing.Any: ...
    def takeWhile(self, p: scala.Function1) -> typing.Any: ...
    def thisCollection(self) -> 'WrappedArray'[_WrappedArray__T]: ...
    _toArray__U = typing.TypeVar('_toArray__U')  # <U>
    def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__U]) -> typing.Any: ...
    _toBuffer__A1 = typing.TypeVar('_toBuffer__A1')  # <A1>
    def toBuffer(self) -> Buffer[_toBuffer__A1]: ...
    def toCollection(self, repr: 'WrappedArray'[_WrappedArray__T]) -> 'WrappedArray'[_WrappedArray__T]: ...
    def toIterable(self) -> scala.collection.Iterable[typing.Any]: ...
    def toList(self) -> scala.collection.immutable.List[_WrappedArray__T]: ...
    def toSeq(self) -> scala.collection.Seq[typing.Any]: ...
    def toTraversable(self) -> scala.collection.Traversable[typing.Any]: ...
    def update(self, index: int, elem: _WrappedArray__T) -> None: ...
    @typing.overload
    def view(self) -> 'IndexedSeqView'[_WrappedArray__T, 'WrappedArray'[_WrappedArray__T]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> 'IndexedSeqView'[_WrappedArray__T, 'WrappedArray'[_WrappedArray__T]]: ...
    _zip__A1 = typing.TypeVar('_zip__A1')  # <A1>
    _zip__B = typing.TypeVar('_zip__B')  # <B>
    _zip__That = typing.TypeVar('_zip__That')  # <That>
    def zip(self, that: scala.collection.GenIterable[_zip__B], bf: scala.collection.generic.CanBuildFrom['WrappedArray'[_WrappedArray__T], scala.Tuple2[_zip__A1, _zip__B], _zip__That]) -> _zip__That: ...
    _zipWithIndex__A1 = typing.TypeVar('_zipWithIndex__A1')  # <A1>
    _zipWithIndex__That = typing.TypeVar('_zipWithIndex__That')  # <That>
    def zipWithIndex(self, bf: scala.collection.generic.CanBuildFrom['WrappedArray'[_WrappedArray__T], scala.Tuple2[_zipWithIndex__A1, typing.Any], _zipWithIndex__That]) -> _zipWithIndex__That: ...
    class ofBoolean(scala.collection.mutable.WrappedArray[typing.Any], scala.Serializable):
        def __init__(self, array: typing.List[bool]): ...
        def apply(self, index: int) -> bool: ...
        def apply$mcZI$sp(self, index: int) -> bool: ...
        def array(self) -> typing.List[bool]: ...
        def elemTag(self) -> scala.reflect.ClassTag[typing.Any]: ...
        def equals(self, that: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def length(self) -> int: ...
        def update(self, index: int, elem: bool) -> None: ...
    class ofByte(scala.collection.mutable.WrappedArray[typing.Any], scala.Serializable):
        def __init__(self, array: typing.List[int]): ...
        def apply(self, index: int) -> int: ...
        def array(self) -> typing.List[int]: ...
        def elemTag(self) -> scala.reflect.ClassTag[typing.Any]: ...
        def equals(self, that: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def length(self) -> int: ...
        def update(self, index: int, elem: int) -> None: ...
    class ofChar(scala.collection.mutable.WrappedArray[typing.Any], scala.Serializable):
        def __init__(self, array: typing.List[str]): ...
        def apply(self, index: int) -> str: ...
        def array(self) -> typing.List[str]: ...
        def elemTag(self) -> scala.reflect.ClassTag[typing.Any]: ...
        def equals(self, that: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def length(self) -> int: ...
        def update(self, index: int, elem: str) -> None: ...
    class ofDouble(scala.collection.mutable.WrappedArray[typing.Any], scala.Serializable):
        def __init__(self, array: typing.List[float]): ...
        def apply(self, index: int) -> float: ...
        def apply$mcDI$sp(self, index: int) -> float: ...
        def array(self) -> typing.List[float]: ...
        def elemTag(self) -> scala.reflect.ClassTag[typing.Any]: ...
        def equals(self, that: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def length(self) -> int: ...
        def update(self, index: int, elem: float) -> None: ...
    class ofFloat(scala.collection.mutable.WrappedArray[typing.Any], scala.Serializable):
        def __init__(self, array: typing.List[float]): ...
        def apply(self, index: int) -> float: ...
        def apply$mcFI$sp(self, index: int) -> float: ...
        def array(self) -> typing.List[float]: ...
        def elemTag(self) -> scala.reflect.ClassTag[typing.Any]: ...
        def equals(self, that: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def length(self) -> int: ...
        def update(self, index: int, elem: float) -> None: ...
    class ofInt(scala.collection.mutable.WrappedArray[typing.Any], scala.Serializable):
        def __init__(self, array: typing.List[int]): ...
        def apply(self, index: int) -> int: ...
        def apply$mcII$sp(self, index: int) -> int: ...
        def array(self) -> typing.List[int]: ...
        def elemTag(self) -> scala.reflect.ClassTag[typing.Any]: ...
        def equals(self, that: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def length(self) -> int: ...
        def update(self, index: int, elem: int) -> None: ...
    class ofLong(scala.collection.mutable.WrappedArray[typing.Any], scala.Serializable):
        def __init__(self, array: typing.List[int]): ...
        def apply(self, index: int) -> int: ...
        def apply$mcJI$sp(self, index: int) -> int: ...
        def array(self) -> typing.List[int]: ...
        def elemTag(self) -> scala.reflect.ClassTag[typing.Any]: ...
        def equals(self, that: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def length(self) -> int: ...
        def update(self, index: int, elem: int) -> None: ...
    class ofRef(scala.collection.mutable.WrappedArray[_WrappedArray__ofRef__T], scala.Serializable, typing.Generic[_WrappedArray__ofRef__T]):
        def __init__(self, array: typing.List[_WrappedArray__ofRef__T]): ...
        def apply(self, index: int) -> _WrappedArray__ofRef__T: ...
        def array(self) -> typing.List[_WrappedArray__ofRef__T]: ...
        def elemTag(self) -> scala.reflect.ClassTag[_WrappedArray__ofRef__T]: ...
        def hashCode(self) -> int: ...
        def length(self) -> int: ...
        def update(self, index: int, elem: _WrappedArray__ofRef__T) -> None: ...
    class ofShort(scala.collection.mutable.WrappedArray[typing.Any], scala.Serializable):
        def __init__(self, array: typing.List[int]): ...
        def apply(self, index: int) -> int: ...
        def array(self) -> typing.List[int]: ...
        def elemTag(self) -> scala.reflect.ClassTag[typing.Any]: ...
        def equals(self, that: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def length(self) -> int: ...
        def update(self, index: int, elem: int) -> None: ...
    class ofUnit(scala.collection.mutable.WrappedArray[scala.runtime.BoxedUnit], scala.Serializable):
        def __init__(self, array: typing.List[scala.runtime.BoxedUnit]): ...
        def apply(self, index: int) -> None: ...
        def apply$mcVI$sp(self, index: int) -> None: ...
        def array(self) -> typing.List[scala.runtime.BoxedUnit]: ...
        def elemTag(self) -> scala.reflect.ClassTag[scala.runtime.BoxedUnit]: ...
        def equals(self, that: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def length(self) -> int: ...
        def update(self, index: int, elem: scala.runtime.BoxedUnit) -> None: ...

class IndexedSeqView: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("scala.collection.mutable")``.

    AbstractBuffer: typing.Type[AbstractBuffer]
    AbstractIterable: typing.Type[AbstractIterable]
    AbstractMap: typing.Type[AbstractMap]
    AbstractSeq: typing.Type[AbstractSeq]
    AbstractSet: typing.Type[AbstractSet]
    AbstractSortedMap: typing.Type[AbstractSortedMap]
    AbstractSortedSet: typing.Type[AbstractSortedSet]
    AnyRefMap: typing.Type[AnyRefMap]
    ArrayBuffer: typing.Type[ArrayBuffer]
    ArrayBuilder: typing.Type[ArrayBuilder]
    ArrayLike: typing.Type[ArrayLike]
    ArrayOps: typing.Type[ArrayOps]
    ArraySeq: typing.Type[ArraySeq]
    ArrayStack: typing.Type[ArrayStack]
    BitSet: typing.Type[BitSet]
    Buffer: typing.Type[Buffer]
    BufferLike: typing.Type[BufferLike]
    BufferProxy: typing.Type[BufferProxy]
    Builder: typing.Type[Builder]
    Cloneable: typing.Type[Cloneable]
    DefaultEntry: typing.Type[DefaultEntry]
    DefaultMapModel: typing.Type[DefaultMapModel]
    DoubleLinkedList: typing.Type[DoubleLinkedList]
    DoubleLinkedListLike: typing.Type[DoubleLinkedListLike]
    DoublingUnrolledBuffer: typing.Type[DoublingUnrolledBuffer]
    FlatHashTable: typing.Type[FlatHashTable]
    GrowingBuilder: typing.Type[GrowingBuilder]
    HashEntry: typing.Type[HashEntry]
    HashMap: typing.Type[HashMap]
    HashSet: typing.Type[HashSet]
    HashTable: typing.Type[HashTable]
    History: typing.Type[History]
    ImmutableMapAdaptor: typing.Type[ImmutableMapAdaptor]
    ImmutableSetAdaptor: typing.Type[ImmutableSetAdaptor]
    IndexedSeq: typing.Type[IndexedSeq]
    IndexedSeqLike: typing.Type[IndexedSeqLike]
    IndexedSeqOptimized: typing.Type[IndexedSeqOptimized]
    IndexedSeqView: typing.Type[IndexedSeqView]
    Iterable: typing.Type[Iterable]
    LazyBuilder: typing.Type[LazyBuilder]
    LinearSeq: typing.Type[LinearSeq]
    LinkedEntry: typing.Type[LinkedEntry]
    LinkedHashMap: typing.Type[LinkedHashMap]
    LinkedHashSet: typing.Type[LinkedHashSet]
    LinkedList: typing.Type[LinkedList]
    LinkedListLike: typing.Type[LinkedListLike]
    ListBuffer: typing.Type[ListBuffer]
    ListMap: typing.Type[ListMap]
    LongMap: typing.Type[LongMap]
    Map: typing.Type[Map]
    MapBuilder: typing.Type[MapBuilder]
    MapLike: typing.Type[MapLike]
    MapProxy: typing.Type[MapProxy]
    MultiMap: typing.Type[MultiMap]
    MutableList: typing.Type[MutableList]
    ObservableBuffer: typing.Type[ObservableBuffer]
    ObservableMap: typing.Type[ObservableMap]
    ObservableSet: typing.Type[ObservableSet]
    OpenHashMap: typing.Type[OpenHashMap]
    PriorityQueue: typing.Type[PriorityQueue]
    PriorityQueueProxy: typing.Type[PriorityQueueProxy]
    Publisher: typing.Type[Publisher]
    Queue: typing.Type[Queue]
    QueueProxy: typing.Type[QueueProxy]
    RedBlackTree: typing.Type[RedBlackTree]
    ResizableArray: typing.Type[ResizableArray]
    ReusableBuilder: typing.Type[ReusableBuilder]
    RevertibleHistory: typing.Type[RevertibleHistory]
    Seq: typing.Type[Seq]
    SeqLike: typing.Type[SeqLike]
    Set: typing.Type[Set]
    SetBuilder: typing.Type[SetBuilder]
    SetLike: typing.Type[SetLike]
    SetProxy: typing.Type[SetProxy]
    SortedMap: typing.Type[SortedMap]
    SortedSet: typing.Type[SortedSet]
    Stack: typing.Type[Stack]
    StackProxy: typing.Type[StackProxy]
    StringBuilder: typing.Type[StringBuilder]
    Subscriber: typing.Type[Subscriber]
    SynchronizedBuffer: typing.Type[SynchronizedBuffer]
    SynchronizedMap: typing.Type[SynchronizedMap]
    SynchronizedPriorityQueue: typing.Type[SynchronizedPriorityQueue]
    SynchronizedQueue: typing.Type[SynchronizedQueue]
    SynchronizedSet: typing.Type[SynchronizedSet]
    SynchronizedStack: typing.Type[SynchronizedStack]
    Traversable: typing.Type[Traversable]
    TreeMap: typing.Type[TreeMap]
    TreeSet: typing.Type[TreeSet]
    Undoable: typing.Type[Undoable]
    UnrolledBuffer: typing.Type[UnrolledBuffer]
    WeakHashMap: typing.Type[WeakHashMap]
    WrappedArray: typing.Type[WrappedArray]
    WrappedArrayBuilder: typing.Type[WrappedArrayBuilder]
