import java.io
import java.lang
import java.util.concurrent
import java.util.concurrent.atomic
import scala
import scala.collection
import scala.collection.generic
import scala.collection.immutable
import scala.collection.mutable
import scala.collection.parallel
import scala.collection.parallel.mutable
import scala.math
import scala.reflect
import scala.runtime
import scala.util.hashing
import typing



class BasicNode:
    def __init__(self): ...
    def string(self, int: int) -> str: ...

class Debug:
    @staticmethod
    def clear() -> None: ...
    @staticmethod
    def flush() -> None: ...
    @staticmethod
    def log(s: typing.Any) -> bool: ...
    @staticmethod
    def logbuffer() -> java.util.concurrent.ConcurrentLinkedQueue[typing.Any]: ...

_KVNode__K = typing.TypeVar('_KVNode__K')  # <K>
_KVNode__V = typing.TypeVar('_KVNode__V')  # <V>
class KVNode(typing.Generic[_KVNode__K, _KVNode__V]):
    def kvPair(self) -> scala.Tuple2[_KVNode__K, _KVNode__V]: ...

_Map__A = typing.TypeVar('_Map__A')  # <A>
_Map__B = typing.TypeVar('_Map__B')  # <B>
class Map(scala.collection.mutable.Map[_Map__A, _Map__B], typing.Generic[_Map__A, _Map__B]):
    @staticmethod
    def $init$($this: 'Map') -> None: ...
    def equals(self, that: typing.Any) -> bool: ...
    def getOrElseUpdate(self, key: _Map__A, op: scala.Function0[_Map__B]) -> _Map__B: ...
    def hashCode(self) -> int: ...
    def putIfAbsent(self, k: _Map__A, v: _Map__B) -> scala.Option[_Map__B]: ...
    @typing.overload
    def remove(self, k: _Map__A, v: _Map__B) -> bool: ...
    @typing.overload
    def remove(self, key: typing.Any) -> scala.Option[typing.Any]: ...
    @typing.overload
    def replace(self, k: _Map__A, oldvalue: _Map__B, newvalue: _Map__B) -> bool: ...
    @typing.overload
    def replace(self, k: _Map__A, v: _Map__B) -> scala.Option[_Map__B]: ...
    def toString(self) -> str: ...

_RDCSS_Descriptor__K = typing.TypeVar('_RDCSS_Descriptor__K')  # <K>
_RDCSS_Descriptor__V = typing.TypeVar('_RDCSS_Descriptor__V')  # <V>
class RDCSS_Descriptor(scala.Product, scala.Serializable, typing.Generic[_RDCSS_Descriptor__K, _RDCSS_Descriptor__V]):
    def __init__(self, old: 'INode'[_RDCSS_Descriptor__K, _RDCSS_Descriptor__V], expectedmain: 'MainNode'[_RDCSS_Descriptor__K, _RDCSS_Descriptor__V], nv: 'INode'[_RDCSS_Descriptor__K, _RDCSS_Descriptor__V]): ...
    _apply__K = typing.TypeVar('_apply__K')  # <K>
    _apply__V = typing.TypeVar('_apply__V')  # <V>
    @staticmethod
    def apply(old: 'INode'[_apply__K, _apply__V], expectedmain: 'MainNode'[_apply__K, _apply__V], nv: 'INode'[_apply__K, _apply__V]) -> 'RDCSS_Descriptor'[_apply__K, _apply__V]: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def committed(self) -> bool: ...
    def committed_$eq(self, x$1: bool) -> None: ...
    _copy__K = typing.TypeVar('_copy__K')  # <K>
    _copy__V = typing.TypeVar('_copy__V')  # <V>
    def copy(self, old: 'INode'[typing.Any, typing.Any], expectedmain: 'MainNode'[typing.Any, typing.Any], nv: 'INode'[typing.Any, typing.Any]) -> 'RDCSS_Descriptor'[typing.Any, typing.Any]: ...
    _copy$default$1__K = typing.TypeVar('_copy$default$1__K')  # <K>
    _copy$default$1__V = typing.TypeVar('_copy$default$1__V')  # <V>
    def copy$default$1(self) -> 'INode'[typing.Any, typing.Any]: ...
    _copy$default$2__K = typing.TypeVar('_copy$default$2__K')  # <K>
    _copy$default$2__V = typing.TypeVar('_copy$default$2__V')  # <V>
    def copy$default$2(self) -> 'MainNode'[typing.Any, typing.Any]: ...
    _copy$default$3__K = typing.TypeVar('_copy$default$3__K')  # <K>
    _copy$default$3__V = typing.TypeVar('_copy$default$3__V')  # <V>
    def copy$default$3(self) -> 'INode'[typing.Any, typing.Any]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def expectedmain(self) -> 'MainNode'[_RDCSS_Descriptor__K, _RDCSS_Descriptor__V]: ...
    def hashCode(self) -> int: ...
    def nv(self) -> 'INode'[_RDCSS_Descriptor__K, _RDCSS_Descriptor__V]: ...
    def old(self) -> 'INode'[_RDCSS_Descriptor__K, _RDCSS_Descriptor__V]: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> str: ...
    def toString(self) -> str: ...
    _unapply__K = typing.TypeVar('_unapply__K')  # <K>
    _unapply__V = typing.TypeVar('_unapply__V')  # <V>
    @staticmethod
    def unapply(x$0: 'RDCSS_Descriptor'[_unapply__K, _unapply__V]) -> scala.Option[scala.Tuple3['INode'[_unapply__K, _unapply__V], 'MainNode'[_unapply__K, _unapply__V], 'INode'[_unapply__K, _unapply__V]]]: ...

class RestartException:
    @staticmethod
    def addSuppressed(x$1: java.lang.Throwable) -> None: ...
    @staticmethod
    def fillInStackTrace() -> java.lang.Throwable: ...
    @staticmethod
    def getCause() -> java.lang.Throwable: ...
    @staticmethod
    def getLocalizedMessage() -> str: ...
    @staticmethod
    def getMessage() -> str: ...
    @staticmethod
    def getStackTrace() -> typing.List[java.lang.StackTraceElement]: ...
    @staticmethod
    def getSuppressed() -> typing.List[java.lang.Throwable]: ...
    @staticmethod
    def initCause(x$1: java.lang.Throwable) -> java.lang.Throwable: ...
    @typing.overload
    @staticmethod
    def printStackTrace() -> None: ...
    @typing.overload
    @staticmethod
    def printStackTrace(x$1: java.io.PrintStream) -> None: ...
    @typing.overload
    @staticmethod
    def printStackTrace(x$1: java.io.PrintWriter) -> None: ...
    @staticmethod
    def setStackTrace(x$1: typing.List[java.lang.StackTraceElement]) -> None: ...
    @staticmethod
    def toString() -> str: ...

_TrieMapIterator__K = typing.TypeVar('_TrieMapIterator__K')  # <K>
_TrieMapIterator__V = typing.TypeVar('_TrieMapIterator__V')  # <V>
class TrieMapIterator(scala.collection.Iterator[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V]], typing.Generic[_TrieMapIterator__K, _TrieMapIterator__V]):
    def __init__(self, level: int, ct: 'TrieMap'[_TrieMapIterator__K, _TrieMapIterator__V], mustInit: bool): ...
    _$colon$bslash__B = typing.TypeVar('_$colon$bslash__B')  # <B>
    def $colon$bslash(self, z: _.colon.bslash__B, op: scala.Function2[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], _.colon.bslash__B, _.colon.bslash__B]) -> _.colon.bslash__B: ...
    _$div$colon__B = typing.TypeVar('_$div$colon__B')  # <B>
    def $div$colon(self, z: _.div.colon__B, op: scala.Function2[_.div.colon__B, scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], _.div.colon__B]) -> _.div.colon__B: ...
    _$lessinit$greater$default$3__K = typing.TypeVar('_$lessinit$greater$default$3__K')  # <K>
    _$lessinit$greater$default$3__V = typing.TypeVar('_$lessinit$greater$default$3__V')  # <V>
    @staticmethod
    def $lessinit$greater$default$3() -> bool: ...
    _$plus$plus__B = typing.TypeVar('_$plus$plus__B')  # <B>
    def $plus$plus(self, that: scala.Function0[scala.collection.GenTraversableOnce[_.plus.plus__B]]) -> scala.collection.Iterator[_.plus.plus__B]: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder) -> scala.collection.mutable.StringBuilder: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder, sep: str) -> scala.collection.mutable.StringBuilder: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder, start: str, sep: str, end: str) -> scala.collection.mutable.StringBuilder: ...
    def advance(self) -> None: ...
    _aggregate__B = typing.TypeVar('_aggregate__B')  # <B>
    def aggregate(self, z: scala.Function0[_aggregate__B], seqop: scala.Function2[_aggregate__B, scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], _aggregate__B], combop: scala.Function2[_aggregate__B, _aggregate__B, _aggregate__B]) -> _aggregate__B: ...
    def buffered(self) -> scala.collection.BufferedIterator[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V]]: ...
    _collect__B = typing.TypeVar('_collect__B')  # <B>
    def collect(self, pf: scala.PartialFunction[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], _collect__B]) -> scala.collection.Iterator[_collect__B]: ...
    _collectFirst__B = typing.TypeVar('_collectFirst__B')  # <B>
    def collectFirst(self, pf: scala.PartialFunction[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], _collectFirst__B]) -> scala.Option[_collectFirst__B]: ...
    def contains(self, elem: typing.Any) -> bool: ...
    _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
    _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
    _copyToArray_2__B = typing.TypeVar('_copyToArray_2__B')  # <B>
    @typing.overload
    def copyToArray(self, xs: typing.Any) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
    _copyToBuffer__B = typing.TypeVar('_copyToBuffer__B')  # <B>
    def copyToBuffer(self, dest: scala.collection.mutable.Buffer[_copyToBuffer__B]) -> None: ...
    _corresponds__B = typing.TypeVar('_corresponds__B')  # <B>
    def corresponds(self, that: scala.collection.GenTraversableOnce[_corresponds__B], p: scala.Function2[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], _corresponds__B, typing.Any]) -> bool: ...
    def count(self, p: scala.Function1[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], typing.Any]) -> int: ...
    def drop(self, n: int) -> scala.collection.Iterator[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V]]: ...
    def dropWhile(self, p: scala.Function1[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], typing.Any]) -> scala.collection.Iterator[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V]]: ...
    def dupTo(self, it: 'TrieMapIterator'[_TrieMapIterator__K, _TrieMapIterator__V]) -> None: ...
    def duplicate(self) -> scala.Tuple2[scala.collection.Iterator[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V]], scala.collection.Iterator[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V]]]: ...
    def exists(self, p: scala.Function1[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], typing.Any]) -> bool: ...
    def filter(self, p: scala.Function1[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], typing.Any]) -> scala.collection.Iterator[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V]]: ...
    def filterNot(self, p: scala.Function1[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], typing.Any]) -> scala.collection.Iterator[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V]]: ...
    def find(self, p: scala.Function1[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], typing.Any]) -> scala.Option[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V]]: ...
    _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
    def flatMap(self, f: scala.Function1[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], scala.collection.GenTraversableOnce[_flatMap__B]]) -> scala.collection.Iterator[_flatMap__B]: ...
    _fold__A1 = typing.TypeVar('_fold__A1')  # <A1>
    def fold(self, z: _fold__A1, op: scala.Function2[_fold__A1, _fold__A1, _fold__A1]) -> _fold__A1: ...
    _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
    def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], _foldLeft__B]) -> _foldLeft__B: ...
    _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
    def foldRight(self, z: _foldRight__B, op: scala.Function2[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
    def forall(self, p: scala.Function1[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], typing.Any]) -> bool: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], _foreach__U]) -> None: ...
    _grouped__B = typing.TypeVar('_grouped__B')  # <B>
    def grouped(self, size: int) -> scala.collection.Iterator.GroupedIterator[_grouped__B]: ...
    def hasDefiniteSize(self) -> bool: ...
    def hasNext(self) -> bool: ...
    _indexOf_0__B = typing.TypeVar('_indexOf_0__B')  # <B>
    _indexOf_1__B = typing.TypeVar('_indexOf_1__B')  # <B>
    @typing.overload
    def indexOf(self, elem: _indexOf_0__B) -> int: ...
    @typing.overload
    def indexOf(self, elem: _indexOf_1__B, from_: int) -> int: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], typing.Any]) -> int: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], typing.Any], from_: int) -> int: ...
    def isEmpty(self) -> bool: ...
    def isTraversableAgain(self) -> bool: ...
    def length(self) -> int: ...
    def level(self) -> int: ...
    def level_$eq(self, x$1: int) -> None: ...
    _map__B = typing.TypeVar('_map__B')  # <B>
    def map(self, f: scala.Function1[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], _map__B]) -> scala.collection.Iterator[_map__B]: ...
    def max(self, cmp: scala.math.Ordering) -> typing.Any: ...
    def maxBy(self, f: scala.Function1, cmp: scala.math.Ordering) -> typing.Any: ...
    def min(self, cmp: scala.math.Ordering) -> typing.Any: ...
    def minBy(self, f: scala.Function1, cmp: scala.math.Ordering) -> typing.Any: ...
    @typing.overload
    def mkString(self) -> str: ...
    @typing.overload
    def mkString(self, sep: str) -> str: ...
    @typing.overload
    def mkString(self, start: str, sep: str, end: str) -> str: ...
    def newIterator(self, _lev: int, _ct: 'TrieMap'[_TrieMapIterator__K, _TrieMapIterator__V], _mustInit: bool) -> 'TrieMapIterator'[_TrieMapIterator__K, _TrieMapIterator__V]: ...
    def next(self) -> scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V]: ...
    def nonEmpty(self) -> bool: ...
    _padTo__A1 = typing.TypeVar('_padTo__A1')  # <A1>
    def padTo(self, len: int, elem: _padTo__A1) -> scala.collection.Iterator[_padTo__A1]: ...
    def partition(self, p: scala.Function1[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], typing.Any]) -> scala.Tuple2[scala.collection.Iterator[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V]], scala.collection.Iterator[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V]]]: ...
    _patch__B = typing.TypeVar('_patch__B')  # <B>
    def patch(self, from_: int, patchElems: scala.collection.Iterator[_patch__B], replaced: int) -> scala.collection.Iterator[_patch__B]: ...
    def printDebug(self) -> None: ...
    _product__B = typing.TypeVar('_product__B')  # <B>
    def product(self, num: scala.math.Numeric[_product__B]) -> _product__B: ...
    _reduce__A1 = typing.TypeVar('_reduce__A1')  # <A1>
    def reduce(self, op: scala.Function2[_reduce__A1, _reduce__A1, _reduce__A1]) -> _reduce__A1: ...
    _reduceLeft__B = typing.TypeVar('_reduceLeft__B')  # <B>
    def reduceLeft(self, op: scala.Function2[_reduceLeft__B, scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], _reduceLeft__B]) -> _reduceLeft__B: ...
    _reduceLeftOption__B = typing.TypeVar('_reduceLeftOption__B')  # <B>
    def reduceLeftOption(self, op: scala.Function2[_reduceLeftOption__B, scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], _reduceLeftOption__B]) -> scala.Option[_reduceLeftOption__B]: ...
    _reduceOption__A1 = typing.TypeVar('_reduceOption__A1')  # <A1>
    def reduceOption(self, op: scala.Function2[_reduceOption__A1, _reduceOption__A1, _reduceOption__A1]) -> scala.Option[_reduceOption__A1]: ...
    _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
    def reduceRight(self, op: scala.Function2[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
    _reduceRightOption__B = typing.TypeVar('_reduceRightOption__B')  # <B>
    def reduceRightOption(self, op: scala.Function2[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], _reduceRightOption__B, _reduceRightOption__B]) -> scala.Option[_reduceRightOption__B]: ...
    def reversed(self) -> scala.collection.immutable.List[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V]]: ...
    def sameElements(self, that: scala.collection.Iterator[typing.Any]) -> bool: ...
    _scanLeft__B = typing.TypeVar('_scanLeft__B')  # <B>
    def scanLeft(self, z: _scanLeft__B, op: scala.Function2[_scanLeft__B, scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], _scanLeft__B]) -> scala.collection.Iterator[_scanLeft__B]: ...
    _scanRight__B = typing.TypeVar('_scanRight__B')  # <B>
    def scanRight(self, z: _scanRight__B, op: scala.Function2[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], _scanRight__B, _scanRight__B]) -> scala.collection.Iterator[_scanRight__B]: ...
    def seq(self) -> scala.collection.Iterator[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V]]: ...
    def size(self) -> int: ...
    def sizeHintIfCheap(self) -> int: ...
    def slice(self, from_: int, until: int) -> scala.collection.Iterator[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V]]: ...
    def sliceIterator(self, from_: int, until: int) -> scala.collection.Iterator[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V]]: ...
    _sliding__B = typing.TypeVar('_sliding__B')  # <B>
    def sliding(self, size: int, step: int) -> scala.collection.Iterator.GroupedIterator[_sliding__B]: ...
    _sliding$default$2__B = typing.TypeVar('_sliding$default$2__B')  # <B>
    def sliding$default$2(self) -> int: ...
    def span(self, p: scala.Function1[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], typing.Any]) -> scala.Tuple2[scala.collection.Iterator[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V]], scala.collection.Iterator[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V]]]: ...
    def subdivide(self) -> scala.collection.Seq[scala.collection.Iterator[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V]]]: ...
    _sum__B = typing.TypeVar('_sum__B')  # <B>
    def sum(self, num: scala.math.Numeric[_sum__B]) -> _sum__B: ...
    def take(self, n: int) -> scala.collection.Iterator[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V]]: ...
    def takeWhile(self, p: scala.Function1[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], typing.Any]) -> scala.collection.Iterator[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V]]: ...
    _to__Col = typing.TypeVar('_to__Col')  # <Col>
    def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], _to__Col]) -> _to__Col: ...
    _toArray__B = typing.TypeVar('_toArray__B')  # <B>
    def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__B]) -> typing.Any: ...
    _toBuffer__B = typing.TypeVar('_toBuffer__B')  # <B>
    def toBuffer(self) -> scala.collection.mutable.Buffer[_toBuffer__B]: ...
    def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V]]: ...
    def toIterable(self) -> scala.collection.Iterable[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V]]: ...
    def toIterator(self) -> scala.collection.Iterator[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V]]: ...
    def toList(self) -> scala.collection.immutable.List[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V]]: ...
    _toMap__T = typing.TypeVar('_toMap__T')  # <T>
    _toMap__U = typing.TypeVar('_toMap__U')  # <U>
    def toMap(self, ev: scala.Predef..less.colon.less[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], scala.Tuple2[_toMap__T, _toMap__U]]) -> scala.collection.immutable.Map[_toMap__T, _toMap__U]: ...
    def toSeq(self) -> scala.collection.Seq[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V]]: ...
    _toSet__B = typing.TypeVar('_toSet__B')  # <B>
    def toSet(self) -> scala.collection.immutable.Set[_toSet__B]: ...
    def toStream(self) -> scala.collection.immutable.Stream[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V]]: ...
    def toString(self) -> str: ...
    def toTraversable(self) -> scala.collection.Traversable[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V]]: ...
    def toVector(self) -> scala.collection.immutable.Vector[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V]]: ...
    def withFilter(self, p: scala.Function1[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], typing.Any]) -> scala.collection.Iterator[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V]]: ...
    _zip__B = typing.TypeVar('_zip__B')  # <B>
    def zip(self, that: scala.collection.Iterator[_zip__B]) -> scala.collection.Iterator[scala.Tuple2[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], _zip__B]]: ...
    _zipAll__B = typing.TypeVar('_zipAll__B')  # <B>
    _zipAll__A1 = typing.TypeVar('_zipAll__A1')  # <A1>
    _zipAll__B1 = typing.TypeVar('_zipAll__B1')  # <B1>
    def zipAll(self, that: scala.collection.Iterator[_zipAll__B], thisElem: _zipAll__A1, thatElem: _zipAll__B1) -> scala.collection.Iterator[scala.Tuple2[_zipAll__A1, _zipAll__B1]]: ...
    def zipWithIndex(self) -> scala.collection.Iterator[scala.Tuple2[scala.Tuple2[_TrieMapIterator__K, _TrieMapIterator__V], typing.Any]]: ...

class TrieMapSerializationEnd:
    @staticmethod
    def canEqual(x$1: typing.Any) -> bool: ...
    @staticmethod
    def hashCode() -> int: ...
    @staticmethod
    def productArity() -> int: ...
    @staticmethod
    def productElement(x$1: int) -> typing.Any: ...
    @staticmethod
    def productIterator() -> scala.collection.Iterator[typing.Any]: ...
    @staticmethod
    def productPrefix() -> str: ...
    @staticmethod
    def toString() -> str: ...

class MainNode: ...

_FailedNode__K = typing.TypeVar('_FailedNode__K')  # <K>
_FailedNode__V = typing.TypeVar('_FailedNode__V')  # <V>
class FailedNode(MainNode[_FailedNode__K, _FailedNode__V], typing.Generic[_FailedNode__K, _FailedNode__V]):
    def __init__(self, p: MainNode[_FailedNode__K, _FailedNode__V]): ...
    def cachedSize(self, ct: typing.Any) -> int: ...
    def string(self, lev: int) -> scala.runtime.Nothing.: ...
    def toString(self) -> str: ...

_LNode__K = typing.TypeVar('_LNode__K')  # <K>
_LNode__V = typing.TypeVar('_LNode__V')  # <V>
class LNode(MainNode[_LNode__K, _LNode__V], typing.Generic[_LNode__K, _LNode__V]):
    @typing.overload
    def __init__(self, k: _LNode__K, v: _LNode__V): ...
    @typing.overload
    def __init__(self, k1: _LNode__K, v1: _LNode__V, k2: _LNode__K, v2: _LNode__V): ...
    @typing.overload
    def __init__(self, listmap: scala.collection.immutable.ListMap[_LNode__K, _LNode__V]): ...
    def cachedSize(self, ct: typing.Any) -> int: ...
    def get(self, k: _LNode__K) -> scala.Option[_LNode__V]: ...
    def inserted(self, k: _LNode__K, v: _LNode__V) -> 'LNode'[_LNode__K, _LNode__V]: ...
    def listmap(self) -> scala.collection.immutable.ListMap[_LNode__K, _LNode__V]: ...
    def removed(self, k: _LNode__K, ct: 'TrieMap'[_LNode__K, _LNode__V]) -> MainNode[_LNode__K, _LNode__V]: ...
    def string(self, lev: int) -> str: ...

_SNode__K = typing.TypeVar('_SNode__K')  # <K>
_SNode__V = typing.TypeVar('_SNode__V')  # <V>
class SNode(BasicNode, KVNode[_SNode__K, _SNode__V], typing.Generic[_SNode__K, _SNode__V]):
    def __init__(self, k: _SNode__K, v: _SNode__V, hc: int): ...
    def copy(self) -> 'SNode'[_SNode__K, _SNode__V]: ...
    def copyTombed(self) -> 'TNode'[_SNode__K, _SNode__V]: ...
    def copyUntombed(self) -> 'SNode'[_SNode__K, _SNode__V]: ...
    def hc(self) -> int: ...
    def k(self) -> _SNode__K: ...
    def kvPair(self) -> scala.Tuple2[_SNode__K, _SNode__V]: ...
    def string(self, lev: int) -> str: ...
    def v(self) -> _SNode__V: ...

_TNode__K = typing.TypeVar('_TNode__K')  # <K>
_TNode__V = typing.TypeVar('_TNode__V')  # <V>
class TNode(MainNode[_TNode__K, _TNode__V], KVNode[_TNode__K, _TNode__V], typing.Generic[_TNode__K, _TNode__V]):
    def __init__(self, k: _TNode__K, v: _TNode__V, hc: int): ...
    def cachedSize(self, ct: typing.Any) -> int: ...
    def copy(self) -> 'TNode'[_TNode__K, _TNode__V]: ...
    def copyTombed(self) -> 'TNode'[_TNode__K, _TNode__V]: ...
    def copyUntombed(self) -> SNode[_TNode__K, _TNode__V]: ...
    def hc(self) -> int: ...
    def k(self) -> _TNode__K: ...
    def kvPair(self) -> scala.Tuple2[_TNode__K, _TNode__V]: ...
    def string(self, lev: int) -> str: ...
    def v(self) -> _TNode__V: ...

_TrieMap__MangledHashing__K = typing.TypeVar('_TrieMap__MangledHashing__K')  # <K>
_TrieMap__K = typing.TypeVar('_TrieMap__K')  # <K>
_TrieMap__V = typing.TypeVar('_TrieMap__V')  # <V>
class TrieMap(Map[_TrieMap__K, _TrieMap__V], scala.collection.CustomParallelizable[scala.Tuple2[_TrieMap__K, _TrieMap__V], scala.collection.parallel.mutable.ParTrieMap[_TrieMap__K, _TrieMap__V]], scala.Serializable, typing.Generic[_TrieMap__K, _TrieMap__V]):
    serialVersionUID: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, hashf: scala.util.hashing.Hashing[_TrieMap__K], ef: scala.math.Equiv[_TrieMap__K]): ...
    _$colon$bslash__B = typing.TypeVar('_$colon$bslash__B')  # <B>
    def $colon$bslash(self, z: _.colon.bslash__B, op: scala.Function2[scala.Tuple2[_TrieMap__K, _TrieMap__V], _.colon.bslash__B, _.colon.bslash__B]) -> _.colon.bslash__B: ...
    _$div$colon__B = typing.TypeVar('_$div$colon__B')  # <B>
    def $div$colon(self, z: _.div.colon__B, op: scala.Function2[_.div.colon__B, scala.Tuple2[_TrieMap__K, _TrieMap__V], _.div.colon__B]) -> _.div.colon__B: ...
    @typing.overload
    def $minus(self, key: typing.Any) -> scala.collection.mutable.Map: ...
    @typing.overload
    def $minus(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq) -> scala.collection.mutable.Map: ...
    @typing.overload
    def $minus$eq(self, k: _TrieMap__K) -> 'TrieMap'[_TrieMap__K, _TrieMap__V]: ...
    @typing.overload
    def $minus$eq(self, elem1: _TrieMap__K, elem2: _TrieMap__K, elems: scala.collection.Seq[_TrieMap__K]) -> scala.collection.generic.Shrinkable[_TrieMap__K]: ...
    def $minus$minus(self, xs: scala.collection.GenTraversableOnce) -> scala.collection.mutable.Map: ...
    def $minus$minus$eq(self, xs: scala.collection.TraversableOnce[_TrieMap__K]) -> scala.collection.generic.Shrinkable[_TrieMap__K]: ...
    _$plus_0__V1 = typing.TypeVar('_$plus_0__V1')  # <V1>
    _$plus_1__V1 = typing.TypeVar('_$plus_1__V1')  # <V1>
    @typing.overload
    def $plus(self, kv: scala.Tuple2[_TrieMap__K, _.plus_0__V1]) -> scala.collection.mutable.Map[_TrieMap__K, _.plus_0__V1]: ...
    @typing.overload
    def $plus(self, elem1: scala.Tuple2[_TrieMap__K, _.plus_1__V1], elem2: scala.Tuple2[_TrieMap__K, _.plus_1__V1], elems: scala.collection.Seq[scala.Tuple2[_TrieMap__K, _.plus_1__V1]]) -> scala.collection.mutable.Map[_TrieMap__K, _.plus_1__V1]: ...
    @typing.overload
    def $plus$eq(self, kv: scala.Tuple2[_TrieMap__K, _TrieMap__V]) -> 'TrieMap'[_TrieMap__K, _TrieMap__V]: ...
    @typing.overload
    def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq) -> scala.collection.generic.Growable: ...
    _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
    _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
    _$plus$plus_1__V1 = typing.TypeVar('_$plus$plus_1__V1')  # <V1>
    @typing.overload
    def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus_0__B], bf: scala.collection.generic.CanBuildFrom['TrieMap'[_TrieMap__K, _TrieMap__V], _.plus.plus_0__B, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
    @typing.overload
    def $plus$plus(self, xs: scala.collection.GenTraversableOnce[scala.Tuple2[_TrieMap__K, _.plus.plus_1__V1]]) -> scala.collection.mutable.Map[_TrieMap__K, _.plus.plus_1__V1]: ...
    _$plus$plus$colon_0__B = typing.TypeVar('_$plus$plus$colon_0__B')  # <B>
    _$plus$plus$colon_0__That = typing.TypeVar('_$plus$plus$colon_0__That')  # <That>
    _$plus$plus$colon_1__B = typing.TypeVar('_$plus$plus$colon_1__B')  # <B>
    _$plus$plus$colon_1__That = typing.TypeVar('_$plus$plus$colon_1__That')  # <That>
    @typing.overload
    def $plus$plus$colon(self, that: scala.collection.Traversable[_.plus.plus.colon_0__B], bf: scala.collection.generic.CanBuildFrom['TrieMap'[_TrieMap__K, _TrieMap__V], _.plus.plus.colon_0__B, _.plus.plus.colon_0__That]) -> _.plus.plus.colon_0__That: ...
    @typing.overload
    def $plus$plus$colon(self, that: scala.collection.TraversableOnce[_.plus.plus.colon_1__B], bf: scala.collection.generic.CanBuildFrom['TrieMap'[_TrieMap__K, _TrieMap__V], _.plus.plus.colon_1__B, _.plus.plus.colon_1__That]) -> _.plus.plus.colon_1__That: ...
    def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[scala.Tuple2[_TrieMap__K, _TrieMap__V]]) -> scala.collection.generic.Growable[scala.Tuple2[_TrieMap__K, _TrieMap__V]]: ...
    def CAS_ROOT(self, ov: typing.Any, nv: typing.Any) -> bool: ...
    def RDCSS_READ_ROOT(self, abort: bool) -> 'INode'[_TrieMap__K, _TrieMap__V]: ...
    def RDCSS_READ_ROOT$default$1(self) -> bool: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder) -> scala.collection.mutable.StringBuilder: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder, sep: str) -> scala.collection.mutable.StringBuilder: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder, start: str, sep: str, end: str) -> scala.collection.mutable.StringBuilder: ...
    _aggregate__B = typing.TypeVar('_aggregate__B')  # <B>
    def aggregate(self, z: scala.Function0[_aggregate__B], seqop: scala.Function2[_aggregate__B, scala.Tuple2[_TrieMap__K, _TrieMap__V], _aggregate__B], combop: scala.Function2[_aggregate__B, _aggregate__B, _aggregate__B]) -> _aggregate__B: ...
    _andThen__C = typing.TypeVar('_andThen__C')  # <C>
    def andThen(self, k: scala.Function1[_TrieMap__V, _andThen__C]) -> scala.PartialFunction[_TrieMap__K, _andThen__C]: ...
    def apply(self, k: _TrieMap__K) -> _TrieMap__V: ...
    def apply$mcDD$sp(self, v1: float) -> float: ...
    def apply$mcDF$sp(self, v1: float) -> float: ...
    def apply$mcDI$sp(self, v1: int) -> float: ...
    def apply$mcDJ$sp(self, v1: int) -> float: ...
    def apply$mcFD$sp(self, v1: float) -> float: ...
    def apply$mcFF$sp(self, v1: float) -> float: ...
    def apply$mcFI$sp(self, v1: int) -> float: ...
    def apply$mcFJ$sp(self, v1: int) -> float: ...
    def apply$mcID$sp(self, v1: float) -> int: ...
    def apply$mcIF$sp(self, v1: float) -> int: ...
    def apply$mcII$sp(self, v1: int) -> int: ...
    def apply$mcIJ$sp(self, v1: int) -> int: ...
    def apply$mcJD$sp(self, v1: float) -> int: ...
    def apply$mcJF$sp(self, v1: float) -> int: ...
    def apply$mcJI$sp(self, v1: int) -> int: ...
    def apply$mcJJ$sp(self, v1: int) -> int: ...
    def apply$mcVD$sp(self, v1: float) -> None: ...
    def apply$mcVF$sp(self, v1: float) -> None: ...
    def apply$mcVI$sp(self, v1: int) -> None: ...
    def apply$mcVJ$sp(self, v1: int) -> None: ...
    def apply$mcZD$sp(self, v1: float) -> bool: ...
    def apply$mcZF$sp(self, v1: float) -> bool: ...
    def apply$mcZI$sp(self, v1: int) -> bool: ...
    def apply$mcZJ$sp(self, v1: int) -> bool: ...
    _applyOrElse__K1 = typing.TypeVar('_applyOrElse__K1')  # <K1>
    _applyOrElse__V1 = typing.TypeVar('_applyOrElse__V1')  # <V1>
    def applyOrElse(self, x: _applyOrElse__K1, default: scala.Function1[_applyOrElse__K1, _applyOrElse__V1]) -> _applyOrElse__V1: ...
    _canBuildFrom__K = typing.TypeVar('_canBuildFrom__K')  # <K>
    _canBuildFrom__V = typing.TypeVar('_canBuildFrom__V')  # <V>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanBuildFrom['TrieMap'[typing.Any, typing.Any], scala.Tuple2[_canBuildFrom__K, _canBuildFrom__V], 'TrieMap'[_canBuildFrom__K, _canBuildFrom__V]]: ...
    def canEqual(self, that: typing.Any) -> bool: ...
    def clear(self) -> None: ...
    def clone(self) -> scala.collection.mutable.Map: ...
    _collect__B = typing.TypeVar('_collect__B')  # <B>
    _collect__That = typing.TypeVar('_collect__That')  # <That>
    def collect(self, pf: scala.PartialFunction[scala.Tuple2[_TrieMap__K, _TrieMap__V], _collect__B], bf: scala.collection.generic.CanBuildFrom['TrieMap'[_TrieMap__K, _TrieMap__V], _collect__B, _collect__That]) -> _collect__That: ...
    _collectFirst__B = typing.TypeVar('_collectFirst__B')  # <B>
    def collectFirst(self, pf: scala.PartialFunction[scala.Tuple2[_TrieMap__K, _TrieMap__V], _collectFirst__B]) -> scala.Option[_collectFirst__B]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion[scala.collection.mutable.Iterable]: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    def compose(self, g: scala.Function1[_compose__A, _TrieMap__K]) -> scala.Function1[_compose__A, _TrieMap__V]: ...
    def computeHash(self, k: _TrieMap__K) -> int: ...
    def contains(self, key: _TrieMap__K) -> bool: ...
    _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
    _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
    _copyToArray_2__B = typing.TypeVar('_copyToArray_2__B')  # <B>
    @typing.overload
    def copyToArray(self, xs: typing.Any) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
    _copyToBuffer__B = typing.TypeVar('_copyToBuffer__B')  # <B>
    def copyToBuffer(self, dest: scala.collection.mutable.Buffer[_copyToBuffer__B]) -> None: ...
    def count(self, p: scala.Function1[scala.Tuple2[_TrieMap__K, _TrieMap__V], typing.Any]) -> int: ...
    def default(self, key: _TrieMap__K) -> _TrieMap__V: ...
    def drop(self, n: int) -> typing.Any: ...
    def dropRight(self, n: int) -> typing.Any: ...
    def dropWhile(self, p: scala.Function1) -> typing.Any: ...
    def empty(self) -> 'TrieMap'[_TrieMap__K, _TrieMap__V]: ...
    def equality(self) -> scala.math.Equiv[_TrieMap__K]: ...
    def equals(self, that: typing.Any) -> bool: ...
    def exists(self, p: scala.Function1[scala.Tuple2[_TrieMap__K, _TrieMap__V], typing.Any]) -> bool: ...
    def filter(self, p: scala.Function1) -> typing.Any: ...
    def filterImpl(self, p: scala.Function1, isFlipped: bool) -> typing.Any: ...
    def filterKeys(self, p: scala.Function1[_TrieMap__K, typing.Any]) -> scala.collection.Map[_TrieMap__K, _TrieMap__V]: ...
    def filterNot(self, p: scala.Function1) -> scala.collection.Map: ...
    def find(self, p: scala.Function1[scala.Tuple2[_TrieMap__K, _TrieMap__V], typing.Any]) -> scala.Option[scala.Tuple2[_TrieMap__K, _TrieMap__V]]: ...
    _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
    _flatMap__That = typing.TypeVar('_flatMap__That')  # <That>
    def flatMap(self, f: scala.Function1[scala.Tuple2[_TrieMap__K, _TrieMap__V], scala.collection.GenTraversableOnce[_flatMap__B]], bf: scala.collection.generic.CanBuildFrom['TrieMap'[_TrieMap__K, _TrieMap__V], _flatMap__B, _flatMap__That]) -> _flatMap__That: ...
    def flatten(self, asTraversable: scala.Function1) -> scala.collection.GenTraversable: ...
    _fold__A1 = typing.TypeVar('_fold__A1')  # <A1>
    def fold(self, z: _fold__A1, op: scala.Function2[_fold__A1, _fold__A1, _fold__A1]) -> _fold__A1: ...
    _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
    def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, scala.Tuple2[_TrieMap__K, _TrieMap__V], _foldLeft__B]) -> _foldLeft__B: ...
    _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
    def foldRight(self, z: _foldRight__B, op: scala.Function2[scala.Tuple2[_TrieMap__K, _TrieMap__V], _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
    def forall(self, p: scala.Function1[scala.Tuple2[_TrieMap__K, _TrieMap__V], typing.Any]) -> bool: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[scala.Tuple2[_TrieMap__K, _TrieMap__V], _foreach__U]) -> None: ...
    _genericBuilder__B = typing.TypeVar('_genericBuilder__B')  # <B>
    def genericBuilder(self) -> scala.collection.mutable.Builder[_genericBuilder__B, scala.collection.mutable.Iterable[_genericBuilder__B]]: ...
    def get(self, k: _TrieMap__K) -> scala.Option[_TrieMap__V]: ...
    _getOrElse__V1 = typing.TypeVar('_getOrElse__V1')  # <V1>
    def getOrElse(self, key: _TrieMap__K, default: scala.Function0[_getOrElse__V1]) -> _getOrElse__V1: ...
    def getOrElseUpdate(self, k: _TrieMap__K, op: scala.Function0[_TrieMap__V]) -> _TrieMap__V: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1[scala.Tuple2[typing.Any, _TrieMap__V], typing.Any]) -> scala.collection.immutable.Map[typing.Any, 'TrieMap'[typing.Any, _TrieMap__V]]: ...
    def grouped(self, size: int) -> scala.collection.Iterator['TrieMap'[_TrieMap__K, _TrieMap__V]]: ...
    def hasDefiniteSize(self) -> bool: ...
    def hashCode(self) -> int: ...
    def hashing(self) -> scala.util.hashing.Hashing[_TrieMap__K]: ...
    def head(self) -> typing.Any: ...
    def headOption(self) -> scala.Option[scala.Tuple2[_TrieMap__K, _TrieMap__V]]: ...
    def init(self) -> typing.Any: ...
    def inits(self) -> scala.collection.Iterator['TrieMap'[_TrieMap__K, _TrieMap__V]]: ...
    @staticmethod
    def inodeupdater() -> java.util.concurrent.atomic.AtomicReferenceFieldUpdater['INodeBase'[typing.Any, typing.Any], MainNode[typing.Any, typing.Any]]: ...
    def isDefinedAt(self, key: _TrieMap__K) -> bool: ...
    def isEmpty(self) -> bool: ...
    def isReadOnly(self) -> bool: ...
    def isTraversableAgain(self) -> bool: ...
    def iterator(self) -> scala.collection.Iterator[scala.Tuple2[_TrieMap__K, _TrieMap__V]]: ...
    def keySet(self) -> scala.collection.Set[_TrieMap__K]: ...
    def keys(self) -> scala.collection.Iterable[_TrieMap__K]: ...
    def keysIterator(self) -> scala.collection.Iterator[_TrieMap__K]: ...
    def last(self) -> typing.Any: ...
    def lastOption(self) -> scala.Option[scala.Tuple2[_TrieMap__K, _TrieMap__V]]: ...
    def lift(self) -> scala.Function1[_TrieMap__K, scala.Option[_TrieMap__V]]: ...
    def lookup(self, k: _TrieMap__K) -> _TrieMap__V: ...
    _map__B = typing.TypeVar('_map__B')  # <B>
    _map__That = typing.TypeVar('_map__That')  # <That>
    def map(self, f: scala.Function1[scala.Tuple2[_TrieMap__K, _TrieMap__V], _map__B], bf: scala.collection.generic.CanBuildFrom['TrieMap'[_TrieMap__K, _TrieMap__V], _map__B, _map__That]) -> _map__That: ...
    _mapResult__NewTo = typing.TypeVar('_mapResult__NewTo')  # <NewTo>
    def mapResult(self, f: scala.Function1['TrieMap'[_TrieMap__K, _TrieMap__V], _mapResult__NewTo]) -> scala.collection.mutable.Builder[scala.Tuple2[_TrieMap__K, _TrieMap__V], _mapResult__NewTo]: ...
    _mapValues__W = typing.TypeVar('_mapValues__W')  # <W>
    def mapValues(self, f: scala.Function1[_TrieMap__V, _mapValues__W]) -> scala.collection.Map[_TrieMap__K, _mapValues__W]: ...
    def max(self, cmp: scala.math.Ordering) -> typing.Any: ...
    def maxBy(self, f: scala.Function1, cmp: scala.math.Ordering) -> typing.Any: ...
    def min(self, cmp: scala.math.Ordering) -> typing.Any: ...
    def minBy(self, f: scala.Function1, cmp: scala.math.Ordering) -> typing.Any: ...
    @typing.overload
    def mkString(self) -> str: ...
    @typing.overload
    def mkString(self, sep: str) -> str: ...
    @typing.overload
    def mkString(self, start: str, sep: str, end: str) -> str: ...
    def newBuilder(self) -> scala.collection.mutable.Builder[scala.Tuple2[_TrieMap__K, _TrieMap__V], 'TrieMap'[_TrieMap__K, _TrieMap__V]]: ...
    def nonEmpty(self) -> bool: ...
    def nonReadOnly(self) -> bool: ...
    _orElse__A1 = typing.TypeVar('_orElse__A1')  # <A1>
    _orElse__B1 = typing.TypeVar('_orElse__B1')  # <B1>
    def orElse(self, that: scala.PartialFunction[_orElse__A1, _orElse__B1]) -> scala.PartialFunction[_orElse__A1, _orElse__B1]: ...
    def par(self) -> scala.collection.parallel.mutable.ParTrieMap[_TrieMap__K, _TrieMap__V]: ...
    def parCombiner(self) -> scala.collection.parallel.Combiner[scala.Tuple2[_TrieMap__K, _TrieMap__V], scala.collection.parallel.mutable.ParTrieMap[_TrieMap__K, _TrieMap__V]]: ...
    def partition(self, p: scala.Function1[scala.Tuple2[_TrieMap__K, _TrieMap__V], typing.Any]) -> scala.Tuple2['TrieMap'[_TrieMap__K, _TrieMap__V], 'TrieMap'[_TrieMap__K, _TrieMap__V]]: ...
    _product__B = typing.TypeVar('_product__B')  # <B>
    def product(self, num: scala.math.Numeric[_product__B]) -> _product__B: ...
    def put(self, key: _TrieMap__K, value: _TrieMap__V) -> scala.Option[_TrieMap__V]: ...
    def putIfAbsent(self, k: _TrieMap__K, v: _TrieMap__V) -> scala.Option[_TrieMap__V]: ...
    def readOnlySnapshot(self) -> scala.collection.Map[_TrieMap__K, _TrieMap__V]: ...
    def readRoot(self, abort: bool) -> 'INode'[_TrieMap__K, _TrieMap__V]: ...
    def readRoot$default$1(self) -> bool: ...
    _reduce__A1 = typing.TypeVar('_reduce__A1')  # <A1>
    def reduce(self, op: scala.Function2[_reduce__A1, _reduce__A1, _reduce__A1]) -> _reduce__A1: ...
    _reduceLeft__B = typing.TypeVar('_reduceLeft__B')  # <B>
    def reduceLeft(self, op: scala.Function2[_reduceLeft__B, scala.Tuple2[_TrieMap__K, _TrieMap__V], _reduceLeft__B]) -> _reduceLeft__B: ...
    _reduceLeftOption__B = typing.TypeVar('_reduceLeftOption__B')  # <B>
    def reduceLeftOption(self, op: scala.Function2[_reduceLeftOption__B, scala.Tuple2[_TrieMap__K, _TrieMap__V], _reduceLeftOption__B]) -> scala.Option[_reduceLeftOption__B]: ...
    _reduceOption__A1 = typing.TypeVar('_reduceOption__A1')  # <A1>
    def reduceOption(self, op: scala.Function2[_reduceOption__A1, _reduceOption__A1, _reduceOption__A1]) -> scala.Option[_reduceOption__A1]: ...
    _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
    def reduceRight(self, op: scala.Function2[scala.Tuple2[_TrieMap__K, _TrieMap__V], _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
    _reduceRightOption__B = typing.TypeVar('_reduceRightOption__B')  # <B>
    def reduceRightOption(self, op: scala.Function2[scala.Tuple2[_TrieMap__K, _TrieMap__V], _reduceRightOption__B, _reduceRightOption__B]) -> scala.Option[_reduceRightOption__B]: ...
    @typing.overload
    def remove(self, k: _TrieMap__K, v: _TrieMap__V) -> bool: ...
    @typing.overload
    def remove(self, k: _TrieMap__K) -> scala.Option[_TrieMap__V]: ...
    @typing.overload
    def replace(self, k: _TrieMap__K, oldvalue: _TrieMap__V, newvalue: _TrieMap__V) -> bool: ...
    @typing.overload
    def replace(self, k: _TrieMap__K, v: _TrieMap__V) -> scala.Option[_TrieMap__V]: ...
    def repr(self) -> typing.Any: ...
    def result(self) -> scala.collection.mutable.Map: ...
    def retain(self, p: scala.Function2[_TrieMap__K, _TrieMap__V, typing.Any]) -> scala.collection.mutable.MapLike[_TrieMap__K, _TrieMap__V, 'TrieMap'[_TrieMap__K, _TrieMap__V]]: ...
    def reversed(self) -> scala.collection.immutable.List[scala.Tuple2[_TrieMap__K, _TrieMap__V]]: ...
    def root(self) -> typing.Any: ...
    def root_$eq(self, x$1: typing.Any) -> None: ...
    _runWith__U = typing.TypeVar('_runWith__U')  # <U>
    def runWith(self, action: scala.Function1[_TrieMap__V, _runWith__U]) -> scala.Function1[_TrieMap__K, typing.Any]: ...
    _sameElements__B = typing.TypeVar('_sameElements__B')  # <B>
    def sameElements(self, that: scala.collection.GenIterable[_sameElements__B]) -> bool: ...
    _scan__B = typing.TypeVar('_scan__B')  # <B>
    _scan__That = typing.TypeVar('_scan__That')  # <That>
    def scan(self, z: _scan__B, op: scala.Function2[_scan__B, _scan__B, _scan__B], cbf: scala.collection.generic.CanBuildFrom['TrieMap'[_TrieMap__K, _TrieMap__V], _scan__B, _scan__That]) -> _scan__That: ...
    _scanLeft__B = typing.TypeVar('_scanLeft__B')  # <B>
    _scanLeft__That = typing.TypeVar('_scanLeft__That')  # <That>
    def scanLeft(self, z: _scanLeft__B, op: scala.Function2[_scanLeft__B, scala.Tuple2[_TrieMap__K, _TrieMap__V], _scanLeft__B], bf: scala.collection.generic.CanBuildFrom['TrieMap'[_TrieMap__K, _TrieMap__V], _scanLeft__B, _scanLeft__That]) -> _scanLeft__That: ...
    _scanRight__B = typing.TypeVar('_scanRight__B')  # <B>
    _scanRight__That = typing.TypeVar('_scanRight__That')  # <That>
    def scanRight(self, z: _scanRight__B, op: scala.Function2[scala.Tuple2[_TrieMap__K, _TrieMap__V], _scanRight__B, _scanRight__B], bf: scala.collection.generic.CanBuildFrom['TrieMap'[_TrieMap__K, _TrieMap__V], _scanRight__B, _scanRight__That]) -> _scanRight__That: ...
    def seq(self) -> 'TrieMap'[_TrieMap__K, _TrieMap__V]: ...
    def size(self) -> int: ...
    @typing.overload
    def sizeHint(self, size: int) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any], delta: int) -> None: ...
    def sizeHintBounded(self, size: int, boundingColl: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
    def sizeHintIfCheap(self) -> int: ...
    def slice(self, from_: int, until: int) -> typing.Any: ...
    def sliceWithKnownBound(self, from_: int, until: int) -> typing.Any: ...
    def sliceWithKnownDelta(self, from_: int, until: int, delta: int) -> typing.Any: ...
    @typing.overload
    def sliding(self, size: int) -> scala.collection.Iterator['TrieMap'[_TrieMap__K, _TrieMap__V]]: ...
    @typing.overload
    def sliding(self, size: int, step: int) -> scala.collection.Iterator['TrieMap'[_TrieMap__K, _TrieMap__V]]: ...
    def snapshot(self) -> 'TrieMap'[_TrieMap__K, _TrieMap__V]: ...
    def span(self, p: scala.Function1[scala.Tuple2[_TrieMap__K, _TrieMap__V], typing.Any]) -> scala.Tuple2['TrieMap'[_TrieMap__K, _TrieMap__V], 'TrieMap'[_TrieMap__K, _TrieMap__V]]: ...
    def splitAt(self, n: int) -> scala.Tuple2['TrieMap'[_TrieMap__K, _TrieMap__V], 'TrieMap'[_TrieMap__K, _TrieMap__V]]: ...
    def string(self) -> str: ...
    def stringPrefix(self) -> str: ...
    _sum__B = typing.TypeVar('_sum__B')  # <B>
    def sum(self, num: scala.math.Numeric[_sum__B]) -> _sum__B: ...
    def tail(self) -> typing.Any: ...
    def tails(self) -> scala.collection.Iterator['TrieMap'[_TrieMap__K, _TrieMap__V]]: ...
    def take(self, n: int) -> typing.Any: ...
    def takeRight(self, n: int) -> typing.Any: ...
    def takeWhile(self, p: scala.Function1) -> typing.Any: ...
    def thisCollection(self) -> scala.collection.Iterable[scala.Tuple2[_TrieMap__K, _TrieMap__V]]: ...
    _to__Col = typing.TypeVar('_to__Col')  # <Col>
    def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., scala.Tuple2[_TrieMap__K, _TrieMap__V], _to__Col]) -> _to__Col: ...
    _toArray__B = typing.TypeVar('_toArray__B')  # <B>
    def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__B]) -> typing.Any: ...
    _toBuffer__E = typing.TypeVar('_toBuffer__E')  # <E>
    def toBuffer(self) -> scala.collection.mutable.Buffer[_toBuffer__E]: ...
    def toCollection(self, repr: typing.Any) -> scala.collection.Iterable: ...
    def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq[scala.Tuple2[_TrieMap__K, _TrieMap__V]]: ...
    def toIterable(self) -> scala.collection.Iterable[scala.Tuple2[_TrieMap__K, _TrieMap__V]]: ...
    def toIterator(self) -> scala.collection.Iterator[scala.Tuple2[_TrieMap__K, _TrieMap__V]]: ...
    def toList(self) -> scala.collection.immutable.List[scala.Tuple2[_TrieMap__K, _TrieMap__V]]: ...
    _toMap__T = typing.TypeVar('_toMap__T')  # <T>
    _toMap__U = typing.TypeVar('_toMap__U')  # <U>
    def toMap(self, ev: scala.Predef..less.colon.less[scala.Tuple2[_TrieMap__K, _TrieMap__V], scala.Tuple2[_toMap__T, _toMap__U]]) -> scala.collection.immutable.Map[_toMap__T, _toMap__U]: ...
    def toSeq(self) -> scala.collection.Seq[scala.Tuple2[_TrieMap__K, _TrieMap__V]]: ...
    _toSet__B = typing.TypeVar('_toSet__B')  # <B>
    def toSet(self) -> scala.collection.immutable.Set[_toSet__B]: ...
    def toStream(self) -> scala.collection.immutable.Stream[scala.Tuple2[_TrieMap__K, _TrieMap__V]]: ...
    def toString(self) -> str: ...
    def toTraversable(self) -> scala.collection.Traversable[scala.Tuple2[_TrieMap__K, _TrieMap__V]]: ...
    def toVector(self) -> scala.collection.immutable.Vector[scala.Tuple2[_TrieMap__K, _TrieMap__V]]: ...
    def transform(self, f: scala.Function2[_TrieMap__K, _TrieMap__V, _TrieMap__V]) -> scala.collection.mutable.MapLike[_TrieMap__K, _TrieMap__V, 'TrieMap'[_TrieMap__K, _TrieMap__V]]: ...
    def transpose(self, asTraversable: scala.Function1) -> scala.collection.GenTraversable: ...
    _unzip__A1 = typing.TypeVar('_unzip__A1')  # <A1>
    _unzip__A2 = typing.TypeVar('_unzip__A2')  # <A2>
    def unzip(self, asPair: scala.Function1[scala.Tuple2[_TrieMap__K, _TrieMap__V], scala.Tuple2[_unzip__A1, _unzip__A2]]) -> scala.Tuple2[scala.collection.mutable.Iterable[_unzip__A1], scala.collection.mutable.Iterable[_unzip__A2]]: ...
    _unzip3__A1 = typing.TypeVar('_unzip3__A1')  # <A1>
    _unzip3__A2 = typing.TypeVar('_unzip3__A2')  # <A2>
    _unzip3__A3 = typing.TypeVar('_unzip3__A3')  # <A3>
    def unzip3(self, asTriple: scala.Function1[scala.Tuple2[_TrieMap__K, _TrieMap__V], scala.Tuple3[_unzip3__A1, _unzip3__A2, _unzip3__A3]]) -> scala.Tuple3[scala.collection.mutable.Iterable[_unzip3__A1], scala.collection.mutable.Iterable[_unzip3__A2], scala.collection.mutable.Iterable[_unzip3__A3]]: ...
    def update(self, k: _TrieMap__K, v: _TrieMap__V) -> None: ...
    _updated__V1 = typing.TypeVar('_updated__V1')  # <V1>
    def updated(self, key: _TrieMap__K, value: _updated__V1) -> scala.collection.mutable.Map[_TrieMap__K, _updated__V1]: ...
    def values(self) -> scala.collection.Iterable[_TrieMap__V]: ...
    def valuesIterator(self) -> scala.collection.Iterator[_TrieMap__V]: ...
    @typing.overload
    def view(self) -> scala.collection.IterableView[scala.Tuple2[_TrieMap__K, _TrieMap__V], 'TrieMap'[_TrieMap__K, _TrieMap__V]]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> scala.collection.IterableView[scala.Tuple2[_TrieMap__K, _TrieMap__V], 'TrieMap'[_TrieMap__K, _TrieMap__V]]: ...
    def withDefault(self, d: scala.Function1[_TrieMap__K, _TrieMap__V]) -> scala.collection.mutable.Map[_TrieMap__K, _TrieMap__V]: ...
    def withDefaultValue(self, d: _TrieMap__V) -> scala.collection.mutable.Map[_TrieMap__K, _TrieMap__V]: ...
    def withFilter(self, p: scala.Function1[scala.Tuple2[_TrieMap__K, _TrieMap__V], typing.Any]) -> scala.collection.generic.FilterMonadic[scala.Tuple2[_TrieMap__K, _TrieMap__V], 'TrieMap'[_TrieMap__K, _TrieMap__V]]: ...
    _zip__A1 = typing.TypeVar('_zip__A1')  # <A1>
    _zip__B = typing.TypeVar('_zip__B')  # <B>
    _zip__That = typing.TypeVar('_zip__That')  # <That>
    def zip(self, that: scala.collection.GenIterable[_zip__B], bf: scala.collection.generic.CanBuildFrom['TrieMap'[_TrieMap__K, _TrieMap__V], scala.Tuple2[_zip__A1, _zip__B], _zip__That]) -> _zip__That: ...
    _zipAll__B = typing.TypeVar('_zipAll__B')  # <B>
    _zipAll__A1 = typing.TypeVar('_zipAll__A1')  # <A1>
    _zipAll__That = typing.TypeVar('_zipAll__That')  # <That>
    def zipAll(self, that: scala.collection.GenIterable[_zipAll__B], thisElem: _zipAll__A1, thatElem: _zipAll__B, bf: scala.collection.generic.CanBuildFrom['TrieMap'[_TrieMap__K, _TrieMap__V], scala.Tuple2[_zipAll__A1, _zipAll__B], _zipAll__That]) -> _zipAll__That: ...
    _zipWithIndex__A1 = typing.TypeVar('_zipWithIndex__A1')  # <A1>
    _zipWithIndex__That = typing.TypeVar('_zipWithIndex__That')  # <That>
    def zipWithIndex(self, bf: scala.collection.generic.CanBuildFrom['TrieMap'[_TrieMap__K, _TrieMap__V], scala.Tuple2[_zipWithIndex__A1, typing.Any], _zipWithIndex__That]) -> _zipWithIndex__That: ...
    class MangledHashing(scala.util.hashing.Hashing[_TrieMap__MangledHashing__K], typing.Generic[_TrieMap__MangledHashing__K]):
        def __init__(self): ...
        def hash(self, k: _TrieMap__MangledHashing__K) -> int: ...

class INodeBase: ...

_INode__K = typing.TypeVar('_INode__K')  # <K>
_INode__V = typing.TypeVar('_INode__V')  # <V>
class INode(INodeBase[_INode__K, _INode__V], typing.Generic[_INode__K, _INode__V]):
    @typing.overload
    def __init__(self, g: 'Gen'): ...
    @typing.overload
    def __init__(self, bn: MainNode[_INode__K, _INode__V], g: 'Gen'): ...
    def CAS(self, old: MainNode[_INode__K, _INode__V], n: MainNode[_INode__K, _INode__V]) -> bool: ...
    def GCAS(self, old: MainNode[_INode__K, _INode__V], n: MainNode[_INode__K, _INode__V], ct: TrieMap[_INode__K, _INode__V]) -> bool: ...
    def GCAS_READ(self, ct: TrieMap[_INode__K, _INode__V]) -> MainNode[_INode__K, _INode__V]: ...
    @staticmethod
    def KEY_ABSENT() -> typing.Any: ...
    @staticmethod
    def KEY_PRESENT() -> typing.Any: ...
    def WRITE(self, nval: MainNode[_INode__K, _INode__V]) -> None: ...
    def cachedSize(self, ct: TrieMap[_INode__K, _INode__V]) -> int: ...
    def copyToGen(self, ngen: 'Gen', ct: TrieMap[_INode__K, _INode__V]) -> 'INode'[_INode__K, _INode__V]: ...
    def gcasRead(self, ct: TrieMap[_INode__K, _INode__V]) -> MainNode[_INode__K, _INode__V]: ...
    def isNullInode(self, ct: TrieMap[_INode__K, _INode__V]) -> bool: ...
    _newRootNode__K = typing.TypeVar('_newRootNode__K')  # <K>
    _newRootNode__V = typing.TypeVar('_newRootNode__V')  # <V>
    @staticmethod
    def newRootNode() -> 'INode'[_newRootNode__K, _newRootNode__V]: ...
    def rec_insert(self, k: _INode__K, v: _INode__V, hc: int, lev: int, parent: 'INode'[_INode__K, _INode__V], startgen: 'Gen', ct: TrieMap[_INode__K, _INode__V]) -> bool: ...
    def rec_insertif(self, k: _INode__K, v: _INode__V, hc: int, cond: typing.Any, lev: int, parent: 'INode'[_INode__K, _INode__V], startgen: 'Gen', ct: TrieMap[_INode__K, _INode__V]) -> scala.Option[_INode__V]: ...
    def rec_lookup(self, k: _INode__K, hc: int, lev: int, parent: 'INode'[_INode__K, _INode__V], startgen: 'Gen', ct: TrieMap[_INode__K, _INode__V]) -> typing.Any: ...
    def rec_remove(self, k: _INode__K, v: _INode__V, hc: int, lev: int, parent: 'INode'[_INode__K, _INode__V], startgen: 'Gen', ct: TrieMap[_INode__K, _INode__V]) -> scala.Option[_INode__V]: ...
    def string(self, lev: int) -> str: ...

class Gen: ...

_CNode__K = typing.TypeVar('_CNode__K')  # <K>
_CNode__V = typing.TypeVar('_CNode__V')  # <V>
class CNode(scala.collection.concurrent.CNodeBase[_CNode__K, _CNode__V], typing.Generic[_CNode__K, _CNode__V]):
    def __init__(self, bitmap: int, array: typing.List[BasicNode], gen: Gen): ...
    def array(self) -> typing.List[BasicNode]: ...
    def bitmap(self) -> int: ...
    def cachedSize(self, ct: typing.Any) -> int: ...
    _dual__K = typing.TypeVar('_dual__K')  # <K>
    _dual__V = typing.TypeVar('_dual__V')  # <V>
    @staticmethod
    def dual(x: SNode[_dual__K, _dual__V], xhc: int, y: SNode[_dual__K, _dual__V], yhc: int, lev: int, gen: Gen) -> MainNode[_dual__K, _dual__V]: ...
    def gen(self) -> Gen: ...
    def insertedAt(self, pos: int, flag: int, nn: BasicNode, gen: Gen) -> 'CNode'[_CNode__K, _CNode__V]: ...
    def removedAt(self, pos: int, flag: int, gen: Gen) -> 'CNode'[_CNode__K, _CNode__V]: ...
    def renewed(self, ngen: Gen, ct: TrieMap[_CNode__K, _CNode__V]) -> 'CNode'[_CNode__K, _CNode__V]: ...
    def string(self, lev: int) -> str: ...
    def toCompressed(self, ct: TrieMap[_CNode__K, _CNode__V], lev: int, gen: Gen) -> MainNode[_CNode__K, _CNode__V]: ...
    def toContracted(self, lev: int) -> MainNode[_CNode__K, _CNode__V]: ...
    def toString(self) -> str: ...
    def updatedAt(self, pos: int, nn: BasicNode, gen: Gen) -> 'CNode'[_CNode__K, _CNode__V]: ...

class CNodeBase: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("scala.collection.concurrent")``.

    BasicNode: typing.Type[BasicNode]
    CNode: typing.Type[CNode]
    CNodeBase: typing.Type[CNodeBase]
    Debug: typing.Type[Debug]
    FailedNode: typing.Type[FailedNode]
    Gen: typing.Type[Gen]
    INode: typing.Type[INode]
    INodeBase: typing.Type[INodeBase]
    KVNode: typing.Type[KVNode]
    LNode: typing.Type[LNode]
    MainNode: typing.Type[MainNode]
    Map: typing.Type[Map]
    RDCSS_Descriptor: typing.Type[RDCSS_Descriptor]
    RestartException: typing.Type[RestartException]
    SNode: typing.Type[SNode]
    TNode: typing.Type[TNode]
    TrieMap: typing.Type[TrieMap]
    TrieMapIterator: typing.Type[TrieMapIterator]
    TrieMapSerializationEnd: typing.Type[TrieMapSerializationEnd]
