import java.lang
import java.net
import scala
import scala.collection
import scala.collection.immutable
import scala.reflect
import scala.reflect.api
import scala.reflect.internal.util
import scala.reflect.macros.blackbox
import scala.reflect.macros.internal
import scala.reflect.macros.whitebox
import scala.runtime
import typing



class Aliases:
    @staticmethod
    def $init$($this: 'Aliases') -> None: ...
    _Expr_0__T = typing.TypeVar('_Expr_0__T')  # <T>
    @typing.overload
    def Expr(self, tree: scala.reflect.api.Trees.TreeApi, evidence$1: scala.reflect.api.TypeTags.WeakTypeTag[_Expr_0__T]) -> scala.reflect.api.Exprs.Expr[_Expr_0__T]: ...
    @typing.overload
    def Expr(self) -> scala.reflect.api.Exprs.Expr.: ...
    _TypeTag_0__T = typing.TypeVar('_TypeTag_0__T')  # <T>
    @typing.overload
    def TypeTag(self, tpe: scala.reflect.api.Types.TypeApi) -> scala.reflect.api.TypeTags.TypeTag[_TypeTag_0__T]: ...
    @typing.overload
    def TypeTag(self) -> scala.reflect.api.TypeTags.TypeTag.: ...
    _WeakTypeTag_0__T = typing.TypeVar('_WeakTypeTag_0__T')  # <T>
    @typing.overload
    def WeakTypeTag(self, tpe: scala.reflect.api.Types.TypeApi) -> scala.reflect.api.TypeTags.WeakTypeTag[_WeakTypeTag_0__T]: ...
    @typing.overload
    def WeakTypeTag(self) -> scala.reflect.api.TypeTags.WeakTypeTag.: ...
    def scala$reflect$macros$Aliases$_setter_$Expr_$eq(self, x$1: scala.reflect.api.Exprs.Expr.) -> None: ...
    def scala$reflect$macros$Aliases$_setter_$TypeTag_$eq(self, x$1: scala.reflect.api.TypeTags.TypeTag.) -> None: ...
    def scala$reflect$macros$Aliases$_setter_$WeakTypeTag_$eq(self, x$1: scala.reflect.api.TypeTags.WeakTypeTag.) -> None: ...
    _symbolOf__T = typing.TypeVar('_symbolOf__T')  # <T>
    def symbolOf(self, evidence$2: scala.reflect.api.TypeTags.WeakTypeTag[_symbolOf__T]) -> scala.reflect.api.Symbols.TypeSymbolApi: ...
    _typeOf__T = typing.TypeVar('_typeOf__T')  # <T>
    def typeOf(self, ttag: scala.reflect.api.TypeTags.TypeTag[_typeOf__T]) -> scala.reflect.api.Types.TypeApi: ...
    _typeTag__T = typing.TypeVar('_typeTag__T')  # <T>
    def typeTag(self, ttag: scala.reflect.api.TypeTags.TypeTag[_typeTag__T]) -> scala.reflect.api.TypeTags.TypeTag[_typeTag__T]: ...
    _weakTypeOf__T = typing.TypeVar('_weakTypeOf__T')  # <T>
    def weakTypeOf(self, attag: scala.reflect.api.TypeTags.WeakTypeTag[_weakTypeOf__T]) -> scala.reflect.api.Types.TypeApi: ...
    _weakTypeTag__T = typing.TypeVar('_weakTypeTag__T')  # <T>
    def weakTypeTag(self, attag: scala.reflect.api.TypeTags.WeakTypeTag[_weakTypeTag__T]) -> scala.reflect.api.TypeTags.WeakTypeTag[_weakTypeTag__T]: ...

class Attachments:
    def __init__(self): ...
    def all(self) -> scala.collection.immutable.Set[typing.Any]: ...
    _contains__T = typing.TypeVar('_contains__T')  # <T>
    def contains(self, evidence$3: scala.reflect.ClassTag[_contains__T]) -> bool: ...
    _get__T = typing.TypeVar('_get__T')  # <T>
    def get(self, evidence$2: scala.reflect.ClassTag[_get__T]) -> scala.Option[_get__T]: ...
    def isEmpty(self) -> bool: ...
    def pos(self) -> typing.Any: ...
    _remove__T = typing.TypeVar('_remove__T')  # <T>
    def remove(self, evidence$5: scala.reflect.ClassTag[_remove__T]) -> 'Attachments': ...
    _update__T = typing.TypeVar('_update__T')  # <T>
    def update(self, attachment: _update__T, evidence$4: scala.reflect.ClassTag[_update__T]) -> 'Attachments': ...
    def withPos(self, newPos: typing.Any) -> 'Attachments': ...

class Enclosures:
    @staticmethod
    def $init$($this: 'Enclosures') -> None: ...
    def enclosingClass(self) -> scala.reflect.api.Trees.TreeApi: ...
    def enclosingDef(self) -> scala.reflect.api.Trees.DefDefApi: ...
    def enclosingImpl(self) -> scala.reflect.api.Trees.ImplDefApi: ...
    def enclosingMacros(self) -> scala.collection.immutable.List[scala.reflect.macros.blackbox.Context]: ...
    def enclosingMethod(self) -> scala.reflect.api.Trees.TreeApi: ...
    def enclosingPackage(self) -> scala.reflect.api.Trees.PackageDefApi: ...
    def enclosingPosition(self) -> scala.reflect.api.Position: ...
    def enclosingRun(self) -> 'Universe.RunContextApi': ...
    def enclosingTemplate(self) -> scala.reflect.api.Trees.TemplateApi: ...
    def enclosingUnit(self) -> 'Universe.CompilationUnitContextApi': ...
    def macroApplication(self) -> scala.reflect.api.Trees.TreeApi: ...
    class EnclosureException(java.lang.Exception, scala.Product, scala.Serializable):
        $outer: scala.reflect.macros.blackbox.Context = ...
        def __init__(self, $outer: scala.reflect.macros.blackbox.Context, expected: typing.Type[typing.Any], enclosingTrees: scala.collection.immutable.List[scala.reflect.api.Trees.TreeApi]): ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        def copy(self, expected: typing.Type[typing.Any], enclosingTrees: scala.collection.immutable.List[scala.reflect.api.Trees.TreeApi]) -> 'Enclosures.EnclosureException': ...
        def copy$default$1(self) -> typing.Type[typing.Any]: ...
        def copy$default$2(self) -> scala.collection.immutable.List[scala.reflect.api.Trees.TreeApi]: ...
        def enclosingTrees(self) -> scala.collection.immutable.List[scala.reflect.api.Trees.TreeApi]: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def expected(self) -> typing.Type[typing.Any]: ...
        def hashCode(self) -> int: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> str: ...
    class EnclosureException$(scala.runtime.AbstractFunction2[typing.Type[typing.Any], scala.collection.immutable.List[scala.reflect.api.Trees.TreeApi], 'Enclosures.EnclosureException'], scala.Serializable):
        def __init__(self, $outer: scala.reflect.macros.blackbox.Context): ...
        def apply(self, expected: typing.Type[typing.Any], enclosingTrees: scala.collection.immutable.List[scala.reflect.api.Trees.TreeApi]) -> 'Enclosures.EnclosureException': ...
        def toString(self) -> str: ...
        def unapply(self, x$0: 'Enclosures.EnclosureException') -> scala.Option[scala.Tuple2[typing.Type[typing.Any], scala.collection.immutable.List[scala.reflect.api.Trees.TreeApi]]]: ...

class Evals:
    _eval__T = typing.TypeVar('_eval__T')  # <T>
    def eval(self, expr: scala.reflect.api.Exprs.Expr[_eval__T]) -> _eval__T: ...

class ExprUtils:
    @typing.overload
    def literal(self, x: bool) -> scala.reflect.api.Exprs.Expr[typing.Any]: ...
    @typing.overload
    def literal(self, x: int) -> scala.reflect.api.Exprs.Expr[typing.Any]: ...
    @typing.overload
    def literal(self, x: str) -> scala.reflect.api.Exprs.Expr[typing.Any]: ...
    @typing.overload
    def literal(self, x: float) -> scala.reflect.api.Exprs.Expr[typing.Any]: ...
    @typing.overload
    def literal(self, x: float) -> scala.reflect.api.Exprs.Expr[typing.Any]: ...
    @typing.overload
    def literal(self, x: int) -> scala.reflect.api.Exprs.Expr[typing.Any]: ...
    @typing.overload
    def literal(self, x: str) -> scala.reflect.api.Exprs.Expr[str]: ...
    @typing.overload
    def literal(self, x: int) -> scala.reflect.api.Exprs.Expr[typing.Any]: ...
    @typing.overload
    def literal(self, x: int) -> scala.reflect.api.Exprs.Expr[typing.Any]: ...
    def literalFalse(self) -> scala.reflect.api.Exprs.Expr[typing.Any]: ...
    def literalNull(self) -> scala.reflect.api.Exprs.Expr[scala.runtime.Null.]: ...
    def literalTrue(self) -> scala.reflect.api.Exprs.Expr[typing.Any]: ...
    def literalUnit(self) -> scala.reflect.api.Exprs.Expr[scala.runtime.BoxedUnit]: ...

class FrontEnds:
    def abort(self, pos: scala.reflect.api.Position, msg: str) -> scala.runtime.Nothing.: ...
    def echo(self, pos: scala.reflect.api.Position, msg: str) -> None: ...
    def error(self, pos: scala.reflect.api.Position, msg: str) -> None: ...
    def hasErrors(self) -> bool: ...
    def hasWarnings(self) -> bool: ...
    def info(self, pos: scala.reflect.api.Position, msg: str, force: bool) -> None: ...
    def warning(self, pos: scala.reflect.api.Position, msg: str) -> None: ...

class Infrastructure:
    def classPath(self) -> scala.collection.immutable.List[java.net.URL]: ...
    def compilerSettings(self) -> scala.collection.immutable.List[str]: ...
    def settings(self) -> scala.collection.immutable.List[str]: ...

class Names:
    _fresh_2__NameType = typing.TypeVar('_fresh_2__NameType', bound=scala.reflect.api.Names.NameApi)  # <NameType>
    @typing.overload
    def fresh(self) -> str: ...
    @typing.overload
    def fresh(self, name: str) -> str: ...
    @typing.overload
    def fresh(self, name: _fresh_2__NameType) -> _fresh_2__NameType: ...
    _freshName_2__NameType = typing.TypeVar('_freshName_2__NameType', bound=scala.reflect.api.Names.NameApi)  # <NameType>
    @typing.overload
    def freshName(self) -> str: ...
    @typing.overload
    def freshName(self, name: str) -> str: ...
    @typing.overload
    def freshName(self, name: _freshName_2__NameType) -> _freshName_2__NameType: ...

class ParseException(java.lang.Exception, scala.Product, scala.Serializable):
    def __init__(self, pos: scala.reflect.api.Position, msg: str): ...
    @staticmethod
    def apply(pos: scala.reflect.api.Position, msg: str) -> 'ParseException': ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def copy(self, pos: scala.reflect.api.Position, msg: str) -> 'ParseException': ...
    def copy$default$1(self) -> scala.reflect.api.Position: ...
    def copy$default$2(self) -> str: ...
    @staticmethod
    def curried() -> scala.Function1[scala.reflect.api.Position, scala.Function1[str, 'ParseException']]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def msg(self) -> str: ...
    def pos(self) -> scala.reflect.api.Position: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> str: ...
    @staticmethod
    def tupled() -> scala.Function1[scala.Tuple2[scala.reflect.api.Position, str], 'ParseException']: ...
    @staticmethod
    def unapply(x$0: 'ParseException') -> scala.Option[scala.Tuple2[scala.reflect.api.Position, str]]: ...

class Parsers:
    def parse(self, code: str) -> scala.reflect.api.Trees.TreeApi: ...

class ReificationException(java.lang.Exception, scala.Product, scala.Serializable):
    def __init__(self, pos: scala.reflect.api.Position, msg: str): ...
    @staticmethod
    def apply(pos: scala.reflect.api.Position, msg: str) -> 'ReificationException': ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def copy(self, pos: scala.reflect.api.Position, msg: str) -> 'ReificationException': ...
    def copy$default$1(self) -> scala.reflect.api.Position: ...
    def copy$default$2(self) -> str: ...
    @staticmethod
    def curried() -> scala.Function1[scala.reflect.api.Position, scala.Function1[str, 'ReificationException']]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def msg(self) -> str: ...
    def pos(self) -> scala.reflect.api.Position: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> str: ...
    @staticmethod
    def tupled() -> scala.Function1[scala.Tuple2[scala.reflect.api.Position, str], 'ReificationException']: ...
    @staticmethod
    def unapply(x$0: 'ReificationException') -> scala.Option[scala.Tuple2[scala.reflect.api.Position, str]]: ...

class Reifiers:
    def reifyEnclosingRuntimeClass(self) -> scala.reflect.api.Trees.TreeApi: ...
    def reifyRuntimeClass(self, tpe: scala.reflect.api.Types.TypeApi, concrete: bool) -> scala.reflect.api.Trees.TreeApi: ...
    def reifyRuntimeClass$default$2(self) -> bool: ...
    def reifyTree(self, universe: scala.reflect.api.Trees.TreeApi, mirror: scala.reflect.api.Trees.TreeApi, tree: scala.reflect.api.Trees.TreeApi) -> scala.reflect.api.Trees.TreeApi: ...
    def reifyType(self, universe: scala.reflect.api.Trees.TreeApi, mirror: scala.reflect.api.Trees.TreeApi, tpe: scala.reflect.api.Types.TypeApi, concrete: bool) -> scala.reflect.api.Trees.TreeApi: ...
    def reifyType$default$4(self) -> bool: ...
    def unreifyTree(self, tree: scala.reflect.api.Trees.TreeApi) -> scala.reflect.api.Trees.TreeApi: ...

class TypecheckException(java.lang.Exception, scala.Product, scala.Serializable):
    def __init__(self, pos: scala.reflect.api.Position, msg: str): ...
    @staticmethod
    def apply(pos: scala.reflect.api.Position, msg: str) -> 'TypecheckException': ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def copy(self, pos: scala.reflect.api.Position, msg: str) -> 'TypecheckException': ...
    def copy$default$1(self) -> scala.reflect.api.Position: ...
    def copy$default$2(self) -> str: ...
    @staticmethod
    def curried() -> scala.Function1[scala.reflect.api.Position, scala.Function1[str, 'TypecheckException']]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def msg(self) -> str: ...
    def pos(self) -> scala.reflect.api.Position: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> str: ...
    @staticmethod
    def tupled() -> scala.Function1[scala.Tuple2[scala.reflect.api.Position, str], 'TypecheckException']: ...
    @staticmethod
    def unapply(x$0: 'TypecheckException') -> scala.Option[scala.Tuple2[scala.reflect.api.Position, str]]: ...

class Typers:
    @staticmethod
    def $init$($this: 'Typers') -> None: ...
    def PATTERNmode(self) -> typing.Any: ...
    def TERMmode(self) -> typing.Any: ...
    def TYPEmode(self) -> typing.Any: ...
    def TypecheckException(self) -> 'TypecheckException.': ...
    def inferImplicitValue(self, pt: scala.reflect.api.Types.TypeApi, silent: bool, withMacrosDisabled: bool, pos: scala.reflect.api.Position) -> scala.reflect.api.Trees.TreeApi: ...
    def inferImplicitValue$default$2(self) -> bool: ...
    def inferImplicitValue$default$3(self) -> bool: ...
    def inferImplicitValue$default$4(self) -> scala.reflect.api.Position: ...
    def inferImplicitView(self, tree: scala.reflect.api.Trees.TreeApi, from_: scala.reflect.api.Types.TypeApi, to: scala.reflect.api.Types.TypeApi, silent: bool, withMacrosDisabled: bool, pos: scala.reflect.api.Position) -> scala.reflect.api.Trees.TreeApi: ...
    def inferImplicitView$default$4(self) -> bool: ...
    def inferImplicitView$default$5(self) -> bool: ...
    def inferImplicitView$default$6(self) -> scala.reflect.api.Position: ...
    def openMacros(self) -> scala.collection.immutable.List[scala.reflect.macros.blackbox.Context]: ...
    def resetLocalAttrs(self, tree: scala.reflect.api.Trees.TreeApi) -> scala.reflect.api.Trees.TreeApi: ...
    def scala$reflect$macros$Typers$_setter_$TypecheckException_$eq(self, x$1: 'TypecheckException.') -> None: ...
    def typeCheck(self, tree: scala.reflect.api.Trees.TreeApi, pt: scala.reflect.api.Types.TypeApi, silent: bool, withImplicitViewsDisabled: bool, withMacrosDisabled: bool) -> scala.reflect.api.Trees.TreeApi: ...
    def typeCheck$default$2(self) -> scala.reflect.api.Types.TypeApi: ...
    def typeCheck$default$3(self) -> bool: ...
    def typeCheck$default$4(self) -> bool: ...
    def typeCheck$default$5(self) -> bool: ...
    def typecheck(self, tree: scala.reflect.api.Trees.TreeApi, mode: typing.Any, pt: scala.reflect.api.Types.TypeApi, silent: bool, withImplicitViewsDisabled: bool, withMacrosDisabled: bool) -> scala.reflect.api.Trees.TreeApi: ...
    def typecheck$default$2(self) -> typing.Any: ...
    def typecheck$default$3(self) -> scala.reflect.api.Types.TypeApi: ...
    def typecheck$default$4(self) -> bool: ...
    def typecheck$default$5(self) -> bool: ...
    def typecheck$default$6(self) -> bool: ...
    def untypecheck(self, tree: scala.reflect.api.Trees.TreeApi) -> scala.reflect.api.Trees.TreeApi: ...

class UnexpectedReificationException(java.lang.Exception, scala.Product, scala.Serializable):
    def __init__(self, pos: scala.reflect.api.Position, msg: str, cause: java.lang.Throwable): ...
    @staticmethod
    def $lessinit$greater$default$3() -> java.lang.Throwable: ...
    @staticmethod
    def apply(pos: scala.reflect.api.Position, msg: str, cause: java.lang.Throwable) -> 'UnexpectedReificationException': ...
    @staticmethod
    def apply$default$3() -> java.lang.Throwable: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def cause(self) -> java.lang.Throwable: ...
    def copy(self, pos: scala.reflect.api.Position, msg: str, cause: java.lang.Throwable) -> 'UnexpectedReificationException': ...
    def copy$default$1(self) -> scala.reflect.api.Position: ...
    def copy$default$2(self) -> str: ...
    def copy$default$3(self) -> java.lang.Throwable: ...
    @staticmethod
    def curried() -> scala.Function1[scala.reflect.api.Position, scala.Function1[str, scala.Function1[java.lang.Throwable, 'UnexpectedReificationException']]]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def msg(self) -> str: ...
    def pos(self) -> scala.reflect.api.Position: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> str: ...
    @staticmethod
    def tupled() -> scala.Function1[scala.Tuple3[scala.reflect.api.Position, str, java.lang.Throwable], 'UnexpectedReificationException']: ...
    @staticmethod
    def unapply(x$0: 'UnexpectedReificationException') -> scala.Option[scala.Tuple3[scala.reflect.api.Position, str, java.lang.Throwable]]: ...

_Universe__MacroInternalApi__MacroDecoratorApi__MacroScopeDecoratorApi__T = typing.TypeVar('_Universe__MacroInternalApi__MacroDecoratorApi__MacroScopeDecoratorApi__T', bound=scala.reflect.api.Scopes.ScopeApi)  # <T>
_Universe__MacroInternalApi__MacroDecoratorApi__MacroSymbolDecoratorApi__T = typing.TypeVar('_Universe__MacroInternalApi__MacroDecoratorApi__MacroSymbolDecoratorApi__T', bound=scala.reflect.api.Symbols.SymbolApi)  # <T>
_Universe__MacroInternalApi__MacroDecoratorApi__MacroTreeDecoratorApi__T = typing.TypeVar('_Universe__MacroInternalApi__MacroDecoratorApi__MacroTreeDecoratorApi__T', bound=scala.reflect.api.Trees.TreeApi)  # <T>
_Universe__MacroInternalApi__MacroDecoratorApi__MacroTypeTreeDecoratorApi__T = typing.TypeVar('_Universe__MacroInternalApi__MacroDecoratorApi__MacroTypeTreeDecoratorApi__T', bound=scala.reflect.api.Trees.TypeTreeApi)  # <T>
class Universe(scala.reflect.api.Universe):
    def __init__(self): ...
    def treeBuild(self) -> 'Universe.TreeGen': ...
    class CompilationUnitContextApi:
        def body(self) -> scala.reflect.api.Trees.TreeApi: ...
        def source(self) -> scala.reflect.internal.util.SourceFile: ...
    class MacroCompatApi(scala.reflect.api.Internals.CompatApi):
        @staticmethod
        def $init$($this: 'Universe.MacroCompatApi') -> None: ...
        def captureVariable(self, vble: scala.reflect.api.Symbols.SymbolApi) -> None: ...
        def capturedVariableType(self, vble: scala.reflect.api.Symbols.SymbolApi) -> scala.reflect.api.Types.TypeApi: ...
        def referenceCapturedVariable(self, vble: scala.reflect.api.Symbols.SymbolApi) -> scala.reflect.api.Trees.TreeApi: ...
        class CompatibleTypeTree:
            $outer: 'Universe.MacroCompatApi' = ...
            def __init__(self, $outer: 'Universe.MacroCompatApi', tt: scala.reflect.api.Trees.TypeTreeApi): ...
            def setOriginal(self, tree: scala.reflect.api.Trees.TreeApi) -> scala.reflect.api.Trees.TypeTreeApi: ...
        class MacroCompatibleSymbol:
            $outer: 'Universe.MacroCompatApi' = ...
            def __init__(self, $outer: 'Universe.MacroCompatApi', symbol: scala.reflect.api.Symbols.SymbolApi): ...
            def attachments(self) -> Attachments: ...
            _removeAttachment__T = typing.TypeVar('_removeAttachment__T')  # <T>
            def removeAttachment(self, evidence$10: scala.reflect.ClassTag[_removeAttachment__T]) -> scala.reflect.api.Symbols.SymbolApi: ...
            def setAnnotations(self, annots: scala.collection.Seq[scala.reflect.api.Annotations.AnnotationApi]) -> scala.reflect.api.Symbols.SymbolApi: ...
            def setName(self, name: scala.reflect.api.Names.NameApi) -> scala.reflect.api.Symbols.SymbolApi: ...
            def setPrivateWithin(self, sym: scala.reflect.api.Symbols.SymbolApi) -> scala.reflect.api.Symbols.SymbolApi: ...
            def setTypeSignature(self, tpe: scala.reflect.api.Types.TypeApi) -> scala.reflect.api.Symbols.SymbolApi: ...
            _updateAttachment__T = typing.TypeVar('_updateAttachment__T')  # <T>
            def updateAttachment(self, attachment: _updateAttachment__T, evidence$9: scala.reflect.ClassTag[_updateAttachment__T]) -> scala.reflect.api.Symbols.SymbolApi: ...
        class MacroCompatibleTree:
            $outer: 'Universe.MacroCompatApi' = ...
            def __init__(self, $outer: 'Universe.MacroCompatApi', tree: scala.reflect.api.Trees.TreeApi): ...
            def attachments(self) -> Attachments: ...
            def defineType(self, tp: scala.reflect.api.Types.TypeApi) -> scala.reflect.api.Trees.TreeApi: ...
            def pos_$eq(self, pos: scala.reflect.api.Position) -> None: ...
            _removeAttachment__T = typing.TypeVar('_removeAttachment__T')  # <T>
            def removeAttachment(self, evidence$12: scala.reflect.ClassTag[_removeAttachment__T]) -> scala.reflect.api.Trees.TreeApi: ...
            def setPos(self, newpos: scala.reflect.api.Position) -> scala.reflect.api.Trees.TreeApi: ...
            def setSymbol(self, sym: scala.reflect.api.Symbols.SymbolApi) -> scala.reflect.api.Trees.TreeApi: ...
            def setType(self, tp: scala.reflect.api.Types.TypeApi) -> scala.reflect.api.Trees.TreeApi: ...
            def symbol_$eq(self, sym: scala.reflect.api.Symbols.SymbolApi) -> None: ...
            def tpe_$eq(self, t: scala.reflect.api.Types.TypeApi) -> None: ...
            _updateAttachment__T = typing.TypeVar('_updateAttachment__T')  # <T>
            def updateAttachment(self, attachment: _updateAttachment__T, evidence$11: scala.reflect.ClassTag[_updateAttachment__T]) -> scala.reflect.api.Trees.TreeApi: ...
    class MacroInternalApi(scala.reflect.api.Internals.InternalApi):
        @staticmethod
        def $init$($this: 'Universe.MacroInternalApi') -> None: ...
        @typing.overload
        def attachments(self, symbol: scala.reflect.api.Symbols.SymbolApi) -> Attachments: ...
        @typing.overload
        def attachments(self, tree: scala.reflect.api.Trees.TreeApi) -> Attachments: ...
        def captureVariable(self, vble: scala.reflect.api.Symbols.SymbolApi) -> None: ...
        def capturedVariableType(self, vble: scala.reflect.api.Symbols.SymbolApi) -> scala.reflect.api.Types.TypeApi: ...
        def changeOwner(self, tree: scala.reflect.api.Trees.TreeApi, prev: scala.reflect.api.Symbols.SymbolApi, next: scala.reflect.api.Symbols.SymbolApi) -> scala.reflect.api.Trees.TreeApi: ...
        def defineType(self, tree: scala.reflect.api.Trees.TreeApi, tp: scala.reflect.api.Types.TypeApi) -> scala.reflect.api.Trees.TreeApi: ...
        def enter(self, scope: scala.reflect.api.Scopes.ScopeApi, sym: scala.reflect.api.Symbols.SymbolApi) -> scala.reflect.api.Scopes.ScopeApi: ...
        def gen(self) -> 'Universe.TreeGen': ...
        def referenceCapturedVariable(self, vble: scala.reflect.api.Symbols.SymbolApi) -> scala.reflect.api.Trees.TreeApi: ...
        _removeAttachment_0__T = typing.TypeVar('_removeAttachment_0__T')  # <T>
        _removeAttachment_1__T = typing.TypeVar('_removeAttachment_1__T')  # <T>
        @typing.overload
        def removeAttachment(self, symbol: scala.reflect.api.Symbols.SymbolApi, evidence$2: scala.reflect.ClassTag[_removeAttachment_0__T]) -> scala.reflect.api.Symbols.SymbolApi: ...
        @typing.overload
        def removeAttachment(self, tree: scala.reflect.api.Trees.TreeApi, evidence$4: scala.reflect.ClassTag[_removeAttachment_1__T]) -> scala.reflect.api.Trees.TreeApi: ...
        def resetFlag(self, symbol: scala.reflect.api.Symbols.SymbolApi, flags: typing.Any) -> scala.reflect.api.Symbols.SymbolApi: ...
        def setAnnotations(self, symbol: scala.reflect.api.Symbols.SymbolApi, annots: scala.collection.Seq[scala.reflect.api.Annotations.AnnotationApi]) -> scala.reflect.api.Symbols.SymbolApi: ...
        def setFlag(self, symbol: scala.reflect.api.Symbols.SymbolApi, flags: typing.Any) -> scala.reflect.api.Symbols.SymbolApi: ...
        def setInfo(self, symbol: scala.reflect.api.Symbols.SymbolApi, tpe: scala.reflect.api.Types.TypeApi) -> scala.reflect.api.Symbols.SymbolApi: ...
        def setName(self, symbol: scala.reflect.api.Symbols.SymbolApi, name: scala.reflect.api.Names.NameApi) -> scala.reflect.api.Symbols.SymbolApi: ...
        def setOriginal(self, tt: scala.reflect.api.Trees.TypeTreeApi, original: scala.reflect.api.Trees.TreeApi) -> scala.reflect.api.Trees.TypeTreeApi: ...
        def setOwner(self, symbol: scala.reflect.api.Symbols.SymbolApi, newowner: scala.reflect.api.Symbols.SymbolApi) -> scala.reflect.api.Symbols.SymbolApi: ...
        def setPos(self, tree: scala.reflect.api.Trees.TreeApi, newpos: scala.reflect.api.Position) -> scala.reflect.api.Trees.TreeApi: ...
        def setPrivateWithin(self, symbol: scala.reflect.api.Symbols.SymbolApi, sym: scala.reflect.api.Symbols.SymbolApi) -> scala.reflect.api.Symbols.SymbolApi: ...
        def setSymbol(self, tree: scala.reflect.api.Trees.TreeApi, sym: scala.reflect.api.Symbols.SymbolApi) -> scala.reflect.api.Trees.TreeApi: ...
        def setType(self, tree: scala.reflect.api.Trees.TreeApi, tp: scala.reflect.api.Types.TypeApi) -> scala.reflect.api.Trees.TreeApi: ...
        def subpatterns(self, tree: scala.reflect.api.Trees.TreeApi) -> scala.Option[scala.collection.immutable.List[scala.reflect.api.Trees.TreeApi]]: ...
        def unlink(self, scope: scala.reflect.api.Scopes.ScopeApi, sym: scala.reflect.api.Symbols.SymbolApi) -> scala.reflect.api.Scopes.ScopeApi: ...
        _updateAttachment_0__T = typing.TypeVar('_updateAttachment_0__T')  # <T>
        _updateAttachment_1__T = typing.TypeVar('_updateAttachment_1__T')  # <T>
        @typing.overload
        def updateAttachment(self, symbol: scala.reflect.api.Symbols.SymbolApi, attachment: _updateAttachment_0__T, evidence$1: scala.reflect.ClassTag[_updateAttachment_0__T]) -> scala.reflect.api.Symbols.SymbolApi: ...
        @typing.overload
        def updateAttachment(self, tree: scala.reflect.api.Trees.TreeApi, attachment: _updateAttachment_1__T, evidence$3: scala.reflect.ClassTag[_updateAttachment_1__T]) -> scala.reflect.api.Trees.TreeApi: ...
        class MacroDecoratorApi(scala.reflect.api.Internals.InternalApi.DecoratorApi):
            @staticmethod
            def $init$($this: 'Universe.MacroInternalApi.MacroDecoratorApi') -> None: ...
            _scopeDecorator__T = typing.TypeVar('_scopeDecorator__T', bound=scala.reflect.api.Scopes.ScopeApi)  # <T>
            def scopeDecorator(self, tree: _scopeDecorator__T) -> 'Universe.MacroInternalApi.MacroDecoratorApi.MacroScopeDecoratorApi': ...
            _typeTreeDecorator__T = typing.TypeVar('_typeTreeDecorator__T', bound=scala.reflect.api.Trees.TypeTreeApi)  # <T>
            def typeTreeDecorator(self, tt: _typeTreeDecorator__T) -> 'Universe.MacroInternalApi.MacroDecoratorApi.MacroTypeTreeDecoratorApi': ...
            class MacroScopeDecoratorApi(typing.Generic[_Universe__MacroInternalApi__MacroDecoratorApi__MacroScopeDecoratorApi__T]):
                $outer: 'Universe.MacroInternalApi.MacroDecoratorApi' = ...
                def __init__(self, $outer: 'Universe.MacroInternalApi.MacroDecoratorApi', scope: _Universe__MacroInternalApi__MacroDecoratorApi__MacroScopeDecoratorApi__T): ...
                def enter(self, sym: scala.reflect.api.Symbols.SymbolApi) -> _Universe__MacroInternalApi__MacroDecoratorApi__MacroScopeDecoratorApi__T: ...
                def scope(self) -> _Universe__MacroInternalApi__MacroDecoratorApi__MacroScopeDecoratorApi__T: ...
                def unlink(self, sym: scala.reflect.api.Symbols.SymbolApi) -> _Universe__MacroInternalApi__MacroDecoratorApi__MacroScopeDecoratorApi__T: ...
            class MacroSymbolDecoratorApi(scala.reflect.api.Internals.InternalApi.DecoratorApi.SymbolDecoratorApi[_Universe__MacroInternalApi__MacroDecoratorApi__MacroSymbolDecoratorApi__T], typing.Generic[_Universe__MacroInternalApi__MacroDecoratorApi__MacroSymbolDecoratorApi__T]):
                def __init__(self, $outer: 'Universe.MacroInternalApi.MacroDecoratorApi', symbol: _Universe__MacroInternalApi__MacroDecoratorApi__MacroSymbolDecoratorApi__T): ...
                def attachments(self) -> Attachments: ...
                _removeAttachment__A = typing.TypeVar('_removeAttachment__A')  # <A>
                def removeAttachment(self, evidence$8: scala.reflect.ClassTag[_removeAttachment__A]) -> _Universe__MacroInternalApi__MacroDecoratorApi__MacroSymbolDecoratorApi__T: ...
                def resetFlag(self, flags: typing.Any) -> _Universe__MacroInternalApi__MacroDecoratorApi__MacroSymbolDecoratorApi__T: ...
                def setAnnotations(self, annots: scala.collection.Seq[scala.reflect.api.Annotations.AnnotationApi]) -> _Universe__MacroInternalApi__MacroDecoratorApi__MacroSymbolDecoratorApi__T: ...
                def setFlag(self, flags: typing.Any) -> _Universe__MacroInternalApi__MacroDecoratorApi__MacroSymbolDecoratorApi__T: ...
                def setInfo(self, tpe: scala.reflect.api.Types.TypeApi) -> _Universe__MacroInternalApi__MacroDecoratorApi__MacroSymbolDecoratorApi__T: ...
                def setName(self, name: scala.reflect.api.Names.NameApi) -> _Universe__MacroInternalApi__MacroDecoratorApi__MacroSymbolDecoratorApi__T: ...
                def setOwner(self, newowner: scala.reflect.api.Symbols.SymbolApi) -> _Universe__MacroInternalApi__MacroDecoratorApi__MacroSymbolDecoratorApi__T: ...
                def setPrivateWithin(self, sym: scala.reflect.api.Symbols.SymbolApi) -> _Universe__MacroInternalApi__MacroDecoratorApi__MacroSymbolDecoratorApi__T: ...
                def symbol(self) -> _Universe__MacroInternalApi__MacroDecoratorApi__MacroSymbolDecoratorApi__T: ...
                _updateAttachment__A = typing.TypeVar('_updateAttachment__A')  # <A>
                def updateAttachment(self, attachment: _updateAttachment__A, evidence$7: scala.reflect.ClassTag[_updateAttachment__A]) -> _Universe__MacroInternalApi__MacroDecoratorApi__MacroSymbolDecoratorApi__T: ...
            class MacroTreeDecoratorApi(scala.reflect.api.Internals.InternalApi.DecoratorApi.TreeDecoratorApi[_Universe__MacroInternalApi__MacroDecoratorApi__MacroTreeDecoratorApi__T], typing.Generic[_Universe__MacroInternalApi__MacroDecoratorApi__MacroTreeDecoratorApi__T]):
                def __init__(self, $outer: 'Universe.MacroInternalApi.MacroDecoratorApi', tree: _Universe__MacroInternalApi__MacroDecoratorApi__MacroTreeDecoratorApi__T): ...
                def attachments(self) -> Attachments: ...
                def changeOwner(self, prev: scala.reflect.api.Symbols.SymbolApi, next: scala.reflect.api.Symbols.SymbolApi) -> _Universe__MacroInternalApi__MacroDecoratorApi__MacroTreeDecoratorApi__T: ...
                def defineType(self, tp: scala.reflect.api.Types.TypeApi) -> _Universe__MacroInternalApi__MacroDecoratorApi__MacroTreeDecoratorApi__T: ...
                _removeAttachment__A = typing.TypeVar('_removeAttachment__A')  # <A>
                def removeAttachment(self, evidence$6: scala.reflect.ClassTag[_removeAttachment__A]) -> _Universe__MacroInternalApi__MacroDecoratorApi__MacroTreeDecoratorApi__T: ...
                def setPos(self, newpos: scala.reflect.api.Position) -> _Universe__MacroInternalApi__MacroDecoratorApi__MacroTreeDecoratorApi__T: ...
                def setSymbol(self, sym: scala.reflect.api.Symbols.SymbolApi) -> _Universe__MacroInternalApi__MacroDecoratorApi__MacroTreeDecoratorApi__T: ...
                def setType(self, tp: scala.reflect.api.Types.TypeApi) -> _Universe__MacroInternalApi__MacroDecoratorApi__MacroTreeDecoratorApi__T: ...
                def tree(self) -> _Universe__MacroInternalApi__MacroDecoratorApi__MacroTreeDecoratorApi__T: ...
                _updateAttachment__A = typing.TypeVar('_updateAttachment__A')  # <A>
                def updateAttachment(self, attachment: _updateAttachment__A, evidence$5: scala.reflect.ClassTag[_updateAttachment__A]) -> _Universe__MacroInternalApi__MacroDecoratorApi__MacroTreeDecoratorApi__T: ...
            class MacroTypeTreeDecoratorApi(typing.Generic[_Universe__MacroInternalApi__MacroDecoratorApi__MacroTypeTreeDecoratorApi__T]):
                $outer: 'Universe.MacroInternalApi.MacroDecoratorApi' = ...
                def __init__(self, $outer: 'Universe.MacroInternalApi.MacroDecoratorApi', tt: _Universe__MacroInternalApi__MacroDecoratorApi__MacroTypeTreeDecoratorApi__T): ...
                def setOriginal(self, tree: scala.reflect.api.Trees.TreeApi) -> scala.reflect.api.Trees.TypeTreeApi: ...
                def tt(self) -> _Universe__MacroInternalApi__MacroDecoratorApi__MacroTypeTreeDecoratorApi__T: ...
    class RunContextApi:
        def currentUnit(self) -> 'Universe.CompilationUnitContextApi': ...
        def units(self) -> scala.collection.Iterator['Universe.CompilationUnitContextApi']: ...
    class TreeGen:
        def mkAttributedIdent(self, sym: scala.reflect.api.Symbols.SymbolApi) -> scala.reflect.api.Trees.RefTreeApi: ...
        @typing.overload
        def mkAttributedQualifier(self, tpe: scala.reflect.api.Types.TypeApi) -> scala.reflect.api.Trees.TreeApi: ...
        @typing.overload
        def mkAttributedQualifier(self, tpe: scala.reflect.api.Types.TypeApi, termSym: scala.reflect.api.Symbols.SymbolApi) -> scala.reflect.api.Trees.TreeApi: ...
        @typing.overload
        def mkAttributedRef(self, sym: scala.reflect.api.Symbols.SymbolApi) -> scala.reflect.api.Trees.RefTreeApi: ...
        @typing.overload
        def mkAttributedRef(self, pre: scala.reflect.api.Types.TypeApi, sym: scala.reflect.api.Symbols.SymbolApi) -> scala.reflect.api.Trees.RefTreeApi: ...
        def mkAttributedSelect(self, qual: scala.reflect.api.Trees.TreeApi, sym: scala.reflect.api.Symbols.SymbolApi) -> scala.reflect.api.Trees.RefTreeApi: ...
        @typing.overload
        def mkAttributedStableRef(self, sym: scala.reflect.api.Symbols.SymbolApi) -> scala.reflect.api.Trees.TreeApi: ...
        @typing.overload
        def mkAttributedStableRef(self, pre: scala.reflect.api.Types.TypeApi, sym: scala.reflect.api.Symbols.SymbolApi) -> scala.reflect.api.Trees.TreeApi: ...
        def mkAttributedThis(self, sym: scala.reflect.api.Symbols.SymbolApi) -> scala.reflect.api.Trees.ThisApi: ...
        def mkCast(self, tree: scala.reflect.api.Trees.TreeApi, pt: scala.reflect.api.Types.TypeApi) -> scala.reflect.api.Trees.TreeApi: ...
        @typing.overload
        def mkMethodCall(self, method: scala.reflect.api.Symbols.SymbolApi, args: scala.collection.immutable.List[scala.reflect.api.Trees.TreeApi]) -> scala.reflect.api.Trees.TreeApi: ...
        @typing.overload
        def mkMethodCall(self, method: scala.reflect.api.Symbols.SymbolApi, targs: scala.collection.immutable.List[scala.reflect.api.Types.TypeApi], args: scala.collection.immutable.List[scala.reflect.api.Trees.TreeApi]) -> scala.reflect.api.Trees.TreeApi: ...
        @typing.overload
        def mkMethodCall(self, receiver: scala.reflect.api.Symbols.SymbolApi, methodName: scala.reflect.api.Names.NameApi, args: scala.collection.immutable.List[scala.reflect.api.Trees.TreeApi]) -> scala.reflect.api.Trees.TreeApi: ...
        @typing.overload
        def mkMethodCall(self, receiver: scala.reflect.api.Symbols.SymbolApi, methodName: scala.reflect.api.Names.NameApi, targs: scala.collection.immutable.List[scala.reflect.api.Types.TypeApi], args: scala.collection.immutable.List[scala.reflect.api.Trees.TreeApi]) -> scala.reflect.api.Trees.TreeApi: ...
        @typing.overload
        def mkMethodCall(self, target: scala.reflect.api.Trees.TreeApi, args: scala.collection.immutable.List[scala.reflect.api.Trees.TreeApi]) -> scala.reflect.api.Trees.TreeApi: ...
        @typing.overload
        def mkMethodCall(self, target: scala.reflect.api.Trees.TreeApi, targs: scala.collection.immutable.List[scala.reflect.api.Types.TypeApi], args: scala.collection.immutable.List[scala.reflect.api.Trees.TreeApi]) -> scala.reflect.api.Trees.TreeApi: ...
        @typing.overload
        def mkMethodCall(self, receiver: scala.reflect.api.Trees.TreeApi, method: scala.reflect.api.Symbols.SymbolApi, targs: scala.collection.immutable.List[scala.reflect.api.Types.TypeApi], args: scala.collection.immutable.List[scala.reflect.api.Trees.TreeApi]) -> scala.reflect.api.Trees.TreeApi: ...
        def mkNullaryCall(self, method: scala.reflect.api.Symbols.SymbolApi, targs: scala.collection.immutable.List[scala.reflect.api.Types.TypeApi]) -> scala.reflect.api.Trees.TreeApi: ...
        def mkRuntimeUniverseRef(self) -> scala.reflect.api.Trees.TreeApi: ...
        @typing.overload
        def mkUnattributedRef(self, fullName: scala.reflect.api.Names.NameApi) -> scala.reflect.api.Trees.RefTreeApi: ...
        @typing.overload
        def mkUnattributedRef(self, sym: scala.reflect.api.Symbols.SymbolApi) -> scala.reflect.api.Trees.RefTreeApi: ...
        def mkZero(self, tp: scala.reflect.api.Types.TypeApi) -> scala.reflect.api.Trees.TreeApi: ...
        def stabilize(self, tree: scala.reflect.api.Trees.TreeApi) -> scala.reflect.api.Trees.TreeApi: ...

class package: ...

_NonemptyAttachments__P = typing.TypeVar('_NonemptyAttachments__P')  # <P>
class NonemptyAttachments(Attachments, typing.Generic[_NonemptyAttachments__P]):
    def __init__(self, pos: _NonemptyAttachments__P, all: scala.collection.immutable.Set[typing.Any]): ...
    def all(self) -> scala.collection.immutable.Set[typing.Any]: ...
    def isEmpty(self) -> bool: ...
    def pos(self) -> _NonemptyAttachments__P: ...
    def withPos(self, newPos: _NonemptyAttachments__P) -> 'NonemptyAttachments'[_NonemptyAttachments__P]: ...

class Internals:
    @staticmethod
    def $init$($this: 'Internals') -> None: ...
    def internal(self) -> 'Internals.ContextInternalApi': ...
    class ContextInternalApi(Universe.MacroInternalApi):
        @staticmethod
        def $init$($this: 'Internals.ContextInternalApi') -> None: ...
        def enclosingOwner(self) -> scala.reflect.api.Symbols.SymbolApi: ...
        def transform(self, tree: scala.reflect.api.Trees.TreeApi, transformer: scala.Function2[scala.reflect.api.Trees.TreeApi, 'Internals.ContextInternalApi.TransformApi', scala.reflect.api.Trees.TreeApi]) -> scala.reflect.api.Trees.TreeApi: ...
        @typing.overload
        def typingTransform(self, tree: scala.reflect.api.Trees.TreeApi, transformer: scala.Function2[scala.reflect.api.Trees.TreeApi, 'Internals.ContextInternalApi.TypingTransformApi', scala.reflect.api.Trees.TreeApi]) -> scala.reflect.api.Trees.TreeApi: ...
        @typing.overload
        def typingTransform(self, tree: scala.reflect.api.Trees.TreeApi, owner: scala.reflect.api.Symbols.SymbolApi, transformer: scala.Function2[scala.reflect.api.Trees.TreeApi, 'Internals.ContextInternalApi.TypingTransformApi', scala.reflect.api.Trees.TreeApi]) -> scala.reflect.api.Trees.TreeApi: ...
        class TransformApi:
            def default(self, tree: scala.reflect.api.Trees.TreeApi) -> scala.reflect.api.Trees.TreeApi: ...
            def recur(self, tree: scala.reflect.api.Trees.TreeApi) -> scala.reflect.api.Trees.TreeApi: ...
        class TypingTransformApi(scala.reflect.macros.Internals.ContextInternalApi.TransformApi):
            _atOwner_0__T = typing.TypeVar('_atOwner_0__T')  # <T>
            _atOwner_1__T = typing.TypeVar('_atOwner_1__T')  # <T>
            @typing.overload
            def atOwner(self, owner: scala.reflect.api.Symbols.SymbolApi, op: scala.Function0[_atOwner_0__T]) -> _atOwner_0__T: ...
            @typing.overload
            def atOwner(self, tree: scala.reflect.api.Trees.TreeApi, owner: scala.reflect.api.Symbols.SymbolApi, op: scala.Function0[_atOwner_1__T]) -> _atOwner_1__T: ...
            def currentOwner(self) -> scala.reflect.api.Symbols.SymbolApi: ...
            def typecheck(self, tree: scala.reflect.api.Trees.TreeApi) -> scala.reflect.api.Trees.TreeApi: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("scala.reflect.macros")``.

    Aliases: typing.Type[Aliases]
    Attachments: typing.Type[Attachments]
    Enclosures: typing.Type[Enclosures]
    Evals: typing.Type[Evals]
    ExprUtils: typing.Type[ExprUtils]
    FrontEnds: typing.Type[FrontEnds]
    Infrastructure: typing.Type[Infrastructure]
    Internals: typing.Type[Internals]
    Names: typing.Type[Names]
    NonemptyAttachments: typing.Type[NonemptyAttachments]
    ParseException: typing.Type[ParseException]
    Parsers: typing.Type[Parsers]
    ReificationException: typing.Type[ReificationException]
    Reifiers: typing.Type[Reifiers]
    TypecheckException: typing.Type[TypecheckException]
    Typers: typing.Type[Typers]
    UnexpectedReificationException: typing.Type[UnexpectedReificationException]
    Universe: typing.Type[Universe]
    package: typing.Type[package]
    blackbox: scala.reflect.macros.blackbox.__module_protocol__
    internal: scala.reflect.macros.internal.__module_protocol__
    whitebox: scala.reflect.macros.whitebox.__module_protocol__
