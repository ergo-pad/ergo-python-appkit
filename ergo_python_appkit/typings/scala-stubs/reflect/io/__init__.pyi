import java.io
import java.lang
import java.net
import java.nio.file
import java.util
import java.util.zip
import jpype.protocol
import scala
import scala.collection
import scala.collection.generic
import scala.collection.immutable
import scala.collection.mutable
import scala.collection.parallel
import scala.io
import scala.math
import scala.reflect
import scala.runtime
import typing



class AbstractFile(scala.collection.Iterable['AbstractFile']):
    def __init__(self): ...
    _$colon$bslash__B = typing.TypeVar('_$colon$bslash__B')  # <B>
    def $colon$bslash(self, z: _.colon.bslash__B, op: scala.Function2['AbstractFile', _.colon.bslash__B, _.colon.bslash__B]) -> _.colon.bslash__B: ...
    _$div$colon__B = typing.TypeVar('_$div$colon__B')  # <B>
    def $div$colon(self, z: _.div.colon__B, op: scala.Function2[_.div.colon__B, 'AbstractFile', _.div.colon__B]) -> _.div.colon__B: ...
    _$plus$plus__B = typing.TypeVar('_$plus$plus__B')  # <B>
    _$plus$plus__That = typing.TypeVar('_$plus$plus__That')  # <That>
    def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus__B], bf: scala.collection.generic.CanBuildFrom[scala.collection.Iterable['AbstractFile'], _.plus.plus__B, _.plus.plus__That]) -> _.plus.plus__That: ...
    _$plus$plus$colon_0__B = typing.TypeVar('_$plus$plus$colon_0__B')  # <B>
    _$plus$plus$colon_0__That = typing.TypeVar('_$plus$plus$colon_0__That')  # <That>
    _$plus$plus$colon_1__B = typing.TypeVar('_$plus$plus$colon_1__B')  # <B>
    _$plus$plus$colon_1__That = typing.TypeVar('_$plus$plus$colon_1__That')  # <That>
    @typing.overload
    def $plus$plus$colon(self, that: scala.collection.Traversable[_.plus.plus.colon_0__B], bf: scala.collection.generic.CanBuildFrom[scala.collection.Iterable['AbstractFile'], _.plus.plus.colon_0__B, _.plus.plus.colon_0__That]) -> _.plus.plus.colon_0__That: ...
    @typing.overload
    def $plus$plus$colon(self, that: scala.collection.TraversableOnce[_.plus.plus.colon_1__B], bf: scala.collection.generic.CanBuildFrom[scala.collection.Iterable['AbstractFile'], _.plus.plus.colon_1__B, _.plus.plus.colon_1__That]) -> _.plus.plus.colon_1__That: ...
    def absolute(self) -> 'AbstractFile': ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder) -> scala.collection.mutable.StringBuilder: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder, sep: str) -> scala.collection.mutable.StringBuilder: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder, start: str, sep: str, end: str) -> scala.collection.mutable.StringBuilder: ...
    _aggregate__B = typing.TypeVar('_aggregate__B')  # <B>
    def aggregate(self, z: scala.Function0[_aggregate__B], seqop: scala.Function2[_aggregate__B, 'AbstractFile', _aggregate__B], combop: scala.Function2[_aggregate__B, _aggregate__B, _aggregate__B]) -> _aggregate__B: ...
    def bufferedOutput(self) -> java.io.BufferedOutputStream: ...
    def canEqual(self, that: typing.Any) -> bool: ...
    def canonicalPath(self) -> str: ...
    _collect__B = typing.TypeVar('_collect__B')  # <B>
    _collect__That = typing.TypeVar('_collect__That')  # <That>
    def collect(self, pf: scala.PartialFunction['AbstractFile', _collect__B], bf: scala.collection.generic.CanBuildFrom[scala.collection.Iterable['AbstractFile'], _collect__B, _collect__That]) -> _collect__That: ...
    _collectFirst__B = typing.TypeVar('_collectFirst__B')  # <B>
    def collectFirst(self, pf: scala.PartialFunction['AbstractFile', _collectFirst__B]) -> scala.Option[_collectFirst__B]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion[scala.collection.Iterable]: ...
    def container(self) -> 'AbstractFile': ...
    _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
    _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
    _copyToArray_2__B = typing.TypeVar('_copyToArray_2__B')  # <B>
    @typing.overload
    def copyToArray(self, xs: typing.Any) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
    _copyToBuffer__B = typing.TypeVar('_copyToBuffer__B')  # <B>
    def copyToBuffer(self, dest: scala.collection.mutable.Buffer[_copyToBuffer__B]) -> None: ...
    def count(self, p: scala.Function1['AbstractFile', typing.Any]) -> int: ...
    def create(self) -> None: ...
    def delete(self) -> None: ...
    def drop(self, n: int) -> typing.Any: ...
    def dropRight(self, n: int) -> typing.Any: ...
    def dropWhile(self, p: scala.Function1) -> typing.Any: ...
    @typing.overload
    def exists(self) -> bool: ...
    @typing.overload
    def exists(self, p: scala.Function1['AbstractFile', typing.Any]) -> bool: ...
    def file(self) -> java.io.File: ...
    def fileNamed(self, name: str) -> 'AbstractFile': ...
    def filter(self, p: scala.Function1) -> typing.Any: ...
    def filterImpl(self, p: scala.Function1, isFlipped: bool) -> typing.Any: ...
    def filterNot(self, p: scala.Function1) -> typing.Any: ...
    def find(self, p: scala.Function1['AbstractFile', typing.Any]) -> scala.Option['AbstractFile']: ...
    _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
    _flatMap__That = typing.TypeVar('_flatMap__That')  # <That>
    def flatMap(self, f: scala.Function1['AbstractFile', scala.collection.GenTraversableOnce[_flatMap__B]], bf: scala.collection.generic.CanBuildFrom[scala.collection.Iterable['AbstractFile'], _flatMap__B, _flatMap__That]) -> _flatMap__That: ...
    def flatten(self, asTraversable: scala.Function1) -> scala.collection.GenTraversable: ...
    _fold__A1 = typing.TypeVar('_fold__A1')  # <A1>
    def fold(self, z: _fold__A1, op: scala.Function2[_fold__A1, _fold__A1, _fold__A1]) -> _fold__A1: ...
    _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
    def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, 'AbstractFile', _foldLeft__B]) -> _foldLeft__B: ...
    _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
    def foldRight(self, z: _foldRight__B, op: scala.Function2['AbstractFile', _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
    def forall(self, p: scala.Function1['AbstractFile', typing.Any]) -> bool: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1['AbstractFile', _foreach__U]) -> None: ...
    _genericBuilder__B = typing.TypeVar('_genericBuilder__B')  # <B>
    def genericBuilder(self) -> scala.collection.mutable.Builder[_genericBuilder__B, scala.collection.Iterable[_genericBuilder__B]]: ...
    @typing.overload
    @staticmethod
    def getDirectory(file: 'File') -> 'AbstractFile': ...
    @typing.overload
    @staticmethod
    def getDirectory(path: 'Path') -> 'AbstractFile': ...
    @typing.overload
    @staticmethod
    def getFile(path: str) -> 'AbstractFile': ...
    @typing.overload
    @staticmethod
    def getFile(file: 'File') -> 'AbstractFile': ...
    @typing.overload
    @staticmethod
    def getFile(path: 'Path') -> 'AbstractFile': ...
    @staticmethod
    def getResources(url: java.net.URL) -> 'AbstractFile': ...
    @staticmethod
    def getURL(url: java.net.URL) -> 'AbstractFile': ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    def groupBy(self, f: scala.Function1['AbstractFile', _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Iterable['AbstractFile']]: ...
    def grouped(self, size: int) -> scala.collection.Iterator[scala.collection.Iterable['AbstractFile']]: ...
    def hasDefiniteSize(self) -> bool: ...
    def hasExtension(self, other: str) -> bool: ...
    def head(self) -> typing.Any: ...
    def headOption(self) -> scala.Option['AbstractFile']: ...
    def init(self) -> typing.Any: ...
    def inits(self) -> scala.collection.Iterator[scala.collection.Iterable['AbstractFile']]: ...
    def input(self) -> java.io.InputStream: ...
    def isClassContainer(self) -> bool: ...
    def isDirectory(self) -> bool: ...
    def isEmpty(self) -> bool: ...
    def isTraversableAgain(self) -> bool: ...
    def isVirtual(self) -> bool: ...
    def iterator(self) -> scala.collection.Iterator['AbstractFile']: ...
    def last(self) -> typing.Any: ...
    def lastModified(self) -> int: ...
    def lastOption(self) -> scala.Option['AbstractFile']: ...
    def lookupName(self, name: str, directory: bool) -> 'AbstractFile': ...
    def lookupNameUnchecked(self, name: str, directory: bool) -> 'AbstractFile': ...
    def lookupPathUnchecked(self, path: str, directory: bool) -> 'AbstractFile': ...
    _map__B = typing.TypeVar('_map__B')  # <B>
    _map__That = typing.TypeVar('_map__That')  # <That>
    def map(self, f: scala.Function1['AbstractFile', _map__B], bf: scala.collection.generic.CanBuildFrom[scala.collection.Iterable['AbstractFile'], _map__B, _map__That]) -> _map__That: ...
    def max(self, cmp: scala.math.Ordering) -> typing.Any: ...
    def maxBy(self, f: scala.Function1, cmp: scala.math.Ordering) -> typing.Any: ...
    def min(self, cmp: scala.math.Ordering) -> typing.Any: ...
    def minBy(self, f: scala.Function1, cmp: scala.math.Ordering) -> typing.Any: ...
    @typing.overload
    def mkString(self) -> str: ...
    @typing.overload
    def mkString(self, sep: str) -> str: ...
    @typing.overload
    def mkString(self, start: str, sep: str, end: str) -> str: ...
    def name(self) -> str: ...
    def newBuilder(self) -> scala.collection.mutable.Builder['AbstractFile', scala.collection.Iterable['AbstractFile']]: ...
    def nonEmpty(self) -> bool: ...
    def output(self) -> java.io.OutputStream: ...
    def par(self) -> scala.collection.Parallel: ...
    def parCombiner(self) -> scala.collection.parallel.Combiner['AbstractFile', scala.collection.parallel.ParIterable['AbstractFile']]: ...
    def partition(self, p: scala.Function1['AbstractFile', typing.Any]) -> scala.Tuple2[scala.collection.Iterable['AbstractFile'], scala.collection.Iterable['AbstractFile']]: ...
    def path(self) -> str: ...
    _product__B = typing.TypeVar('_product__B')  # <B>
    def product(self, num: scala.math.Numeric[_product__B]) -> _product__B: ...
    _reduce__A1 = typing.TypeVar('_reduce__A1')  # <A1>
    def reduce(self, op: scala.Function2[_reduce__A1, _reduce__A1, _reduce__A1]) -> _reduce__A1: ...
    _reduceLeft__B = typing.TypeVar('_reduceLeft__B')  # <B>
    def reduceLeft(self, op: scala.Function2[_reduceLeft__B, 'AbstractFile', _reduceLeft__B]) -> _reduceLeft__B: ...
    _reduceLeftOption__B = typing.TypeVar('_reduceLeftOption__B')  # <B>
    def reduceLeftOption(self, op: scala.Function2[_reduceLeftOption__B, 'AbstractFile', _reduceLeftOption__B]) -> scala.Option[_reduceLeftOption__B]: ...
    _reduceOption__A1 = typing.TypeVar('_reduceOption__A1')  # <A1>
    def reduceOption(self, op: scala.Function2[_reduceOption__A1, _reduceOption__A1, _reduceOption__A1]) -> scala.Option[_reduceOption__A1]: ...
    _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
    def reduceRight(self, op: scala.Function2['AbstractFile', _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
    _reduceRightOption__B = typing.TypeVar('_reduceRightOption__B')  # <B>
    def reduceRightOption(self, op: scala.Function2['AbstractFile', _reduceRightOption__B, _reduceRightOption__B]) -> scala.Option[_reduceRightOption__B]: ...
    def repr(self) -> typing.Any: ...
    def reversed(self) -> scala.collection.immutable.List['AbstractFile']: ...
    _sameElements__B = typing.TypeVar('_sameElements__B')  # <B>
    def sameElements(self, that: scala.collection.GenIterable[_sameElements__B]) -> bool: ...
    _scan__B = typing.TypeVar('_scan__B')  # <B>
    _scan__That = typing.TypeVar('_scan__That')  # <That>
    def scan(self, z: _scan__B, op: scala.Function2[_scan__B, _scan__B, _scan__B], cbf: scala.collection.generic.CanBuildFrom[scala.collection.Iterable['AbstractFile'], _scan__B, _scan__That]) -> _scan__That: ...
    _scanLeft__B = typing.TypeVar('_scanLeft__B')  # <B>
    _scanLeft__That = typing.TypeVar('_scanLeft__That')  # <That>
    def scanLeft(self, z: _scanLeft__B, op: scala.Function2[_scanLeft__B, 'AbstractFile', _scanLeft__B], bf: scala.collection.generic.CanBuildFrom[scala.collection.Iterable['AbstractFile'], _scanLeft__B, _scanLeft__That]) -> _scanLeft__That: ...
    _scanRight__B = typing.TypeVar('_scanRight__B')  # <B>
    _scanRight__That = typing.TypeVar('_scanRight__That')  # <That>
    def scanRight(self, z: _scanRight__B, op: scala.Function2['AbstractFile', _scanRight__B, _scanRight__B], bf: scala.collection.generic.CanBuildFrom[scala.collection.Iterable['AbstractFile'], _scanRight__B, _scanRight__That]) -> _scanRight__That: ...
    def seq(self) -> scala.collection.Iterable['AbstractFile']: ...
    def size(self) -> int: ...
    def sizeHintIfCheap(self) -> int: ...
    def sizeOption(self) -> scala.Option[typing.Any]: ...
    def slice(self, from_: int, until: int) -> typing.Any: ...
    def sliceWithKnownBound(self, from_: int, until: int) -> typing.Any: ...
    def sliceWithKnownDelta(self, from_: int, until: int, delta: int) -> typing.Any: ...
    @typing.overload
    def sliding(self, size: int) -> scala.collection.Iterator[scala.collection.Iterable['AbstractFile']]: ...
    @typing.overload
    def sliding(self, size: int, step: int) -> scala.collection.Iterator[scala.collection.Iterable['AbstractFile']]: ...
    def span(self, p: scala.Function1['AbstractFile', typing.Any]) -> scala.Tuple2[scala.collection.Iterable['AbstractFile'], scala.collection.Iterable['AbstractFile']]: ...
    def splitAt(self, n: int) -> scala.Tuple2[scala.collection.Iterable['AbstractFile'], scala.collection.Iterable['AbstractFile']]: ...
    def stringPrefix(self) -> str: ...
    def subdirectoryNamed(self, name: str) -> 'AbstractFile': ...
    _sum__B = typing.TypeVar('_sum__B')  # <B>
    def sum(self, num: scala.math.Numeric[_sum__B]) -> _sum__B: ...
    def tail(self) -> typing.Any: ...
    def tails(self) -> scala.collection.Iterator[scala.collection.Iterable['AbstractFile']]: ...
    def take(self, n: int) -> typing.Any: ...
    def takeRight(self, n: int) -> typing.Any: ...
    def takeWhile(self, p: scala.Function1) -> typing.Any: ...
    def thisCollection(self) -> scala.collection.Iterable['AbstractFile']: ...
    _to__Col = typing.TypeVar('_to__Col')  # <Col>
    def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., 'AbstractFile', _to__Col]) -> _to__Col: ...
    _toArray__B = typing.TypeVar('_toArray__B')  # <B>
    def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__B]) -> typing.Any: ...
    _toBuffer__B = typing.TypeVar('_toBuffer__B')  # <B>
    def toBuffer(self) -> scala.collection.mutable.Buffer[_toBuffer__B]: ...
    def toByteArray(self) -> typing.List[int]: ...
    def toCharArray(self) -> typing.List[str]: ...
    def toCollection(self, repr: typing.Any) -> scala.collection.Iterable: ...
    def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq['AbstractFile']: ...
    def toIterable(self) -> scala.collection.Iterable['AbstractFile']: ...
    def toIterator(self) -> scala.collection.Iterator['AbstractFile']: ...
    def toList(self) -> scala.collection.immutable.List['AbstractFile']: ...
    _toMap__T = typing.TypeVar('_toMap__T')  # <T>
    _toMap__U = typing.TypeVar('_toMap__U')  # <U>
    def toMap(self, ev: scala.Predef..less.colon.less['AbstractFile', scala.Tuple2[_toMap__T, _toMap__U]]) -> scala.collection.immutable.Map[_toMap__T, _toMap__U]: ...
    def toSeq(self) -> scala.collection.Seq['AbstractFile']: ...
    _toSet__B = typing.TypeVar('_toSet__B')  # <B>
    def toSet(self) -> scala.collection.immutable.Set[_toSet__B]: ...
    def toStream(self) -> scala.collection.immutable.Stream['AbstractFile']: ...
    def toString(self) -> str: ...
    def toTraversable(self) -> scala.collection.Traversable['AbstractFile']: ...
    def toURL(self) -> java.net.URL: ...
    def toVector(self) -> scala.collection.immutable.Vector['AbstractFile']: ...
    def transpose(self, asTraversable: scala.Function1) -> scala.collection.GenTraversable: ...
    def underlyingSource(self) -> scala.Option['AbstractFile']: ...
    @typing.overload
    def unsupported(self) -> scala.runtime.Nothing.: ...
    @typing.overload
    def unsupported(self, msg: str) -> scala.runtime.Nothing.: ...
    _unzip__A1 = typing.TypeVar('_unzip__A1')  # <A1>
    _unzip__A2 = typing.TypeVar('_unzip__A2')  # <A2>
    def unzip(self, asPair: scala.Function1['AbstractFile', scala.Tuple2[_unzip__A1, _unzip__A2]]) -> scala.Tuple2[scala.collection.Iterable[_unzip__A1], scala.collection.Iterable[_unzip__A2]]: ...
    _unzip3__A1 = typing.TypeVar('_unzip3__A1')  # <A1>
    _unzip3__A2 = typing.TypeVar('_unzip3__A2')  # <A2>
    _unzip3__A3 = typing.TypeVar('_unzip3__A3')  # <A3>
    def unzip3(self, asTriple: scala.Function1['AbstractFile', scala.Tuple3[_unzip3__A1, _unzip3__A2, _unzip3__A3]]) -> scala.Tuple3[scala.collection.Iterable[_unzip3__A1], scala.collection.Iterable[_unzip3__A2], scala.collection.Iterable[_unzip3__A3]]: ...
    @typing.overload
    def view(self) -> scala.collection.IterableView['AbstractFile', scala.collection.Iterable['AbstractFile']]: ...
    @typing.overload
    def view(self, from_: int, until: int) -> scala.collection.IterableView['AbstractFile', scala.collection.Iterable['AbstractFile']]: ...
    def withFilter(self, p: scala.Function1['AbstractFile', typing.Any]) -> scala.collection.generic.FilterMonadic['AbstractFile', scala.collection.Iterable['AbstractFile']]: ...
    _zip__A1 = typing.TypeVar('_zip__A1')  # <A1>
    _zip__B = typing.TypeVar('_zip__B')  # <B>
    _zip__That = typing.TypeVar('_zip__That')  # <That>
    def zip(self, that: scala.collection.GenIterable[_zip__B], bf: scala.collection.generic.CanBuildFrom[scala.collection.Iterable['AbstractFile'], scala.Tuple2[_zip__A1, _zip__B], _zip__That]) -> _zip__That: ...
    _zipAll__B = typing.TypeVar('_zipAll__B')  # <B>
    _zipAll__A1 = typing.TypeVar('_zipAll__A1')  # <A1>
    _zipAll__That = typing.TypeVar('_zipAll__That')  # <That>
    def zipAll(self, that: scala.collection.GenIterable[_zipAll__B], thisElem: _zipAll__A1, thatElem: _zipAll__B, bf: scala.collection.generic.CanBuildFrom[scala.collection.Iterable['AbstractFile'], scala.Tuple2[_zipAll__A1, _zipAll__B], _zipAll__That]) -> _zipAll__That: ...
    _zipWithIndex__A1 = typing.TypeVar('_zipWithIndex__A1')  # <A1>
    _zipWithIndex__That = typing.TypeVar('_zipWithIndex__That')  # <That>
    def zipWithIndex(self, bf: scala.collection.generic.CanBuildFrom[scala.collection.Iterable['AbstractFile'], scala.Tuple2[_zipWithIndex__A1, typing.Any], _zipWithIndex__That]) -> _zipWithIndex__That: ...

class FileOperationException(java.lang.RuntimeException, scala.Product, scala.Serializable):
    def __init__(self, msg: str): ...
    _andThen__A = typing.TypeVar('_andThen__A')  # <A>
    @staticmethod
    def andThen(g: scala.Function1['FileOperationException', _andThen__A]) -> scala.Function1[str, _andThen__A]: ...
    @staticmethod
    def apply(msg: str) -> 'FileOperationException': ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    @staticmethod
    def compose(g: scala.Function1[_compose__A, str]) -> scala.Function1[_compose__A, 'FileOperationException']: ...
    def copy(self, msg: str) -> 'FileOperationException': ...
    def copy$default$1(self) -> str: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def msg(self) -> str: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> str: ...
    @staticmethod
    def unapply(x$0: 'FileOperationException') -> scala.Option[str]: ...

class NoAbstractFile:
    _$colon$bslash__B = typing.TypeVar('_$colon$bslash__B')  # <B>
    @staticmethod
    def $colon$bslash(z: _.colon.bslash__B, op: scala.Function2[AbstractFile, _.colon.bslash__B, _.colon.bslash__B]) -> _.colon.bslash__B: ...
    _$div$colon__B = typing.TypeVar('_$div$colon__B')  # <B>
    @staticmethod
    def $div$colon(z: _.div.colon__B, op: scala.Function2[_.div.colon__B, AbstractFile, _.div.colon__B]) -> _.div.colon__B: ...
    _$plus$plus__B = typing.TypeVar('_$plus$plus__B')  # <B>
    _$plus$plus__That = typing.TypeVar('_$plus$plus__That')  # <That>
    @staticmethod
    def $plus$plus(that: scala.collection.GenTraversableOnce[_.plus.plus__B], bf: scala.collection.generic.CanBuildFrom[scala.collection.Iterable[AbstractFile], _.plus.plus__B, _.plus.plus__That]) -> _.plus.plus__That: ...
    _$plus$plus$colon_0__B = typing.TypeVar('_$plus$plus$colon_0__B')  # <B>
    _$plus$plus$colon_0__That = typing.TypeVar('_$plus$plus$colon_0__That')  # <That>
    _$plus$plus$colon_1__B = typing.TypeVar('_$plus$plus$colon_1__B')  # <B>
    _$plus$plus$colon_1__That = typing.TypeVar('_$plus$plus$colon_1__That')  # <That>
    @typing.overload
    @staticmethod
    def $plus$plus$colon(that: scala.collection.Traversable[_.plus.plus.colon_0__B], bf: scala.collection.generic.CanBuildFrom[scala.collection.Iterable[AbstractFile], _.plus.plus.colon_0__B, _.plus.plus.colon_0__That]) -> _.plus.plus.colon_0__That: ...
    @typing.overload
    @staticmethod
    def $plus$plus$colon(that: scala.collection.TraversableOnce[_.plus.plus.colon_1__B], bf: scala.collection.generic.CanBuildFrom[scala.collection.Iterable[AbstractFile], _.plus.plus.colon_1__B, _.plus.plus.colon_1__That]) -> _.plus.plus.colon_1__That: ...
    @staticmethod
    def absolute() -> AbstractFile: ...
    @typing.overload
    @staticmethod
    def addString(b: scala.collection.mutable.StringBuilder) -> scala.collection.mutable.StringBuilder: ...
    @typing.overload
    @staticmethod
    def addString(b: scala.collection.mutable.StringBuilder, sep: str) -> scala.collection.mutable.StringBuilder: ...
    @typing.overload
    @staticmethod
    def addString(b: scala.collection.mutable.StringBuilder, start: str, sep: str, end: str) -> scala.collection.mutable.StringBuilder: ...
    _aggregate__B = typing.TypeVar('_aggregate__B')  # <B>
    @staticmethod
    def aggregate(z: scala.Function0[_aggregate__B], seqop: scala.Function2[_aggregate__B, AbstractFile, _aggregate__B], combop: scala.Function2[_aggregate__B, _aggregate__B, _aggregate__B]) -> _aggregate__B: ...
    @staticmethod
    def bufferedOutput() -> java.io.BufferedOutputStream: ...
    @staticmethod
    def canEqual(that: typing.Any) -> bool: ...
    @staticmethod
    def canonicalPath() -> str: ...
    _collect__B = typing.TypeVar('_collect__B')  # <B>
    _collect__That = typing.TypeVar('_collect__That')  # <That>
    @staticmethod
    def collect(pf: scala.PartialFunction[AbstractFile, _collect__B], bf: scala.collection.generic.CanBuildFrom[scala.collection.Iterable[AbstractFile], _collect__B, _collect__That]) -> _collect__That: ...
    _collectFirst__B = typing.TypeVar('_collectFirst__B')  # <B>
    @staticmethod
    def collectFirst(pf: scala.PartialFunction[AbstractFile, _collectFirst__B]) -> scala.Option[_collectFirst__B]: ...
    @staticmethod
    def companion() -> scala.collection.generic.GenericCompanion[scala.collection.Iterable]: ...
    @staticmethod
    def container() -> AbstractFile: ...
    _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
    _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
    _copyToArray_2__B = typing.TypeVar('_copyToArray_2__B')  # <B>
    @typing.overload
    @staticmethod
    def copyToArray(xs: typing.Any) -> None: ...
    @typing.overload
    @staticmethod
    def copyToArray(xs: typing.Any, start: int) -> None: ...
    @typing.overload
    @staticmethod
    def copyToArray(xs: typing.Any, start: int, len: int) -> None: ...
    _copyToBuffer__B = typing.TypeVar('_copyToBuffer__B')  # <B>
    @staticmethod
    def copyToBuffer(dest: scala.collection.mutable.Buffer[_copyToBuffer__B]) -> None: ...
    @staticmethod
    def count(p: scala.Function1[AbstractFile, typing.Any]) -> int: ...
    @staticmethod
    def create() -> None: ...
    @staticmethod
    def delete() -> None: ...
    @staticmethod
    def drop(n: int) -> typing.Any: ...
    @staticmethod
    def dropRight(n: int) -> typing.Any: ...
    @staticmethod
    def dropWhile(p: scala.Function1) -> typing.Any: ...
    @typing.overload
    @staticmethod
    def exists() -> bool: ...
    @typing.overload
    @staticmethod
    def exists(p: scala.Function1[AbstractFile, typing.Any]) -> bool: ...
    @staticmethod
    def file() -> java.io.File: ...
    @staticmethod
    def fileNamed(name: str) -> AbstractFile: ...
    @staticmethod
    def filter(p: scala.Function1) -> typing.Any: ...
    @staticmethod
    def filterNot(p: scala.Function1) -> typing.Any: ...
    @staticmethod
    def find(p: scala.Function1[AbstractFile, typing.Any]) -> scala.Option[AbstractFile]: ...
    _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
    _flatMap__That = typing.TypeVar('_flatMap__That')  # <That>
    @staticmethod
    def flatMap(f: scala.Function1[AbstractFile, scala.collection.GenTraversableOnce[_flatMap__B]], bf: scala.collection.generic.CanBuildFrom[scala.collection.Iterable[AbstractFile], _flatMap__B, _flatMap__That]) -> _flatMap__That: ...
    @staticmethod
    def flatten(asTraversable: scala.Function1) -> scala.collection.GenTraversable: ...
    _fold__A1 = typing.TypeVar('_fold__A1')  # <A1>
    @staticmethod
    def fold(z: _fold__A1, op: scala.Function2[_fold__A1, _fold__A1, _fold__A1]) -> _fold__A1: ...
    _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
    @staticmethod
    def foldLeft(z: _foldLeft__B, op: scala.Function2[_foldLeft__B, AbstractFile, _foldLeft__B]) -> _foldLeft__B: ...
    _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
    @staticmethod
    def foldRight(z: _foldRight__B, op: scala.Function2[AbstractFile, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
    @staticmethod
    def forall(p: scala.Function1[AbstractFile, typing.Any]) -> bool: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    @staticmethod
    def foreach(f: scala.Function1[AbstractFile, _foreach__U]) -> None: ...
    _genericBuilder__B = typing.TypeVar('_genericBuilder__B')  # <B>
    @staticmethod
    def genericBuilder() -> scala.collection.mutable.Builder[_genericBuilder__B, scala.collection.Iterable[_genericBuilder__B]]: ...
    _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
    @staticmethod
    def groupBy(f: scala.Function1[AbstractFile, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Iterable[AbstractFile]]: ...
    @staticmethod
    def grouped(size: int) -> scala.collection.Iterator[scala.collection.Iterable[AbstractFile]]: ...
    @staticmethod
    def hasDefiniteSize() -> bool: ...
    @staticmethod
    def hasExtension(other: str) -> bool: ...
    @staticmethod
    def head() -> typing.Any: ...
    @staticmethod
    def headOption() -> scala.Option[AbstractFile]: ...
    @staticmethod
    def init() -> typing.Any: ...
    @staticmethod
    def inits() -> scala.collection.Iterator[scala.collection.Iterable[AbstractFile]]: ...
    @staticmethod
    def input() -> java.io.InputStream: ...
    @staticmethod
    def isClassContainer() -> bool: ...
    @staticmethod
    def isDirectory() -> bool: ...
    @staticmethod
    def isEmpty() -> bool: ...
    @staticmethod
    def isTraversableAgain() -> bool: ...
    @staticmethod
    def isVirtual() -> bool: ...
    @staticmethod
    def iterator() -> scala.collection.Iterator[AbstractFile]: ...
    @staticmethod
    def last() -> typing.Any: ...
    @staticmethod
    def lastModified() -> int: ...
    @staticmethod
    def lastOption() -> scala.Option[AbstractFile]: ...
    @staticmethod
    def lookupName(name: str, directory: bool) -> AbstractFile: ...
    @staticmethod
    def lookupNameUnchecked(name: str, directory: bool) -> AbstractFile: ...
    @staticmethod
    def lookupPathUnchecked(path: str, directory: bool) -> AbstractFile: ...
    _map__B = typing.TypeVar('_map__B')  # <B>
    _map__That = typing.TypeVar('_map__That')  # <That>
    @staticmethod
    def map(f: scala.Function1[AbstractFile, _map__B], bf: scala.collection.generic.CanBuildFrom[scala.collection.Iterable[AbstractFile], _map__B, _map__That]) -> _map__That: ...
    @staticmethod
    def max(cmp: scala.math.Ordering) -> typing.Any: ...
    @staticmethod
    def maxBy(f: scala.Function1, cmp: scala.math.Ordering) -> typing.Any: ...
    @staticmethod
    def min(cmp: scala.math.Ordering) -> typing.Any: ...
    @staticmethod
    def minBy(f: scala.Function1, cmp: scala.math.Ordering) -> typing.Any: ...
    @typing.overload
    @staticmethod
    def mkString() -> str: ...
    @typing.overload
    @staticmethod
    def mkString(sep: str) -> str: ...
    @typing.overload
    @staticmethod
    def mkString(start: str, sep: str, end: str) -> str: ...
    @staticmethod
    def name() -> str: ...
    @staticmethod
    def nonEmpty() -> bool: ...
    @staticmethod
    def output() -> java.io.OutputStream: ...
    @staticmethod
    def par() -> scala.collection.Parallel: ...
    @staticmethod
    def partition(p: scala.Function1[AbstractFile, typing.Any]) -> scala.Tuple2[scala.collection.Iterable[AbstractFile], scala.collection.Iterable[AbstractFile]]: ...
    @staticmethod
    def path() -> str: ...
    _product__B = typing.TypeVar('_product__B')  # <B>
    @staticmethod
    def product(num: scala.math.Numeric[_product__B]) -> _product__B: ...
    _reduce__A1 = typing.TypeVar('_reduce__A1')  # <A1>
    @staticmethod
    def reduce(op: scala.Function2[_reduce__A1, _reduce__A1, _reduce__A1]) -> _reduce__A1: ...
    _reduceLeft__B = typing.TypeVar('_reduceLeft__B')  # <B>
    @staticmethod
    def reduceLeft(op: scala.Function2[_reduceLeft__B, AbstractFile, _reduceLeft__B]) -> _reduceLeft__B: ...
    _reduceLeftOption__B = typing.TypeVar('_reduceLeftOption__B')  # <B>
    @staticmethod
    def reduceLeftOption(op: scala.Function2[_reduceLeftOption__B, AbstractFile, _reduceLeftOption__B]) -> scala.Option[_reduceLeftOption__B]: ...
    _reduceOption__A1 = typing.TypeVar('_reduceOption__A1')  # <A1>
    @staticmethod
    def reduceOption(op: scala.Function2[_reduceOption__A1, _reduceOption__A1, _reduceOption__A1]) -> scala.Option[_reduceOption__A1]: ...
    _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
    @staticmethod
    def reduceRight(op: scala.Function2[AbstractFile, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
    _reduceRightOption__B = typing.TypeVar('_reduceRightOption__B')  # <B>
    @staticmethod
    def reduceRightOption(op: scala.Function2[AbstractFile, _reduceRightOption__B, _reduceRightOption__B]) -> scala.Option[_reduceRightOption__B]: ...
    @staticmethod
    def repr() -> typing.Any: ...
    _sameElements__B = typing.TypeVar('_sameElements__B')  # <B>
    @staticmethod
    def sameElements(that: scala.collection.GenIterable[_sameElements__B]) -> bool: ...
    _scan__B = typing.TypeVar('_scan__B')  # <B>
    _scan__That = typing.TypeVar('_scan__That')  # <That>
    @staticmethod
    def scan(z: _scan__B, op: scala.Function2[_scan__B, _scan__B, _scan__B], cbf: scala.collection.generic.CanBuildFrom[scala.collection.Iterable[AbstractFile], _scan__B, _scan__That]) -> _scan__That: ...
    _scanLeft__B = typing.TypeVar('_scanLeft__B')  # <B>
    _scanLeft__That = typing.TypeVar('_scanLeft__That')  # <That>
    @staticmethod
    def scanLeft(z: _scanLeft__B, op: scala.Function2[_scanLeft__B, AbstractFile, _scanLeft__B], bf: scala.collection.generic.CanBuildFrom[scala.collection.Iterable[AbstractFile], _scanLeft__B, _scanLeft__That]) -> _scanLeft__That: ...
    _scanRight__B = typing.TypeVar('_scanRight__B')  # <B>
    _scanRight__That = typing.TypeVar('_scanRight__That')  # <That>
    @staticmethod
    def scanRight(z: _scanRight__B, op: scala.Function2[AbstractFile, _scanRight__B, _scanRight__B], bf: scala.collection.generic.CanBuildFrom[scala.collection.Iterable[AbstractFile], _scanRight__B, _scanRight__That]) -> _scanRight__That: ...
    @staticmethod
    def seq() -> scala.collection.Iterable[AbstractFile]: ...
    @staticmethod
    def size() -> int: ...
    @staticmethod
    def sizeOption() -> scala.Option[typing.Any]: ...
    @staticmethod
    def slice(from_: int, until: int) -> typing.Any: ...
    @typing.overload
    @staticmethod
    def sliding(size: int) -> scala.collection.Iterator[scala.collection.Iterable[AbstractFile]]: ...
    @typing.overload
    @staticmethod
    def sliding(size: int, step: int) -> scala.collection.Iterator[scala.collection.Iterable[AbstractFile]]: ...
    @staticmethod
    def span(p: scala.Function1[AbstractFile, typing.Any]) -> scala.Tuple2[scala.collection.Iterable[AbstractFile], scala.collection.Iterable[AbstractFile]]: ...
    @staticmethod
    def splitAt(n: int) -> scala.Tuple2[scala.collection.Iterable[AbstractFile], scala.collection.Iterable[AbstractFile]]: ...
    @staticmethod
    def stringPrefix() -> str: ...
    @staticmethod
    def subdirectoryNamed(name: str) -> AbstractFile: ...
    _sum__B = typing.TypeVar('_sum__B')  # <B>
    @staticmethod
    def sum(num: scala.math.Numeric[_sum__B]) -> _sum__B: ...
    @staticmethod
    def tail() -> typing.Any: ...
    @staticmethod
    def tails() -> scala.collection.Iterator[scala.collection.Iterable[AbstractFile]]: ...
    @staticmethod
    def take(n: int) -> typing.Any: ...
    @staticmethod
    def takeRight(n: int) -> typing.Any: ...
    @staticmethod
    def takeWhile(p: scala.Function1) -> typing.Any: ...
    _to__Col = typing.TypeVar('_to__Col')  # <Col>
    @staticmethod
    def to(cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., AbstractFile, _to__Col]) -> _to__Col: ...
    @staticmethod
    def toArray(evidence$1: scala.reflect.ClassTag) -> typing.Any: ...
    _toBuffer__B = typing.TypeVar('_toBuffer__B')  # <B>
    @staticmethod
    def toBuffer() -> scala.collection.mutable.Buffer[_toBuffer__B]: ...
    @staticmethod
    def toByteArray() -> typing.List[int]: ...
    @staticmethod
    def toCharArray() -> typing.List[str]: ...
    @staticmethod
    def toIndexedSeq() -> scala.collection.immutable.IndexedSeq[AbstractFile]: ...
    @staticmethod
    def toIterable() -> scala.collection.Iterable[AbstractFile]: ...
    @staticmethod
    def toIterator() -> scala.collection.Iterator[AbstractFile]: ...
    @staticmethod
    def toList() -> scala.collection.immutable.List[AbstractFile]: ...
    _toMap__T = typing.TypeVar('_toMap__T')  # <T>
    _toMap__U = typing.TypeVar('_toMap__U')  # <U>
    @staticmethod
    def toMap(ev: scala.Predef..less.colon.less[AbstractFile, scala.Tuple2[_toMap__T, _toMap__U]]) -> scala.collection.immutable.Map[_toMap__T, _toMap__U]: ...
    @staticmethod
    def toSeq() -> scala.collection.Seq[AbstractFile]: ...
    _toSet__B = typing.TypeVar('_toSet__B')  # <B>
    @staticmethod
    def toSet() -> scala.collection.immutable.Set[_toSet__B]: ...
    @staticmethod
    def toStream() -> scala.collection.immutable.Stream[AbstractFile]: ...
    @staticmethod
    def toString() -> str: ...
    @staticmethod
    def toTraversable() -> scala.collection.Traversable[AbstractFile]: ...
    @staticmethod
    def toURL() -> java.net.URL: ...
    @staticmethod
    def toVector() -> scala.collection.immutable.Vector[AbstractFile]: ...
    @staticmethod
    def transpose(asTraversable: scala.Function1) -> scala.collection.GenTraversable: ...
    @staticmethod
    def underlyingSource() -> scala.Option[AbstractFile]: ...
    _unzip__A1 = typing.TypeVar('_unzip__A1')  # <A1>
    _unzip__A2 = typing.TypeVar('_unzip__A2')  # <A2>
    @staticmethod
    def unzip(asPair: scala.Function1[AbstractFile, scala.Tuple2[_unzip__A1, _unzip__A2]]) -> scala.Tuple2[scala.collection.Iterable[_unzip__A1], scala.collection.Iterable[_unzip__A2]]: ...
    _unzip3__A1 = typing.TypeVar('_unzip3__A1')  # <A1>
    _unzip3__A2 = typing.TypeVar('_unzip3__A2')  # <A2>
    _unzip3__A3 = typing.TypeVar('_unzip3__A3')  # <A3>
    @staticmethod
    def unzip3(asTriple: scala.Function1[AbstractFile, scala.Tuple3[_unzip3__A1, _unzip3__A2, _unzip3__A3]]) -> scala.Tuple3[scala.collection.Iterable[_unzip3__A1], scala.collection.Iterable[_unzip3__A2], scala.collection.Iterable[_unzip3__A3]]: ...
    @typing.overload
    @staticmethod
    def view() -> scala.collection.IterableView[AbstractFile, scala.collection.Iterable[AbstractFile]]: ...
    @typing.overload
    @staticmethod
    def view(from_: int, until: int) -> scala.collection.IterableView[AbstractFile, scala.collection.Iterable[AbstractFile]]: ...
    @staticmethod
    def withFilter(p: scala.Function1[AbstractFile, typing.Any]) -> scala.collection.generic.FilterMonadic[AbstractFile, scala.collection.Iterable[AbstractFile]]: ...
    _zip__A1 = typing.TypeVar('_zip__A1')  # <A1>
    _zip__B = typing.TypeVar('_zip__B')  # <B>
    _zip__That = typing.TypeVar('_zip__That')  # <That>
    @staticmethod
    def zip(that: scala.collection.GenIterable[_zip__B], bf: scala.collection.generic.CanBuildFrom[scala.collection.Iterable[AbstractFile], scala.Tuple2[_zip__A1, _zip__B], _zip__That]) -> _zip__That: ...
    _zipAll__B = typing.TypeVar('_zipAll__B')  # <B>
    _zipAll__A1 = typing.TypeVar('_zipAll__A1')  # <A1>
    _zipAll__That = typing.TypeVar('_zipAll__That')  # <That>
    @staticmethod
    def zipAll(that: scala.collection.GenIterable[_zipAll__B], thisElem: _zipAll__A1, thatElem: _zipAll__B, bf: scala.collection.generic.CanBuildFrom[scala.collection.Iterable[AbstractFile], scala.Tuple2[_zipAll__A1, _zipAll__B], _zipAll__That]) -> _zipAll__That: ...
    _zipWithIndex__A1 = typing.TypeVar('_zipWithIndex__A1')  # <A1>
    _zipWithIndex__That = typing.TypeVar('_zipWithIndex__That')  # <That>
    @staticmethod
    def zipWithIndex(bf: scala.collection.generic.CanBuildFrom[scala.collection.Iterable[AbstractFile], scala.Tuple2[_zipWithIndex__A1, typing.Any], _zipWithIndex__That]) -> _zipWithIndex__That: ...

class Path:
    def __init__(self, jfile: typing.Union[java.io.File, jpype.protocol.SupportsPath]): ...
    @typing.overload
    def $div(self, child: 'Directory') -> 'Directory': ...
    @typing.overload
    def $div(self, child: 'File') -> 'File': ...
    @typing.overload
    def $div(self, child: 'Path') -> 'Path': ...
    def addExtension(self, ext: str) -> 'Path': ...
    @typing.overload
    @staticmethod
    def apply(jfile: typing.Union[java.io.File, jpype.protocol.SupportsPath]) -> 'Path': ...
    @typing.overload
    @staticmethod
    def apply(path: str) -> 'Path': ...
    def canRead(self) -> bool: ...
    def canWrite(self) -> bool: ...
    def changeExtension(self, ext: str) -> 'Path': ...
    def createDirectory(self, force: bool, failIfExists: bool) -> 'Directory': ...
    def createDirectory$default$1(self) -> bool: ...
    def createDirectory$default$2(self) -> bool: ...
    def createFile(self, failIfExists: bool) -> 'File': ...
    def createFile$default$1(self) -> bool: ...
    def delete(self) -> bool: ...
    def deleteRecursively(self) -> bool: ...
    def endsWith(self, other: 'Path') -> bool: ...
    def equals(self, other: typing.Any) -> bool: ...
    def exists(self) -> bool: ...
    def extension(self) -> str: ...
    def hasExtension(self, ext: str, exts: scala.collection.Seq[str]) -> bool: ...
    def hashCode(self) -> int: ...
    _ifDirectory__T = typing.TypeVar('_ifDirectory__T')  # <T>
    def ifDirectory(self, f: scala.Function1['Directory', _ifDirectory__T]) -> scala.Option[_ifDirectory__T]: ...
    _ifFile__T = typing.TypeVar('_ifFile__T')  # <T>
    def ifFile(self, f: scala.Function1['File', _ifFile__T]) -> scala.Option[_ifFile__T]: ...
    def isAbsolute(self) -> bool: ...
    def isDirectory(self) -> bool: ...
    def isEmpty(self) -> bool: ...
    @typing.overload
    @staticmethod
    def isExtensionJarOrZip(jfile: typing.Union[java.io.File, jpype.protocol.SupportsPath]) -> bool: ...
    @typing.overload
    @staticmethod
    def isExtensionJarOrZip(name: str) -> bool: ...
    def isFile(self) -> bool: ...
    def isFresher(self, other: 'Path') -> bool: ...
    def isSame(self, other: 'Path') -> bool: ...
    def jfile(self) -> java.io.File: ...
    @staticmethod
    def jfile2path(jfile: typing.Union[java.io.File, jpype.protocol.SupportsPath]) -> 'Path': ...
    def lastModified(self) -> int: ...
    def length(self) -> int: ...
    def name(self) -> str: ...
    def normalize(self) -> 'Path': ...
    @typing.overload
    @staticmethod
    def onlyDirs(xs: scala.collection.Iterator['Path']) -> scala.collection.Iterator['Directory']: ...
    @typing.overload
    @staticmethod
    def onlyDirs(xs: scala.collection.immutable.List['Path']) -> scala.collection.immutable.List['Directory']: ...
    @staticmethod
    def onlyFiles(xs: scala.collection.Iterator['Path']) -> scala.collection.Iterator['File']: ...
    def parent(self) -> 'Directory': ...
    def parents(self) -> scala.collection.immutable.List['Directory']: ...
    def path(self) -> str: ...
    def relativize(self, other: 'Path') -> 'Path': ...
    def resolve(self, other: 'Path') -> 'Path': ...
    @staticmethod
    def roots() -> scala.collection.immutable.List['Path']: ...
    def segments(self) -> scala.collection.immutable.List[str]: ...
    def separator(self) -> str: ...
    def separatorStr(self) -> str: ...
    @staticmethod
    def string2path(s: str) -> 'Path': ...
    def stripExtension(self) -> str: ...
    def toAbsolute(self) -> 'Path': ...
    def toAbsoluteWithRoot(self, root: 'Path') -> 'Path': ...
    def toCanonical(self) -> 'Path': ...
    def toDirectory(self) -> 'Directory': ...
    def toFile(self) -> 'File': ...
    def toString(self) -> str: ...
    def toURI(self) -> java.net.URI: ...
    def toURL(self) -> java.net.URL: ...
    def truncate(self) -> bool: ...
    def walk(self) -> scala.collection.Iterator['Path']: ...
    def walkFilter(self, cond: scala.Function1['Path', typing.Any]) -> scala.collection.Iterator['Path']: ...

class RootPath(java.io.Closeable):
    def __init__(self): ...
    @staticmethod
    def apply(path: typing.Union[java.nio.file.Path, jpype.protocol.SupportsPath], writable: bool) -> 'RootPath': ...
    def root(self) -> java.nio.file.Path: ...

class Directory(Path):
    def __init__(self, jfile: typing.Union[java.io.File, jpype.protocol.SupportsPath]): ...
    @staticmethod
    def Current() -> scala.Option['Directory']: ...
    @typing.overload
    @staticmethod
    def apply(path: Path) -> 'Directory': ...
    @typing.overload
    @staticmethod
    def apply(jfile: typing.Union[java.io.File, jpype.protocol.SupportsPath]) -> Path: ...
    @typing.overload
    @staticmethod
    def apply(path: str) -> Path: ...
    def deepFiles(self) -> scala.collection.Iterator['File']: ...
    def deepList(self, depth: int) -> scala.collection.Iterator[Path]: ...
    def deepList$default$1(self) -> int: ...
    def dirs(self) -> scala.collection.Iterator['Directory']: ...
    def files(self) -> scala.collection.Iterator['File']: ...
    def list(self) -> scala.collection.Iterator[Path]: ...
    @staticmethod
    def makeTemp(prefix: str, suffix: str, dir: typing.Union[java.io.File, jpype.protocol.SupportsPath]) -> 'Directory': ...
    @staticmethod
    def makeTemp$default$1() -> str: ...
    @staticmethod
    def makeTemp$default$2() -> str: ...
    @staticmethod
    def makeTemp$default$3() -> java.io.File: ...
    def normalize(self) -> 'Directory': ...
    def toAbsolute(self) -> 'Directory': ...
    def toDirectory(self) -> 'Directory': ...
    def toFile(self) -> 'File': ...
    def walkFilter(self, cond: scala.Function1[Path, typing.Any]) -> scala.collection.Iterator[Path]: ...

class PlainFile(AbstractFile):
    def __init__(self, givenPath: Path): ...
    def absolute(self) -> 'PlainFile': ...
    def canonicalPath(self) -> str: ...
    def container(self) -> AbstractFile: ...
    def create(self) -> None: ...
    def delete(self) -> None: ...
    def equals(self, that: typing.Any) -> bool: ...
    def file(self) -> java.io.File: ...
    def givenPath(self) -> Path: ...
    def hashCode(self) -> int: ...
    def input(self) -> java.io.FileInputStream: ...
    def isDirectory(self) -> bool: ...
    def iterator(self) -> scala.collection.Iterator[AbstractFile]: ...
    def lastModified(self) -> int: ...
    def lookupName(self, name: str, directory: bool) -> AbstractFile: ...
    def lookupNameUnchecked(self, name: str, directory: bool) -> AbstractFile: ...
    def name(self) -> str: ...
    def output(self) -> java.io.FileOutputStream: ...
    def path(self) -> str: ...
    def sizeOption(self) -> scala.Some[typing.Any]: ...
    def underlyingSource(self) -> scala.Some['PlainFile']: ...

class PlainNioFile(AbstractFile):
    def __init__(self, nioPath: typing.Union[java.nio.file.Path, jpype.protocol.SupportsPath]): ...
    def absolute(self) -> 'PlainNioFile': ...
    def canonicalPath(self) -> str: ...
    def container(self) -> AbstractFile: ...
    def create(self) -> None: ...
    def delete(self) -> None: ...
    def equals(self, that: typing.Any) -> bool: ...
    def file(self) -> java.io.File: ...
    def hashCode(self) -> int: ...
    def input(self) -> java.io.InputStream: ...
    def isDirectory(self) -> bool: ...
    def iterator(self) -> scala.collection.Iterator[AbstractFile]: ...
    def lastModified(self) -> int: ...
    def lookupName(self, name: str, directory: bool) -> AbstractFile: ...
    def lookupNameUnchecked(self, name: str, directory: bool) -> AbstractFile: ...
    def name(self) -> str: ...
    def output(self) -> java.io.OutputStream: ...
    def path(self) -> str: ...
    def sizeOption(self) -> scala.Some[typing.Any]: ...
    def underlyingSource(self) -> scala.Some['PlainNioFile']: ...

class VirtualDirectory(AbstractFile):
    def __init__(self, name: str, maybeContainer: scala.Option['VirtualDirectory']): ...
    def absolute(self) -> 'VirtualDirectory': ...
    def clear(self) -> None: ...
    def container(self) -> 'VirtualDirectory': ...
    def create(self) -> None: ...
    def delete(self) -> None: ...
    def file(self) -> scala.runtime.Null.: ...
    def fileNamed(self, name: str) -> AbstractFile: ...
    def input(self) -> scala.runtime.Nothing.: ...
    def isDirectory(self) -> bool: ...
    def isVirtual(self) -> bool: ...
    def iterator(self) -> scala.collection.Iterator[AbstractFile]: ...
    def lastModified(self) -> int: ...
    def lookupName(self, name: str, directory: bool) -> AbstractFile: ...
    def lookupNameUnchecked(self, name: str, directory: bool) -> AbstractFile: ...
    def name(self) -> str: ...
    def output(self) -> scala.runtime.Nothing.: ...
    def path(self) -> str: ...
    def subdirectoryNamed(self, name: str) -> AbstractFile: ...

class VirtualFile(AbstractFile):
    @typing.overload
    def __init__(self, name: str): ...
    @typing.overload
    def __init__(self, name: str, path: str): ...
    def absolute(self) -> 'VirtualFile': ...
    def container(self) -> AbstractFile: ...
    def create(self) -> None: ...
    def delete(self) -> None: ...
    def equals(self, that: typing.Any) -> bool: ...
    def file(self) -> java.io.File: ...
    def hashCode(self) -> int: ...
    def input(self) -> java.io.InputStream: ...
    def isDirectory(self) -> bool: ...
    def isVirtual(self) -> bool: ...
    def iterator(self) -> scala.collection.Iterator[AbstractFile]: ...
    def lastModified(self) -> int: ...
    def lookupName(self, name: str, directory: bool) -> AbstractFile: ...
    def lookupNameUnchecked(self, name: str, directory: bool) -> scala.runtime.Nothing.: ...
    def name(self) -> str: ...
    def output(self) -> java.io.OutputStream: ...
    def path(self) -> str: ...
    def scala$reflect$io$VirtualFile$$content_$eq(self, x$1: typing.List[int]) -> None: ...
    def sizeOption(self) -> scala.Option[typing.Any]: ...

class PlainDirectory(PlainFile):
    def __init__(self, givenPath: Directory): ...
    def delete(self) -> None: ...
    def isDirectory(self) -> bool: ...
    def iterator(self) -> scala.collection.Iterator[PlainFile]: ...

class File(Path, scala.reflect.io.Streamable.Chars):
    def __init__(self, jfile: typing.Union[java.io.File, jpype.protocol.SupportsPath], constructorCodec: scala.io.Codec): ...
    def addExtension(self, ext: str) -> 'File': ...
    def appendAll(self, strings: scala.collection.Seq[str]) -> None: ...
    @typing.overload
    @staticmethod
    def apply(path: Path, codec: scala.io.Codec) -> 'File': ...
    @typing.overload
    @staticmethod
    def apply(jfile: typing.Union[java.io.File, jpype.protocol.SupportsPath]) -> Path: ...
    @typing.overload
    @staticmethod
    def apply(path: str) -> Path: ...
    _applyReader__T = typing.TypeVar('_applyReader__T')  # <T>
    def applyReader(self, f: scala.Function1[java.io.BufferedReader, _applyReader__T]) -> _applyReader__T: ...
    def bufferedInput(self) -> java.io.BufferedInputStream: ...
    def bufferedOutput(self, append: bool) -> java.io.BufferedOutputStream: ...
    def bufferedOutput$default$1(self) -> bool: ...
    @typing.overload
    def bufferedReader(self) -> java.io.BufferedReader: ...
    @typing.overload
    def bufferedReader(self, codec: scala.io.Codec) -> java.io.BufferedReader: ...
    @typing.overload
    def bufferedWriter(self) -> java.io.BufferedWriter: ...
    @typing.overload
    def bufferedWriter(self, append: bool) -> java.io.BufferedWriter: ...
    @typing.overload
    def bufferedWriter(self, append: bool, codec: scala.io.Codec) -> java.io.BufferedWriter: ...
    def bytes(self) -> scala.collection.Iterator[typing.Any]: ...
    def bytesAsInts(self) -> scala.collection.Iterator[typing.Any]: ...
    def chars(self, codec: scala.io.Codec) -> scala.io.BufferedSource: ...
    def creationCodec(self) -> scala.io.Codec: ...
    def inputStream(self) -> java.io.FileInputStream: ...
    def length(self) -> int: ...
    @typing.overload
    def lines(self) -> scala.collection.Iterator[str]: ...
    @typing.overload
    def lines(self, codec: scala.io.Codec) -> scala.collection.Iterator[str]: ...
    @staticmethod
    def makeTemp(prefix: str, suffix: str, dir: typing.Union[java.io.File, jpype.protocol.SupportsPath]) -> 'File': ...
    @staticmethod
    def makeTemp$default$1() -> str: ...
    @staticmethod
    def makeTemp$default$2() -> str: ...
    @staticmethod
    def makeTemp$default$3() -> java.io.File: ...
    def normalize(self) -> 'File': ...
    def outputStream(self, append: bool) -> java.io.FileOutputStream: ...
    def outputStream$default$1(self) -> bool: ...
    @staticmethod
    def pathSeparator() -> str: ...
    def printWriter(self) -> java.io.PrintWriter: ...
    def printlnAll(self, strings: scala.collection.Seq[str]) -> None: ...
    def reader(self, codec: scala.io.Codec) -> java.io.InputStreamReader: ...
    def safeSlurp(self) -> scala.Option[str]: ...
    def setExecutable(self, executable: bool, ownerOnly: bool) -> bool: ...
    def setExecutable$default$2(self) -> bool: ...
    @typing.overload
    def slurp(self) -> str: ...
    @typing.overload
    def slurp(self, codec: scala.io.Codec) -> str: ...
    def toAbsolute(self) -> 'File': ...
    def toByteArray(self) -> typing.List[int]: ...
    def toDirectory(self) -> Directory: ...
    def toFile(self) -> 'File': ...
    def walkFilter(self, cond: scala.Function1[Path, typing.Any]) -> scala.collection.Iterator[Path]: ...
    def writeAll(self, strings: scala.collection.Seq[str]) -> None: ...
    def writer(self, append: bool, codec: scala.io.Codec) -> java.io.OutputStreamWriter: ...

class FileZipArchive(scala.reflect.io.ZipArchive):
    @typing.overload
    def __init__(self, file: typing.Union[java.io.File, jpype.protocol.SupportsPath]): ...
    @typing.overload
    def __init__(self, file: typing.Union[java.io.File, jpype.protocol.SupportsPath], release: scala.Option[str]): ...
    def allDirs(self) -> java.util.Map[str, 'ZipArchive.DirEntry']: ...
    def canEqual(self, other: typing.Any) -> bool: ...
    def close(self) -> None: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def input(self) -> java.io.FileInputStream: ...
    def iterator(self) -> scala.collection.Iterator['ZipArchive.Entry']: ...
    def lastModified(self) -> int: ...
    def name(self) -> str: ...
    def path(self) -> str: ...
    def root(self) -> 'ZipArchive.DirEntry': ...
    def scala$reflect$io$FileZipArchive$$openZipFile(self) -> java.util.zip.ZipFile: ...
    def sizeOption(self) -> scala.Some[typing.Any]: ...
    class LazyEntry(scala.reflect.io.ZipArchive.Entry):
        def __init__(self, $outer: 'FileZipArchive', name: str, time: int, size: int): ...
        def input(self) -> java.io.InputStream: ...
        def lastModified(self) -> int: ...
        def sizeOption(self) -> scala.Option[typing.Any]: ...
    class LeakyEntry(scala.reflect.io.ZipArchive.Entry):
        def __init__(self, $outer: 'FileZipArchive', zipFile: java.util.zip.ZipFile, zipEntry: java.util.zip.ZipEntry, name: str): ...
        def input(self) -> java.io.InputStream: ...
        def lastModified(self) -> int: ...
        def sizeOption(self) -> scala.Option[typing.Any]: ...

class ManifestResources(scala.reflect.io.ZipArchive):
    def __init__(self, url: java.net.URL): ...
    def canEqual(self, other: typing.Any) -> bool: ...
    def close(self) -> None: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def input(self) -> java.io.InputStream: ...
    def iterator(self) -> scala.collection.Iterator[AbstractFile]: ...
    def lastModified(self) -> int: ...
    def name(self) -> str: ...
    def path(self) -> str: ...
    def scala$reflect$io$ManifestResources$$resourceInputStream(self, path: str) -> java.io.InputStream: ...
    def url(self) -> java.net.URL: ...

class Streamable:
    @staticmethod
    def bytes(is_: scala.Function0[java.io.InputStream]) -> typing.List[int]: ...
    _closing__T = typing.TypeVar('_closing__T', bound=java.io.Closeable)  # <T>
    _closing__U = typing.TypeVar('_closing__U')  # <U>
    @staticmethod
    def closing(stream: _closing__T, f: scala.Function1[_closing__T, _closing__U]) -> _closing__U: ...
    @typing.overload
    @staticmethod
    def slurp(url: java.net.URL, codec: scala.io.Codec) -> str: ...
    @typing.overload
    @staticmethod
    def slurp(is_: scala.Function0[java.io.InputStream], codec: scala.io.Codec) -> str: ...
    class Bytes:
        @staticmethod
        def $init$($this: 'Streamable.Bytes') -> None: ...
        def bufferedInput(self) -> java.io.BufferedInputStream: ...
        def bytes(self) -> scala.collection.Iterator[typing.Any]: ...
        def bytesAsInts(self) -> scala.collection.Iterator[typing.Any]: ...
        def inputStream(self) -> java.io.InputStream: ...
        def length(self) -> int: ...
        def toByteArray(self) -> typing.List[int]: ...
    class Chars(scala.reflect.io.Streamable.Bytes):
        @staticmethod
        def $init$($this: 'Streamable.Chars') -> None: ...
        _applyReader__T = typing.TypeVar('_applyReader__T')  # <T>
        def applyReader(self, f: scala.Function1[java.io.BufferedReader, _applyReader__T]) -> _applyReader__T: ...
        @typing.overload
        def bufferedReader(self) -> java.io.BufferedReader: ...
        @typing.overload
        def bufferedReader(self, codec: scala.io.Codec) -> java.io.BufferedReader: ...
        def chars(self, codec: scala.io.Codec) -> scala.io.BufferedSource: ...
        def creationCodec(self) -> scala.io.Codec: ...
        @typing.overload
        def lines(self) -> scala.collection.Iterator[str]: ...
        @typing.overload
        def lines(self, codec: scala.io.Codec) -> scala.collection.Iterator[str]: ...
        def reader(self, codec: scala.io.Codec) -> java.io.InputStreamReader: ...
        @typing.overload
        def slurp(self) -> str: ...
        @typing.overload
        def slurp(self, codec: scala.io.Codec) -> str: ...

class URLZipArchive(scala.reflect.io.ZipArchive):
    def __init__(self, url: java.net.URL): ...
    def canEqual(self, other: typing.Any) -> bool: ...
    def close(self) -> None: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def input(self) -> java.io.InputStream: ...
    def iterator(self) -> scala.collection.Iterator['ZipArchive.Entry']: ...
    def lastModified(self) -> int: ...
    def name(self) -> str: ...
    def path(self) -> str: ...
    def url(self) -> java.net.URL: ...

class ZipArchive(AbstractFile):
    @typing.overload
    def __init__(self, file: typing.Union[java.io.File, jpype.protocol.SupportsPath]): ...
    @typing.overload
    def __init__(self, file: typing.Union[java.io.File, jpype.protocol.SupportsPath], release: scala.Option[str]): ...
    def absolute(self) -> scala.runtime.Nothing.: ...
    def canonicalPath(self) -> str: ...
    def close(self) -> None: ...
    def container(self) -> scala.runtime.Nothing.: ...
    def create(self) -> scala.runtime.Nothing.: ...
    def delete(self) -> scala.runtime.Nothing.: ...
    def file(self) -> java.io.File: ...
    @typing.overload
    @staticmethod
    def fromFile(file: typing.Union[java.io.File, jpype.protocol.SupportsPath]) -> FileZipArchive: ...
    @typing.overload
    @staticmethod
    def fromFile(file: File) -> FileZipArchive: ...
    @staticmethod
    def fromManifestURL(url: java.net.URL) -> AbstractFile: ...
    @staticmethod
    def fromURL(url: java.net.URL) -> URLZipArchive: ...
    def getDir(self, dirs: typing.Union[java.util.Map[str, 'ZipArchive.DirEntry'], typing.Mapping[str, 'ZipArchive.DirEntry']], entry: java.util.zip.ZipEntry) -> 'ZipArchive.DirEntry': ...
    def isDirectory(self) -> bool: ...
    def lookupName(self, name: str, directory: bool) -> scala.runtime.Nothing.: ...
    def lookupNameUnchecked(self, name: str, directory: bool) -> scala.runtime.Nothing.: ...
    def output(self) -> scala.runtime.Nothing.: ...
    def underlyingSource(self) -> scala.Some['ZipArchive']: ...
    class DirEntry(scala.reflect.io.ZipArchive.Entry):
        def __init__(self, $outer: 'ZipArchive', path: str): ...
        def entries(self) -> scala.collection.mutable.HashMap[str, 'ZipArchive.Entry']: ...
        def isDirectory(self) -> bool: ...
        def iterator(self) -> scala.collection.Iterator['ZipArchive.Entry']: ...
        def lookupName(self, name: str, directory: bool) -> 'ZipArchive.Entry': ...
    class Entry(VirtualFile):
        $outer: 'ZipArchive' = ...
        def __init__(self, $outer: 'ZipArchive', path: str): ...
        def getArchive(self) -> java.util.zip.ZipFile: ...
        def toString(self) -> str: ...
        def underlyingSource(self) -> scala.Some['ZipArchive']: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("scala.reflect.io")``.

    AbstractFile: typing.Type[AbstractFile]
    Directory: typing.Type[Directory]
    File: typing.Type[File]
    FileOperationException: typing.Type[FileOperationException]
    FileZipArchive: typing.Type[FileZipArchive]
    ManifestResources: typing.Type[ManifestResources]
    NoAbstractFile: typing.Type[NoAbstractFile]
    Path: typing.Type[Path]
    PlainDirectory: typing.Type[PlainDirectory]
    PlainFile: typing.Type[PlainFile]
    PlainNioFile: typing.Type[PlainNioFile]
    RootPath: typing.Type[RootPath]
    Streamable: typing.Type[Streamable]
    URLZipArchive: typing.Type[URLZipArchive]
    VirtualDirectory: typing.Type[VirtualDirectory]
    VirtualFile: typing.Type[VirtualFile]
    ZipArchive: typing.Type[ZipArchive]
