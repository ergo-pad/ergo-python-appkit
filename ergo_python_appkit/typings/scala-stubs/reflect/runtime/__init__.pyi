import java.lang
import java.lang.annotation
import java.lang.ref
import java.lang.reflect
import java.util.concurrent.atomic
import java.util.concurrent.locks
import scala
import scala.collection
import scala.collection.immutable
import scala.collection.mutable
import scala.ref
import scala.reflect
import scala.reflect.api
import scala.reflect.internal
import scala.reflect.internal.pickling
import scala.reflect.internal.settings
import scala.reflect.internal.tpe
import scala.reflect.internal.util
import scala.reflect.io
import scala.reflect.macros
import scala.reflect.macros.blackbox
import scala.runtime
import typing



class Gil:
    @staticmethod
    def $init$($this: 'Gil') -> None: ...
    _gilSynchronized__T = typing.TypeVar('_gilSynchronized__T')  # <T>
    def gilSynchronized(self, body: scala.Function0[_gilSynchronized__T]) -> _gilSynchronized__T: ...
    def scala$reflect$runtime$Gil$$gil(self) -> java.util.concurrent.locks.ReentrantLock: ...

_HasJavaClass__J = typing.TypeVar('_HasJavaClass__J')  # <J>
class HasJavaClass(typing.Generic[_HasJavaClass__J]):
    def __init__(self, getClazz: scala.Function1[_HasJavaClass__J, typing.Type[typing.Any]]): ...
    def getClazz(self) -> scala.Function1[_HasJavaClass__J, typing.Type[typing.Any]]: ...

class JavaUniverseForce:
    @staticmethod
    def $init$($this: 'JavaUniverseForce') -> None: ...
    def force(self) -> None: ...

class Macros:
    @staticmethod
    def currentMirror(c: scala.reflect.macros.blackbox.Context) -> scala.reflect.api.Exprs.Expr[scala.reflect.api.JavaUniverse.JavaMirror]: ...

class ReflectError(java.lang.Error):
    def __init__(self, msg: str): ...

class ReflectSetup:
    @staticmethod
    def $init$($this: 'ReflectSetup') -> None: ...
    def currentRunId(self) -> int: ...
    def phaseWithId(self) -> typing.List[scala.reflect.internal.Phase]: ...
    def scala$reflect$runtime$ReflectSetup$_setter_$currentRunId_$eq(self, x$1: int) -> None: ...
    def scala$reflect$runtime$ReflectSetup$_setter_$phaseWithId_$eq(self, x$1: typing.List[scala.reflect.internal.Phase]) -> None: ...

class SynchronizedTypes(scala.reflect.internal.Types):
    @staticmethod
    def $init$($this: 'SynchronizedTypes') -> None: ...
    def basetypeRecursions(self) -> int: ...
    def basetypeRecursions_$eq(self, value: int) -> None: ...
    def commonOwnerMap(self) -> scala.reflect.internal.tpe.CommonOwners.CommonOwnerMap: ...
    def defineBaseClassesOfCompoundType(self, tpe: scala.reflect.internal.Types.CompoundType) -> None: ...
    def defineBaseTypeSeqOfCompoundType(self, tpe: scala.reflect.internal.Types.CompoundType) -> None: ...
    def defineBaseTypeSeqOfTypeRef(self, tpe: scala.reflect.internal.Types.TypeRef) -> None: ...
    def defineParentsOfTypeRef(self, tpe: scala.reflect.internal.Types.TypeRef) -> None: ...
    def defineUnderlyingOfSingleType(self, tpe: scala.reflect.internal.Types.SingleType) -> None: ...
    def glbResults(self) -> scala.collection.mutable.HashMap[scala.Tuple2[scala.reflect.internal.Depth, scala.collection.immutable.List[scala.reflect.internal.Types.Type]], scala.reflect.internal.Types.Type]: ...
    def indent(self) -> str: ...
    def indent_$eq(self, value: str) -> None: ...
    def intersectionWitness(self) -> scala.collection.mutable.WeakHashMap[scala.collection.immutable.List[scala.reflect.internal.Types.Type], scala.ref.WeakReference[scala.reflect.internal.Types.Type]]: ...
    def lubResults(self) -> scala.collection.mutable.HashMap[scala.Tuple2[scala.reflect.internal.Depth, scala.collection.immutable.List[scala.reflect.internal.Types.Type]], scala.reflect.internal.Types.Type]: ...
    def pendingBaseTypes(self) -> scala.collection.mutable.HashSet[scala.reflect.internal.Types.Type]: ...
    def pendingSubTypes(self) -> scala.collection.mutable.HashSet[scala.reflect.internal.tpe.TypeComparers.SubTypePair]: ...
    def scala$reflect$runtime$SynchronizedTypes$$_basetypeRecursions(self) -> 'ThreadLocalStorage.ThreadLocalStorage'[typing.Any]: ...
    def scala$reflect$runtime$SynchronizedTypes$$_glbResults(self) -> 'ThreadLocalStorage.ThreadLocalStorage'[scala.collection.mutable.HashMap[scala.Tuple2[scala.reflect.internal.Depth, scala.collection.immutable.List[scala.reflect.internal.Types.Type]], scala.reflect.internal.Types.Type]]: ...
    def scala$reflect$runtime$SynchronizedTypes$$_indent(self) -> 'ThreadLocalStorage.ThreadLocalStorage'[str]: ...
    def scala$reflect$runtime$SynchronizedTypes$$_intersectionWitness(self) -> 'ThreadLocalStorage.ThreadLocalStorage'[scala.collection.mutable.WeakHashMap[scala.collection.immutable.List[scala.reflect.internal.Types.Type], scala.ref.WeakReference[scala.reflect.internal.Types.Type]]]: ...
    def scala$reflect$runtime$SynchronizedTypes$$_lubResults(self) -> 'ThreadLocalStorage.ThreadLocalStorage'[scala.collection.mutable.HashMap[scala.Tuple2[scala.reflect.internal.Depth, scala.collection.immutable.List[scala.reflect.internal.Types.Type]], scala.reflect.internal.Types.Type]]: ...
    def scala$reflect$runtime$SynchronizedTypes$$_pendingBaseTypes(self) -> 'ThreadLocalStorage.ThreadLocalStorage'[scala.collection.mutable.HashSet[scala.reflect.internal.Types.Type]]: ...
    def scala$reflect$runtime$SynchronizedTypes$$_pendingSubTypes(self) -> 'ThreadLocalStorage.ThreadLocalStorage'[scala.collection.mutable.HashSet[scala.reflect.internal.tpe.TypeComparers.SubTypePair]]: ...
    def scala$reflect$runtime$SynchronizedTypes$$_skolemizationLevel(self) -> 'ThreadLocalStorage.ThreadLocalStorage'[typing.Any]: ...
    def scala$reflect$runtime$SynchronizedTypes$$_subsametypeRecursions(self) -> 'ThreadLocalStorage.ThreadLocalStorage'[typing.Any]: ...
    def scala$reflect$runtime$SynchronizedTypes$$_toStringRecursions(self) -> 'ThreadLocalStorage.ThreadLocalStorage'[typing.Any]: ...
    def scala$reflect$runtime$SynchronizedTypes$$_toStringSubjects(self) -> 'ThreadLocalStorage.ThreadLocalStorage'[scala.collection.mutable.HashSet[scala.reflect.internal.Types.Type]]: ...
    def scala$reflect$runtime$SynchronizedTypes$$_undoLog(self) -> 'ThreadLocalStorage.ThreadLocalStorage'[scala.reflect.internal.tpe.TypeConstraints.UndoLog]: ...
    def scala$reflect$runtime$SynchronizedTypes$$uniqueLock(self) -> typing.Any: ...
    def scala$reflect$runtime$SynchronizedTypes$$uniques(self) -> scala.collection.mutable.WeakHashMap[scala.reflect.internal.Types.Type, java.lang.ref.WeakReference[scala.reflect.internal.Types.Type]]: ...
    def scala$reflect$runtime$SynchronizedTypes$_setter_$scala$reflect$runtime$SynchronizedTypes$$uniques_$eq(self, x$1: scala.collection.mutable.WeakHashMap[scala.reflect.internal.Types.Type, java.lang.ref.WeakReference[scala.reflect.internal.Types.Type]]) -> None: ...
    def skolemizationLevel(self) -> int: ...
    def skolemizationLevel_$eq(self, value: int) -> None: ...
    def subsametypeRecursions(self) -> int: ...
    def subsametypeRecursions_$eq(self, value: int) -> None: ...
    def toStringRecursions(self) -> int: ...
    def toStringRecursions_$eq(self, value: int) -> None: ...
    def toStringSubjects(self) -> scala.collection.mutable.HashSet[scala.reflect.internal.Types.Type]: ...
    def undoLog(self) -> scala.reflect.internal.tpe.TypeConstraints.UndoLog: ...
    _unique__T = typing.TypeVar('_unique__T', bound=scala.reflect.internal.Types.Type)  # <T>
    def unique(self, tp: _unique__T) -> _unique__T: ...

_TwoWayCache__J = typing.TypeVar('_TwoWayCache__J')  # <J>
_TwoWayCache__S = typing.TypeVar('_TwoWayCache__S')  # <S>
class TwoWayCache(typing.Generic[_TwoWayCache__J, _TwoWayCache__S]):
    def __init__(self): ...
    def enter(self, j: _TwoWayCache__J, s: _TwoWayCache__S) -> None: ...
    def toJava(self, key: _TwoWayCache__S, body: scala.Function0[_TwoWayCache__J]) -> _TwoWayCache__J: ...
    def toScala(self, key: _TwoWayCache__J, body: scala.Function0[_TwoWayCache__S]) -> _TwoWayCache__S: ...
    class SomeRef$:
        def __init__(self, $outer: 'TwoWayCache'): ...
        _unapply__T = typing.TypeVar('_unapply__T')  # <T>
        def unapply(self, optRef: scala.Option[java.lang.ref.WeakReference[_unapply__T]]) -> scala.Option[_unapply__T]: ...

_TwoWayCaches__TwoWayCache__J = typing.TypeVar('_TwoWayCaches__TwoWayCache__J')  # <J>
_TwoWayCaches__TwoWayCache__S = typing.TypeVar('_TwoWayCaches__TwoWayCache__S')  # <S>
class TwoWayCaches:
    @staticmethod
    def $init$($this: 'TwoWayCaches') -> None: ...
    class TwoWayCache(typing.Generic[_TwoWayCaches__TwoWayCache__J, _TwoWayCaches__TwoWayCache__S]):
        $outer: 'SymbolTable' = ...
        def __init__(self, $outer: 'SymbolTable'): ...
        def enter(self, j: _TwoWayCaches__TwoWayCache__J, s: _TwoWayCaches__TwoWayCache__S) -> None: ...
        def toJava(self, key: _TwoWayCaches__TwoWayCache__S, body: scala.Function0[_TwoWayCaches__TwoWayCache__J]) -> _TwoWayCaches__TwoWayCache__J: ...
        def toJavaOption(self, key: _TwoWayCaches__TwoWayCache__S, body: scala.Function0[scala.Option[_TwoWayCaches__TwoWayCache__J]]) -> scala.Option[_TwoWayCaches__TwoWayCache__J]: ...
        def toScala(self, key: _TwoWayCaches__TwoWayCache__J, body: scala.Function0[_TwoWayCaches__TwoWayCache__S]) -> _TwoWayCaches__TwoWayCache__S: ...
        class SomeRef$:
            def __init__(self, $outer: 'TwoWayCaches.TwoWayCache'): ...
            _unapply__T = typing.TypeVar('_unapply__T')  # <T>
            def unapply(self, optRef: scala.Option[java.lang.ref.WeakReference[_unapply__T]]) -> scala.Option[_unapply__T]: ...

class package:
    @staticmethod
    def universe() -> scala.reflect.api.JavaUniverse: ...

_JavaMirrors__JavaMirror__BytecodelessMethodMirror__T = typing.TypeVar('_JavaMirrors__JavaMirror__BytecodelessMethodMirror__T')  # <T>
_JavaMirrors__JavaMirror__JavaInstanceMirror__T = typing.TypeVar('_JavaMirrors__JavaMirror__JavaInstanceMirror__T')  # <T>
class JavaMirrors(scala.reflect.api.JavaUniverse, TwoWayCaches):
    @staticmethod
    def $init$($this: 'JavaMirrors') -> None: ...
    def MirrorTag(self) -> scala.reflect.ClassTag['JavaMirrors.JavaMirror']: ...
    def mirrorThatLoaded(self, sym: scala.reflect.internal.Symbols.Symbol) -> 'JavaMirrors.JavaMirror': ...
    def missingHook(self, owner: scala.reflect.internal.Symbols.Symbol, name: scala.reflect.internal.Names.Name) -> scala.reflect.internal.Symbols.Symbol: ...
    def newPackageScope(self, pkgClass: scala.reflect.internal.Symbols.Symbol) -> 'SymbolLoaders.PackageScope': ...
    def rootClassLoader(self) -> java.lang.ClassLoader: ...
    def rootMirror(self) -> 'JavaMirrors.JavaMirror': ...
    @typing.overload
    def runtimeMirror(self, cl: java.lang.ClassLoader) -> scala.reflect.api.JavaUniverse.JavaMirror: ...
    @typing.overload
    def runtimeMirror(self, cl: java.lang.ClassLoader) -> 'JavaMirrors.JavaMirror': ...
    def scala$reflect$runtime$JavaMirrors$$mirrors(self) -> scala.collection.mutable.WeakHashMap[java.lang.ClassLoader, scala.ref.WeakReference['JavaMirrors.JavaMirror']]: ...
    def scala$reflect$runtime$JavaMirrors$_setter_$MirrorTag_$eq(self, x$1: scala.reflect.ClassTag['JavaMirrors.JavaMirror']) -> None: ...
    def scopeTransform(self, owner: scala.reflect.internal.Symbols.Symbol, op: scala.Function0[scala.reflect.internal.Scopes.Scope]) -> scala.reflect.internal.Scopes.Scope: ...
    def validateClassInfo(self, tp: scala.reflect.internal.Types.ClassInfoType) -> None: ...
    class JavaClassCompleter: ...
    class JavaMirror(scala.reflect.internal.Mirrors.Roots, scala.reflect.api.JavaUniverse.JavaMirror):
        def __init__(self, $outer: 'SymbolTable', owner: scala.reflect.internal.Symbols.Symbol, classLoader: java.lang.ClassLoader): ...
        def EmptyPackage(self) -> scala.reflect.internal.Mirrors.Roots.EmptyPackage: ...
        def EmptyPackageClass(self) -> scala.reflect.internal.Mirrors.Roots.EmptyPackageClass: ...
        def RootClass(self) -> scala.reflect.internal.Mirrors.Roots.RootClass: ...
        def RootPackage(self) -> scala.reflect.internal.Mirrors.Roots.RootPackage: ...
        def bytecodefulObjectMethods(self) -> scala.collection.immutable.Set[scala.reflect.internal.Symbols.Symbol]: ...
        def bytecodelessMethodOwners(self) -> scala.collection.immutable.Set[scala.reflect.internal.Symbols.Symbol]: ...
        def classLoader(self) -> java.lang.ClassLoader: ...
        def classSymbol(self, rtcls: typing.Type[typing.Any]) -> scala.reflect.internal.Symbols.ClassSymbol: ...
        def classToJava(self, clazz: scala.reflect.internal.Symbols.ClassSymbol) -> typing.Type[typing.Any]: ...
        def classToScala(self, jclazz: typing.Type[typing.Any]) -> scala.reflect.internal.Symbols.ClassSymbol: ...
        def constructorToJava(self, constr: scala.reflect.internal.Symbols.MethodSymbol) -> java.lang.reflect.Constructor[typing.Any]: ...
        def constructorToScala(self, jconstr: java.lang.reflect.Constructor[typing.Any]) -> scala.reflect.internal.Symbols.MethodSymbol: ...
        def fieldToJava(self, fld: scala.reflect.internal.Symbols.TermSymbol) -> java.lang.reflect.Field: ...
        def genericDeclarationToScala(self, jdecl: java.lang.reflect.GenericDeclaration) -> scala.reflect.internal.Symbols.Symbol: ...
        def javaClass(self, path: str) -> typing.Type[typing.Any]: ...
        def methodToJava(self, meth: scala.reflect.internal.Symbols.MethodSymbol) -> java.lang.reflect.Method: ...
        def methodToScala(self, jmeth: java.lang.reflect.Method) -> scala.reflect.internal.Symbols.MethodSymbol: ...
        def mirrorDefining(self, jclazz: typing.Type[typing.Any]) -> 'JavaMirrors.JavaMirror': ...
        def moduleSymbol(self, rtcls: typing.Type[typing.Any]) -> scala.reflect.internal.Symbols.ModuleSymbol: ...
        def packageNameToScala(self, fullname: str) -> scala.reflect.internal.Symbols.ModuleSymbol: ...
        def packageToScala(self, jpkg: java.lang.Package) -> scala.reflect.internal.Symbols.ModuleSymbol: ...
        _reflect__T = typing.TypeVar('_reflect__T')  # <T>
        def reflect(self, obj: _reflect__T, evidence$2: scala.reflect.ClassTag[_reflect__T]) -> scala.reflect.api.Mirrors.InstanceMirror: ...
        def reflectClass(self, cls: scala.reflect.internal.Symbols.ClassSymbol) -> scala.reflect.api.Mirrors.ClassMirror: ...
        def reflectMemberToScala(self, m: java.lang.reflect.Member) -> scala.reflect.internal.Symbols.Symbol: ...
        def reflectModule(self, mod: scala.reflect.internal.Symbols.ModuleSymbol) -> scala.reflect.api.Mirrors.ModuleMirror: ...
        def rootLoader(self) -> scala.reflect.internal.Types.FlagAgnosticCompleter: ...
        def runDefinitions(self) -> scala.reflect.internal.Definitions.DefinitionsClass.RunDefinitions: ...
        @typing.overload
        def runtimeClass(self, cls: scala.reflect.internal.Symbols.ClassSymbol) -> typing.Type[typing.Any]: ...
        @typing.overload
        def runtimeClass(self, tpe: scala.reflect.internal.Types.Type) -> typing.Type[typing.Any]: ...
        def scala$reflect$runtime$JavaMirrors$$makeScalaPackage(self, fullname: str) -> scala.reflect.internal.Symbols.ModuleSymbol: ...
        def scala$reflect$runtime$JavaMirrors$JavaMirror$$ErrorNonExistentField(self, sym: scala.reflect.internal.Symbols.Symbol) -> scala.runtime.Nothing.: ...
        def scala$reflect$runtime$JavaMirrors$JavaMirror$$ErrorNotField(self, sym: scala.reflect.internal.Symbols.Symbol) -> scala.runtime.Nothing.: ...
        def scala$reflect$runtime$JavaMirrors$JavaMirror$$ErrorStaticClass(self, sym: scala.reflect.internal.Symbols.Symbol) -> scala.runtime.Nothing.: ...
        def scala$reflect$runtime$JavaMirrors$JavaMirror$$ErrorStaticModule(self, sym: scala.reflect.internal.Symbols.Symbol) -> scala.runtime.Nothing.: ...
        def scala$reflect$runtime$JavaMirrors$JavaMirror$$abort(self, msg: str) -> scala.runtime.Nothing.: ...
        def scala$reflect$runtime$JavaMirrors$JavaMirror$$assignAssociatedFile(self, clazz: scala.reflect.internal.Symbols.Symbol, module: scala.reflect.internal.Symbols.Symbol, jclazz: typing.Type[typing.Any]) -> None: ...
        def scala$reflect$runtime$JavaMirrors$JavaMirror$$checkConstructorOf(self, sym: scala.reflect.internal.Symbols.Symbol, owner: scala.reflect.internal.Symbols.ClassSymbol) -> None: ...
        def scala$reflect$runtime$JavaMirrors$JavaMirror$$checkMemberOf(self, sym: scala.reflect.internal.Symbols.Symbol, owner: scala.reflect.internal.Symbols.ClassSymbol) -> None: ...
        def scala$reflect$runtime$JavaMirrors$JavaMirror$$copyAnnotations(self, sym: scala.reflect.internal.Symbols.Symbol, jann: java.lang.reflect.AnnotatedElement) -> None: ...
        def scala$reflect$runtime$JavaMirrors$JavaMirror$$createTypeParameter(self, jtvar: java.lang.reflect.TypeVariable[java.lang.reflect.GenericDeclaration]) -> scala.reflect.internal.Symbols.TypeSymbol: ...
        def scala$reflect$runtime$JavaMirrors$JavaMirror$$followStatic(self, clazz: scala.reflect.internal.Symbols.Symbol, module: scala.reflect.internal.Symbols.Symbol, mods: int) -> scala.reflect.internal.Symbols.Symbol: ...
        def scala$reflect$runtime$JavaMirrors$JavaMirror$$isByNameParam(self, p: scala.reflect.internal.Types.Type) -> bool: ...
        def scala$reflect$runtime$JavaMirrors$JavaMirror$$isGetClass(self, meth: scala.reflect.internal.Symbols.MethodSymbol) -> bool: ...
        def scala$reflect$runtime$JavaMirrors$JavaMirror$$isStringConcat(self, meth: scala.reflect.internal.Symbols.MethodSymbol) -> bool: ...
        def scala$reflect$runtime$JavaMirrors$JavaMirror$$jClassOps(self, clazz: typing.Type[typing.Any]) -> 'JavaMirrors.JavaMirror.jClassOps': ...
        def scala$reflect$runtime$JavaMirrors$JavaMirror$$jMemberOps(self, member: java.lang.reflect.Member) -> 'JavaMirrors.JavaMirror.jMemberOps': ...
        def scala$reflect$runtime$JavaMirrors$JavaMirror$$jclassAsScala(self, jclazz: typing.Type[typing.Any]) -> scala.reflect.internal.Symbols.ClassSymbol: ...
        def scala$reflect$runtime$JavaMirrors$JavaMirror$$jconstrAsScala(self, jconstr: java.lang.reflect.Constructor[typing.Any]) -> scala.reflect.internal.Symbols.MethodSymbol: ...
        def scala$reflect$runtime$JavaMirrors$JavaMirror$$jfieldAsScala(self, jfield: java.lang.reflect.Field) -> scala.reflect.internal.Symbols.TermSymbol: ...
        def scala$reflect$runtime$JavaMirrors$JavaMirror$$jmethodAsScala(self, jmeth: java.lang.reflect.Method) -> scala.reflect.internal.Symbols.MethodSymbol: ...
        _scala$reflect$runtime$JavaMirrors$JavaMirror$$mkMethodMirror__T = typing.TypeVar('_scala$reflect$runtime$JavaMirrors$JavaMirror$$mkMethodMirror__T')  # <T>
        def scala$reflect$runtime$JavaMirrors$JavaMirror$$mkMethodMirror(self, receiver: _scala.reflect.runtime.JavaMirrors.JavaMirror..mkMethodMirror__T, symbol: scala.reflect.internal.Symbols.MethodSymbol, evidence$5: scala.reflect.ClassTag[_scala.reflect.runtime.JavaMirrors.JavaMirror..mkMethodMirror__T]) -> scala.reflect.api.Mirrors.MethodMirror: ...
        _scala$reflect$runtime$JavaMirrors$JavaMirror$$preciseClass__T = typing.TypeVar('_scala$reflect$runtime$JavaMirrors$JavaMirror$$preciseClass__T')  # <T>
        def scala$reflect$runtime$JavaMirrors$JavaMirror$$preciseClass(self, instance: _scala.reflect.runtime.JavaMirrors.JavaMirror..preciseClass__T, evidence$3: scala.reflect.ClassTag[_scala.reflect.runtime.JavaMirrors.JavaMirror..preciseClass__T]) -> typing.Type[typing.Any]: ...
        def scala$reflect$runtime$JavaMirrors$JavaMirror$$toAnnotArg(self) -> 'JavaMirrors.JavaMirror.toAnnotArg.': ...
        def staticPackage(self, fullname: str) -> scala.reflect.internal.Symbols.ModuleSymbol: ...
        _toScala__J = typing.TypeVar('_toScala__J')  # <J>
        _toScala__S = typing.TypeVar('_toScala__S')  # <S>
        def toScala(self, cache: TwoWayCaches.TwoWayCache[_toScala__J, _toScala__S], key: _toScala__J, body: scala.Function2['JavaMirrors.JavaMirror', _toScala__J, _toScala__S], evidence$1: HasJavaClass[_toScala__J]) -> _toScala__S: ...
        def toString(self) -> str: ...
        def tryJavaClass(self, path: str) -> scala.Option[typing.Type[typing.Any]]: ...
        def typeParamToScala(self, jparam: java.lang.reflect.TypeVariable[java.lang.reflect.GenericDeclaration]) -> scala.reflect.internal.Symbols.TypeSymbol: ...
        def typeTag(self, typeCreator: scala.reflect.api.TypeCreator) -> scala.reflect.api.TypeTags.TypeTag[typing.Any]: ...
        def typeToJavaClass(self, tpe: scala.reflect.internal.Types.Type) -> typing.Type[typing.Any]: ...
        def typeToScala(self, jtpe: java.lang.reflect.Type) -> scala.reflect.internal.Types.Type: ...
        def universe(self) -> 'SymbolTable': ...
        def unpickleClass(self, clazz: scala.reflect.internal.Symbols.ClassSymbol, module: scala.reflect.internal.Symbols.ModuleSymbol, jclazz: typing.Type[typing.Any]) -> None: ...
        class BytecodelessMethodMirror(scala.reflect.api.Mirrors.MethodMirror, typing.Generic[_JavaMirrors__JavaMirror__BytecodelessMethodMirror__T]):
            $outer: 'JavaMirrors.JavaMirror' = ...
            def __init__(self, $outer: 'JavaMirrors.JavaMirror', receiver: _JavaMirrors__JavaMirror__BytecodelessMethodMirror__T, symbol: scala.reflect.internal.Symbols.MethodSymbol, evidence$6: scala.reflect.ClassTag[_JavaMirrors__JavaMirror__BytecodelessMethodMirror__T]): ...
            def apply(self, args: scala.collection.Seq[typing.Any]) -> typing.Any: ...
            def bind(self, newReceiver: typing.Any) -> 'JavaMirrors.JavaMirror.BytecodelessMethodMirror'[_JavaMirrors__JavaMirror__BytecodelessMethodMirror__T]: ...
            def receiver(self) -> _JavaMirrors__JavaMirror__BytecodelessMethodMirror__T: ...
            def symbol(self) -> scala.reflect.internal.Symbols.MethodSymbol: ...
            def toString(self) -> str: ...
        class DerivedValueClassMetadata:
            $outer: 'JavaMirrors.JavaMirror' = ...
            def __init__(self, $outer: 'JavaMirrors.JavaMirror', info: scala.reflect.internal.Types.Type): ...
            def boxer(self) -> java.lang.reflect.Constructor[typing.Any]: ...
            def isDerivedValueClass(self) -> bool: ...
            def symbol(self) -> scala.reflect.internal.Symbols.Symbol: ...
            def unboxer(self) -> java.lang.reflect.Method: ...
        class FromJavaClassCompleter(scala.reflect.internal.Types.LazyType, scala.reflect.runtime.JavaMirrors.JavaClassCompleter, scala.reflect.internal.Types.FlagAgnosticCompleter):
            scala$reflect$runtime$JavaMirrors$JavaMirror$FromJavaClassCompleter$$clazz: scala.reflect.internal.Symbols.Symbol = ...
            scala$reflect$runtime$JavaMirrors$JavaMirror$FromJavaClassCompleter$$module: scala.reflect.internal.Symbols.Symbol = ...
            $outer: 'JavaMirrors.JavaMirror' = ...
            def __init__(self, $outer: 'JavaMirrors.JavaMirror', clazz: scala.reflect.internal.Symbols.Symbol, module: scala.reflect.internal.Symbols.Symbol, jclazz: typing.Type[typing.Any]): ...
            def complete(self, sym: scala.reflect.internal.Symbols.Symbol) -> None: ...
            def completeRest(self) -> None: ...
            def flags(self) -> int: ...
            def load(self, sym: scala.reflect.internal.Symbols.Symbol) -> None: ...
            class LazyPolyType(scala.reflect.internal.Types.LazyType, scala.reflect.internal.Types.FlagAgnosticCompleter):
                $outer: 'JavaMirrors.JavaMirror.FromJavaClassCompleter' = ...
                def __init__(self, $outer: 'JavaMirrors.JavaMirror.FromJavaClassCompleter', typeParams: scala.collection.immutable.List[scala.reflect.internal.Symbols.Symbol]): ...
                def complete(self, sym: scala.reflect.internal.Symbols.Symbol) -> None: ...
                def typeParams(self) -> scala.collection.immutable.List[scala.reflect.internal.Symbols.Symbol]: ...
        class JavaAnnotationProxy(scala.reflect.internal.AnnotationInfos.AnnotationInfo, scala.Product, scala.Serializable):
            $outer: 'JavaMirrors.JavaMirror' = ...
            def __init__(self, $outer: 'JavaMirrors.JavaMirror', jann: java.lang.annotation.Annotation): ...
            def args(self) -> scala.collection.immutable.List[scala.reflect.internal.Trees.Tree]: ...
            def assocs(self) -> scala.collection.immutable.List[scala.Tuple2[scala.reflect.internal.Names.Name, scala.reflect.internal.AnnotationInfos.ClassfileAnnotArg]]: ...
            def atp(self) -> scala.reflect.internal.Types.Type: ...
            def canEqual(self, x$1: typing.Any) -> bool: ...
            def copy(self, jann: java.lang.annotation.Annotation) -> 'JavaMirrors.JavaMirror.JavaAnnotationProxy': ...
            def copy$default$1(self) -> java.lang.annotation.Annotation: ...
            def jann(self) -> java.lang.annotation.Annotation: ...
            def original(self) -> scala.reflect.internal.Trees.Tree: ...
            def pos(self) -> scala.reflect.internal.util.Position: ...
            def productArity(self) -> int: ...
            def productElement(self, x$1: int) -> typing.Any: ...
            def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
            def productPrefix(self) -> str: ...
            def setOriginal(self, t: scala.reflect.internal.Trees.Tree) -> 'JavaMirrors.JavaMirror.JavaAnnotationProxy': ...
            def setPos(self, pos: scala.reflect.internal.util.Position) -> 'JavaMirrors.JavaMirror.JavaAnnotationProxy': ...
            def toString(self) -> str: ...
            def transformArgs(self, f: scala.Function1[scala.collection.immutable.List[scala.reflect.internal.Trees.Tree], scala.collection.immutable.List[scala.reflect.internal.Trees.Tree]]) -> 'JavaMirrors.JavaMirror.JavaAnnotationProxy': ...
        class JavaAnnotationProxy$(scala.runtime.AbstractFunction1[java.lang.annotation.Annotation, 'JavaMirrors.JavaMirror.JavaAnnotationProxy'], scala.Serializable):
            def __init__(self, $outer: 'JavaMirrors.JavaMirror'): ...
            def apply(self, jann: java.lang.annotation.Annotation) -> 'JavaMirrors.JavaMirror.JavaAnnotationProxy': ...
            def toString(self) -> str: ...
            def unapply(self, x$0: 'JavaMirrors.JavaMirror.JavaAnnotationProxy') -> scala.Option[java.lang.annotation.Annotation]: ...
        class JavaClassMirror(scala.reflect.runtime.JavaMirrors.JavaMirror.JavaTemplateMirror, scala.reflect.api.Mirrors.ClassMirror):
            def __init__(self, $outer: 'JavaMirrors.JavaMirror', outer: typing.Any, symbol: scala.reflect.internal.Symbols.ClassSymbol): ...
            def erasure(self) -> scala.reflect.internal.Symbols.ClassSymbol: ...
            def isStatic(self) -> bool: ...
            def outer(self) -> typing.Any: ...
            def reflectConstructor(self, constructor: scala.reflect.internal.Symbols.MethodSymbol) -> scala.reflect.api.Mirrors.MethodMirror: ...
            def symbol(self) -> scala.reflect.internal.Symbols.ClassSymbol: ...
            def toString(self) -> str: ...
        class JavaFieldMirror(scala.reflect.api.Mirrors.FieldMirror):
            $outer: 'JavaMirrors.JavaMirror' = ...
            @typing.overload
            def __init__(self, $outer: 'JavaMirrors.JavaMirror', receiver: typing.Any, symbol: scala.reflect.internal.Symbols.TermSymbol): ...
            @typing.overload
            def __init__(self, $outer: 'JavaMirrors.JavaMirror', receiver: typing.Any, symbol: scala.reflect.internal.Symbols.TermSymbol, metadata: 'JavaMirrors.JavaMirror.DerivedValueClassMetadata'): ...
            def bind(self, newReceiver: typing.Any) -> 'JavaMirrors.JavaMirror.JavaFieldMirror': ...
            def get(self) -> typing.Any: ...
            def jfield(self) -> java.lang.reflect.Field: ...
            def receiver(self) -> typing.Any: ...
            def set(self, value: typing.Any) -> None: ...
            def symbol(self) -> scala.reflect.internal.Symbols.TermSymbol: ...
            def toString(self) -> str: ...
        class JavaInstanceMirror(scala.reflect.api.Mirrors.InstanceMirror, typing.Generic[_JavaMirrors__JavaMirror__JavaInstanceMirror__T]):
            $outer: 'JavaMirrors.JavaMirror' = ...
            def __init__(self, $outer: 'JavaMirrors.JavaMirror', instance: _JavaMirrors__JavaMirror__JavaInstanceMirror__T, evidence$4: scala.reflect.ClassTag[_JavaMirrors__JavaMirror__JavaInstanceMirror__T]): ...
            def instance(self) -> _JavaMirrors__JavaMirror__JavaInstanceMirror__T: ...
            def reflectClass(self, cls: scala.reflect.internal.Symbols.ClassSymbol) -> scala.reflect.api.Mirrors.ClassMirror: ...
            def reflectField(self, field: scala.reflect.internal.Symbols.TermSymbol) -> scala.reflect.api.Mirrors.FieldMirror: ...
            def reflectMethod(self, method: scala.reflect.internal.Symbols.MethodSymbol) -> scala.reflect.api.Mirrors.MethodMirror: ...
            def reflectModule(self, mod: scala.reflect.internal.Symbols.ModuleSymbol) -> scala.reflect.api.Mirrors.ModuleMirror: ...
            def symbol(self) -> scala.reflect.internal.Symbols.ClassSymbol: ...
            def toString(self) -> str: ...
        class JavaMethodMirror(scala.reflect.api.Mirrors.MethodMirror):
            $outer: 'JavaMirrors.JavaMirror' = ...
            def __init__(self, $outer: 'JavaMirrors.JavaMirror', symbol: scala.reflect.internal.Symbols.MethodSymbol, ret: 'JavaMirrors.JavaMirror.DerivedValueClassMetadata'): ...
            def jconstr(self) -> java.lang.reflect.Constructor[typing.Any]: ...
            def jinvoke(self, args: scala.collection.Seq[typing.Any]) -> typing.Any: ...
            def jinvokeraw(self, args: scala.collection.Seq[typing.Any]) -> typing.Any: ...
            def jmeth(self) -> java.lang.reflect.Method: ...
            def ret(self) -> 'JavaMirrors.JavaMirror.DerivedValueClassMetadata': ...
            def symbol(self) -> scala.reflect.internal.Symbols.MethodSymbol: ...
            def toString(self) -> str: ...
        class JavaModuleMirror(scala.reflect.runtime.JavaMirrors.JavaMirror.JavaTemplateMirror, scala.reflect.api.Mirrors.ModuleMirror):
            def __init__(self, $outer: 'JavaMirrors.JavaMirror', outer: typing.Any, symbol: scala.reflect.internal.Symbols.ModuleSymbol): ...
            def erasure(self) -> scala.reflect.internal.Symbols.ClassSymbol: ...
            def instance(self) -> typing.Any: ...
            def isStatic(self) -> bool: ...
            def outer(self) -> typing.Any: ...
            def symbol(self) -> scala.reflect.internal.Symbols.ModuleSymbol: ...
            def toString(self) -> str: ...
        class JavaTemplateMirror(scala.reflect.api.Mirrors.TemplateMirror):
            $outer: 'JavaMirrors.JavaMirror' = ...
            def __init__(self, $outer: 'JavaMirrors.JavaMirror'): ...
            def erasure(self) -> scala.reflect.internal.Symbols.ClassSymbol: ...
            def outer(self) -> typing.Any: ...
        class JavaTransformingMethodMirror(scala.reflect.runtime.JavaMirrors.JavaMirror.JavaMethodMirror):
            @typing.overload
            def __init__(self, $outer: 'JavaMirrors.JavaMirror', receiver: typing.Any, symbol: scala.reflect.internal.Symbols.MethodSymbol): ...
            @typing.overload
            def __init__(self, $outer: 'JavaMirrors.JavaMirror', receiver: typing.Any, symbol: scala.reflect.internal.Symbols.MethodSymbol, metadata: 'JavaMirrors.JavaMirror.MethodMetadata'): ...
            def apply(self, args: scala.collection.Seq[typing.Any]) -> typing.Any: ...
            def bind(self, newReceiver: typing.Any) -> 'JavaMirrors.JavaMirror.JavaTransformingMethodMirror': ...
            def receiver(self) -> typing.Any: ...
        class JavaVanillaMethodMirror(scala.reflect.runtime.JavaMirrors.JavaMirror.JavaMethodMirror):
            @typing.overload
            def __init__(self, $outer: 'JavaMirrors.JavaMirror', receiver: typing.Any, symbol: scala.reflect.internal.Symbols.MethodSymbol): ...
            @typing.overload
            def __init__(self, $outer: 'JavaMirrors.JavaMirror', receiver: typing.Any, symbol: scala.reflect.internal.Symbols.MethodSymbol, ret: 'JavaMirrors.JavaMirror.DerivedValueClassMetadata'): ...
            def apply(self, args: scala.collection.Seq[typing.Any]) -> typing.Any: ...
            def bind(self, newReceiver: typing.Any) -> 'JavaMirrors.JavaMirror.JavaVanillaMethodMirror': ...
            def receiver(self) -> typing.Any: ...
        class JavaVanillaMethodMirror0(scala.reflect.runtime.JavaMirrors.JavaMirror.JavaVanillaMethodMirror):
            @typing.overload
            def __init__(self, $outer: 'JavaMirrors.JavaMirror', receiver: typing.Any, symbol: scala.reflect.internal.Symbols.MethodSymbol): ...
            @typing.overload
            def __init__(self, $outer: 'JavaMirrors.JavaMirror', receiver: typing.Any, symbol: scala.reflect.internal.Symbols.MethodSymbol, ret: 'JavaMirrors.JavaMirror.DerivedValueClassMetadata'): ...
            def bind(self, newReceiver: typing.Any) -> 'JavaMirrors.JavaMirror.JavaVanillaMethodMirror0': ...
            def jinvokeraw(self, args: scala.collection.Seq[typing.Any]) -> typing.Any: ...
        class JavaVanillaMethodMirror1(scala.reflect.runtime.JavaMirrors.JavaMirror.JavaVanillaMethodMirror):
            @typing.overload
            def __init__(self, $outer: 'JavaMirrors.JavaMirror', receiver: typing.Any, symbol: scala.reflect.internal.Symbols.MethodSymbol): ...
            @typing.overload
            def __init__(self, $outer: 'JavaMirrors.JavaMirror', receiver: typing.Any, symbol: scala.reflect.internal.Symbols.MethodSymbol, ret: 'JavaMirrors.JavaMirror.DerivedValueClassMetadata'): ...
            def bind(self, newReceiver: typing.Any) -> 'JavaMirrors.JavaMirror.JavaVanillaMethodMirror1': ...
            def jinvokeraw(self, args: scala.collection.Seq[typing.Any]) -> typing.Any: ...
        class JavaVanillaMethodMirror2(scala.reflect.runtime.JavaMirrors.JavaMirror.JavaVanillaMethodMirror):
            @typing.overload
            def __init__(self, $outer: 'JavaMirrors.JavaMirror', receiver: typing.Any, symbol: scala.reflect.internal.Symbols.MethodSymbol): ...
            @typing.overload
            def __init__(self, $outer: 'JavaMirrors.JavaMirror', receiver: typing.Any, symbol: scala.reflect.internal.Symbols.MethodSymbol, ret: 'JavaMirrors.JavaMirror.DerivedValueClassMetadata'): ...
            def bind(self, newReceiver: typing.Any) -> 'JavaMirrors.JavaMirror.JavaVanillaMethodMirror2': ...
            def jinvokeraw(self, args: scala.collection.Seq[typing.Any]) -> typing.Any: ...
        class JavaVanillaMethodMirror3(scala.reflect.runtime.JavaMirrors.JavaMirror.JavaVanillaMethodMirror):
            @typing.overload
            def __init__(self, $outer: 'JavaMirrors.JavaMirror', receiver: typing.Any, symbol: scala.reflect.internal.Symbols.MethodSymbol): ...
            @typing.overload
            def __init__(self, $outer: 'JavaMirrors.JavaMirror', receiver: typing.Any, symbol: scala.reflect.internal.Symbols.MethodSymbol, ret: 'JavaMirrors.JavaMirror.DerivedValueClassMetadata'): ...
            def bind(self, newReceiver: typing.Any) -> 'JavaMirrors.JavaMirror.JavaVanillaMethodMirror3': ...
            def jinvokeraw(self, args: scala.collection.Seq[typing.Any]) -> typing.Any: ...
        class JavaVanillaMethodMirror4(scala.reflect.runtime.JavaMirrors.JavaMirror.JavaVanillaMethodMirror):
            @typing.overload
            def __init__(self, $outer: 'JavaMirrors.JavaMirror', receiver: typing.Any, symbol: scala.reflect.internal.Symbols.MethodSymbol): ...
            @typing.overload
            def __init__(self, $outer: 'JavaMirrors.JavaMirror', receiver: typing.Any, symbol: scala.reflect.internal.Symbols.MethodSymbol, ret: 'JavaMirrors.JavaMirror.DerivedValueClassMetadata'): ...
            def bind(self, newReceiver: typing.Any) -> 'JavaMirrors.JavaMirror.JavaVanillaMethodMirror4': ...
            def jinvokeraw(self, args: scala.collection.Seq[typing.Any]) -> typing.Any: ...
        class MethodMetadata:
            $outer: 'JavaMirrors.JavaMirror' = ...
            def __init__(self, $outer: 'JavaMirrors.JavaMirror', symbol: scala.reflect.internal.Symbols.MethodSymbol): ...
            def isByName(self) -> typing.List[bool]: ...
            def isDerivedValueClass(self, i: int) -> bool: ...
            def paramCount(self) -> int: ...
            def paramUnboxers(self, i: int) -> java.lang.reflect.Method: ...
            def ret(self) -> 'JavaMirrors.JavaMirror.DerivedValueClassMetadata': ...
        class RichClass:
            $outer: 'JavaMirrors.JavaMirror' = ...
            def __init__(self, $outer: 'JavaMirrors.JavaMirror', jclazz: typing.Type[typing.Any]): ...
            def isLocalClass0(self) -> bool: ...
        class TypeParamCompleter(scala.reflect.internal.Types.LazyType, scala.reflect.internal.Types.FlagAgnosticCompleter):
            $outer: 'JavaMirrors.JavaMirror' = ...
            def __init__(self, $outer: 'JavaMirrors.JavaMirror', jtvar: java.lang.reflect.TypeVariable[java.lang.reflect.GenericDeclaration]): ...
            def complete(self, sym: scala.reflect.internal.Symbols.Symbol) -> None: ...
            def load(self, sym: scala.reflect.internal.Symbols.Symbol) -> None: ...
        class jClassOps:
            $outer: 'JavaMirrors.JavaMirror' = ...
            def __init__(self, $outer: 'JavaMirrors.JavaMirror', clazz: typing.Type[typing.Any]): ...
            def clazz(self) -> typing.Type[typing.Any]: ...
            def javaFlags(self) -> int: ...
            def scalaFlags(self) -> int: ...
        class jMemberOps:
            $outer: 'JavaMirrors.JavaMirror' = ...
            def __init__(self, $outer: 'JavaMirrors.JavaMirror', member: java.lang.reflect.Member): ...
            def javaFlags(self) -> int: ...
            def member(self) -> java.lang.reflect.Member: ...
            def scalaFlags(self) -> int: ...
        class toAnnotArg$:
            def __init__(self, $outer: 'JavaMirrors.JavaMirror'): ...
            def AnnotationClass(self) -> 'JavaMirrors.JavaMirror.toAnnotArg.AnnotationClass.': ...
            def ArrayClass(self) -> 'JavaMirrors.JavaMirror.toAnnotArg.ArrayClass.': ...
            def ClassClass(self) -> typing.Type[typing.Type[typing.Any]]: ...
            def ConstantArg(self) -> 'JavaMirrors.JavaMirror.toAnnotArg.ConstantArg.': ...
            def EnumClass(self) -> 'JavaMirrors.JavaMirror.toAnnotArg.EnumClass.': ...
            def PrimitiveClass(self) -> 'JavaMirrors.JavaMirror.toAnnotArg.PrimitiveClass.': ...
            def StringClass(self) -> typing.Type[str]: ...
            def apply(self, schemaAndValue: scala.Tuple2[typing.Type[typing.Any], typing.Any]) -> scala.reflect.internal.AnnotationInfos.ClassfileAnnotArg: ...
            class AnnotationClass$:
                def __init__(self, $outer: 'JavaMirrors.JavaMirror.toAnnotArg.'): ...
                def unapply(self, x: typing.Type[typing.Any]) -> bool: ...
            class ArrayClass$:
                def __init__(self, $outer: 'JavaMirrors.JavaMirror.toAnnotArg.'): ...
                def unapply(self, x: typing.Type[typing.Any]) -> bool: ...
            class ConstantArg$:
                def __init__(self, $outer: 'JavaMirrors.JavaMirror.toAnnotArg.'): ...
                def enumToSymbol(self, enum: java.lang.Enum[typing.Any]) -> scala.reflect.internal.Symbols.Symbol: ...
                def unapply(self, schemaAndValue: scala.Tuple2[typing.Type[typing.Any], typing.Any]) -> scala.Option[typing.Any]: ...
            class EnumClass$:
                def __init__(self, $outer: 'JavaMirrors.JavaMirror.toAnnotArg.'): ...
                def unapply(self, x: typing.Type[typing.Any]) -> bool: ...
            class PrimitiveClass$:
                def __init__(self, $outer: 'JavaMirrors.JavaMirror.toAnnotArg.'): ...
                def unapply(self, x: typing.Type[typing.Any]) -> bool: ...
        class typeTagCache$(java.lang.ClassValue[scala.reflect.api.TypeTags.TypeTag[typing.Any]]):
            def __init__(self, $outer: 'JavaMirrors.JavaMirror'): ...
            def computeValue(self, cls: typing.Type[typing.Any]) -> scala.reflect.api.TypeTags.TypeTag[typing.Any]: ...
            def typeCreator(self) -> java.lang.ThreadLocal[scala.reflect.api.TypeCreator]: ...
        class unpickler$(scala.reflect.internal.pickling.UnPickler):
            def __init__(self, $outer: 'JavaMirrors.JavaMirror'): ...
            def symbolTable(self) -> 'SymbolTable': ...

class JavaUniverse(scala.reflect.internal.SymbolTable, JavaUniverseForce, ReflectSetup, scala.reflect.runtime.SymbolTable):
    def __init__(self): ...
    def MirrorTag(self) -> scala.reflect.ClassTag[JavaMirrors.JavaMirror]: ...
    def RuntimeClassTag(self) -> scala.reflect.ClassTag[typing.Type[typing.Any]]: ...
    def TreeCopierTag(self) -> scala.reflect.ClassTag[scala.reflect.internal.Trees.InternalTreeCopierOps]: ...
    def basetypeRecursions(self) -> int: ...
    def basetypeRecursions_$eq(self, value: int) -> None: ...
    def commonOwnerMap(self) -> scala.reflect.internal.tpe.CommonOwners.CommonOwnerMap: ...
    def connectModuleToClass(self, m: scala.reflect.internal.Symbols.ModuleSymbol, moduleClass: scala.reflect.internal.Symbols.ClassSymbol) -> scala.reflect.internal.Symbols.ModuleSymbol: ...
    def currentFreshNameCreator(self) -> scala.reflect.internal.util.FreshNameCreator: ...
    def currentRun(self) -> scala.reflect.internal.Reporting.RunReporting: ...
    def currentRunId(self) -> int: ...
    def debugInfo(self, msg: scala.Function0[str]) -> None: ...
    def defineBaseClassesOfCompoundType(self, tpe: scala.reflect.internal.Types.CompoundType) -> None: ...
    def defineBaseTypeSeqOfCompoundType(self, tpe: scala.reflect.internal.Types.CompoundType) -> None: ...
    def defineBaseTypeSeqOfTypeRef(self, tpe: scala.reflect.internal.Types.TypeRef) -> None: ...
    def defineParentsOfTypeRef(self, tpe: scala.reflect.internal.Types.TypeRef) -> None: ...
    def defineUnderlyingOfSingleType(self, tpe: scala.reflect.internal.Types.SingleType) -> None: ...
    def erasurePhase(self) -> scala.reflect.internal.SomePhase.: ...
    def force(self) -> None: ...
    _gilSynchronized__T = typing.TypeVar('_gilSynchronized__T')  # <T>
    def gilSynchronized(self, body: scala.Function0[_gilSynchronized__T]) -> _gilSynchronized__T: ...
    def glbResults(self) -> scala.collection.mutable.HashMap[scala.Tuple2[scala.reflect.internal.Depth, scala.collection.immutable.List[scala.reflect.internal.Types.Type]], scala.reflect.internal.Types.Type]: ...
    def indent(self) -> str: ...
    def indent_$eq(self, value: str) -> None: ...
    def info(self, msg: scala.Function0[str]) -> None: ...
    def init(self) -> None: ...
    def initAndEnterClassAndModule(self, owner: scala.reflect.internal.Symbols.Symbol, name: scala.reflect.internal.Names.TypeName, completer: scala.Function2[scala.reflect.internal.Symbols.ClassSymbol, scala.reflect.internal.Symbols.ModuleSymbol, scala.reflect.internal.Types.LazyType]) -> scala.Tuple2[scala.reflect.internal.Symbols.ClassSymbol, scala.reflect.internal.Symbols.ModuleSymbol]: ...
    def initClassAndModule(self, clazz: scala.reflect.internal.Symbols.Symbol, module: scala.reflect.internal.Symbols.Symbol, completer: scala.reflect.internal.Types.LazyType) -> None: ...
    def internal(self) -> scala.reflect.macros.Universe.MacroInternalApi: ...
    def intersectionWitness(self) -> scala.collection.mutable.WeakHashMap[scala.collection.immutable.List[scala.reflect.internal.Types.Type], scala.ref.WeakReference[scala.reflect.internal.Types.Type]]: ...
    def isCompilerUniverse(self) -> bool: ...
    def log(self, msg: scala.Function0[typing.Any]) -> None: ...
    def lubResults(self) -> scala.collection.mutable.HashMap[scala.Tuple2[scala.reflect.internal.Depth, scala.collection.immutable.List[scala.reflect.internal.Types.Type]], scala.reflect.internal.Types.Type]: ...
    def makeNoSymbol(self) -> scala.reflect.internal.Symbols.NoSymbol: ...
    def mirrorThatLoaded(self, sym: scala.reflect.internal.Symbols.Symbol) -> JavaMirrors.JavaMirror: ...
    def missingHook(self, owner: scala.reflect.internal.Symbols.Symbol, name: scala.reflect.internal.Names.Name) -> scala.reflect.internal.Symbols.Symbol: ...
    _mkThreadLocalStorage__T = typing.TypeVar('_mkThreadLocalStorage__T')  # <T>
    def mkThreadLocalStorage(self, x: scala.Function0[_mkThreadLocalStorage__T]) -> 'ThreadLocalStorage.ThreadLocalStorage'[_mkThreadLocalStorage__T]: ...
    def newBaseTypeSeq(self, parents: scala.collection.immutable.List[scala.reflect.internal.Types.Type], elems: typing.List[scala.reflect.internal.Types.Type]) -> scala.reflect.internal.BaseTypeSeqs.BaseTypeSeq: ...
    def newFreeTermSymbol(self, name: scala.reflect.internal.Names.TermName, value: scala.Function0[typing.Any], flags: int, origin: str) -> scala.reflect.internal.Symbols.FreeTermSymbol: ...
    def newFreeTermSymbol$default$3(self) -> int: ...
    def newFreeTermSymbol$default$4(self) -> str: ...
    def newFreeTypeSymbol(self, name: scala.reflect.internal.Names.TypeName, flags: int, origin: str) -> scala.reflect.internal.Symbols.FreeTypeSymbol: ...
    def newFreeTypeSymbol$default$2(self) -> int: ...
    def newFreeTypeSymbol$default$3(self) -> str: ...
    def newLazyTreeCopier(self) -> scala.reflect.internal.Trees.InternalTreeCopierOps: ...
    def newMappedBaseTypeSeq(self, orig: scala.reflect.internal.BaseTypeSeqs.BaseTypeSeq, f: scala.Function1[scala.reflect.internal.Types.Type, scala.reflect.internal.Types.Type]) -> scala.reflect.internal.BaseTypeSeqs.MappedBaseTypeSeq: ...
    def newPackageScope(self, pkgClass: scala.reflect.internal.Symbols.Symbol) -> 'SymbolLoaders.PackageScope': ...
    def newScope(self) -> 'SynchronizedOps.SynchronizedScope': ...
    def newStrictTreeCopier(self) -> scala.reflect.internal.Trees.InternalTreeCopierOps: ...
    def nextExistentialId(self) -> int: ...
    def nextId(self) -> int: ...
    def pendingBaseTypes(self) -> scala.collection.mutable.HashSet[scala.reflect.internal.Types.Type]: ...
    def pendingSubTypes(self) -> scala.collection.mutable.HashSet[scala.reflect.internal.tpe.TypeComparers.SubTypePair]: ...
    def phaseWithId(self) -> typing.List[scala.reflect.internal.Phase]: ...
    def picklerPhase(self) -> scala.reflect.internal.SomePhase.: ...
    def recursionTable(self) -> scala.collection.immutable.Map[scala.reflect.internal.Symbols.Symbol, typing.Any]: ...
    def recursionTable_$eq(self, value: scala.collection.immutable.Map[scala.reflect.internal.Symbols.Symbol, typing.Any]) -> None: ...
    def reporter(self) -> scala.reflect.internal.Reporter: ...
    def rootClassLoader(self) -> java.lang.ClassLoader: ...
    def rootMirror(self) -> JavaMirrors.JavaMirror: ...
    def runtimeMirror(self, cl: java.lang.ClassLoader) -> JavaMirrors.JavaMirror: ...
    def scala$reflect$api$JavaUniverse$_setter_$RuntimeClassTag_$eq(self, x$1: scala.reflect.ClassTag[typing.Type[typing.Any]]) -> None: ...
    def scala$reflect$runtime$Gil$$gil(self) -> java.util.concurrent.locks.ReentrantLock: ...
    def scala$reflect$runtime$JavaMirrors$$mirrors(self) -> scala.collection.mutable.WeakHashMap[java.lang.ClassLoader, scala.ref.WeakReference[JavaMirrors.JavaMirror]]: ...
    def scala$reflect$runtime$JavaMirrors$_setter_$MirrorTag_$eq(self, x$1: scala.reflect.ClassTag[JavaMirrors.JavaMirror]) -> None: ...
    def scala$reflect$runtime$ReflectSetup$_setter_$currentRunId_$eq(self, x$1: int) -> None: ...
    def scala$reflect$runtime$ReflectSetup$_setter_$phaseWithId_$eq(self, x$1: typing.List[scala.reflect.internal.Phase]) -> None: ...
    def scala$reflect$runtime$SynchronizedSymbols$$_recursionTable(self) -> 'ThreadLocalStorage.ThreadLocalStorage'[scala.collection.immutable.Map[scala.reflect.internal.Symbols.Symbol, typing.Any]]: ...
    def scala$reflect$runtime$SynchronizedSymbols$$atomicExistentialIds(self) -> java.util.concurrent.atomic.AtomicInteger: ...
    def scala$reflect$runtime$SynchronizedSymbols$$atomicIds(self) -> java.util.concurrent.atomic.AtomicInteger: ...
    def scala$reflect$runtime$SynchronizedTypes$$_basetypeRecursions(self) -> 'ThreadLocalStorage.ThreadLocalStorage'[typing.Any]: ...
    def scala$reflect$runtime$SynchronizedTypes$$_glbResults(self) -> 'ThreadLocalStorage.ThreadLocalStorage'[scala.collection.mutable.HashMap[scala.Tuple2[scala.reflect.internal.Depth, scala.collection.immutable.List[scala.reflect.internal.Types.Type]], scala.reflect.internal.Types.Type]]: ...
    def scala$reflect$runtime$SynchronizedTypes$$_indent(self) -> 'ThreadLocalStorage.ThreadLocalStorage'[str]: ...
    def scala$reflect$runtime$SynchronizedTypes$$_intersectionWitness(self) -> 'ThreadLocalStorage.ThreadLocalStorage'[scala.collection.mutable.WeakHashMap[scala.collection.immutable.List[scala.reflect.internal.Types.Type], scala.ref.WeakReference[scala.reflect.internal.Types.Type]]]: ...
    def scala$reflect$runtime$SynchronizedTypes$$_lubResults(self) -> 'ThreadLocalStorage.ThreadLocalStorage'[scala.collection.mutable.HashMap[scala.Tuple2[scala.reflect.internal.Depth, scala.collection.immutable.List[scala.reflect.internal.Types.Type]], scala.reflect.internal.Types.Type]]: ...
    def scala$reflect$runtime$SynchronizedTypes$$_pendingBaseTypes(self) -> 'ThreadLocalStorage.ThreadLocalStorage'[scala.collection.mutable.HashSet[scala.reflect.internal.Types.Type]]: ...
    def scala$reflect$runtime$SynchronizedTypes$$_pendingSubTypes(self) -> 'ThreadLocalStorage.ThreadLocalStorage'[scala.collection.mutable.HashSet[scala.reflect.internal.tpe.TypeComparers.SubTypePair]]: ...
    def scala$reflect$runtime$SynchronizedTypes$$_skolemizationLevel(self) -> 'ThreadLocalStorage.ThreadLocalStorage'[typing.Any]: ...
    def scala$reflect$runtime$SynchronizedTypes$$_subsametypeRecursions(self) -> 'ThreadLocalStorage.ThreadLocalStorage'[typing.Any]: ...
    def scala$reflect$runtime$SynchronizedTypes$$_toStringRecursions(self) -> 'ThreadLocalStorage.ThreadLocalStorage'[typing.Any]: ...
    def scala$reflect$runtime$SynchronizedTypes$$_toStringSubjects(self) -> 'ThreadLocalStorage.ThreadLocalStorage'[scala.collection.mutable.HashSet[scala.reflect.internal.Types.Type]]: ...
    def scala$reflect$runtime$SynchronizedTypes$$_undoLog(self) -> 'ThreadLocalStorage.ThreadLocalStorage'[scala.reflect.internal.tpe.TypeConstraints.UndoLog]: ...
    def scala$reflect$runtime$SynchronizedTypes$$uniqueLock(self) -> typing.Any: ...
    def scala$reflect$runtime$SynchronizedTypes$$uniques(self) -> scala.collection.mutable.WeakHashMap[scala.reflect.internal.Types.Type, java.lang.ref.WeakReference[scala.reflect.internal.Types.Type]]: ...
    def scala$reflect$runtime$SynchronizedTypes$_setter_$scala$reflect$runtime$SynchronizedTypes$$uniques_$eq(self, x$1: scala.collection.mutable.WeakHashMap[scala.reflect.internal.Types.Type, java.lang.ref.WeakReference[scala.reflect.internal.Types.Type]]) -> None: ...
    def scopeTransform(self, owner: scala.reflect.internal.Symbols.Symbol, op: scala.Function0[scala.reflect.internal.Scopes.Scope]) -> scala.reflect.internal.Scopes.Scope: ...
    def setAllInfos(self, clazz: scala.reflect.internal.Symbols.Symbol, module: scala.reflect.internal.Symbols.Symbol, info: scala.reflect.internal.Types.Type) -> None: ...
    def settings(self) -> 'Settings': ...
    def skolemizationLevel(self) -> int: ...
    def skolemizationLevel_$eq(self, value: int) -> None: ...
    def statistics(self) -> scala.reflect.internal.util.Statistics: ...
    def subsametypeRecursions(self) -> int: ...
    def subsametypeRecursions_$eq(self, value: int) -> None: ...
    def synchronizeNames(self) -> bool: ...
    def toStringRecursions(self) -> int: ...
    def toStringRecursions_$eq(self, value: int) -> None: ...
    def toStringSubjects(self) -> scala.collection.mutable.HashSet[scala.reflect.internal.Types.Type]: ...
    def treeInfo(self) -> 'JavaUniverse.treeInfo.': ...
    def undoLog(self) -> scala.reflect.internal.tpe.TypeConstraints.UndoLog: ...
    _unique__T = typing.TypeVar('_unique__T', bound=scala.reflect.internal.Types.Type)  # <T>
    def unique(self, tp: _unique__T) -> _unique__T: ...
    def validateClassInfo(self, tp: scala.reflect.internal.Types.ClassInfoType) -> None: ...
    class PerRunReporting(scala.reflect.internal.Reporting.PerRunReportingBase):
        def __init__(self, $outer: 'JavaUniverse'): ...
        def deprecationWarning(self, pos: scala.reflect.internal.util.Position, msg: str, since: str) -> None: ...
    class treeInfo$(scala.reflect.internal.TreeInfo):
        def __init__(self, $outer: 'JavaUniverse'): ...

_ReflectionUtils__EnclosedIn__T = typing.TypeVar('_ReflectionUtils__EnclosedIn__T')  # <T>
class ReflectionUtils:
    @staticmethod
    def associatedFile(clazz: typing.Type[typing.Any]) -> scala.reflect.io.AbstractFile: ...
    @staticmethod
    def innerSingletonInstance(outer: typing.Any, className: str) -> typing.Any: ...
    @staticmethod
    def show(cl: java.lang.ClassLoader) -> str: ...
    @typing.overload
    @staticmethod
    def staticSingletonInstance(clazz: typing.Type[typing.Any]) -> typing.Any: ...
    @typing.overload
    @staticmethod
    def staticSingletonInstance(cl: java.lang.ClassLoader, className: str) -> typing.Any: ...
    _unwrapHandler__T = typing.TypeVar('_unwrapHandler__T')  # <T>
    @staticmethod
    def unwrapHandler(pf: scala.PartialFunction[java.lang.Throwable, _unwrapHandler__T]) -> scala.PartialFunction[java.lang.Throwable, _unwrapHandler__T]: ...
    @staticmethod
    def unwrapThrowable(x: java.lang.Throwable) -> java.lang.Throwable: ...
    class EnclosedIn(typing.Generic[_ReflectionUtils__EnclosedIn__T]):
        def __init__(self, enclosure: scala.Function1[typing.Type[typing.Any], _ReflectionUtils__EnclosedIn__T]): ...
        def unapply(self, jclazz: typing.Type[typing.Any]) -> scala.Option[_ReflectionUtils__EnclosedIn__T]: ...
    class EnclosedInClass$(scala.reflect.runtime.ReflectionUtils.EnclosedIn[typing.Type[typing.Any]]):
        MODULE$: typing.ClassVar['ReflectionUtils.EnclosedInClass.'] = ...
        def __init__(self): ...
    class EnclosedInConstructor$(scala.reflect.runtime.ReflectionUtils.EnclosedIn[java.lang.reflect.Constructor[typing.Any]]):
        MODULE$: typing.ClassVar['ReflectionUtils.EnclosedInConstructor.'] = ...
        def __init__(self): ...
    class EnclosedInMethod$(scala.reflect.runtime.ReflectionUtils.EnclosedIn[java.lang.reflect.Method]):
        MODULE$: typing.ClassVar['ReflectionUtils.EnclosedInMethod.'] = ...
        def __init__(self): ...
    class EnclosedInPackage$(scala.reflect.runtime.ReflectionUtils.EnclosedIn[java.lang.Package]):
        MODULE$: typing.ClassVar['ReflectionUtils.EnclosedInPackage.'] = ...
        def __init__(self): ...
    class PrimitiveOrArray$:
        MODULE$: typing.ClassVar['ReflectionUtils.PrimitiveOrArray.'] = ...
        def __init__(self): ...
        def unapply(self, jclazz: typing.Type[typing.Any]) -> bool: ...

class Settings(scala.reflect.internal.settings.MutableSettings):
    def __init__(self): ...
    def Xexperimental(self) -> 'Settings.BooleanSetting': ...
    def XfullLubs(self) -> 'Settings.BooleanSetting': ...
    def XnoPatmatAnalysis(self) -> 'Settings.BooleanSetting': ...
    def Xprintpos(self) -> 'Settings.BooleanSetting': ...
    def YpartialUnification(self) -> 'Settings.BooleanSetting': ...
    def Yposdebug(self) -> 'Settings.BooleanSetting': ...
    def Yrangepos(self) -> 'Settings.BooleanSetting': ...
    def Yrecursion(self) -> 'Settings.IntSetting': ...
    def Yshowsymkinds(self) -> 'Settings.BooleanSetting': ...
    def Yshowsymowners(self) -> 'Settings.BooleanSetting': ...
    def Yvirtpatmat(self) -> 'Settings.BooleanSetting': ...
    def breakCycles(self) -> 'Settings.BooleanSetting': ...
    def debug(self) -> 'Settings.BooleanSetting': ...
    def developer(self) -> 'Settings.BooleanSetting': ...
    def explaintypes(self) -> 'Settings.BooleanSetting': ...
    def isScala211(self) -> bool: ...
    def isScala212(self) -> bool: ...
    def isScala213(self) -> bool: ...
    def maxClassfileName(self) -> 'Settings.IntSetting': ...
    def overrideObjects(self) -> 'Settings.BooleanSetting': ...
    def printtypes(self) -> 'Settings.BooleanSetting': ...
    def strictInference(self) -> 'Settings.BooleanSetting': ...
    def uniqid(self) -> 'Settings.BooleanSetting': ...
    def verbose(self) -> 'Settings.BooleanSetting': ...
    class BooleanSetting(scala.reflect.runtime.Settings.Setting):
        $outer: 'Settings' = ...
        def __init__(self, $outer: 'Settings', x: bool): ...
        def isDefault(self) -> bool: ...
        def isSetByUser(self) -> bool: ...
        def postSetHook(self) -> None: ...
        def setByUser(self) -> bool: ...
        def setByUser_$eq(self, x$1: bool) -> None: ...
        def v(self) -> bool: ...
        def v_$eq(self, x$1: bool) -> None: ...
        def value(self) -> bool: ...
        def valueSetByUser(self) -> scala.Option[typing.Any]: ...
        def value_$eq(self, arg: typing.Any) -> None: ...
    class IntSetting(scala.reflect.runtime.Settings.Setting):
        $outer: 'Settings' = ...
        def __init__(self, $outer: 'Settings', x: int): ...
        def isDefault(self) -> bool: ...
        def isSetByUser(self) -> bool: ...
        def postSetHook(self) -> None: ...
        def setByUser(self) -> bool: ...
        def setByUser_$eq(self, x$1: bool) -> None: ...
        def v(self) -> int: ...
        def v_$eq(self, x$1: int) -> None: ...
        def value(self) -> int: ...
        def valueSetByUser(self) -> scala.Option[typing.Any]: ...
        def value_$eq(self, arg: typing.Any) -> None: ...
    class MultiStringSetting(scala.reflect.runtime.Settings.Setting):
        $outer: 'Settings' = ...
        def __init__(self, $outer: 'Settings', xs: scala.collection.immutable.List[str]): ...
        def isDefault(self) -> bool: ...
        def isSetByUser(self) -> bool: ...
        def postSetHook(self) -> None: ...
        def setByUser(self) -> bool: ...
        def setByUser_$eq(self, x$1: bool) -> None: ...
        def v(self) -> scala.collection.immutable.List[str]: ...
        def v_$eq(self, x$1: scala.collection.immutable.List[str]) -> None: ...
        def value(self) -> scala.collection.immutable.List[str]: ...
        def valueSetByUser(self) -> scala.Option[typing.Any]: ...
        def value_$eq(self, arg: typing.Any) -> None: ...
    class Setting(scala.reflect.internal.settings.MutableSettings.SettingValue): ...

class SymbolLoaders:
    @staticmethod
    def $init$($this: 'SymbolLoaders') -> None: ...
    def initAndEnterClassAndModule(self, owner: scala.reflect.internal.Symbols.Symbol, name: scala.reflect.internal.Names.TypeName, completer: scala.Function2[scala.reflect.internal.Symbols.ClassSymbol, scala.reflect.internal.Symbols.ModuleSymbol, scala.reflect.internal.Types.LazyType]) -> scala.Tuple2[scala.reflect.internal.Symbols.ClassSymbol, scala.reflect.internal.Symbols.ModuleSymbol]: ...
    def initClassAndModule(self, clazz: scala.reflect.internal.Symbols.Symbol, module: scala.reflect.internal.Symbols.Symbol, completer: scala.reflect.internal.Types.LazyType) -> None: ...
    def newPackageScope(self, pkgClass: scala.reflect.internal.Symbols.Symbol) -> 'SymbolLoaders.PackageScope': ...
    def scopeTransform(self, owner: scala.reflect.internal.Symbols.Symbol, op: scala.Function0[scala.reflect.internal.Scopes.Scope]) -> scala.reflect.internal.Scopes.Scope: ...
    def setAllInfos(self, clazz: scala.reflect.internal.Symbols.Symbol, module: scala.reflect.internal.Symbols.Symbol, info: scala.reflect.internal.Types.Type) -> None: ...
    def validateClassInfo(self, tp: scala.reflect.internal.Types.ClassInfoType) -> None: ...
    class LazyPackageType(scala.reflect.internal.Types.LazyType, scala.reflect.internal.Types.FlagAgnosticCompleter):
        $outer: 'SymbolTable' = ...
        def __init__(self, $outer: 'SymbolTable'): ...
        def complete(self, sym: scala.reflect.internal.Symbols.Symbol) -> None: ...
    class PackageScope(scala.reflect.internal.Scopes.Scope, scala.reflect.runtime.SynchronizedOps.SynchronizedScope):
        $outer: 'SymbolTable' = ...
        def __init__(self, $outer: 'SymbolTable', pkgClass: scala.reflect.internal.Symbols.Symbol): ...
        _enter__T = typing.TypeVar('_enter__T', bound=scala.reflect.internal.Symbols.Symbol)  # <T>
        def enter(self, sym: _enter__T) -> _enter__T: ...
        _enterIfNew__T = typing.TypeVar('_enterIfNew__T', bound=scala.reflect.internal.Symbols.Symbol)  # <T>
        def enterIfNew(self, sym: _enterIfNew__T) -> _enterIfNew__T: ...
        def isEmpty(self) -> bool: ...
        def lookupAll(self, name: scala.reflect.internal.Names.Name) -> scala.collection.Iterator[scala.reflect.internal.Symbols.Symbol]: ...
        def lookupEntry(self, name: scala.reflect.internal.Names.Name) -> scala.reflect.internal.Scopes.ScopeEntry: ...
        def lookupNextEntry(self, entry: scala.reflect.internal.Scopes.ScopeEntry) -> scala.reflect.internal.Scopes.ScopeEntry: ...
        def rehash(self, sym: scala.reflect.internal.Symbols.Symbol, newname: scala.reflect.internal.Names.Name) -> None: ...
        def scala$reflect$runtime$SynchronizedOps$SynchronizedScope$$syncLock(self) -> typing.Any: ...
        def size(self) -> int: ...
        _syncLockSynchronized__T = typing.TypeVar('_syncLockSynchronized__T')  # <T>
        def syncLockSynchronized(self, body: scala.Function0[_syncLockSynchronized__T]) -> _syncLockSynchronized__T: ...
        def toList(self) -> scala.collection.immutable.List[scala.reflect.internal.Symbols.Symbol]: ...
        @typing.overload
        def unlink(self, e: scala.reflect.internal.Scopes.ScopeEntry) -> None: ...
        @typing.overload
        def unlink(self, sym: scala.reflect.internal.Symbols.Symbol) -> None: ...
    class TopClassCompleter(scala.reflect.internal.SymbolTable.SymLoader, scala.reflect.internal.Types.FlagAssigningCompleter):
        $outer: 'SymbolTable' = ...
        def __init__(self, $outer: 'SymbolTable', clazz: scala.reflect.internal.Symbols.ClassSymbol, module: scala.reflect.internal.Symbols.ModuleSymbol): ...
        def complete(self, sym: scala.reflect.internal.Symbols.Symbol) -> None: ...
        def load(self, sym: scala.reflect.internal.Symbols.Symbol) -> None: ...

class SymbolTable(JavaMirrors, SymbolLoaders, scala.reflect.runtime.SynchronizedOps, Gil, scala.reflect.runtime.ThreadLocalStorage):
    @staticmethod
    def $init$($this: 'SymbolTable') -> None: ...
    def debugInfo(self, msg: scala.Function0[str]) -> None: ...
    def info(self, msg: scala.Function0[str]) -> None: ...
    def isCompilerUniverse(self) -> bool: ...

class SynchronizedOps(scala.reflect.runtime.SynchronizedSymbols, SynchronizedTypes):
    @staticmethod
    def $init$($this: 'SynchronizedOps') -> None: ...
    def newBaseTypeSeq(self, parents: scala.collection.immutable.List[scala.reflect.internal.Types.Type], elems: typing.List[scala.reflect.internal.Types.Type]) -> scala.reflect.internal.BaseTypeSeqs.BaseTypeSeq: ...
    def newMappedBaseTypeSeq(self, orig: scala.reflect.internal.BaseTypeSeqs.BaseTypeSeq, f: scala.Function1[scala.reflect.internal.Types.Type, scala.reflect.internal.Types.Type]) -> scala.reflect.internal.BaseTypeSeqs.MappedBaseTypeSeq: ...
    def newScope(self) -> 'SynchronizedOps.SynchronizedScope': ...
    def synchronizeNames(self) -> bool: ...
    class SynchronizedBaseTypeSeq:
        @staticmethod
        def $init$($this: 'SynchronizedOps.SynchronizedBaseTypeSeq') -> None: ...
        def apply(self, i: int) -> scala.reflect.internal.Types.Type: ...
        def copy(self, head: scala.reflect.internal.Types.Type, offset: int) -> scala.reflect.internal.BaseTypeSeqs.BaseTypeSeq: ...
        def exists(self, p: scala.Function1[scala.reflect.internal.Types.Type, typing.Any]) -> bool: ...
        def map(self, f: scala.Function1[scala.reflect.internal.Types.Type, scala.reflect.internal.Types.Type]) -> scala.reflect.internal.BaseTypeSeqs.BaseTypeSeq: ...
        def maxDepth(self) -> int: ...
        def rawElem(self, i: int) -> scala.reflect.internal.Types.Type: ...
        def toList(self) -> scala.collection.immutable.List[scala.reflect.internal.Types.Type]: ...
        def toString(self) -> str: ...
        def typeSymbol(self, i: int) -> scala.reflect.internal.Symbols.Symbol: ...
    class SynchronizedScope:
        @staticmethod
        def $init$($this: 'SynchronizedOps.SynchronizedScope') -> None: ...
        _enter__T = typing.TypeVar('_enter__T', bound=scala.reflect.internal.Symbols.Symbol)  # <T>
        def enter(self, sym: _enter__T) -> _enter__T: ...
        def isEmpty(self) -> bool: ...
        def lookupAll(self, name: scala.reflect.internal.Names.Name) -> scala.collection.Iterator[scala.reflect.internal.Symbols.Symbol]: ...
        def lookupEntry(self, name: scala.reflect.internal.Names.Name) -> scala.reflect.internal.Scopes.ScopeEntry: ...
        def lookupNextEntry(self, entry: scala.reflect.internal.Scopes.ScopeEntry) -> scala.reflect.internal.Scopes.ScopeEntry: ...
        def rehash(self, sym: scala.reflect.internal.Symbols.Symbol, newname: scala.reflect.internal.Names.Name) -> None: ...
        def scala$reflect$runtime$SynchronizedOps$SynchronizedScope$$syncLock(self) -> typing.Any: ...
        def size(self) -> int: ...
        _syncLockSynchronized__T = typing.TypeVar('_syncLockSynchronized__T')  # <T>
        def syncLockSynchronized(self, body: scala.Function0[_syncLockSynchronized__T]) -> _syncLockSynchronized__T: ...
        def toList(self) -> scala.collection.immutable.List[scala.reflect.internal.Symbols.Symbol]: ...
        @typing.overload
        def unlink(self, e: scala.reflect.internal.Scopes.ScopeEntry) -> None: ...
        @typing.overload
        def unlink(self, sym: scala.reflect.internal.Symbols.Symbol) -> None: ...

class SynchronizedSymbols(scala.reflect.internal.Symbols):
    @staticmethod
    def $init$($this: 'SynchronizedSymbols') -> None: ...
    def connectModuleToClass(self, m: scala.reflect.internal.Symbols.ModuleSymbol, moduleClass: scala.reflect.internal.Symbols.ClassSymbol) -> scala.reflect.internal.Symbols.ModuleSymbol: ...
    def makeNoSymbol(self) -> scala.reflect.internal.Symbols.NoSymbol: ...
    def newFreeTermSymbol(self, name: scala.reflect.internal.Names.TermName, value: scala.Function0[typing.Any], flags: int, origin: str) -> scala.reflect.internal.Symbols.FreeTermSymbol: ...
    def newFreeTermSymbol$default$3(self) -> int: ...
    def newFreeTermSymbol$default$4(self) -> str: ...
    def newFreeTypeSymbol(self, name: scala.reflect.internal.Names.TypeName, flags: int, origin: str) -> scala.reflect.internal.Symbols.FreeTypeSymbol: ...
    def newFreeTypeSymbol$default$2(self) -> int: ...
    def newFreeTypeSymbol$default$3(self) -> str: ...
    def nextExistentialId(self) -> int: ...
    def nextId(self) -> int: ...
    def recursionTable(self) -> scala.collection.immutable.Map[scala.reflect.internal.Symbols.Symbol, typing.Any]: ...
    def recursionTable_$eq(self, value: scala.collection.immutable.Map[scala.reflect.internal.Symbols.Symbol, typing.Any]) -> None: ...
    def scala$reflect$runtime$SynchronizedSymbols$$_recursionTable(self) -> 'ThreadLocalStorage.ThreadLocalStorage'[scala.collection.immutable.Map[scala.reflect.internal.Symbols.Symbol, typing.Any]]: ...
    def scala$reflect$runtime$SynchronizedSymbols$$atomicExistentialIds(self) -> java.util.concurrent.atomic.AtomicInteger: ...
    def scala$reflect$runtime$SynchronizedSymbols$$atomicIds(self) -> java.util.concurrent.atomic.AtomicInteger: ...
    class SynchronizedClassSymbol(scala.reflect.runtime.SynchronizedSymbols.SynchronizedTypeSymbol): ...
    class SynchronizedMethodSymbol(scala.reflect.runtime.SynchronizedSymbols.SynchronizedTermSymbol): ...
    class SynchronizedModuleClassSymbol(scala.reflect.runtime.SynchronizedSymbols.SynchronizedClassSymbol): ...
    class SynchronizedModuleSymbol(scala.reflect.runtime.SynchronizedSymbols.SynchronizedTermSymbol): ...
    class SynchronizedSymbol:
        @staticmethod
        def $init$($this: 'SynchronizedSymbols.SynchronizedSymbol') -> None: ...
        def annotations(self) -> scala.collection.immutable.List[scala.reflect.internal.AnnotationInfos.AnnotationInfo]: ...
        def createAbstractTypeSymbol(self, name: scala.reflect.internal.Names.TypeName, pos: scala.reflect.internal.util.Position, newFlags: int) -> scala.reflect.internal.Symbols.AbstractTypeSymbol: ...
        def createAliasTypeSymbol(self, name: scala.reflect.internal.Names.TypeName, pos: scala.reflect.internal.util.Position, newFlags: int) -> scala.reflect.internal.Symbols.AliasTypeSymbol: ...
        def createClassSymbol(self, name: scala.reflect.internal.Names.TypeName, pos: scala.reflect.internal.util.Position, newFlags: int) -> scala.reflect.internal.Symbols.ClassSymbol: ...
        def createMethodSymbol(self, name: scala.reflect.internal.Names.TermName, pos: scala.reflect.internal.util.Position, newFlags: int) -> scala.reflect.internal.Symbols.MethodSymbol: ...
        def createModuleClassSymbol(self, name: scala.reflect.internal.Names.TypeName, pos: scala.reflect.internal.util.Position, newFlags: int) -> scala.reflect.internal.Symbols.ModuleClassSymbol: ...
        def createModuleSymbol(self, name: scala.reflect.internal.Names.TermName, pos: scala.reflect.internal.util.Position, newFlags: int) -> scala.reflect.internal.Symbols.ModuleSymbol: ...
        def createPackageClassSymbol(self, name: scala.reflect.internal.Names.TypeName, pos: scala.reflect.internal.util.Position, newFlags: int) -> scala.reflect.internal.Symbols.PackageClassSymbol: ...
        def createPackageObjectClassSymbol(self, pos: scala.reflect.internal.util.Position, newFlags: int) -> scala.reflect.internal.Symbols.PackageObjectClassSymbol: ...
        def createPackageSymbol(self, name: scala.reflect.internal.Names.TermName, pos: scala.reflect.internal.util.Position, newFlags: int) -> scala.reflect.internal.Symbols.ModuleSymbol: ...
        def createRefinementClassSymbol(self, pos: scala.reflect.internal.util.Position, newFlags: int) -> scala.reflect.internal.Symbols.RefinementClassSymbol: ...
        def createTypeSkolemSymbol(self, name: scala.reflect.internal.Names.TypeName, origin: typing.Any, pos: scala.reflect.internal.util.Position, newFlags: int) -> scala.reflect.internal.Symbols.TypeSkolem: ...
        def createValueMemberSymbol(self, name: scala.reflect.internal.Names.TermName, pos: scala.reflect.internal.util.Position, newFlags: int) -> scala.reflect.internal.Symbols.TermSymbol: ...
        def createValueParameterSymbol(self, name: scala.reflect.internal.Names.TermName, pos: scala.reflect.internal.util.Position, newFlags: int) -> scala.reflect.internal.Symbols.TermSymbol: ...
        def exists(self) -> bool: ...
        def getFlag(self, mask: int) -> int: ...
        _gilSynchronizedIfNotThreadsafe__T = typing.TypeVar('_gilSynchronizedIfNotThreadsafe__T')  # <T>
        def gilSynchronizedIfNotThreadsafe(self, body: scala.Function0[_gilSynchronizedIfNotThreadsafe__T]) -> _gilSynchronizedIfNotThreadsafe__T: ...
        def info(self) -> scala.reflect.internal.Types.Type: ...
        def isThreadsafe(self, purpose: scala.reflect.internal.Symbols.SymbolOps) -> bool: ...
        def markAllCompleted(self) -> 'SynchronizedSymbols.SynchronizedSymbol': ...
        def markFlagsCompleted(self, mask: int) -> 'SynchronizedSymbols.SynchronizedSymbol': ...
        def privateWithin(self) -> scala.reflect.internal.Symbols.Symbol: ...
        def rawInfo(self) -> scala.reflect.internal.Types.Type: ...
        def scala$reflect$runtime$SynchronizedSymbols$SynchronizedSymbol$$_initializationMask(self) -> int: ...
        def scala$reflect$runtime$SynchronizedSymbols$SynchronizedSymbol$$_initializationMask_$eq(self, x$1: int) -> None: ...
        def scala$reflect$runtime$SynchronizedSymbols$SynchronizedSymbol$$_initialized(self) -> bool: ...
        def scala$reflect$runtime$SynchronizedSymbols$SynchronizedSymbol$$_initialized_$eq(self, x$1: bool) -> None: ...
        def typeConstructor(self) -> scala.reflect.internal.Types.Type: ...
        def typeParams(self) -> scala.collection.immutable.List[scala.reflect.internal.Symbols.Symbol]: ...
        def typeSignature(self) -> scala.reflect.internal.Types.Type: ...
        def typeSignatureIn(self, site: scala.reflect.internal.Types.Type) -> scala.reflect.internal.Types.Type: ...
        def unsafeTypeParams(self) -> scala.collection.immutable.List[scala.reflect.internal.Symbols.Symbol]: ...
        def validTo(self) -> int: ...
    class SynchronizedTermSymbol(scala.reflect.runtime.SynchronizedSymbols.SynchronizedSymbol): ...
    class SynchronizedTypeSymbol(scala.reflect.runtime.SynchronizedSymbols.SynchronizedSymbol):
        @staticmethod
        def $init$($this: 'SynchronizedSymbols.SynchronizedTypeSymbol') -> None: ...
        def scala$reflect$runtime$SynchronizedSymbols$SynchronizedTypeSymbol$$tpeLock(self) -> typing.Any: ...
        def tpe_$times(self) -> scala.reflect.internal.Types.Type: ...

_ThreadLocalStorage__MyThreadLocalStorage__T = typing.TypeVar('_ThreadLocalStorage__MyThreadLocalStorage__T')  # <T>
_ThreadLocalStorage__ThreadLocalStorage__T = typing.TypeVar('_ThreadLocalStorage__ThreadLocalStorage__T')  # <T>
class ThreadLocalStorage:
    @staticmethod
    def $init$($this: 'ThreadLocalStorage') -> None: ...
    _mkThreadLocalStorage__T = typing.TypeVar('_mkThreadLocalStorage__T')  # <T>
    def mkThreadLocalStorage(self, x: scala.Function0[_mkThreadLocalStorage__T]) -> 'ThreadLocalStorage.ThreadLocalStorage'[_mkThreadLocalStorage__T]: ...
    class MyThreadLocalStorage(scala.reflect.runtime.ThreadLocalStorage.ThreadLocalStorage[_ThreadLocalStorage__MyThreadLocalStorage__T], typing.Generic[_ThreadLocalStorage__MyThreadLocalStorage__T]):
        $outer: SymbolTable = ...
        def __init__(self, $outer: SymbolTable, initialValue: scala.Function0[_ThreadLocalStorage__MyThreadLocalStorage__T]): ...
        def get(self) -> _ThreadLocalStorage__MyThreadLocalStorage__T: ...
        def set(self, newValue: _ThreadLocalStorage__MyThreadLocalStorage__T) -> None: ...
    class ThreadLocalStorage(typing.Generic[_ThreadLocalStorage__ThreadLocalStorage__T]):
        def get(self) -> _ThreadLocalStorage__ThreadLocalStorage__T: ...
        def set(self, newValue: _ThreadLocalStorage__ThreadLocalStorage__T) -> None: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("scala.reflect.runtime")``.

    Gil: typing.Type[Gil]
    HasJavaClass: typing.Type[HasJavaClass]
    JavaMirrors: typing.Type[JavaMirrors]
    JavaUniverse: typing.Type[JavaUniverse]
    JavaUniverseForce: typing.Type[JavaUniverseForce]
    Macros: typing.Type[Macros]
    ReflectError: typing.Type[ReflectError]
    ReflectSetup: typing.Type[ReflectSetup]
    ReflectionUtils: typing.Type[ReflectionUtils]
    Settings: typing.Type[Settings]
    SymbolLoaders: typing.Type[SymbolLoaders]
    SymbolTable: typing.Type[SymbolTable]
    SynchronizedOps: typing.Type[SynchronizedOps]
    SynchronizedSymbols: typing.Type[SynchronizedSymbols]
    SynchronizedTypes: typing.Type[SynchronizedTypes]
    ThreadLocalStorage: typing.Type[ThreadLocalStorage]
    TwoWayCache: typing.Type[TwoWayCache]
    TwoWayCaches: typing.Type[TwoWayCaches]
    package: typing.Type[package]
