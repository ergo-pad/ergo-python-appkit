import java.lang
import scala
import scala.collection
import scala.reflect
import scala.runtime
import scala.util
import typing



_Breaks__TryBlock__T = typing.TypeVar('_Breaks__TryBlock__T')  # <T>
class Breaks:
    def __init__(self): ...
    def breakable(self, op: scala.Function0[scala.runtime.BoxedUnit]) -> None: ...
    def scala$util$control$Breaks$$breakException(self) -> 'BreakControl': ...
    _tryBreakable__T = typing.TypeVar('_tryBreakable__T')  # <T>
    def tryBreakable(self, op: scala.Function0[_tryBreakable__T]) -> 'Breaks.TryBlock'[_tryBreakable__T]: ...
    class TryBlock(typing.Generic[_Breaks__TryBlock__T]):
        def catchBreak(self, onBreak: scala.Function0[_Breaks__TryBlock__T]) -> _Breaks__TryBlock__T: ...

class NoStackTrace:
    @staticmethod
    def $init$($this: 'NoStackTrace') -> None: ...
    def fillInStackTrace(self) -> java.lang.Throwable: ...
    @staticmethod
    def noSuppression() -> bool: ...

class NonFatal:
    @staticmethod
    def apply(t: java.lang.Throwable) -> bool: ...
    @staticmethod
    def unapply(t: java.lang.Throwable) -> scala.Option[java.lang.Throwable]: ...

class ControlThrowable(NoStackTrace): ...

class BreakControl(java.lang.Throwable, ControlThrowable):
    def __init__(self): ...
    def fillInStackTrace(self) -> java.lang.Throwable: ...

_Exception__By__T = typing.TypeVar('_Exception__By__T')  # <T>
_Exception__By__R = typing.TypeVar('_Exception__By__R')  # <R>
_Exception__Catch__T = typing.TypeVar('_Exception__Catch__T')  # <T>
class Exception:
    _allCatch__T = typing.TypeVar('_allCatch__T')  # <T>
    @staticmethod
    def allCatch() -> 'Exception.Catch'[_allCatch__T]: ...
    _allCatcher__T = typing.TypeVar('_allCatcher__T')  # <T>
    @staticmethod
    def allCatcher() -> scala.PartialFunction[java.lang.Throwable, _allCatcher__T]: ...
    _catching_0__T = typing.TypeVar('_catching_0__T')  # <T>
    _catching_1__T = typing.TypeVar('_catching_1__T')  # <T>
    @typing.overload
    @staticmethod
    def catching(c: scala.PartialFunction[java.lang.Throwable, _catching_0__T]) -> 'Exception.Catch'[_catching_0__T]: ...
    @typing.overload
    @staticmethod
    def catching(exceptions: scala.collection.Seq[typing.Type[typing.Any]]) -> 'Exception.Catch'[_catching_1__T]: ...
    _catchingPromiscuously_0__T = typing.TypeVar('_catchingPromiscuously_0__T')  # <T>
    _catchingPromiscuously_1__T = typing.TypeVar('_catchingPromiscuously_1__T')  # <T>
    @typing.overload
    @staticmethod
    def catchingPromiscuously(c: scala.PartialFunction[java.lang.Throwable, _catchingPromiscuously_0__T]) -> 'Exception.Catch'[_catchingPromiscuously_0__T]: ...
    @typing.overload
    @staticmethod
    def catchingPromiscuously(exceptions: scala.collection.Seq[typing.Type[typing.Any]]) -> 'Exception.Catch'[_catchingPromiscuously_1__T]: ...
    _failAsValue__T = typing.TypeVar('_failAsValue__T')  # <T>
    @staticmethod
    def failAsValue(exceptions: scala.collection.Seq[typing.Type[typing.Any]], value: scala.Function0[_failAsValue__T]) -> 'Exception.Catch'[_failAsValue__T]: ...
    _failing__T = typing.TypeVar('_failing__T')  # <T>
    @staticmethod
    def failing(exceptions: scala.collection.Seq[typing.Type[typing.Any]]) -> 'Exception.Catch'[scala.Option[_failing__T]]: ...
    _handling__T = typing.TypeVar('_handling__T')  # <T>
    @staticmethod
    def handling(exceptions: scala.collection.Seq[typing.Type[typing.Any]]) -> 'Exception.By'[scala.Function1[java.lang.Throwable, _handling__T], 'Exception.Catch'[_handling__T]]: ...
    @staticmethod
    def ignoring(exceptions: scala.collection.Seq[typing.Type[typing.Any]]) -> 'Exception.Catch'[scala.runtime.BoxedUnit]: ...
    _mkCatcher__Ex = typing.TypeVar('_mkCatcher__Ex', bound=java.lang.Throwable)  # <Ex>
    _mkCatcher__T = typing.TypeVar('_mkCatcher__T')  # <T>
    @staticmethod
    def mkCatcher(isDef: scala.Function1[_mkCatcher__Ex, typing.Any], f: scala.Function1[_mkCatcher__Ex, _mkCatcher__T], evidence$1: scala.reflect.ClassTag[_mkCatcher__Ex]) -> scala.PartialFunction[java.lang.Throwable, _mkCatcher__T]: ...
    _mkThrowableCatcher__T = typing.TypeVar('_mkThrowableCatcher__T')  # <T>
    @staticmethod
    def mkThrowableCatcher(isDef: scala.Function1[java.lang.Throwable, typing.Any], f: scala.Function1[java.lang.Throwable, _mkThrowableCatcher__T]) -> scala.PartialFunction[java.lang.Throwable, _mkThrowableCatcher__T]: ...
    @staticmethod
    def noCatch() -> 'Exception.Catch'[scala.runtime.Nothing.]: ...
    _nonFatalCatch__T = typing.TypeVar('_nonFatalCatch__T')  # <T>
    @staticmethod
    def nonFatalCatch() -> 'Exception.Catch'[_nonFatalCatch__T]: ...
    _nonFatalCatcher__T = typing.TypeVar('_nonFatalCatcher__T')  # <T>
    @staticmethod
    def nonFatalCatcher() -> scala.PartialFunction[java.lang.Throwable, _nonFatalCatcher__T]: ...
    @staticmethod
    def nothingCatcher() -> scala.PartialFunction[java.lang.Throwable, scala.runtime.Nothing.]: ...
    @staticmethod
    def shouldRethrow(x: java.lang.Throwable) -> bool: ...
    _throwableSubtypeToCatcher__Ex = typing.TypeVar('_throwableSubtypeToCatcher__Ex', bound=java.lang.Throwable)  # <Ex>
    _throwableSubtypeToCatcher__T = typing.TypeVar('_throwableSubtypeToCatcher__T')  # <T>
    @staticmethod
    def throwableSubtypeToCatcher(pf: scala.PartialFunction[_throwableSubtypeToCatcher__Ex, _throwableSubtypeToCatcher__T], evidence$2: scala.reflect.ClassTag[_throwableSubtypeToCatcher__Ex]) -> scala.PartialFunction[java.lang.Throwable, _throwableSubtypeToCatcher__T]: ...
    _ultimately__T = typing.TypeVar('_ultimately__T')  # <T>
    @staticmethod
    def ultimately(body: scala.Function0[scala.runtime.BoxedUnit]) -> 'Exception.Catch'[_ultimately__T]: ...
    _unwrapping__T = typing.TypeVar('_unwrapping__T')  # <T>
    @staticmethod
    def unwrapping(exceptions: scala.collection.Seq[typing.Type[typing.Any]]) -> 'Exception.Catch'[_unwrapping__T]: ...
    class By(typing.Generic[_Exception__By__T, _Exception__By__R]):
        def __init__(self, f: scala.Function1[_Exception__By__T, _Exception__By__R]): ...
        def by(self, x: _Exception__By__T) -> _Exception__By__R: ...
    class Catch(scala.util.control.Exception.Described, typing.Generic[_Exception__Catch__T]):
        def __init__(self, pf: scala.PartialFunction[java.lang.Throwable, _Exception__Catch__T], fin: scala.Option['Exception.Finally'], rethrow: scala.Function1[java.lang.Throwable, typing.Any]): ...
        def andFinally(self, body: scala.Function0[scala.runtime.BoxedUnit]) -> 'Exception.Catch'[_Exception__Catch__T]: ...
        _apply__U = typing.TypeVar('_apply__U')  # <U>
        def apply(self, body: scala.Function0[_apply__U]) -> _apply__U: ...
        def desc(self) -> str: ...
        _either__U = typing.TypeVar('_either__U')  # <U>
        def either(self, body: scala.Function0[_either__U]) -> scala.util.Either[java.lang.Throwable, _either__U]: ...
        def fin(self) -> scala.Option['Exception.Finally']: ...
        def name(self) -> str: ...
        _opt__U = typing.TypeVar('_opt__U')  # <U>
        def opt(self, body: scala.Function0[_opt__U]) -> scala.Option[_opt__U]: ...
        def pf(self) -> scala.PartialFunction[java.lang.Throwable, _Exception__Catch__T]: ...
        def rethrow(self) -> scala.Function1[java.lang.Throwable, typing.Any]: ...
        def scala$util$control$Exception$Described$$_desc(self) -> str: ...
        def scala$util$control$Exception$Described$$_desc_$eq(self, x$1: str) -> None: ...
        def toEither(self) -> 'Exception.Catch'[scala.util.Either[java.lang.Throwable, _Exception__Catch__T]]: ...
        def toOption(self) -> 'Exception.Catch'[scala.Option[_Exception__Catch__T]]: ...
        def toString(self) -> str: ...
        def toTry(self) -> 'Exception.Catch'[scala.util.Try[_Exception__Catch__T]]: ...
        _withApply__U = typing.TypeVar('_withApply__U')  # <U>
        def withApply(self, f: scala.Function1[java.lang.Throwable, _withApply__U]) -> 'Exception.Catch'[_withApply__U]: ...
        def withDesc(self, s: str) -> 'Exception.Described': ...
        _withTry__U = typing.TypeVar('_withTry__U')  # <U>
        def withTry(self, body: scala.Function0[_withTry__U]) -> scala.util.Try[_withTry__U]: ...
    class Catch$:
        MODULE$: typing.ClassVar['Exception.Catch.'] = ...
        def __init__(self): ...
        _$lessinit$greater$default$2__T = typing.TypeVar('_$lessinit$greater$default$2__T')  # <T>
        def $lessinit$greater$default$2(self) -> scala.Option['Exception.Finally']: ...
        _$lessinit$greater$default$3__T = typing.TypeVar('_$lessinit$greater$default$3__T')  # <T>
        def $lessinit$greater$default$3(self) -> scala.Function1[java.lang.Throwable, typing.Any]: ...
    class Described:
        @staticmethod
        def $init$($this: 'Exception.Described') -> None: ...
        def desc(self) -> str: ...
        def name(self) -> str: ...
        def scala$util$control$Exception$Described$$_desc(self) -> str: ...
        def scala$util$control$Exception$Described$$_desc_$eq(self, x$1: str) -> None: ...
        def toString(self) -> str: ...
        def withDesc(self, s: str) -> 'Exception.Described': ...
    class Finally(scala.util.control.Exception.Described):
        def __init__(self, body: scala.Function0[scala.runtime.BoxedUnit]): ...
        def desc(self) -> str: ...
        def invoke(self) -> None: ...
        def name(self) -> str: ...
        def scala$util$control$Exception$Described$$_desc(self) -> str: ...
        def scala$util$control$Exception$Described$$_desc_$eq(self, x$1: str) -> None: ...
        def toString(self) -> str: ...
        def withDesc(self, s: str) -> 'Exception.Described': ...

_TailCalls__Call__A = typing.TypeVar('_TailCalls__Call__A')  # <A>
_TailCalls__Cont__A = typing.TypeVar('_TailCalls__Cont__A')  # <A>
_TailCalls__Cont__B = typing.TypeVar('_TailCalls__Cont__B')  # <B>
_TailCalls__Done__A = typing.TypeVar('_TailCalls__Done__A')  # <A>
_TailCalls__TailRec__A = typing.TypeVar('_TailCalls__TailRec__A')  # <A>
class TailCalls:
    _done__A = typing.TypeVar('_done__A')  # <A>
    @staticmethod
    def done(result: _done__A) -> 'TailCalls.TailRec'[_done__A]: ...
    _tailcall__A = typing.TypeVar('_tailcall__A')  # <A>
    @staticmethod
    def tailcall(rest: scala.Function0['TailCalls.TailRec'[_tailcall__A]]) -> 'TailCalls.TailRec'[_tailcall__A]: ...
    class Call(scala.util.control.TailCalls.TailRec[_TailCalls__Call__A], scala.Product, scala.Serializable, typing.Generic[_TailCalls__Call__A]):
        def __init__(self, rest: scala.Function0['TailCalls.TailRec'[_TailCalls__Call__A]]): ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        _copy__A = typing.TypeVar('_copy__A')  # <A>
        def copy(self, rest: scala.Function0['TailCalls.TailRec'[typing.Any]]) -> 'TailCalls.Call'[typing.Any]: ...
        _copy$default$1__A = typing.TypeVar('_copy$default$1__A')  # <A>
        def copy$default$1(self) -> scala.Function0['TailCalls.TailRec'[typing.Any]]: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> str: ...
        def rest(self) -> scala.Function0['TailCalls.TailRec'[_TailCalls__Call__A]]: ...
        def toString(self) -> str: ...
    class Call$(scala.Serializable):
        MODULE$: typing.ClassVar['TailCalls.Call.'] = ...
        def __init__(self): ...
        _apply__A = typing.TypeVar('_apply__A')  # <A>
        def apply(self, rest: scala.Function0['TailCalls.TailRec'[_apply__A]]) -> 'TailCalls.Call'[_apply__A]: ...
        def toString(self) -> str: ...
        _unapply__A = typing.TypeVar('_unapply__A')  # <A>
        def unapply(self, x$0: 'TailCalls.Call'[_unapply__A]) -> scala.Option[scala.Function0['TailCalls.TailRec'[_unapply__A]]]: ...
    class Cont(scala.util.control.TailCalls.TailRec[_TailCalls__Cont__B], scala.Product, scala.Serializable, typing.Generic[_TailCalls__Cont__A, _TailCalls__Cont__B]):
        def __init__(self, a: 'TailCalls.TailRec'[_TailCalls__Cont__A], f: scala.Function1[_TailCalls__Cont__A, 'TailCalls.TailRec'[_TailCalls__Cont__B]]): ...
        def a(self) -> 'TailCalls.TailRec'[_TailCalls__Cont__A]: ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        _copy__A = typing.TypeVar('_copy__A')  # <A>
        _copy__B = typing.TypeVar('_copy__B')  # <B>
        def copy(self, a: 'TailCalls.TailRec'[typing.Any], f: scala.Function1[typing.Any, 'TailCalls.TailRec'[typing.Any]]) -> 'TailCalls.Cont'[typing.Any, typing.Any]: ...
        _copy$default$1__A = typing.TypeVar('_copy$default$1__A')  # <A>
        _copy$default$1__B = typing.TypeVar('_copy$default$1__B')  # <B>
        def copy$default$1(self) -> 'TailCalls.TailRec'[typing.Any]: ...
        _copy$default$2__A = typing.TypeVar('_copy$default$2__A')  # <A>
        _copy$default$2__B = typing.TypeVar('_copy$default$2__B')  # <B>
        def copy$default$2(self) -> scala.Function1[typing.Any, 'TailCalls.TailRec'[typing.Any]]: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def f(self) -> scala.Function1[_TailCalls__Cont__A, 'TailCalls.TailRec'[_TailCalls__Cont__B]]: ...
        def hashCode(self) -> int: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> str: ...
        def toString(self) -> str: ...
    class Cont$(scala.Serializable):
        MODULE$: typing.ClassVar['TailCalls.Cont.'] = ...
        def __init__(self): ...
        _apply__A = typing.TypeVar('_apply__A')  # <A>
        _apply__B = typing.TypeVar('_apply__B')  # <B>
        def apply(self, a: 'TailCalls.TailRec'[_apply__A], f: scala.Function1[_apply__A, 'TailCalls.TailRec'[_apply__B]]) -> 'TailCalls.Cont'[_apply__A, _apply__B]: ...
        def toString(self) -> str: ...
        _unapply__A = typing.TypeVar('_unapply__A')  # <A>
        _unapply__B = typing.TypeVar('_unapply__B')  # <B>
        def unapply(self, x$0: 'TailCalls.Cont'[_unapply__A, _unapply__B]) -> scala.Option[scala.Tuple2['TailCalls.TailRec'[_unapply__A], scala.Function1[_unapply__A, 'TailCalls.TailRec'[_unapply__B]]]]: ...
    class Done(scala.util.control.TailCalls.TailRec[_TailCalls__Done__A], scala.Product, scala.Serializable, typing.Generic[_TailCalls__Done__A]):
        def __init__(self, value: _TailCalls__Done__A): ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        _copy__A = typing.TypeVar('_copy__A')  # <A>
        def copy(self, value: typing.Any) -> 'TailCalls.Done'[typing.Any]: ...
        _copy$default$1__A = typing.TypeVar('_copy$default$1__A')  # <A>
        def copy$default$1(self) -> typing.Any: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> str: ...
        def toString(self) -> str: ...
        def value(self) -> _TailCalls__Done__A: ...
    class Done$(scala.Serializable):
        MODULE$: typing.ClassVar['TailCalls.Done.'] = ...
        def __init__(self): ...
        _apply__A = typing.TypeVar('_apply__A')  # <A>
        def apply(self, value: _apply__A) -> 'TailCalls.Done'[_apply__A]: ...
        def toString(self) -> str: ...
        _unapply__A = typing.TypeVar('_unapply__A')  # <A>
        def unapply(self, x$0: 'TailCalls.Done'[_unapply__A]) -> scala.Option[_unapply__A]: ...
    class TailRec(typing.Generic[_TailCalls__TailRec__A]):
        def __init__(self): ...
        _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
        def flatMap(self, f: scala.Function1[_TailCalls__TailRec__A, 'TailCalls.TailRec'[_flatMap__B]]) -> 'TailCalls.TailRec'[_flatMap__B]: ...
        _map__B = typing.TypeVar('_map__B')  # <B>
        def map(self, f: scala.Function1[_TailCalls__TailRec__A, _map__B]) -> 'TailCalls.TailRec'[_map__B]: ...
        def result(self) -> _TailCalls__TailRec__A: ...
        def resume(self) -> scala.util.Either[scala.Function0['TailCalls.TailRec'[_TailCalls__TailRec__A]], _TailCalls__TailRec__A]: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("scala.util.control")``.

    BreakControl: typing.Type[BreakControl]
    Breaks: typing.Type[Breaks]
    ControlThrowable: typing.Type[ControlThrowable]
    Exception: typing.Type[Exception]
    NoStackTrace: typing.Type[NoStackTrace]
    NonFatal: typing.Type[NonFatal]
    TailCalls: typing.Type[TailCalls]
