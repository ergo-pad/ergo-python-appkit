import scala
import scala.collection
import scala.collection.immutable
import scala.runtime
import typing



class package:
    @staticmethod
    def byteswap32(v: int) -> int: ...
    @staticmethod
    def byteswap64(v: int) -> int: ...

_ByteswapHashing__Chained__T = typing.TypeVar('_ByteswapHashing__Chained__T')  # <T>
_ByteswapHashing__T = typing.TypeVar('_ByteswapHashing__T')  # <T>
class ByteswapHashing(scala.util.hashing.Hashing[_ByteswapHashing__T], typing.Generic[_ByteswapHashing__T]):
    def __init__(self): ...
    _chain__T = typing.TypeVar('_chain__T')  # <T>
    @staticmethod
    def chain(h: 'Hashing'[_chain__T]) -> 'Hashing'[_chain__T]: ...
    def hash(self, v: _ByteswapHashing__T) -> int: ...
    class Chained(scala.util.hashing.Hashing[_ByteswapHashing__Chained__T], typing.Generic[_ByteswapHashing__Chained__T]):
        def __init__(self, h: 'Hashing'[_ByteswapHashing__Chained__T]): ...
        def hash(self, v: _ByteswapHashing__Chained__T) -> int: ...

_Hashing__Default__T = typing.TypeVar('_Hashing__Default__T')  # <T>
_Hashing__T = typing.TypeVar('_Hashing__T')  # <T>
class Hashing(scala.Serializable, typing.Generic[_Hashing__T]):
    _default__T = typing.TypeVar('_default__T')  # <T>
    @staticmethod
    def default() -> 'Hashing.Default'[_default__T]: ...
    _fromFunction__T = typing.TypeVar('_fromFunction__T')  # <T>
    @staticmethod
    def fromFunction(f: scala.Function1[_fromFunction__T, typing.Any]) -> 'Hashing'[_fromFunction__T]: ...
    def hash(self, x: _Hashing__T) -> int: ...
    class Default(scala.util.hashing.Hashing[_Hashing__Default__T], typing.Generic[_Hashing__Default__T]):
        def __init__(self): ...
        def hash(self, x: _Hashing__Default__T) -> int: ...

_MurmurHash3__ArrayHashing__T = typing.TypeVar('_MurmurHash3__ArrayHashing__T')  # <T>
class MurmurHash3:
    def __init__(self): ...
    _arrayHash__T = typing.TypeVar('_arrayHash__T')  # <T>
    def arrayHash(self, a: typing.Any, seed: int) -> int: ...
    def arrayHash$mBc$sp(self, a: typing.List[int], seed: int) -> int: ...
    def arrayHash$mCc$sp(self, a: typing.List[str], seed: int) -> int: ...
    def arrayHash$mDc$sp(self, a: typing.List[float], seed: int) -> int: ...
    def arrayHash$mFc$sp(self, a: typing.List[float], seed: int) -> int: ...
    def arrayHash$mIc$sp(self, a: typing.List[int], seed: int) -> int: ...
    def arrayHash$mJc$sp(self, a: typing.List[int], seed: int) -> int: ...
    def arrayHash$mSc$sp(self, a: typing.List[int], seed: int) -> int: ...
    def arrayHash$mVc$sp(self, a: typing.List[scala.runtime.BoxedUnit], seed: int) -> int: ...
    def arrayHash$mZc$sp(self, a: typing.List[bool], seed: int) -> int: ...
    _arrayHashing__T = typing.TypeVar('_arrayHashing__T')  # <T>
    @staticmethod
    def arrayHashing() -> 'MurmurHash3.ArrayHashing'[_arrayHashing__T]: ...
    @staticmethod
    def arraySeed() -> int: ...
    def bytesHash(self, data: typing.List[int], seed: int) -> int: ...
    @staticmethod
    def bytesHashing() -> Hashing[typing.List[int]]: ...
    def finalizeHash(self, hash: int, length: int) -> int: ...
    def listHash(self, xs: scala.collection.immutable.List[typing.Any], seed: int) -> int: ...
    @staticmethod
    def mapHash(xs: scala.collection.Map[typing.Any, typing.Any]) -> int: ...
    @staticmethod
    def mapSeed() -> int: ...
    def mix(self, hash: int, data: int) -> int: ...
    def mixLast(self, hash: int, data: int) -> int: ...
    def orderedHash(self, xs: scala.collection.TraversableOnce[typing.Any], seed: int) -> int: ...
    @staticmethod
    def orderedHashing() -> Hashing[scala.collection.TraversableOnce[typing.Any]]: ...
    def productHash(self, x: scala.Product, seed: int) -> int: ...
    @staticmethod
    def productHashing() -> Hashing[scala.Product]: ...
    @staticmethod
    def productSeed() -> int: ...
    @staticmethod
    def seqHash(xs: scala.collection.Seq[typing.Any]) -> int: ...
    @staticmethod
    def seqSeed() -> int: ...
    @staticmethod
    def setHash(xs: scala.collection.Set[typing.Any]) -> int: ...
    @staticmethod
    def setSeed() -> int: ...
    def stringHash(self, str: str, seed: int) -> int: ...
    @staticmethod
    def stringHashing() -> Hashing[str]: ...
    @staticmethod
    def stringSeed() -> int: ...
    @staticmethod
    def symmetricSeed() -> int: ...
    @staticmethod
    def traversableSeed() -> int: ...
    def unorderedHash(self, xs: scala.collection.TraversableOnce[typing.Any], seed: int) -> int: ...
    @staticmethod
    def unorderedHashing() -> Hashing[scala.collection.TraversableOnce[typing.Any]]: ...
    class ArrayHashing(Hashing[typing.Any], typing.Generic[_MurmurHash3__ArrayHashing__T]):
        def __init__(self): ...
        def hash(self, a: typing.Any) -> int: ...
        def hash$mcB$sp(self, a: typing.List[int]) -> int: ...
        def hash$mcC$sp(self, a: typing.List[str]) -> int: ...
        def hash$mcD$sp(self, a: typing.List[float]) -> int: ...
        def hash$mcF$sp(self, a: typing.List[float]) -> int: ...
        def hash$mcI$sp(self, a: typing.List[int]) -> int: ...
        def hash$mcJ$sp(self, a: typing.List[int]) -> int: ...
        def hash$mcS$sp(self, a: typing.List[int]) -> int: ...
        def hash$mcV$sp(self, a: typing.List[scala.runtime.BoxedUnit]) -> int: ...
        def hash$mcZ$sp(self, a: typing.List[bool]) -> int: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("scala.util.hashing")``.

    ByteswapHashing: typing.Type[ByteswapHashing]
    Hashing: typing.Type[Hashing]
    MurmurHash3: typing.Type[MurmurHash3]
    package: typing.Type[package]
