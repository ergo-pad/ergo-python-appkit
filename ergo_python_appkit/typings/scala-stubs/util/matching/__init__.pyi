import java.lang
import java.util.regex
import scala
import scala.collection
import scala.collection.immutable
import typing



class UnanchoredRegex:
    @staticmethod
    def $init$($this: 'UnanchoredRegex') -> None: ...
    def runMatcher(self, m: java.util.regex.Matcher) -> bool: ...
    def unanchored(self) -> 'UnanchoredRegex': ...

class Regex(scala.Serializable):
    serialVersionUID: typing.ClassVar[int] = ...
    scala$util$matching$Regex$$groupNames: scala.collection.Seq = ...
    @typing.overload
    def __init__(self, regex: str, groupNames: scala.collection.Seq[str]): ...
    @typing.overload
    def __init__(self, pattern: java.util.regex.Pattern, groupNames: scala.collection.Seq[str]): ...
    def anchored(self) -> 'Regex': ...
    def findAllIn(self, source: typing.Union[java.lang.CharSequence, str]) -> 'Regex.MatchIterator': ...
    def findAllMatchIn(self, source: typing.Union[java.lang.CharSequence, str]) -> scala.collection.Iterator['Regex.Match']: ...
    def findFirstIn(self, source: typing.Union[java.lang.CharSequence, str]) -> scala.Option[str]: ...
    def findFirstMatchIn(self, source: typing.Union[java.lang.CharSequence, str]) -> scala.Option['Regex.Match']: ...
    def findPrefixMatchOf(self, source: typing.Union[java.lang.CharSequence, str]) -> scala.Option['Regex.Match']: ...
    def findPrefixOf(self, source: typing.Union[java.lang.CharSequence, str]) -> scala.Option[str]: ...
    def pattern(self) -> java.util.regex.Pattern: ...
    @staticmethod
    def quote(text: str) -> str: ...
    @staticmethod
    def quoteReplacement(text: str) -> str: ...
    def regex(self) -> str: ...
    @typing.overload
    def replaceAllIn(self, target: typing.Union[java.lang.CharSequence, str], replacement: str) -> str: ...
    @typing.overload
    def replaceAllIn(self, target: typing.Union[java.lang.CharSequence, str], replacer: scala.Function1['Regex.Match', str]) -> str: ...
    def replaceFirstIn(self, target: typing.Union[java.lang.CharSequence, str], replacement: str) -> str: ...
    def replaceSomeIn(self, target: typing.Union[java.lang.CharSequence, str], replacer: scala.Function1['Regex.Match', scala.Option[str]]) -> str: ...
    def runMatcher(self, m: java.util.regex.Matcher) -> bool: ...
    def split(self, toSplit: typing.Union[java.lang.CharSequence, str]) -> typing.List[str]: ...
    def toString(self) -> str: ...
    def unanchored(self) -> UnanchoredRegex: ...
    @typing.overload
    def unapplySeq(self, c: str) -> scala.Option[scala.collection.immutable.List[typing.Any]]: ...
    @typing.overload
    def unapplySeq(self, s: typing.Union[java.lang.CharSequence, str]) -> scala.Option[scala.collection.immutable.List[str]]: ...
    @typing.overload
    def unapplySeq(self, target: typing.Any) -> scala.Option[scala.collection.immutable.List[str]]: ...
    @typing.overload
    def unapplySeq(self, m: 'Regex.Match') -> scala.Option[scala.collection.immutable.List[str]]: ...
    class Groups$:
        MODULE$: typing.ClassVar['Regex.Groups.'] = ...
        def __init__(self): ...
        def unapplySeq(self, m: 'Regex.Match') -> scala.Option[scala.collection.Seq[str]]: ...
    class Match(scala.util.matching.Regex.MatchData):
        def __init__(self, source: typing.Union[java.lang.CharSequence, str], matcher: java.util.regex.Matcher, groupNames: scala.collection.Seq[str]): ...
        @typing.overload
        def after(self) -> java.lang.CharSequence: ...
        @typing.overload
        def after(self, i: int) -> java.lang.CharSequence: ...
        @typing.overload
        def before(self) -> java.lang.CharSequence: ...
        @typing.overload
        def before(self, i: int) -> java.lang.CharSequence: ...
        @typing.overload
        def end(self) -> int: ...
        @typing.overload
        def end(self, i: int) -> int: ...
        def force(self) -> 'Regex.Match': ...
        @typing.overload
        def group(self, i: int) -> str: ...
        @typing.overload
        def group(self, id: str) -> str: ...
        def groupCount(self) -> int: ...
        def groupNames(self) -> scala.collection.Seq[str]: ...
        def matched(self) -> str: ...
        def matcher(self) -> java.util.regex.Matcher: ...
        def scala$util$matching$Regex$MatchData$$nameToIndex(self) -> scala.collection.immutable.Map[str, typing.Any]: ...
        def source(self) -> java.lang.CharSequence: ...
        @typing.overload
        def start(self) -> int: ...
        @typing.overload
        def start(self, i: int) -> int: ...
        def subgroups(self) -> scala.collection.immutable.List[str]: ...
        def toString(self) -> str: ...
    class Match$:
        MODULE$: typing.ClassVar['Regex.Match.'] = ...
        def __init__(self): ...
        def unapply(self, m: 'Regex.Match') -> scala.Some[str]: ...
    class MatchData:
        @staticmethod
        def $init$($this: 'Regex.MatchData') -> None: ...
        @typing.overload
        def after(self) -> java.lang.CharSequence: ...
        @typing.overload
        def after(self, i: int) -> java.lang.CharSequence: ...
        @typing.overload
        def before(self) -> java.lang.CharSequence: ...
        @typing.overload
        def before(self, i: int) -> java.lang.CharSequence: ...
        @typing.overload
        def end(self) -> int: ...
        @typing.overload
        def end(self, i: int) -> int: ...
        @typing.overload
        def group(self, i: int) -> str: ...
        @typing.overload
        def group(self, id: str) -> str: ...
        def groupCount(self) -> int: ...
        def groupNames(self) -> scala.collection.Seq[str]: ...
        def matched(self) -> str: ...
        def matcher(self) -> java.util.regex.Matcher: ...
        def scala$util$matching$Regex$MatchData$$nameToIndex(self) -> scala.collection.immutable.Map[str, typing.Any]: ...
        def source(self) -> java.lang.CharSequence: ...
        @typing.overload
        def start(self) -> int: ...
        @typing.overload
        def start(self, i: int) -> int: ...
        def subgroups(self) -> scala.collection.immutable.List[str]: ...
        def toString(self) -> str: ...
    class MatchIterator(scala.collection.AbstractIterator[str], scala.util.matching.Regex.MatchData):
        def __init__(self, source: typing.Union[java.lang.CharSequence, str], regex: 'Regex', groupNames: scala.collection.Seq[str]): ...
        @typing.overload
        def after(self) -> java.lang.CharSequence: ...
        @typing.overload
        def after(self, i: int) -> java.lang.CharSequence: ...
        @typing.overload
        def before(self) -> java.lang.CharSequence: ...
        @typing.overload
        def before(self, i: int) -> java.lang.CharSequence: ...
        @typing.overload
        def end(self) -> int: ...
        @typing.overload
        def end(self, i: int) -> int: ...
        @typing.overload
        def group(self, i: int) -> str: ...
        @typing.overload
        def group(self, id: str) -> str: ...
        def groupCount(self) -> int: ...
        def groupNames(self) -> scala.collection.Seq[str]: ...
        def hasNext(self) -> bool: ...
        def matchData(self) -> scala.collection.Iterator['Regex.Match']: ...
        def matched(self) -> str: ...
        def matcher(self) -> java.util.regex.Matcher: ...
        def next(self) -> str: ...
        def regex(self) -> 'Regex': ...
        def replacementData(self) -> scala.collection.AbstractIterator['Regex.Match']: ...
        def scala$util$matching$Regex$MatchData$$nameToIndex(self) -> scala.collection.immutable.Map[str, typing.Any]: ...
        def source(self) -> java.lang.CharSequence: ...
        @typing.overload
        def start(self) -> int: ...
        @typing.overload
        def start(self, i: int) -> int: ...
        def subgroups(self) -> scala.collection.immutable.List[str]: ...
        def toString(self) -> str: ...
    class Replacement:
        @staticmethod
        def $init$($this: 'Regex.Replacement') -> None: ...
        def matcher(self) -> java.util.regex.Matcher: ...
        def replace(self, rs: str) -> java.util.regex.Matcher: ...
        def replaced(self) -> str: ...
        def scala$util$matching$Regex$Replacement$$sb(self) -> java.lang.StringBuffer: ...
        def scala$util$matching$Regex$Replacement$_setter_$scala$util$matching$Regex$Replacement$$sb_$eq(self, x$1: java.lang.StringBuffer) -> None: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("scala.util.matching")``.

    Regex: typing.Type[Regex]
    UnanchoredRegex: typing.Type[UnanchoredRegex]
