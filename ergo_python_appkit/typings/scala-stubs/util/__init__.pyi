import java.lang
import java.util
import java.util.jar
import scala
import scala.collection
import scala.collection.generic
import scala.collection.immutable
import scala.math
import scala.reflect
import scala.runtime
import scala.util.control
import scala.util.hashing
import scala.util.matching
import typing



_DynamicVariable__T = typing.TypeVar('_DynamicVariable__T')  # <T>
class DynamicVariable(typing.Generic[_DynamicVariable__T]):
    scala$util$DynamicVariable$$init: typing.Any = ...
    def __init__(self, init: _DynamicVariable__T): ...
    def toString(self) -> str: ...
    def value(self) -> _DynamicVariable__T: ...
    def value_$eq(self, newval: _DynamicVariable__T) -> None: ...
    _withValue__S = typing.TypeVar('_withValue__S')  # <S>
    def withValue(self, newval: _DynamicVariable__T, thunk: scala.Function0[_withValue__S]) -> _withValue__S: ...

_Either__LeftProjection__A = typing.TypeVar('_Either__LeftProjection__A')  # <A>
_Either__LeftProjection__B = typing.TypeVar('_Either__LeftProjection__B')  # <B>
_Either__MergeableEither__A = typing.TypeVar('_Either__MergeableEither__A')  # <A>
_Either__RightProjection__A = typing.TypeVar('_Either__RightProjection__A')  # <A>
_Either__RightProjection__B = typing.TypeVar('_Either__RightProjection__B')  # <B>
_Either__A = typing.TypeVar('_Either__A')  # <A>
_Either__B = typing.TypeVar('_Either__B')  # <B>
class Either(scala.Product, scala.Serializable, typing.Generic[_Either__A, _Either__B]):
    def __init__(self): ...
    _cond__A = typing.TypeVar('_cond__A')  # <A>
    _cond__B = typing.TypeVar('_cond__B')  # <B>
    @staticmethod
    def cond(test: bool, right: scala.Function0[_cond__B], left: scala.Function0[_cond__A]) -> 'Either'[_cond__A, _cond__B]: ...
    _contains__B1 = typing.TypeVar('_contains__B1')  # <B1>
    def contains(self, elem: _contains__B1) -> bool: ...
    def exists(self, p: scala.Function1[_Either__B, typing.Any]) -> bool: ...
    _filterOrElse__A1 = typing.TypeVar('_filterOrElse__A1')  # <A1>
    def filterOrElse(self, p: scala.Function1[_Either__B, typing.Any], zero: scala.Function0[_filterOrElse__A1]) -> 'Either'[_filterOrElse__A1, _Either__B]: ...
    _flatMap__A1 = typing.TypeVar('_flatMap__A1')  # <A1>
    _flatMap__B1 = typing.TypeVar('_flatMap__B1')  # <B1>
    def flatMap(self, f: scala.Function1[_Either__B, 'Either'[_flatMap__A1, _flatMap__B1]]) -> 'Either'[_flatMap__A1, _flatMap__B1]: ...
    _fold__C = typing.TypeVar('_fold__C')  # <C>
    def fold(self, fa: scala.Function1[_Either__A, _fold__C], fb: scala.Function1[_Either__B, _fold__C]) -> _fold__C: ...
    def forall(self, f: scala.Function1[_Either__B, typing.Any]) -> bool: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_Either__B, _foreach__U]) -> None: ...
    _getOrElse__B1 = typing.TypeVar('_getOrElse__B1')  # <B1>
    def getOrElse(self, or_: scala.Function0[_getOrElse__B1]) -> _getOrElse__B1: ...
    def isLeft(self) -> bool: ...
    def isRight(self) -> bool: ...
    _joinLeft__A1 = typing.TypeVar('_joinLeft__A1')  # <A1>
    _joinLeft__B1 = typing.TypeVar('_joinLeft__B1')  # <B1>
    _joinLeft__C = typing.TypeVar('_joinLeft__C')  # <C>
    def joinLeft(self, ev: scala.Predef..less.colon.less[_joinLeft__A1, 'Either'[_joinLeft__C, _joinLeft__B1]]) -> 'Either'[_joinLeft__C, _joinLeft__B1]: ...
    _joinRight__A1 = typing.TypeVar('_joinRight__A1')  # <A1>
    _joinRight__B1 = typing.TypeVar('_joinRight__B1')  # <B1>
    _joinRight__C = typing.TypeVar('_joinRight__C')  # <C>
    def joinRight(self, ev: scala.Predef..less.colon.less[_joinRight__B1, 'Either'[_joinRight__A1, _joinRight__C]]) -> 'Either'[_joinRight__A1, _joinRight__C]: ...
    def left(self) -> 'Either.LeftProjection'[_Either__A, _Either__B]: ...
    _map__B1 = typing.TypeVar('_map__B1')  # <B1>
    def map(self, f: scala.Function1[_Either__B, _map__B1]) -> 'Either'[_Either__A, _map__B1]: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> str: ...
    def right(self) -> 'Either.RightProjection'[_Either__A, _Either__B]: ...
    def swap(self) -> 'Either'[_Either__B, _Either__A]: ...
    def toOption(self) -> scala.Option[_Either__B]: ...
    def toSeq(self) -> scala.collection.immutable.Seq[_Either__B]: ...
    def toTry(self, ev: scala.Predef..less.colon.less[_Either__A, java.lang.Throwable]) -> 'Try'[_Either__B]: ...
    class LeftProjection(scala.Product, scala.Serializable, typing.Generic[_Either__LeftProjection__A, _Either__LeftProjection__B]):
        def __init__(self, e: 'Either'[_Either__LeftProjection__A, _Either__LeftProjection__B]): ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        _copy__A = typing.TypeVar('_copy__A')  # <A>
        _copy__B = typing.TypeVar('_copy__B')  # <B>
        def copy(self, e: 'Either'[typing.Any, typing.Any]) -> 'Either.LeftProjection'[typing.Any, typing.Any]: ...
        _copy$default$1__A = typing.TypeVar('_copy$default$1__A')  # <A>
        _copy$default$1__B = typing.TypeVar('_copy$default$1__B')  # <B>
        def copy$default$1(self) -> 'Either'[typing.Any, typing.Any]: ...
        def e(self) -> 'Either'[_Either__LeftProjection__A, _Either__LeftProjection__B]: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def exists(self, p: scala.Function1[_Either__LeftProjection__A, typing.Any]) -> bool: ...
        _filter__B1 = typing.TypeVar('_filter__B1')  # <B1>
        def filter(self, p: scala.Function1[_Either__LeftProjection__A, typing.Any]) -> scala.Option['Either'[_Either__LeftProjection__A, _filter__B1]]: ...
        _flatMap__A1 = typing.TypeVar('_flatMap__A1')  # <A1>
        _flatMap__B1 = typing.TypeVar('_flatMap__B1')  # <B1>
        def flatMap(self, f: scala.Function1[_Either__LeftProjection__A, 'Either'[_flatMap__A1, _flatMap__B1]]) -> 'Either'[_flatMap__A1, _flatMap__B1]: ...
        def forall(self, p: scala.Function1[_Either__LeftProjection__A, typing.Any]) -> bool: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[_Either__LeftProjection__A, _foreach__U]) -> None: ...
        def get(self) -> _Either__LeftProjection__A: ...
        _getOrElse__A1 = typing.TypeVar('_getOrElse__A1')  # <A1>
        def getOrElse(self, or_: scala.Function0[_getOrElse__A1]) -> _getOrElse__A1: ...
        def hashCode(self) -> int: ...
        _map__A1 = typing.TypeVar('_map__A1')  # <A1>
        def map(self, f: scala.Function1[_Either__LeftProjection__A, _map__A1]) -> 'Either'[_map__A1, _Either__LeftProjection__B]: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> str: ...
        def toOption(self) -> scala.Option[_Either__LeftProjection__A]: ...
        def toSeq(self) -> scala.collection.Seq[_Either__LeftProjection__A]: ...
        def toString(self) -> str: ...
    class LeftProjection$(scala.Serializable):
        MODULE$: typing.ClassVar['Either.LeftProjection.'] = ...
        def __init__(self): ...
        _apply__A = typing.TypeVar('_apply__A')  # <A>
        _apply__B = typing.TypeVar('_apply__B')  # <B>
        def apply(self, e: 'Either'[_apply__A, _apply__B]) -> 'Either.LeftProjection'[_apply__A, _apply__B]: ...
        def toString(self) -> str: ...
        _unapply__A = typing.TypeVar('_unapply__A')  # <A>
        _unapply__B = typing.TypeVar('_unapply__B')  # <B>
        def unapply(self, x$0: 'Either.LeftProjection'[_unapply__A, _unapply__B]) -> scala.Option['Either'[_unapply__A, _unapply__B]]: ...
    class MergeableEither(typing.Generic[_Either__MergeableEither__A]):
        def __init__(self, x: 'Either'[_Either__MergeableEither__A, _Either__MergeableEither__A]): ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def merge(self) -> _Either__MergeableEither__A: ...
        def scala$util$Either$MergeableEither$$x(self) -> 'Either'[_Either__MergeableEither__A, _Either__MergeableEither__A]: ...
    class MergeableEither$:
        MODULE$: typing.ClassVar['Either.MergeableEither.'] = ...
        def __init__(self): ...
        _equals$extension__A = typing.TypeVar('_equals$extension__A')  # <A>
        def equals$extension(self, $this: 'Either'[_equals.extension__A, _equals.extension__A], x$1: typing.Any) -> bool: ...
        _hashCode$extension__A = typing.TypeVar('_hashCode$extension__A')  # <A>
        def hashCode$extension(self, $this: 'Either'[_hashCode.extension__A, _hashCode.extension__A]) -> int: ...
        _merge$extension__A = typing.TypeVar('_merge$extension__A')  # <A>
        def merge$extension(self, $this: 'Either'[_merge.extension__A, _merge.extension__A]) -> _merge.extension__A: ...
    class RightProjection(scala.Product, scala.Serializable, typing.Generic[_Either__RightProjection__A, _Either__RightProjection__B]):
        def __init__(self, e: 'Either'[_Either__RightProjection__A, _Either__RightProjection__B]): ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        _copy__A = typing.TypeVar('_copy__A')  # <A>
        _copy__B = typing.TypeVar('_copy__B')  # <B>
        def copy(self, e: 'Either'[typing.Any, typing.Any]) -> 'Either.RightProjection'[typing.Any, typing.Any]: ...
        _copy$default$1__A = typing.TypeVar('_copy$default$1__A')  # <A>
        _copy$default$1__B = typing.TypeVar('_copy$default$1__B')  # <B>
        def copy$default$1(self) -> 'Either'[typing.Any, typing.Any]: ...
        def e(self) -> 'Either'[_Either__RightProjection__A, _Either__RightProjection__B]: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def exists(self, p: scala.Function1[_Either__RightProjection__B, typing.Any]) -> bool: ...
        _filter__A1 = typing.TypeVar('_filter__A1')  # <A1>
        def filter(self, p: scala.Function1[_Either__RightProjection__B, typing.Any]) -> scala.Option['Either'[_filter__A1, _Either__RightProjection__B]]: ...
        _flatMap__A1 = typing.TypeVar('_flatMap__A1')  # <A1>
        _flatMap__B1 = typing.TypeVar('_flatMap__B1')  # <B1>
        def flatMap(self, f: scala.Function1[_Either__RightProjection__B, 'Either'[_flatMap__A1, _flatMap__B1]]) -> 'Either'[_flatMap__A1, _flatMap__B1]: ...
        def forall(self, f: scala.Function1[_Either__RightProjection__B, typing.Any]) -> bool: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[_Either__RightProjection__B, _foreach__U]) -> None: ...
        def get(self) -> _Either__RightProjection__B: ...
        _getOrElse__B1 = typing.TypeVar('_getOrElse__B1')  # <B1>
        def getOrElse(self, or_: scala.Function0[_getOrElse__B1]) -> _getOrElse__B1: ...
        def hashCode(self) -> int: ...
        _map__B1 = typing.TypeVar('_map__B1')  # <B1>
        def map(self, f: scala.Function1[_Either__RightProjection__B, _map__B1]) -> 'Either'[_Either__RightProjection__A, _map__B1]: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> str: ...
        def toOption(self) -> scala.Option[_Either__RightProjection__B]: ...
        def toSeq(self) -> scala.collection.Seq[_Either__RightProjection__B]: ...
        def toString(self) -> str: ...
    class RightProjection$(scala.Serializable):
        MODULE$: typing.ClassVar['Either.RightProjection.'] = ...
        def __init__(self): ...
        _apply__A = typing.TypeVar('_apply__A')  # <A>
        _apply__B = typing.TypeVar('_apply__B')  # <B>
        def apply(self, e: 'Either'[_apply__A, _apply__B]) -> 'Either.RightProjection'[_apply__A, _apply__B]: ...
        def toString(self) -> str: ...
        _unapply__A = typing.TypeVar('_unapply__A')  # <A>
        _unapply__B = typing.TypeVar('_unapply__B')  # <B>
        def unapply(self, x$0: 'Either.RightProjection'[_unapply__A, _unapply__B]) -> scala.Option['Either'[_unapply__A, _unapply__B]]: ...

_MurmurHash__T = typing.TypeVar('_MurmurHash__T')  # <T>
class MurmurHash(scala.Function1[_MurmurHash__T, scala.runtime.BoxedUnit], typing.Generic[_MurmurHash__T]):
    def __init__(self, seed: int): ...
    _andThen__A = typing.TypeVar('_andThen__A')  # <A>
    def andThen(self, g: scala.Function1[scala.runtime.BoxedUnit, _andThen__A]) -> scala.Function1[_MurmurHash__T, _andThen__A]: ...
    def append(self, i: int) -> None: ...
    def apply(self, t: _MurmurHash__T) -> None: ...
    def apply$mcD$sp(self, t: float) -> None: ...
    def apply$mcDD$sp(self, v1: float) -> float: ...
    def apply$mcDF$sp(self, v1: float) -> float: ...
    def apply$mcDI$sp(self, v1: int) -> float: ...
    def apply$mcDJ$sp(self, v1: int) -> float: ...
    def apply$mcF$sp(self, t: float) -> None: ...
    def apply$mcFD$sp(self, v1: float) -> float: ...
    def apply$mcFF$sp(self, v1: float) -> float: ...
    def apply$mcFI$sp(self, v1: int) -> float: ...
    def apply$mcFJ$sp(self, v1: int) -> float: ...
    def apply$mcI$sp(self, t: int) -> None: ...
    def apply$mcID$sp(self, v1: float) -> int: ...
    def apply$mcIF$sp(self, v1: float) -> int: ...
    def apply$mcII$sp(self, v1: int) -> int: ...
    def apply$mcIJ$sp(self, v1: int) -> int: ...
    def apply$mcJ$sp(self, t: int) -> None: ...
    def apply$mcJD$sp(self, v1: float) -> int: ...
    def apply$mcJF$sp(self, v1: float) -> int: ...
    def apply$mcJI$sp(self, v1: int) -> int: ...
    def apply$mcJJ$sp(self, v1: int) -> int: ...
    def apply$mcVD$sp(self, v1: float) -> None: ...
    def apply$mcVF$sp(self, v1: float) -> None: ...
    def apply$mcVI$sp(self, v1: int) -> None: ...
    def apply$mcVJ$sp(self, v1: int) -> None: ...
    def apply$mcZD$sp(self, v1: float) -> bool: ...
    def apply$mcZF$sp(self, v1: float) -> bool: ...
    def apply$mcZI$sp(self, v1: int) -> bool: ...
    def apply$mcZJ$sp(self, v1: int) -> bool: ...
    _arrayHash__T = typing.TypeVar('_arrayHash__T')  # <T>
    @staticmethod
    def arrayHash(a: typing.Any) -> int: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    def compose(self, g: scala.Function1[_compose__A, _MurmurHash__T]) -> scala.Function1[_compose__A, scala.runtime.BoxedUnit]: ...
    @staticmethod
    def extendHash(hash: int, value: int, magicA: int, magicB: int) -> int: ...
    @staticmethod
    def finalizeHash(hash: int) -> int: ...
    def hash(self) -> int: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def nextMagicA(magicA: int) -> int: ...
    @staticmethod
    def nextMagicB(magicB: int) -> int: ...
    def reset(self) -> None: ...
    def scala$util$MurmurHash$$c(self) -> int: ...
    def scala$util$MurmurHash$$c_$eq(self, x$1: int) -> None: ...
    def scala$util$MurmurHash$$h(self) -> int: ...
    def scala$util$MurmurHash$$h_$eq(self, x$1: int) -> None: ...
    def scala$util$MurmurHash$$hashed_$eq(self, x$1: bool) -> None: ...
    def scala$util$MurmurHash$$k(self) -> int: ...
    def scala$util$MurmurHash$$k_$eq(self, x$1: int) -> None: ...
    @staticmethod
    def startHash(seed: int) -> int: ...
    @staticmethod
    def startMagicA() -> int: ...
    @staticmethod
    def startMagicB() -> int: ...
    @staticmethod
    def storedMagicA() -> typing.List[int]: ...
    @staticmethod
    def storedMagicB() -> typing.List[int]: ...
    @staticmethod
    def stringHash(s: str) -> int: ...
    _symmetricHash__T = typing.TypeVar('_symmetricHash__T')  # <T>
    @staticmethod
    def symmetricHash(xs: scala.collection.TraversableOnce[_symmetricHash__T], seed: int) -> int: ...
    def toString(self) -> str: ...

class Properties:
    @staticmethod
    def ScalaCompilerVersion() -> java.util.jar.Attributes.Name: ...
    @staticmethod
    def clearProp(name: str) -> str: ...
    @staticmethod
    def copyrightString() -> str: ...
    @staticmethod
    def developmentVersion() -> scala.Option[str]: ...
    @staticmethod
    def encodingString() -> str: ...
    @staticmethod
    def envOrElse(name: str, alt: str) -> str: ...
    @staticmethod
    def envOrNone(name: str) -> scala.Option[str]: ...
    @staticmethod
    def envOrSome(name: str, alt: scala.Option[str]) -> scala.Option[str]: ...
    @staticmethod
    def isJavaAtLeast(version: str) -> bool: ...
    @staticmethod
    def isLinux() -> bool: ...
    @staticmethod
    def isMac() -> bool: ...
    @staticmethod
    def isWin() -> bool: ...
    @staticmethod
    def javaClassPath() -> str: ...
    @staticmethod
    def javaHome() -> str: ...
    @staticmethod
    def javaSpecName() -> str: ...
    @staticmethod
    def javaSpecVendor() -> str: ...
    @staticmethod
    def javaSpecVersion() -> str: ...
    @staticmethod
    def javaVendor() -> str: ...
    @staticmethod
    def javaVersion() -> str: ...
    @staticmethod
    def javaVmInfo() -> str: ...
    @staticmethod
    def javaVmName() -> str: ...
    @staticmethod
    def javaVmVendor() -> str: ...
    @staticmethod
    def javaVmVersion() -> str: ...
    @staticmethod
    def jdkHome() -> str: ...
    @staticmethod
    def lineSeparator() -> str: ...
    @staticmethod
    def main(args: typing.List[str]) -> None: ...
    @staticmethod
    def osName() -> str: ...
    @staticmethod
    def propIsSet(name: str) -> bool: ...
    @staticmethod
    def propIsSetTo(name: str, value: str) -> bool: ...
    @staticmethod
    def propOrElse(name: str, alt: str) -> str: ...
    @staticmethod
    def propOrEmpty(name: str) -> str: ...
    @staticmethod
    def propOrFalse(name: str) -> bool: ...
    @staticmethod
    def propOrNone(name: str) -> scala.Option[str]: ...
    @staticmethod
    def propOrNull(name: str) -> str: ...
    @staticmethod
    def releaseVersion() -> scala.Option[str]: ...
    @staticmethod
    def scalaCmd() -> str: ...
    @staticmethod
    def scalaHome() -> str: ...
    @staticmethod
    def scalaPropOrElse(name: str, alt: str) -> str: ...
    @staticmethod
    def scalaPropOrEmpty(name: str) -> str: ...
    @staticmethod
    def scalaPropOrNone(name: str) -> scala.Option[str]: ...
    @staticmethod
    def scalacCmd() -> str: ...
    @staticmethod
    def setProp(name: str, value: str) -> str: ...
    @staticmethod
    def sourceEncoding() -> str: ...
    @staticmethod
    def sourceReader() -> str: ...
    @staticmethod
    def tmpDir() -> str: ...
    @staticmethod
    def userDir() -> str: ...
    @staticmethod
    def userHome() -> str: ...
    @staticmethod
    def userName() -> str: ...
    @staticmethod
    def versionMsg() -> str: ...
    @staticmethod
    def versionNumberString() -> str: ...
    @staticmethod
    def versionString() -> str: ...

class PropertiesTrait:
    @staticmethod
    def $init$($this: 'PropertiesTrait') -> None: ...
    def clearProp(self, name: str) -> str: ...
    def coloredOutputEnabled(self) -> bool: ...
    def copyrightString(self) -> str: ...
    def developmentVersion(self) -> scala.Option[str]: ...
    def encodingString(self) -> str: ...
    def envOrElse(self, name: str, alt: str) -> str: ...
    def envOrNone(self, name: str) -> scala.Option[str]: ...
    def envOrSome(self, name: str, alt: scala.Option[str]) -> scala.Option[str]: ...
    def isAvian(self) -> bool: ...
    def isJavaAtLeast(self, version: str) -> bool: ...
    def isLinux(self) -> bool: ...
    def isMac(self) -> bool: ...
    def isWin(self) -> bool: ...
    def javaClassPath(self) -> str: ...
    def javaHome(self) -> str: ...
    def javaSpecName(self) -> str: ...
    def javaSpecVendor(self) -> str: ...
    def javaSpecVersion(self) -> str: ...
    def javaVendor(self) -> str: ...
    def javaVersion(self) -> str: ...
    def javaVmInfo(self) -> str: ...
    def javaVmName(self) -> str: ...
    def javaVmVendor(self) -> str: ...
    def javaVmVersion(self) -> str: ...
    def jdkHome(self) -> str: ...
    def lineSeparator(self) -> str: ...
    def main(self, args: typing.List[str]) -> None: ...
    def osName(self) -> str: ...
    def pickJarBasedOn(self) -> typing.Type[typing.Any]: ...
    def propCategory(self) -> str: ...
    def propFilename(self) -> str: ...
    def propIsSet(self, name: str) -> bool: ...
    def propIsSetTo(self, name: str, value: str) -> bool: ...
    def propOrElse(self, name: str, alt: str) -> str: ...
    def propOrEmpty(self, name: str) -> str: ...
    def propOrFalse(self, name: str) -> bool: ...
    def propOrNone(self, name: str) -> scala.Option[str]: ...
    def propOrNull(self, name: str) -> str: ...
    def releaseVersion(self) -> scala.Option[str]: ...
    def scala$util$PropertiesTrait$_setter_$copyrightString_$eq(self, x$1: str) -> None: ...
    def scala$util$PropertiesTrait$_setter_$developmentVersion_$eq(self, x$1: scala.Option[str]) -> None: ...
    def scala$util$PropertiesTrait$_setter_$propFilename_$eq(self, x$1: str) -> None: ...
    def scala$util$PropertiesTrait$_setter_$releaseVersion_$eq(self, x$1: scala.Option[str]) -> None: ...
    def scala$util$PropertiesTrait$_setter_$versionString_$eq(self, x$1: str) -> None: ...
    def scalaCmd(self) -> str: ...
    def scalaHome(self) -> str: ...
    def scalaPropOrElse(self, name: str, alt: str) -> str: ...
    def scalaPropOrEmpty(self, name: str) -> str: ...
    def scalaPropOrNone(self, name: str) -> scala.Option[str]: ...
    def scalaProps(self) -> java.util.Properties: ...
    def scalacCmd(self) -> str: ...
    def setProp(self, name: str, value: str) -> str: ...
    def sourceEncoding(self) -> str: ...
    def sourceReader(self) -> str: ...
    def tmpDir(self) -> str: ...
    def userDir(self) -> str: ...
    def userHome(self) -> str: ...
    def userName(self) -> str: ...
    def versionMsg(self) -> str: ...
    def versionNumberString(self) -> str: ...
    def versionString(self) -> str: ...

class Random(scala.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, seed: int): ...
    @typing.overload
    def __init__(self, self): ...
    @typing.overload
    def __init__(self, seed: int): ...
    def alphanumeric(self) -> scala.collection.immutable.Stream[typing.Any]: ...
    @staticmethod
    def javaRandomToRandom(r: java.util.Random) -> 'Random': ...
    def nextBoolean(self) -> bool: ...
    def nextBytes(self, bytes: typing.List[int]) -> None: ...
    def nextDouble(self) -> float: ...
    def nextFloat(self) -> float: ...
    def nextGaussian(self) -> float: ...
    @typing.overload
    def nextInt(self) -> int: ...
    @typing.overload
    def nextInt(self, n: int) -> int: ...
    def nextLong(self) -> int: ...
    def nextPrintableChar(self) -> str: ...
    def nextString(self, length: int) -> str: ...
    def self(self) -> java.util.Random: ...
    def setSeed(self, seed: int) -> None: ...
    _shuffle__T = typing.TypeVar('_shuffle__T')  # <T>
    _shuffle__CC = typing.TypeVar('_shuffle__CC', bound=scala.collection.TraversableOnce)  # <CC>
    def shuffle(self, xs: _shuffle__CC, bf: scala.collection.generic.CanBuildFrom[_shuffle__CC, _shuffle__T, _shuffle__CC]) -> _shuffle__CC: ...

class Sorting:
    _quickSort_3__K = typing.TypeVar('_quickSort_3__K')  # <K>
    @typing.overload
    @staticmethod
    def quickSort(a: typing.List[float]) -> None: ...
    @typing.overload
    @staticmethod
    def quickSort(a: typing.List[float]) -> None: ...
    @typing.overload
    @staticmethod
    def quickSort(a: typing.List[int]) -> None: ...
    @typing.overload
    @staticmethod
    def quickSort(a: typing.Any, evidence$1: scala.math.Ordering[_quickSort_3__K]) -> None: ...
    _stableSort_3__K = typing.TypeVar('_stableSort_3__K')  # <K>
    _stableSort_4__K = typing.TypeVar('_stableSort_4__K')  # <K>
    @typing.overload
    @staticmethod
    def stableSort(a: scala.collection.Seq, f: scala.Function1, evidence$9: scala.reflect.ClassTag, evidence$10: scala.math.Ordering) -> typing.Any: ...
    @typing.overload
    @staticmethod
    def stableSort(a: scala.collection.Seq, f: scala.Function2, evidence$8: scala.reflect.ClassTag) -> typing.Any: ...
    @typing.overload
    @staticmethod
    def stableSort(a: scala.collection.Seq, evidence$6: scala.reflect.ClassTag, evidence$7: scala.math.Ordering) -> typing.Any: ...
    @typing.overload
    @staticmethod
    def stableSort(a: typing.Any, f: scala.Function2[_stableSort_3__K, _stableSort_3__K, typing.Any], evidence$5: scala.reflect.ClassTag[_stableSort_3__K]) -> None: ...
    @typing.overload
    @staticmethod
    def stableSort(a: typing.Any, evidence$3: scala.reflect.ClassTag[_stableSort_4__K], evidence$4: scala.math.Ordering[_stableSort_4__K]) -> None: ...

_Try__T = typing.TypeVar('_Try__T')  # <T>
class Try(scala.Product, scala.Serializable, typing.Generic[_Try__T]):
    def __init__(self): ...
    _apply__T = typing.TypeVar('_apply__T')  # <T>
    @staticmethod
    def apply(r: scala.Function0[_apply__T]) -> 'Try'[_apply__T]: ...
    _collect__U = typing.TypeVar('_collect__U')  # <U>
    def collect(self, pf: scala.PartialFunction[_Try__T, _collect__U]) -> 'Try'[_collect__U]: ...
    def failed(self) -> 'Try'[java.lang.Throwable]: ...
    def filter(self, p: scala.Function1[_Try__T, typing.Any]) -> 'Try'[_Try__T]: ...
    _flatMap__U = typing.TypeVar('_flatMap__U')  # <U>
    def flatMap(self, f: scala.Function1[_Try__T, 'Try'[_flatMap__U]]) -> 'Try'[_flatMap__U]: ...
    _flatten__U = typing.TypeVar('_flatten__U')  # <U>
    def flatten(self, ev: scala.Predef..less.colon.less[_Try__T, 'Try'[_flatten__U]]) -> 'Try'[_flatten__U]: ...
    _fold__U = typing.TypeVar('_fold__U')  # <U>
    def fold(self, fa: scala.Function1[java.lang.Throwable, _fold__U], fb: scala.Function1[_Try__T, _fold__U]) -> _fold__U: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_Try__T, _foreach__U]) -> None: ...
    def get(self) -> _Try__T: ...
    _getOrElse__U = typing.TypeVar('_getOrElse__U')  # <U>
    def getOrElse(self, default: scala.Function0[_getOrElse__U]) -> _getOrElse__U: ...
    def isFailure(self) -> bool: ...
    def isSuccess(self) -> bool: ...
    _map__U = typing.TypeVar('_map__U')  # <U>
    def map(self, f: scala.Function1[_Try__T, _map__U]) -> 'Try'[_map__U]: ...
    _orElse__U = typing.TypeVar('_orElse__U')  # <U>
    def orElse(self, default: scala.Function0['Try'[_orElse__U]]) -> 'Try'[_orElse__U]: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> str: ...
    _recover__U = typing.TypeVar('_recover__U')  # <U>
    def recover(self, pf: scala.PartialFunction[java.lang.Throwable, _recover__U]) -> 'Try'[_recover__U]: ...
    _recoverWith__U = typing.TypeVar('_recoverWith__U')  # <U>
    def recoverWith(self, pf: scala.PartialFunction[java.lang.Throwable, 'Try'[_recoverWith__U]]) -> 'Try'[_recoverWith__U]: ...
    def toEither(self) -> Either[java.lang.Throwable, _Try__T]: ...
    def toOption(self) -> scala.Option[_Try__T]: ...
    _transform__U = typing.TypeVar('_transform__U')  # <U>
    def transform(self, s: scala.Function1[_Try__T, 'Try'[_transform__U]], f: scala.Function1[java.lang.Throwable, 'Try'[_transform__U]]) -> 'Try'[_transform__U]: ...
    def withFilter(self, p: scala.Function1[_Try__T, typing.Any]) -> 'Try.WithFilter': ...
    class WithFilter:
        $outer: 'Try' = ...
        def __init__(self, $outer: 'Try', p: scala.Function1[_Try__T, typing.Any]): ...
        _flatMap__U = typing.TypeVar('_flatMap__U')  # <U>
        def flatMap(self, f: scala.Function1[_Try__T, 'Try'[_flatMap__U]]) -> 'Try'[_flatMap__U]: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[_Try__T, _foreach__U]) -> None: ...
        _map__U = typing.TypeVar('_map__U')  # <U>
        def map(self, f: scala.Function1[_Try__T, _map__U]) -> 'Try'[_map__U]: ...
        def withFilter(self, q: scala.Function1[_Try__T, typing.Any]) -> 'Try.WithFilter': ...

_Failure__T = typing.TypeVar('_Failure__T')  # <T>
class Failure(Try[_Failure__T], typing.Generic[_Failure__T]):
    def __init__(self, exception: java.lang.Throwable): ...
    _apply_0__T = typing.TypeVar('_apply_0__T')  # <T>
    _apply_1__T = typing.TypeVar('_apply_1__T')  # <T>
    @typing.overload
    @staticmethod
    def apply(exception: java.lang.Throwable) -> 'Failure'[_apply_0__T]: ...
    @typing.overload
    @staticmethod
    def apply(r: scala.Function0[_apply_1__T]) -> Try[_apply_1__T]: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _collect__U = typing.TypeVar('_collect__U')  # <U>
    def collect(self, pf: scala.PartialFunction[_Failure__T, _collect__U]) -> Try[_collect__U]: ...
    _copy__T = typing.TypeVar('_copy__T')  # <T>
    def copy(self, exception: java.lang.Throwable) -> 'Failure'[typing.Any]: ...
    _copy$default$1__T = typing.TypeVar('_copy$default$1__T')  # <T>
    def copy$default$1(self) -> java.lang.Throwable: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def exception(self) -> java.lang.Throwable: ...
    def failed(self) -> Try[java.lang.Throwable]: ...
    def filter(self, p: scala.Function1[_Failure__T, typing.Any]) -> Try[_Failure__T]: ...
    _flatMap__U = typing.TypeVar('_flatMap__U')  # <U>
    def flatMap(self, f: scala.Function1[_Failure__T, Try[_flatMap__U]]) -> Try[_flatMap__U]: ...
    _flatten__U = typing.TypeVar('_flatten__U')  # <U>
    def flatten(self, ev: scala.Predef..less.colon.less[_Failure__T, Try[_flatten__U]]) -> Try[_flatten__U]: ...
    _fold__U = typing.TypeVar('_fold__U')  # <U>
    def fold(self, fa: scala.Function1[java.lang.Throwable, _fold__U], fb: scala.Function1[_Failure__T, _fold__U]) -> _fold__U: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_Failure__T, _foreach__U]) -> None: ...
    def get(self) -> _Failure__T: ...
    _getOrElse__U = typing.TypeVar('_getOrElse__U')  # <U>
    def getOrElse(self, default: scala.Function0[_getOrElse__U]) -> _getOrElse__U: ...
    def hashCode(self) -> int: ...
    def isFailure(self) -> bool: ...
    def isSuccess(self) -> bool: ...
    _map__U = typing.TypeVar('_map__U')  # <U>
    def map(self, f: scala.Function1[_Failure__T, _map__U]) -> Try[_map__U]: ...
    _orElse__U = typing.TypeVar('_orElse__U')  # <U>
    def orElse(self, default: scala.Function0[Try[_orElse__U]]) -> Try[_orElse__U]: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> str: ...
    _recover__U = typing.TypeVar('_recover__U')  # <U>
    def recover(self, pf: scala.PartialFunction[java.lang.Throwable, _recover__U]) -> Try[_recover__U]: ...
    _recoverWith__U = typing.TypeVar('_recoverWith__U')  # <U>
    def recoverWith(self, pf: scala.PartialFunction[java.lang.Throwable, Try[_recoverWith__U]]) -> Try[_recoverWith__U]: ...
    def toEither(self) -> Either[java.lang.Throwable, _Failure__T]: ...
    def toOption(self) -> scala.Option[_Failure__T]: ...
    def toString(self) -> str: ...
    _transform__U = typing.TypeVar('_transform__U')  # <U>
    def transform(self, s: scala.Function1[_Failure__T, Try[_transform__U]], f: scala.Function1[java.lang.Throwable, Try[_transform__U]]) -> Try[_transform__U]: ...
    _unapply__T = typing.TypeVar('_unapply__T')  # <T>
    @staticmethod
    def unapply(x$0: 'Failure'[_unapply__T]) -> scala.Option[java.lang.Throwable]: ...

_Left__A = typing.TypeVar('_Left__A')  # <A>
_Left__B = typing.TypeVar('_Left__B')  # <B>
class Left(Either[_Left__A, _Left__B], typing.Generic[_Left__A, _Left__B]):
    def __init__(self, value: _Left__A): ...
    def a(self) -> _Left__A: ...
    _apply__A = typing.TypeVar('_apply__A')  # <A>
    _apply__B = typing.TypeVar('_apply__B')  # <B>
    @staticmethod
    def apply(value: _apply__A) -> 'Left'[_apply__A, _apply__B]: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _copy__A = typing.TypeVar('_copy__A')  # <A>
    _copy__B = typing.TypeVar('_copy__B')  # <B>
    def copy(self, value: typing.Any) -> 'Left'[typing.Any, typing.Any]: ...
    _copy$default$1__A = typing.TypeVar('_copy$default$1__A')  # <A>
    _copy$default$1__B = typing.TypeVar('_copy$default$1__B')  # <B>
    def copy$default$1(self) -> typing.Any: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def isLeft(self) -> bool: ...
    def isRight(self) -> bool: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> str: ...
    def toString(self) -> str: ...
    _unapply__A = typing.TypeVar('_unapply__A')  # <A>
    _unapply__B = typing.TypeVar('_unapply__B')  # <B>
    @staticmethod
    def unapply(x$0: 'Left'[_unapply__A, _unapply__B]) -> scala.Option[_unapply__A]: ...
    def value(self) -> _Left__A: ...

_Right__A = typing.TypeVar('_Right__A')  # <A>
_Right__B = typing.TypeVar('_Right__B')  # <B>
class Right(Either[_Right__A, _Right__B], typing.Generic[_Right__A, _Right__B]):
    def __init__(self, value: _Right__B): ...
    _apply__A = typing.TypeVar('_apply__A')  # <A>
    _apply__B = typing.TypeVar('_apply__B')  # <B>
    @staticmethod
    def apply(value: _apply__B) -> 'Right'[_apply__A, _apply__B]: ...
    def b(self) -> _Right__B: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _copy__A = typing.TypeVar('_copy__A')  # <A>
    _copy__B = typing.TypeVar('_copy__B')  # <B>
    def copy(self, value: typing.Any) -> 'Right'[typing.Any, typing.Any]: ...
    _copy$default$1__A = typing.TypeVar('_copy$default$1__A')  # <A>
    _copy$default$1__B = typing.TypeVar('_copy$default$1__B')  # <B>
    def copy$default$1(self) -> typing.Any: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def isLeft(self) -> bool: ...
    def isRight(self) -> bool: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> str: ...
    def toString(self) -> str: ...
    _unapply__A = typing.TypeVar('_unapply__A')  # <A>
    _unapply__B = typing.TypeVar('_unapply__B')  # <B>
    @staticmethod
    def unapply(x$0: 'Right'[_unapply__A, _unapply__B]) -> scala.Option[_unapply__B]: ...
    def value(self) -> _Right__B: ...

_Success__T = typing.TypeVar('_Success__T')  # <T>
class Success(Try[_Success__T], typing.Generic[_Success__T]):
    def __init__(self, value: _Success__T): ...
    _apply_0__T = typing.TypeVar('_apply_0__T')  # <T>
    _apply_1__T = typing.TypeVar('_apply_1__T')  # <T>
    @typing.overload
    @staticmethod
    def apply(value: _apply_0__T) -> 'Success'[_apply_0__T]: ...
    @typing.overload
    @staticmethod
    def apply(r: scala.Function0[_apply_1__T]) -> Try[_apply_1__T]: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _collect__U = typing.TypeVar('_collect__U')  # <U>
    def collect(self, pf: scala.PartialFunction[_Success__T, _collect__U]) -> Try[_collect__U]: ...
    _copy__T = typing.TypeVar('_copy__T')  # <T>
    def copy(self, value: typing.Any) -> 'Success'[typing.Any]: ...
    _copy$default$1__T = typing.TypeVar('_copy$default$1__T')  # <T>
    def copy$default$1(self) -> typing.Any: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def failed(self) -> Try[java.lang.Throwable]: ...
    def filter(self, p: scala.Function1[_Success__T, typing.Any]) -> Try[_Success__T]: ...
    _flatMap__U = typing.TypeVar('_flatMap__U')  # <U>
    def flatMap(self, f: scala.Function1[_Success__T, Try[_flatMap__U]]) -> Try[_flatMap__U]: ...
    _flatten__U = typing.TypeVar('_flatten__U')  # <U>
    def flatten(self, ev: scala.Predef..less.colon.less[_Success__T, Try[_flatten__U]]) -> Try[_flatten__U]: ...
    _fold__U = typing.TypeVar('_fold__U')  # <U>
    def fold(self, fa: scala.Function1[java.lang.Throwable, _fold__U], fb: scala.Function1[_Success__T, _fold__U]) -> _fold__U: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_Success__T, _foreach__U]) -> None: ...
    def get(self) -> _Success__T: ...
    _getOrElse__U = typing.TypeVar('_getOrElse__U')  # <U>
    def getOrElse(self, default: scala.Function0[_getOrElse__U]) -> _getOrElse__U: ...
    def hashCode(self) -> int: ...
    def isFailure(self) -> bool: ...
    def isSuccess(self) -> bool: ...
    _map__U = typing.TypeVar('_map__U')  # <U>
    def map(self, f: scala.Function1[_Success__T, _map__U]) -> Try[_map__U]: ...
    _orElse__U = typing.TypeVar('_orElse__U')  # <U>
    def orElse(self, default: scala.Function0[Try[_orElse__U]]) -> Try[_orElse__U]: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> str: ...
    _recover__U = typing.TypeVar('_recover__U')  # <U>
    def recover(self, pf: scala.PartialFunction[java.lang.Throwable, _recover__U]) -> Try[_recover__U]: ...
    _recoverWith__U = typing.TypeVar('_recoverWith__U')  # <U>
    def recoverWith(self, pf: scala.PartialFunction[java.lang.Throwable, Try[_recoverWith__U]]) -> Try[_recoverWith__U]: ...
    def toEither(self) -> Either[java.lang.Throwable, _Success__T]: ...
    def toOption(self) -> scala.Option[_Success__T]: ...
    def toString(self) -> str: ...
    _transform__U = typing.TypeVar('_transform__U')  # <U>
    def transform(self, s: scala.Function1[_Success__T, Try[_transform__U]], f: scala.Function1[java.lang.Throwable, Try[_transform__U]]) -> Try[_transform__U]: ...
    _unapply__T = typing.TypeVar('_unapply__T')  # <T>
    @staticmethod
    def unapply(x$0: 'Success'[_unapply__T]) -> scala.Option[_unapply__T]: ...
    def value(self) -> _Success__T: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("scala.util")``.

    DynamicVariable: typing.Type[DynamicVariable]
    Either: typing.Type[Either]
    Failure: typing.Type[Failure]
    Left: typing.Type[Left]
    MurmurHash: typing.Type[MurmurHash]
    Properties: typing.Type[Properties]
    PropertiesTrait: typing.Type[PropertiesTrait]
    Random: typing.Type[Random]
    Right: typing.Type[Right]
    Sorting: typing.Type[Sorting]
    Success: typing.Type[Success]
    Try: typing.Type[Try]
    control: scala.util.control.__module_protocol__
    hashing: scala.util.hashing.__module_protocol__
    matching: scala.util.matching.__module_protocol__
