import com.typesafe.scalalogging
import java.lang
import scala.collection
import scala.collection.generic
import scala.math
import scala.reflect
import scorex.util.encode
import scorex.util.serialization
import supertagged
import typing



class ByteArrayBuilder:
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def append(self, boolean: bool) -> 'ByteArrayBuilder': ...
    @typing.overload
    def append(self, byte: int) -> 'ByteArrayBuilder': ...
    @typing.overload
    def append(self, byteArray: typing.List[int]) -> 'ByteArrayBuilder': ...
    @typing.overload
    def append(self, byteArray: typing.List[int], int: int, int2: int) -> 'ByteArrayBuilder': ...
    @typing.overload
    def append(self, char: str) -> 'ByteArrayBuilder': ...
    @typing.overload
    def append(self, int: int) -> 'ByteArrayBuilder': ...
    @typing.overload
    def append(self, long: int) -> 'ByteArrayBuilder': ...
    @typing.overload
    def append(self, short: int) -> 'ByteArrayBuilder': ...
    def array(self) -> typing.List[int]: ...
    def byteAt(self, int: int) -> int: ...
    def capacity(self) -> int: ...
    def crop(self, int: int) -> None: ...
    def length(self) -> int: ...
    def setLength(self, int: int) -> None: ...
    def toBytes(self) -> typing.List[int]: ...
    def trim(self) -> typing.List[int]: ...

_Extensions__TraversableOps__A = typing.TypeVar('_Extensions__TraversableOps__A')  # <A>
_Extensions__TraversableOps__Source = typing.TypeVar('_Extensions__TraversableOps__Source', bound=scala.collection.Traversable)  # <Source>
class Extensions:
    class ByteOps:
        def __init__(self, b: int): ...
        def b(self) -> int: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def toUByte(self) -> int: ...
    class ByteOps$:
        MODULE$: typing.ClassVar['Extensions.ByteOps.'] = ...
        def __init__(self): ...
        def equals$extension(self, $this: int, x$1: typing.Any) -> bool: ...
        def hashCode$extension(self, $this: int) -> int: ...
        def toUByte$extension(self, $this: int) -> int: ...
    class IntOps:
        def __init__(self, x: int): ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def toByteExact(self) -> int: ...
        def toShortExact(self) -> int: ...
        def x(self) -> int: ...
    class IntOps$:
        MODULE$: typing.ClassVar['Extensions.IntOps.'] = ...
        def __init__(self): ...
        def equals$extension(self, $this: int, x$1: typing.Any) -> bool: ...
        def hashCode$extension(self, $this: int) -> int: ...
        def toByteExact$extension(self, $this: int) -> int: ...
        def toShortExact$extension(self, $this: int) -> int: ...
    class LongOps:
        def __init__(self, x: int): ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def toByteExact(self) -> int: ...
        def toIntExact(self) -> int: ...
        def toShortExact(self) -> int: ...
        def x(self) -> int: ...
    class LongOps$:
        MODULE$: typing.ClassVar['Extensions.LongOps.'] = ...
        def __init__(self): ...
        def equals$extension(self, $this: int, x$1: typing.Any) -> bool: ...
        def hashCode$extension(self, $this: int) -> int: ...
        def toByteExact$extension(self, $this: int) -> int: ...
        def toIntExact$extension(self, $this: int) -> int: ...
        def toShortExact$extension(self, $this: int) -> int: ...
    class ShortOps:
        def __init__(self, x: int): ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def toByteExact(self) -> int: ...
        def x(self) -> int: ...
    class ShortOps$:
        MODULE$: typing.ClassVar['Extensions.ShortOps.'] = ...
        def __init__(self): ...
        def equals$extension(self, $this: int, x$1: typing.Any) -> bool: ...
        def hashCode$extension(self, $this: int) -> int: ...
        def toByteExact$extension(self, $this: int) -> int: ...
    class TraversableOps(typing.Generic[_Extensions__TraversableOps__A, _Extensions__TraversableOps__Source]):
        def __init__(self, xs: _Extensions__TraversableOps__Source): ...
        _cast__B = typing.TypeVar('_cast__B')  # <B>
        def cast(self, evidence$1: scala.reflect.ClassTag[_cast__B], cbf: scala.collection.generic.CanBuildFrom[_Extensions__TraversableOps__Source, _cast__B, _Extensions__TraversableOps__Source]) -> _Extensions__TraversableOps__Source: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def xs(self) -> _Extensions__TraversableOps__Source: ...
    class TraversableOps$:
        MODULE$: typing.ClassVar['Extensions.TraversableOps.'] = ...
        def __init__(self): ...
        _cast$extension__B = typing.TypeVar('_cast$extension__B')  # <B>
        _cast$extension__A = typing.TypeVar('_cast$extension__A')  # <A>
        _cast$extension__Source = typing.TypeVar('_cast$extension__Source', bound=scala.collection.Traversable)  # <Source>
        def cast$extension(self, $this: _cast.extension__Source, evidence$1: scala.reflect.ClassTag[_cast.extension__B], cbf: scala.collection.generic.CanBuildFrom[_cast.extension__Source, _cast.extension__B, _cast.extension__Source]) -> _cast.extension__Source: ...
        _equals$extension__A = typing.TypeVar('_equals$extension__A')  # <A>
        _equals$extension__Source = typing.TypeVar('_equals$extension__Source', bound=scala.collection.Traversable)  # <Source>
        def equals$extension(self, $this: _equals.extension__Source, x$1: typing.Any) -> bool: ...
        _hashCode$extension__A = typing.TypeVar('_hashCode$extension__A')  # <A>
        _hashCode$extension__Source = typing.TypeVar('_hashCode$extension__Source', bound=scala.collection.Traversable)  # <Source>
        def hashCode$extension(self, $this: _hashCode.extension__Source) -> int: ...

class Random:
    @staticmethod
    def randomBytes(howMany: int) -> typing.List[int]: ...
    @staticmethod
    def randomBytes$default$1() -> int: ...

class ScorexEncoding:
    @staticmethod
    def $init$($this: 'ScorexEncoding') -> None: ...
    def encoder(self) -> scorex.util.encode.BytesEncoder: ...
    def scorex$util$ScorexEncoding$_setter_$encoder_$eq(self, x$1: scorex.util.encode.BytesEncoder) -> None: ...

class ScorexLogging(com.typesafe.scalalogging.StrictLogging):
    @staticmethod
    def $init$($this: 'ScorexLogging') -> None: ...
    def log(self) -> com.typesafe.scalalogging.Logger: ...

class package:
    @staticmethod
    def bytesToId(bytes: typing.List[int]) -> java.lang.String: ...
    @staticmethod
    def idToBytes(id: typing.Union[java.lang.String, str]) -> typing.List[int]: ...
    class ByteArrayOps:
        def __init__(self, b: typing.List[int]): ...
        def b(self) -> typing.List[int]: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def toModifierId(self) -> java.lang.String: ...
    class ByteArrayOps$:
        MODULE$: typing.ClassVar['package.ByteArrayOps.'] = ...
        def __init__(self): ...
        def equals$extension(self, $this: typing.List[int], x$1: typing.Any) -> bool: ...
        def hashCode$extension(self, $this: typing.List[int]) -> int: ...
        def toModifierId$extension(self, $this: typing.List[int]) -> java.lang.String: ...
    class ModifierId$(supertagged.package.TaggedType[java.lang.String]):
        MODULE$: typing.ClassVar['package.ModifierId.'] = ...
        def __init__(self): ...
        _$at$at__TagIn = typing.TypeVar('_$at$at__TagIn')  # <TagIn>
        _$at$at__Sub = typing.TypeVar('_$at$at__Sub')  # <Sub>
        _$at$at__C = typing.TypeVar('_$at$at__C')  # <C>
        def $at$at(self, c: _.at.at__C, tagger: supertagged.package.Tagger[_.at.at__TagIn, typing.Union[java.lang.String, str], supertagged.package.TaggedType, _.at.at__Sub, _.at.at__C]) -> typing.Any: ...
        _$bang$at$at__TagIn = typing.TypeVar('_$bang$at$at__TagIn')  # <TagIn>
        _$bang$at$at__Sub = typing.TypeVar('_$bang$at$at__Sub')  # <Sub>
        _$bang$at$at__C = typing.TypeVar('_$bang$at$at__C')  # <C>
        def $bang$at$at(self, c: _.bang.at.at__C, tagger: supertagged.package.Tagger[_.bang.at.at__TagIn, typing.Union[java.lang.String, str], supertagged.package.TaggedType, _.bang.at.at__Sub, _.bang.at.at__C]) -> typing.Any: ...
        _apply__TagIn = typing.TypeVar('_apply__TagIn')  # <TagIn>
        _apply__Sub = typing.TypeVar('_apply__Sub')  # <Sub>
        _apply__C = typing.TypeVar('_apply__C')  # <C>
        def apply(self, c: _apply__C, tagger: supertagged.package.Tagger[_apply__TagIn, typing.Union[java.lang.String, str], supertagged.package.TaggedType, _apply__Sub, _apply__C]) -> typing.Any: ...
        _ordering__U = typing.TypeVar('_ordering__U')  # <U>
        def ordering(self, origin: scala.math.Ordering[typing.Union[java.lang.String, str]]) -> scala.math.Ordering[java.lang.String]: ...
        def raw(self, c: typing.Any) -> typing.Any: ...
        _untag__TagIn = typing.TypeVar('_untag__TagIn')  # <TagIn>
        _untag__Sub = typing.TypeVar('_untag__Sub')  # <Sub>
        _untag__C = typing.TypeVar('_untag__C')  # <C>
        def untag(self, c: _untag__C, tagger: supertagged.package.Tagger[_untag__TagIn, typing.Union[java.lang.String, str], supertagged.package.TaggedType, _untag__Sub, _untag__C]) -> typing.Any: ...
    class ModifierIdOps:
        def __init__(self, m: typing.Union[java.lang.String, str]): ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def m(self) -> java.lang.String: ...
        def toBytes(self) -> typing.List[int]: ...
    class ModifierIdOps$:
        MODULE$: typing.ClassVar['package.ModifierIdOps.'] = ...
        def __init__(self): ...
        def equals$extension(self, $this: typing.Union[java.lang.String, str], x$1: typing.Any) -> bool: ...
        def hashCode$extension(self, $this: typing.Union[java.lang.String, str]) -> int: ...
        def toBytes$extension(self, $this: typing.Union[java.lang.String, str]) -> typing.List[int]: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("scorex.util")``.

    ByteArrayBuilder: typing.Type[ByteArrayBuilder]
    Extensions: typing.Type[Extensions]
    Random: typing.Type[Random]
    ScorexEncoding: typing.Type[ScorexEncoding]
    ScorexLogging: typing.Type[ScorexLogging]
    package: typing.Type[package]
    encode: scorex.util.encode.__module_protocol__
    serialization: scorex.util.serialization.__module_protocol__
