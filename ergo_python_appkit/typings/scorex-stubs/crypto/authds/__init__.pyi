import java.lang
import scala
import scala.collection
import scala.math
import scala.util
import scorex.crypto.authds.avltree
import scorex.crypto.authds.avltree.batch
import scorex.crypto.authds.legacy
import scorex.crypto.authds.legacy.treap
import scorex.crypto.authds.merkle
import scorex.util
import scorex.util.encode
import supertagged
import typing



class Direction: ...

class GoingLeft:
    @staticmethod
    def canEqual(x$1: typing.Any) -> bool: ...
    @staticmethod
    def hashCode() -> int: ...
    @staticmethod
    def productArity() -> int: ...
    @staticmethod
    def productElement(x$1: int) -> typing.Any: ...
    @staticmethod
    def productIterator() -> scala.collection.Iterator[typing.Any]: ...
    @staticmethod
    def productPrefix() -> java.lang.String: ...
    @staticmethod
    def toString() -> java.lang.String: ...

class GoingRight:
    @staticmethod
    def canEqual(x$1: typing.Any) -> bool: ...
    @staticmethod
    def hashCode() -> int: ...
    @staticmethod
    def productArity() -> int: ...
    @staticmethod
    def productElement(x$1: int) -> typing.Any: ...
    @staticmethod
    def productIterator() -> scala.collection.Iterator[typing.Any]: ...
    @staticmethod
    def productPrefix() -> java.lang.String: ...
    @staticmethod
    def toString() -> java.lang.String: ...

class LeafFound:
    @staticmethod
    def canEqual(x$1: typing.Any) -> bool: ...
    @staticmethod
    def hashCode() -> int: ...
    @staticmethod
    def productArity() -> int: ...
    @staticmethod
    def productElement(x$1: int) -> typing.Any: ...
    @staticmethod
    def productIterator() -> scala.collection.Iterator[typing.Any]: ...
    @staticmethod
    def productPrefix() -> java.lang.String: ...
    @staticmethod
    def toString() -> java.lang.String: ...

class LeafNotFound:
    @staticmethod
    def canEqual(x$1: typing.Any) -> bool: ...
    @staticmethod
    def hashCode() -> int: ...
    @staticmethod
    def productArity() -> int: ...
    @staticmethod
    def productElement(x$1: int) -> typing.Any: ...
    @staticmethod
    def productIterator() -> scala.collection.Iterator[typing.Any]: ...
    @staticmethod
    def productPrefix() -> java.lang.String: ...
    @staticmethod
    def toString() -> java.lang.String: ...

class ProofIterator:
    @staticmethod
    def $init$($this: 'ProofIterator') -> None: ...
    def dequeueBalance(self) -> int: ...
    def dequeueDirection(self) -> Direction: ...
    def dequeueKey(self) -> typing.List[int]: ...
    def dequeueLeftLabel(self) -> typing.List[int]: ...
    def dequeueLevel(self) -> scorex.crypto.authds.legacy.treap.Level: ...
    def dequeueNextLeafKey(self) -> typing.List[int]: ...
    def dequeueRightLabel(self) -> typing.List[int]: ...
    def dequeueValue(self) -> typing.List[int]: ...
    def initializeIterator(self) -> None: ...
    def proofSeq(self) -> scala.collection.Seq['TwoPartyProofElement']: ...
    def scorex$crypto$authds$ProofIterator$$i(self) -> int: ...
    def scorex$crypto$authds$ProofIterator$$i_$eq(self, x$1: int) -> None: ...

class TwoPartyDictionary(scorex.util.ScorexEncoding):
    def rootHash(self) -> typing.List[int]: ...
    _run__O = typing.TypeVar('_run__O', bound=scorex.crypto.authds.avltree.batch.Operation)  # <O>
    def run(self, operation: _run__O) -> scala.util.Try['TwoPartyProof']: ...

class TwoPartyProofElement(scorex.util.ScorexEncoding):
    def bytes(self) -> typing.List[int]: ...

class package:
    @staticmethod
    def EmptyByteArray() -> typing.List[int]: ...
    class ADDigest$(supertagged.package.TaggedType[typing.List[int]]):
        MODULE$: typing.ClassVar['package.ADDigest.'] = ...
        def __init__(self): ...
        _$at$at__TagIn = typing.TypeVar('_$at$at__TagIn')  # <TagIn>
        _$at$at__Sub = typing.TypeVar('_$at$at__Sub')  # <Sub>
        _$at$at__C = typing.TypeVar('_$at$at__C')  # <C>
        def $at$at(self, c: _.at.at__C, tagger: supertagged.package.Tagger[_.at.at__TagIn, typing.List[int], supertagged.package.TaggedType, _.at.at__Sub, _.at.at__C]) -> typing.Any: ...
        _$bang$at$at__TagIn = typing.TypeVar('_$bang$at$at__TagIn')  # <TagIn>
        _$bang$at$at__Sub = typing.TypeVar('_$bang$at$at__Sub')  # <Sub>
        _$bang$at$at__C = typing.TypeVar('_$bang$at$at__C')  # <C>
        def $bang$at$at(self, c: _.bang.at.at__C, tagger: supertagged.package.Tagger[_.bang.at.at__TagIn, typing.List[int], supertagged.package.TaggedType, _.bang.at.at__Sub, _.bang.at.at__C]) -> typing.Any: ...
        _apply__TagIn = typing.TypeVar('_apply__TagIn')  # <TagIn>
        _apply__Sub = typing.TypeVar('_apply__Sub')  # <Sub>
        _apply__C = typing.TypeVar('_apply__C')  # <C>
        def apply(self, c: _apply__C, tagger: supertagged.package.Tagger[_apply__TagIn, typing.List[int], supertagged.package.TaggedType, _apply__Sub, _apply__C]) -> typing.Any: ...
        _ordering__U = typing.TypeVar('_ordering__U')  # <U>
        def ordering(self, origin: scala.math.Ordering[typing.List[int]]) -> scala.math.Ordering[typing.List[int]]: ...
        def raw(self, c: typing.Any) -> typing.Any: ...
        _untag__TagIn = typing.TypeVar('_untag__TagIn')  # <TagIn>
        _untag__Sub = typing.TypeVar('_untag__Sub')  # <Sub>
        _untag__C = typing.TypeVar('_untag__C')  # <C>
        def untag(self, c: _untag__C, tagger: supertagged.package.Tagger[_untag__TagIn, typing.List[int], supertagged.package.TaggedType, _untag__Sub, _untag__C]) -> typing.Any: ...
    class ADKey$(supertagged.package.TaggedType[typing.List[int]]):
        MODULE$: typing.ClassVar['package.ADKey.'] = ...
        def __init__(self): ...
        _$at$at__TagIn = typing.TypeVar('_$at$at__TagIn')  # <TagIn>
        _$at$at__Sub = typing.TypeVar('_$at$at__Sub')  # <Sub>
        _$at$at__C = typing.TypeVar('_$at$at__C')  # <C>
        def $at$at(self, c: _.at.at__C, tagger: supertagged.package.Tagger[_.at.at__TagIn, typing.List[int], supertagged.package.TaggedType, _.at.at__Sub, _.at.at__C]) -> typing.Any: ...
        _$bang$at$at__TagIn = typing.TypeVar('_$bang$at$at__TagIn')  # <TagIn>
        _$bang$at$at__Sub = typing.TypeVar('_$bang$at$at__Sub')  # <Sub>
        _$bang$at$at__C = typing.TypeVar('_$bang$at$at__C')  # <C>
        def $bang$at$at(self, c: _.bang.at.at__C, tagger: supertagged.package.Tagger[_.bang.at.at__TagIn, typing.List[int], supertagged.package.TaggedType, _.bang.at.at__Sub, _.bang.at.at__C]) -> typing.Any: ...
        _apply__TagIn = typing.TypeVar('_apply__TagIn')  # <TagIn>
        _apply__Sub = typing.TypeVar('_apply__Sub')  # <Sub>
        _apply__C = typing.TypeVar('_apply__C')  # <C>
        def apply(self, c: _apply__C, tagger: supertagged.package.Tagger[_apply__TagIn, typing.List[int], supertagged.package.TaggedType, _apply__Sub, _apply__C]) -> typing.Any: ...
        _ordering__U = typing.TypeVar('_ordering__U')  # <U>
        def ordering(self, origin: scala.math.Ordering[typing.List[int]]) -> scala.math.Ordering[typing.List[int]]: ...
        def raw(self, c: typing.Any) -> typing.Any: ...
        _untag__TagIn = typing.TypeVar('_untag__TagIn')  # <TagIn>
        _untag__Sub = typing.TypeVar('_untag__Sub')  # <Sub>
        _untag__C = typing.TypeVar('_untag__C')  # <C>
        def untag(self, c: _untag__C, tagger: supertagged.package.Tagger[_untag__TagIn, typing.List[int], supertagged.package.TaggedType, _untag__Sub, _untag__C]) -> typing.Any: ...
    class ADValue$(supertagged.package.TaggedType[typing.List[int]]):
        MODULE$: typing.ClassVar['package.ADValue.'] = ...
        def __init__(self): ...
        _$at$at__TagIn = typing.TypeVar('_$at$at__TagIn')  # <TagIn>
        _$at$at__Sub = typing.TypeVar('_$at$at__Sub')  # <Sub>
        _$at$at__C = typing.TypeVar('_$at$at__C')  # <C>
        def $at$at(self, c: _.at.at__C, tagger: supertagged.package.Tagger[_.at.at__TagIn, typing.List[int], supertagged.package.TaggedType, _.at.at__Sub, _.at.at__C]) -> typing.Any: ...
        _$bang$at$at__TagIn = typing.TypeVar('_$bang$at$at__TagIn')  # <TagIn>
        _$bang$at$at__Sub = typing.TypeVar('_$bang$at$at__Sub')  # <Sub>
        _$bang$at$at__C = typing.TypeVar('_$bang$at$at__C')  # <C>
        def $bang$at$at(self, c: _.bang.at.at__C, tagger: supertagged.package.Tagger[_.bang.at.at__TagIn, typing.List[int], supertagged.package.TaggedType, _.bang.at.at__Sub, _.bang.at.at__C]) -> typing.Any: ...
        _apply__TagIn = typing.TypeVar('_apply__TagIn')  # <TagIn>
        _apply__Sub = typing.TypeVar('_apply__Sub')  # <Sub>
        _apply__C = typing.TypeVar('_apply__C')  # <C>
        def apply(self, c: _apply__C, tagger: supertagged.package.Tagger[_apply__TagIn, typing.List[int], supertagged.package.TaggedType, _apply__Sub, _apply__C]) -> typing.Any: ...
        _ordering__U = typing.TypeVar('_ordering__U')  # <U>
        def ordering(self, origin: scala.math.Ordering[typing.List[int]]) -> scala.math.Ordering[typing.List[int]]: ...
        def raw(self, c: typing.Any) -> typing.Any: ...
        _untag__TagIn = typing.TypeVar('_untag__TagIn')  # <TagIn>
        _untag__Sub = typing.TypeVar('_untag__Sub')  # <Sub>
        _untag__C = typing.TypeVar('_untag__C')  # <C>
        def untag(self, c: _untag__C, tagger: supertagged.package.Tagger[_untag__TagIn, typing.List[int], supertagged.package.TaggedType, _untag__Sub, _untag__C]) -> typing.Any: ...
    class Balance$(supertagged.package.TaggedType[typing.Any]):
        MODULE$: typing.ClassVar['package.Balance.'] = ...
        def __init__(self): ...
        _$at$at__TagIn = typing.TypeVar('_$at$at__TagIn')  # <TagIn>
        _$at$at__Sub = typing.TypeVar('_$at$at__Sub')  # <Sub>
        _$at$at__C = typing.TypeVar('_$at$at__C')  # <C>
        def $at$at(self, c: _.at.at__C, tagger: supertagged.package.Tagger[_.at.at__TagIn, typing.Any, supertagged.package.TaggedType, _.at.at__Sub, _.at.at__C]) -> typing.Any: ...
        _$bang$at$at__TagIn = typing.TypeVar('_$bang$at$at__TagIn')  # <TagIn>
        _$bang$at$at__Sub = typing.TypeVar('_$bang$at$at__Sub')  # <Sub>
        _$bang$at$at__C = typing.TypeVar('_$bang$at$at__C')  # <C>
        def $bang$at$at(self, c: _.bang.at.at__C, tagger: supertagged.package.Tagger[_.bang.at.at__TagIn, typing.Any, supertagged.package.TaggedType, _.bang.at.at__Sub, _.bang.at.at__C]) -> typing.Any: ...
        _apply__TagIn = typing.TypeVar('_apply__TagIn')  # <TagIn>
        _apply__Sub = typing.TypeVar('_apply__Sub')  # <Sub>
        _apply__C = typing.TypeVar('_apply__C')  # <C>
        def apply(self, c: _apply__C, tagger: supertagged.package.Tagger[_apply__TagIn, typing.Any, supertagged.package.TaggedType, _apply__Sub, _apply__C]) -> typing.Any: ...
        _ordering__U = typing.TypeVar('_ordering__U')  # <U>
        def ordering(self, origin: scala.math.Ordering[typing.Any]) -> scala.math.Ordering[typing.Any]: ...
        def raw(self, c: typing.Any) -> typing.Any: ...
        _untag__TagIn = typing.TypeVar('_untag__TagIn')  # <TagIn>
        _untag__Sub = typing.TypeVar('_untag__Sub')  # <Sub>
        _untag__C = typing.TypeVar('_untag__C')  # <C>
        def untag(self, c: _untag__C, tagger: supertagged.package.Tagger[_untag__TagIn, typing.Any, supertagged.package.TaggedType, _untag__Sub, _untag__C]) -> typing.Any: ...
    class LeafData$(supertagged.package.TaggedType[typing.List[int]]):
        MODULE$: typing.ClassVar['package.LeafData.'] = ...
        def __init__(self): ...
        _$at$at__TagIn = typing.TypeVar('_$at$at__TagIn')  # <TagIn>
        _$at$at__Sub = typing.TypeVar('_$at$at__Sub')  # <Sub>
        _$at$at__C = typing.TypeVar('_$at$at__C')  # <C>
        def $at$at(self, c: _.at.at__C, tagger: supertagged.package.Tagger[_.at.at__TagIn, typing.List[int], supertagged.package.TaggedType, _.at.at__Sub, _.at.at__C]) -> typing.Any: ...
        _$bang$at$at__TagIn = typing.TypeVar('_$bang$at$at__TagIn')  # <TagIn>
        _$bang$at$at__Sub = typing.TypeVar('_$bang$at$at__Sub')  # <Sub>
        _$bang$at$at__C = typing.TypeVar('_$bang$at$at__C')  # <C>
        def $bang$at$at(self, c: _.bang.at.at__C, tagger: supertagged.package.Tagger[_.bang.at.at__TagIn, typing.List[int], supertagged.package.TaggedType, _.bang.at.at__Sub, _.bang.at.at__C]) -> typing.Any: ...
        _apply__TagIn = typing.TypeVar('_apply__TagIn')  # <TagIn>
        _apply__Sub = typing.TypeVar('_apply__Sub')  # <Sub>
        _apply__C = typing.TypeVar('_apply__C')  # <C>
        def apply(self, c: _apply__C, tagger: supertagged.package.Tagger[_apply__TagIn, typing.List[int], supertagged.package.TaggedType, _apply__Sub, _apply__C]) -> typing.Any: ...
        _ordering__U = typing.TypeVar('_ordering__U')  # <U>
        def ordering(self, origin: scala.math.Ordering[typing.List[int]]) -> scala.math.Ordering[typing.List[int]]: ...
        def raw(self, c: typing.Any) -> typing.Any: ...
        _untag__TagIn = typing.TypeVar('_untag__TagIn')  # <TagIn>
        _untag__Sub = typing.TypeVar('_untag__Sub')  # <Sub>
        _untag__C = typing.TypeVar('_untag__C')  # <C>
        def untag(self, c: _untag__C, tagger: supertagged.package.Tagger[_untag__TagIn, typing.List[int], supertagged.package.TaggedType, _untag__Sub, _untag__C]) -> typing.Any: ...
    class SerializedAdProof$(supertagged.package.TaggedType[typing.List[int]]):
        MODULE$: typing.ClassVar['package.SerializedAdProof.'] = ...
        def __init__(self): ...
        _$at$at__TagIn = typing.TypeVar('_$at$at__TagIn')  # <TagIn>
        _$at$at__Sub = typing.TypeVar('_$at$at__Sub')  # <Sub>
        _$at$at__C = typing.TypeVar('_$at$at__C')  # <C>
        def $at$at(self, c: _.at.at__C, tagger: supertagged.package.Tagger[_.at.at__TagIn, typing.List[int], supertagged.package.TaggedType, _.at.at__Sub, _.at.at__C]) -> typing.Any: ...
        _$bang$at$at__TagIn = typing.TypeVar('_$bang$at$at__TagIn')  # <TagIn>
        _$bang$at$at__Sub = typing.TypeVar('_$bang$at$at__Sub')  # <Sub>
        _$bang$at$at__C = typing.TypeVar('_$bang$at$at__C')  # <C>
        def $bang$at$at(self, c: _.bang.at.at__C, tagger: supertagged.package.Tagger[_.bang.at.at__TagIn, typing.List[int], supertagged.package.TaggedType, _.bang.at.at__Sub, _.bang.at.at__C]) -> typing.Any: ...
        _apply__TagIn = typing.TypeVar('_apply__TagIn')  # <TagIn>
        _apply__Sub = typing.TypeVar('_apply__Sub')  # <Sub>
        _apply__C = typing.TypeVar('_apply__C')  # <C>
        def apply(self, c: _apply__C, tagger: supertagged.package.Tagger[_apply__TagIn, typing.List[int], supertagged.package.TaggedType, _apply__Sub, _apply__C]) -> typing.Any: ...
        _ordering__U = typing.TypeVar('_ordering__U')  # <U>
        def ordering(self, origin: scala.math.Ordering[typing.List[int]]) -> scala.math.Ordering[typing.List[int]]: ...
        def raw(self, c: typing.Any) -> typing.Any: ...
        _untag__TagIn = typing.TypeVar('_untag__TagIn')  # <TagIn>
        _untag__Sub = typing.TypeVar('_untag__Sub')  # <Sub>
        _untag__C = typing.TypeVar('_untag__C')  # <C>
        def untag(self, c: _untag__C, tagger: supertagged.package.Tagger[_untag__TagIn, typing.List[int], supertagged.package.TaggedType, _untag__Sub, _untag__C]) -> typing.Any: ...
    class Side$(supertagged.package.TaggedType[typing.Any]):
        MODULE$: typing.ClassVar['package.Side.'] = ...
        def __init__(self): ...
        _$at$at__TagIn = typing.TypeVar('_$at$at__TagIn')  # <TagIn>
        _$at$at__Sub = typing.TypeVar('_$at$at__Sub')  # <Sub>
        _$at$at__C = typing.TypeVar('_$at$at__C')  # <C>
        def $at$at(self, c: _.at.at__C, tagger: supertagged.package.Tagger[_.at.at__TagIn, typing.Any, supertagged.package.TaggedType, _.at.at__Sub, _.at.at__C]) -> typing.Any: ...
        _$bang$at$at__TagIn = typing.TypeVar('_$bang$at$at__TagIn')  # <TagIn>
        _$bang$at$at__Sub = typing.TypeVar('_$bang$at$at__Sub')  # <Sub>
        _$bang$at$at__C = typing.TypeVar('_$bang$at$at__C')  # <C>
        def $bang$at$at(self, c: _.bang.at.at__C, tagger: supertagged.package.Tagger[_.bang.at.at__TagIn, typing.Any, supertagged.package.TaggedType, _.bang.at.at__Sub, _.bang.at.at__C]) -> typing.Any: ...
        _apply__TagIn = typing.TypeVar('_apply__TagIn')  # <TagIn>
        _apply__Sub = typing.TypeVar('_apply__Sub')  # <Sub>
        _apply__C = typing.TypeVar('_apply__C')  # <C>
        def apply(self, c: _apply__C, tagger: supertagged.package.Tagger[_apply__TagIn, typing.Any, supertagged.package.TaggedType, _apply__Sub, _apply__C]) -> typing.Any: ...
        _ordering__U = typing.TypeVar('_ordering__U')  # <U>
        def ordering(self, origin: scala.math.Ordering[typing.Any]) -> scala.math.Ordering[typing.Any]: ...
        def raw(self, c: typing.Any) -> typing.Any: ...
        _untag__TagIn = typing.TypeVar('_untag__TagIn')  # <TagIn>
        _untag__Sub = typing.TypeVar('_untag__Sub')  # <Sub>
        _untag__C = typing.TypeVar('_untag__C')  # <C>
        def untag(self, c: _untag__C, tagger: supertagged.package.Tagger[_untag__TagIn, typing.Any, supertagged.package.TaggedType, _untag__Sub, _untag__C]) -> typing.Any: ...

class AVLProofElement(TwoPartyProofElement): ...

class SLTProofElement(TwoPartyProofElement): ...

class TwoPartyProof(ProofIterator):
    @staticmethod
    def $init$($this: 'TwoPartyProof') -> None: ...
    def key(self) -> typing.List[int]: ...
    def proofSeq(self) -> scala.collection.Seq[TwoPartyProofElement]: ...
    @typing.overload
    def verify(self, digest: typing.List[int], updateFn: scala.Function1[scala.Option[typing.List[int]], scala.util.Try[scala.Option[typing.List[int]]]]) -> scala.Option[typing.List[int]]: ...
    @typing.overload
    def verify(self, digest: typing.List[int], modification: scorex.crypto.authds.avltree.batch.Modification) -> scala.Option[typing.List[int]]: ...

class WTProofElement(TwoPartyProofElement): ...

class Key(WTProofElement, AVLProofElement, SLTProofElement):
    @staticmethod
    def $init$($this: 'Key') -> None: ...
    def bytes(self) -> typing.List[int]: ...
    def e(self) -> typing.List[int]: ...
    def scorex$crypto$authds$Key$_setter_$bytes_$eq(self, x$1: typing.List[int]) -> None: ...
    def toString(self) -> java.lang.String: ...

class ProofBalance(AVLProofElement, scala.Product, scala.Serializable):
    def __init__(self, e: int): ...
    _andThen__A = typing.TypeVar('_andThen__A')  # <A>
    @staticmethod
    def andThen(g: scala.Function1['ProofBalance', _andThen__A]) -> scala.Function1[typing.Any, _andThen__A]: ...
    @staticmethod
    def apply(e: int) -> 'ProofBalance': ...
    def bytes(self) -> typing.List[int]: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    @staticmethod
    def compose(g: scala.Function1[_compose__A, typing.Any]) -> scala.Function1[_compose__A, 'ProofBalance']: ...
    def copy(self, e: int) -> 'ProofBalance': ...
    def copy$default$1(self) -> int: ...
    def e(self) -> int: ...
    def encoder(self) -> scorex.util.encode.BytesEncoder: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def scorex$util$ScorexEncoding$_setter_$encoder_$eq(self, x$1: scorex.util.encode.BytesEncoder) -> None: ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def unapply(x$0: 'ProofBalance') -> scala.Option[typing.Any]: ...

class ProofDirection(WTProofElement, AVLProofElement, scala.Product, scala.Serializable):
    def __init__(self, direction: Direction): ...
    _andThen__A = typing.TypeVar('_andThen__A')  # <A>
    @staticmethod
    def andThen(g: scala.Function1['ProofDirection', _andThen__A]) -> scala.Function1[Direction, _andThen__A]: ...
    @staticmethod
    def apply(direction: Direction) -> 'ProofDirection': ...
    def bytes(self) -> typing.List[int]: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    @staticmethod
    def compose(g: scala.Function1[_compose__A, Direction]) -> scala.Function1[_compose__A, 'ProofDirection']: ...
    def copy(self, direction: Direction) -> 'ProofDirection': ...
    def copy$default$1(self) -> Direction: ...
    def direction(self) -> Direction: ...
    def encoder(self) -> scorex.util.encode.BytesEncoder: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def isLeaf(self) -> bool: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def scorex$util$ScorexEncoding$_setter_$encoder_$eq(self, x$1: scorex.util.encode.BytesEncoder) -> None: ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def unapply(x$0: 'ProofDirection') -> scala.Option[Direction]: ...

class ProofLabel(WTProofElement, AVLProofElement, SLTProofElement):
    @staticmethod
    def $init$($this: 'ProofLabel') -> None: ...
    def bytes(self) -> typing.List[int]: ...
    def e(self) -> typing.List[int]: ...
    def scorex$crypto$authds$ProofLabel$_setter_$bytes_$eq(self, x$1: typing.List[int]) -> None: ...
    def toString(self) -> java.lang.String: ...

class ProofLevel(WTProofElement, AVLProofElement, SLTProofElement, scala.Product, scala.Serializable):
    def __init__(self, e: scorex.crypto.authds.legacy.treap.Level): ...
    _andThen__A = typing.TypeVar('_andThen__A')  # <A>
    @staticmethod
    def andThen(g: scala.Function1['ProofLevel', _andThen__A]) -> scala.Function1[scorex.crypto.authds.legacy.treap.Level, _andThen__A]: ...
    @staticmethod
    def apply(e: scorex.crypto.authds.legacy.treap.Level) -> 'ProofLevel': ...
    def bytes(self) -> typing.List[int]: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    @staticmethod
    def compose(g: scala.Function1[_compose__A, scorex.crypto.authds.legacy.treap.Level]) -> scala.Function1[_compose__A, 'ProofLevel']: ...
    def copy(self, e: scorex.crypto.authds.legacy.treap.Level) -> 'ProofLevel': ...
    def copy$default$1(self) -> scorex.crypto.authds.legacy.treap.Level: ...
    def e(self) -> scorex.crypto.authds.legacy.treap.Level: ...
    def encoder(self) -> scorex.util.encode.BytesEncoder: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def scorex$util$ScorexEncoding$_setter_$encoder_$eq(self, x$1: scorex.util.encode.BytesEncoder) -> None: ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def unapply(x$0: 'ProofLevel') -> scala.Option[scorex.crypto.authds.legacy.treap.Level]: ...

class ProofValue(WTProofElement, AVLProofElement, SLTProofElement, scala.Product, scala.Serializable):
    def __init__(self, e: typing.List[int]): ...
    _andThen__A = typing.TypeVar('_andThen__A')  # <A>
    @staticmethod
    def andThen(g: scala.Function1['ProofValue', _andThen__A]) -> scala.Function1[typing.List[int], _andThen__A]: ...
    @staticmethod
    def apply(e: typing.List[int]) -> 'ProofValue': ...
    def bytes(self) -> typing.List[int]: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    @staticmethod
    def compose(g: scala.Function1[_compose__A, typing.List[int]]) -> scala.Function1[_compose__A, 'ProofValue']: ...
    def copy(self, e: typing.List[int]) -> 'ProofValue': ...
    def copy$default$1(self) -> typing.List[int]: ...
    def e(self) -> typing.List[int]: ...
    def encoder(self) -> scorex.util.encode.BytesEncoder: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def scorex$util$ScorexEncoding$_setter_$encoder_$eq(self, x$1: scorex.util.encode.BytesEncoder) -> None: ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def unapply(x$0: 'ProofValue') -> scala.Option[typing.List[int]]: ...

class ProofKey(Key, scala.Product, scala.Serializable):
    def __init__(self, e: typing.List[int]): ...
    _andThen__A = typing.TypeVar('_andThen__A')  # <A>
    @staticmethod
    def andThen(g: scala.Function1['ProofKey', _andThen__A]) -> scala.Function1[typing.List[int], _andThen__A]: ...
    @staticmethod
    def apply(e: typing.List[int]) -> 'ProofKey': ...
    def bytes(self) -> typing.List[int]: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    @staticmethod
    def compose(g: scala.Function1[_compose__A, typing.List[int]]) -> scala.Function1[_compose__A, 'ProofKey']: ...
    def copy(self, e: typing.List[int]) -> 'ProofKey': ...
    def copy$default$1(self) -> typing.List[int]: ...
    def e(self) -> typing.List[int]: ...
    def encoder(self) -> scorex.util.encode.BytesEncoder: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def scorex$crypto$authds$Key$_setter_$bytes_$eq(self, x$1: typing.List[int]) -> None: ...
    def scorex$util$ScorexEncoding$_setter_$encoder_$eq(self, x$1: scorex.util.encode.BytesEncoder) -> None: ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def unapply(x$0: 'ProofKey') -> scala.Option[typing.List[int]]: ...

class ProofLeftLabel(ProofLabel, scala.Product, scala.Serializable):
    def __init__(self, e: typing.List[int]): ...
    _andThen__A = typing.TypeVar('_andThen__A')  # <A>
    @staticmethod
    def andThen(g: scala.Function1['ProofLeftLabel', _andThen__A]) -> scala.Function1[typing.List[int], _andThen__A]: ...
    @staticmethod
    def apply(e: typing.List[int]) -> 'ProofLeftLabel': ...
    def bytes(self) -> typing.List[int]: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    @staticmethod
    def compose(g: scala.Function1[_compose__A, typing.List[int]]) -> scala.Function1[_compose__A, 'ProofLeftLabel']: ...
    def copy(self, e: typing.List[int]) -> 'ProofLeftLabel': ...
    def copy$default$1(self) -> typing.List[int]: ...
    def e(self) -> typing.List[int]: ...
    def encoder(self) -> scorex.util.encode.BytesEncoder: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def scorex$crypto$authds$ProofLabel$_setter_$bytes_$eq(self, x$1: typing.List[int]) -> None: ...
    def scorex$util$ScorexEncoding$_setter_$encoder_$eq(self, x$1: scorex.util.encode.BytesEncoder) -> None: ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def unapply(x$0: 'ProofLeftLabel') -> scala.Option[typing.List[int]]: ...

class ProofNextLeafKey(Key, scala.Product, scala.Serializable):
    def __init__(self, e: typing.List[int]): ...
    _andThen__A = typing.TypeVar('_andThen__A')  # <A>
    @staticmethod
    def andThen(g: scala.Function1['ProofNextLeafKey', _andThen__A]) -> scala.Function1[typing.List[int], _andThen__A]: ...
    @staticmethod
    def apply(e: typing.List[int]) -> 'ProofNextLeafKey': ...
    def bytes(self) -> typing.List[int]: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    @staticmethod
    def compose(g: scala.Function1[_compose__A, typing.List[int]]) -> scala.Function1[_compose__A, 'ProofNextLeafKey']: ...
    def copy(self, e: typing.List[int]) -> 'ProofNextLeafKey': ...
    def copy$default$1(self) -> typing.List[int]: ...
    def e(self) -> typing.List[int]: ...
    def encoder(self) -> scorex.util.encode.BytesEncoder: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def scorex$crypto$authds$Key$_setter_$bytes_$eq(self, x$1: typing.List[int]) -> None: ...
    def scorex$util$ScorexEncoding$_setter_$encoder_$eq(self, x$1: scorex.util.encode.BytesEncoder) -> None: ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def unapply(x$0: 'ProofNextLeafKey') -> scala.Option[typing.List[int]]: ...

class ProofRightLabel(ProofLabel, scala.Product, scala.Serializable):
    def __init__(self, e: typing.List[int]): ...
    _andThen__A = typing.TypeVar('_andThen__A')  # <A>
    @staticmethod
    def andThen(g: scala.Function1['ProofRightLabel', _andThen__A]) -> scala.Function1[typing.List[int], _andThen__A]: ...
    @staticmethod
    def apply(e: typing.List[int]) -> 'ProofRightLabel': ...
    def bytes(self) -> typing.List[int]: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    @staticmethod
    def compose(g: scala.Function1[_compose__A, typing.List[int]]) -> scala.Function1[_compose__A, 'ProofRightLabel']: ...
    def copy(self, e: typing.List[int]) -> 'ProofRightLabel': ...
    def copy$default$1(self) -> typing.List[int]: ...
    def e(self) -> typing.List[int]: ...
    def encoder(self) -> scorex.util.encode.BytesEncoder: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def scorex$crypto$authds$ProofLabel$_setter_$bytes_$eq(self, x$1: typing.List[int]) -> None: ...
    def scorex$util$ScorexEncoding$_setter_$encoder_$eq(self, x$1: scorex.util.encode.BytesEncoder) -> None: ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def unapply(x$0: 'ProofRightLabel') -> scala.Option[typing.List[int]]: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("scorex.crypto.authds")``.

    AVLProofElement: typing.Type[AVLProofElement]
    Direction: typing.Type[Direction]
    GoingLeft: typing.Type[GoingLeft]
    GoingRight: typing.Type[GoingRight]
    Key: typing.Type[Key]
    LeafFound: typing.Type[LeafFound]
    LeafNotFound: typing.Type[LeafNotFound]
    ProofBalance: typing.Type[ProofBalance]
    ProofDirection: typing.Type[ProofDirection]
    ProofIterator: typing.Type[ProofIterator]
    ProofKey: typing.Type[ProofKey]
    ProofLabel: typing.Type[ProofLabel]
    ProofLeftLabel: typing.Type[ProofLeftLabel]
    ProofLevel: typing.Type[ProofLevel]
    ProofNextLeafKey: typing.Type[ProofNextLeafKey]
    ProofRightLabel: typing.Type[ProofRightLabel]
    ProofValue: typing.Type[ProofValue]
    SLTProofElement: typing.Type[SLTProofElement]
    TwoPartyDictionary: typing.Type[TwoPartyDictionary]
    TwoPartyProof: typing.Type[TwoPartyProof]
    TwoPartyProofElement: typing.Type[TwoPartyProofElement]
    WTProofElement: typing.Type[WTProofElement]
    package: typing.Type[package]
    avltree: scorex.crypto.authds.avltree.__module_protocol__
    legacy: scorex.crypto.authds.legacy.__module_protocol__
    merkle: scorex.crypto.authds.merkle.__module_protocol__
