import java.lang
import scala
import scala.collection
import scala.util
import scorex.crypto.authds.avltree.batch
import scorex.crypto.hash
import typing



_BatchAVLProverManifest__D = typing.TypeVar('_BatchAVLProverManifest__D', bound=typing.List[int])  # <D>
_BatchAVLProverManifest__HF = typing.TypeVar('_BatchAVLProverManifest__HF', bound=scorex.crypto.hash.CryptographicHash)  # <HF>
class BatchAVLProverManifest(scala.Product, scala.Serializable, typing.Generic[_BatchAVLProverManifest__D, _BatchAVLProverManifest__HF]):
    def __init__(self, keyLength: int, valueLengthOpt: scala.Option[typing.Any], rootAndHeight: scala.Tuple2[scorex.crypto.authds.avltree.batch.ProverNodes[_BatchAVLProverManifest__D], typing.Any]): ...
    _apply__D = typing.TypeVar('_apply__D', bound=typing.List[int])  # <D>
    _apply__HF = typing.TypeVar('_apply__HF', bound=scorex.crypto.hash.CryptographicHash)  # <HF>
    @staticmethod
    def apply(keyLength: int, valueLengthOpt: scala.Option[typing.Any], rootAndHeight: scala.Tuple2[scorex.crypto.authds.avltree.batch.ProverNodes[_apply__D], typing.Any]) -> 'BatchAVLProverManifest'[_apply__D, _apply__HF]: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _copy__D = typing.TypeVar('_copy__D', bound=typing.List[int])  # <D>
    _copy__HF = typing.TypeVar('_copy__HF', bound=scorex.crypto.hash.CryptographicHash)  # <HF>
    def copy(self, keyLength: int, valueLengthOpt: scala.Option[typing.Any], rootAndHeight: scala.Tuple2[scorex.crypto.authds.avltree.batch.ProverNodes[typing.List[int]], typing.Any]) -> 'BatchAVLProverManifest'[typing.List[int], scorex.crypto.hash.CryptographicHash]: ...
    _copy$default$1__D = typing.TypeVar('_copy$default$1__D', bound=typing.List[int])  # <D>
    _copy$default$1__HF = typing.TypeVar('_copy$default$1__HF', bound=scorex.crypto.hash.CryptographicHash)  # <HF>
    def copy$default$1(self) -> int: ...
    _copy$default$2__D = typing.TypeVar('_copy$default$2__D', bound=typing.List[int])  # <D>
    _copy$default$2__HF = typing.TypeVar('_copy$default$2__HF', bound=scorex.crypto.hash.CryptographicHash)  # <HF>
    def copy$default$2(self) -> scala.Option[typing.Any]: ...
    _copy$default$3__D = typing.TypeVar('_copy$default$3__D', bound=typing.List[int])  # <D>
    _copy$default$3__HF = typing.TypeVar('_copy$default$3__HF', bound=scorex.crypto.hash.CryptographicHash)  # <HF>
    def copy$default$3(self) -> scala.Tuple2[scorex.crypto.authds.avltree.batch.ProverNodes[typing.List[int]], typing.Any]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def keyLength(self) -> int: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def rootAndHeight(self) -> scala.Tuple2[scorex.crypto.authds.avltree.batch.ProverNodes[_BatchAVLProverManifest__D], typing.Any]: ...
    def toString(self) -> java.lang.String: ...
    _unapply__D = typing.TypeVar('_unapply__D', bound=typing.List[int])  # <D>
    _unapply__HF = typing.TypeVar('_unapply__HF', bound=scorex.crypto.hash.CryptographicHash)  # <HF>
    @staticmethod
    def unapply(x$0: 'BatchAVLProverManifest'[_unapply__D, _unapply__HF]) -> scala.Option[scala.Tuple3[typing.Any, scala.Option[typing.Any], scala.Tuple2[scorex.crypto.authds.avltree.batch.ProverNodes[_unapply__D], typing.Any]]]: ...
    def valueLengthOpt(self) -> scala.Option[typing.Any]: ...

_BatchAVLProverSerializer__D = typing.TypeVar('_BatchAVLProverSerializer__D', bound=typing.List[int])  # <D>
_BatchAVLProverSerializer__HF = typing.TypeVar('_BatchAVLProverSerializer__HF', bound=scorex.crypto.hash.CryptographicHash)  # <HF>
class BatchAVLProverSerializer(typing.Generic[_BatchAVLProverSerializer__D, _BatchAVLProverSerializer__HF]):
    def __init__(self, hf: _BatchAVLProverSerializer__HF): ...
    def combine(self, sliced: scala.Tuple2[BatchAVLProverManifest[_BatchAVLProverSerializer__D, _BatchAVLProverSerializer__HF], scala.collection.Seq['BatchAVLProverSubtree'[_BatchAVLProverSerializer__D, _BatchAVLProverSerializer__HF]]]) -> scala.util.Try[scorex.crypto.authds.avltree.batch.BatchAVLProver[_BatchAVLProverSerializer__D, _BatchAVLProverSerializer__HF]]: ...
    def hf(self) -> _BatchAVLProverSerializer__HF: ...
    def manifestFromBytes(self, bytes: typing.List[int]) -> scala.util.Try[BatchAVLProverManifest[_BatchAVLProverSerializer__D, _BatchAVLProverSerializer__HF]]: ...
    def manifestToBytes(self, manifest: BatchAVLProverManifest[_BatchAVLProverSerializer__D, _BatchAVLProverSerializer__HF]) -> typing.List[int]: ...
    def nodesFromBytes(self, bytesIn: typing.List[int], keyLength: int) -> scala.util.Try[scorex.crypto.authds.avltree.batch.ProverNodes[_BatchAVLProverSerializer__D]]: ...
    def nodesToBytes(self, obj: scorex.crypto.authds.avltree.batch.ProverNodes[_BatchAVLProverSerializer__D]) -> typing.List[int]: ...
    @typing.overload
    def slice(self, tree: scorex.crypto.authds.avltree.batch.BatchAVLProver[_BatchAVLProverSerializer__D, _BatchAVLProverSerializer__HF]) -> scala.Tuple2[BatchAVLProverManifest[_BatchAVLProverSerializer__D, _BatchAVLProverSerializer__HF], scala.collection.Seq['BatchAVLProverSubtree'[_BatchAVLProverSerializer__D, _BatchAVLProverSerializer__HF]]]: ...
    @typing.overload
    def slice(self, tree: scorex.crypto.authds.avltree.batch.BatchAVLProver[_BatchAVLProverSerializer__D, _BatchAVLProverSerializer__HF], subtreeDepth: int) -> scala.Tuple2[BatchAVLProverManifest[_BatchAVLProverSerializer__D, _BatchAVLProverSerializer__HF], scala.collection.Seq['BatchAVLProverSubtree'[_BatchAVLProverSerializer__D, _BatchAVLProverSerializer__HF]]]: ...
    def subtreeFromBytes(self, b: typing.List[int], kl: int) -> scala.util.Try['BatchAVLProverSubtree'[_BatchAVLProverSerializer__D, _BatchAVLProverSerializer__HF]]: ...
    def subtreeToBytes(self, t: 'BatchAVLProverSubtree'[_BatchAVLProverSerializer__D, _BatchAVLProverSerializer__HF]) -> typing.List[int]: ...

_BatchAVLProverSubtree__D = typing.TypeVar('_BatchAVLProverSubtree__D', bound=typing.List[int])  # <D>
_BatchAVLProverSubtree__HF = typing.TypeVar('_BatchAVLProverSubtree__HF', bound=scorex.crypto.hash.CryptographicHash)  # <HF>
class BatchAVLProverSubtree(scala.Product, scala.Serializable, typing.Generic[_BatchAVLProverSubtree__D, _BatchAVLProverSubtree__HF]):
    def __init__(self, subtreeTop: scorex.crypto.authds.avltree.batch.ProverNodes[_BatchAVLProverSubtree__D]): ...
    _apply__D = typing.TypeVar('_apply__D', bound=typing.List[int])  # <D>
    _apply__HF = typing.TypeVar('_apply__HF', bound=scorex.crypto.hash.CryptographicHash)  # <HF>
    @staticmethod
    def apply(subtreeTop: scorex.crypto.authds.avltree.batch.ProverNodes[_apply__D]) -> 'BatchAVLProverSubtree'[_apply__D, _apply__HF]: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _copy__D = typing.TypeVar('_copy__D', bound=typing.List[int])  # <D>
    _copy__HF = typing.TypeVar('_copy__HF', bound=scorex.crypto.hash.CryptographicHash)  # <HF>
    def copy(self, subtreeTop: scorex.crypto.authds.avltree.batch.ProverNodes[typing.List[int]]) -> 'BatchAVLProverSubtree'[typing.List[int], scorex.crypto.hash.CryptographicHash]: ...
    _copy$default$1__D = typing.TypeVar('_copy$default$1__D', bound=typing.List[int])  # <D>
    _copy$default$1__HF = typing.TypeVar('_copy$default$1__HF', bound=scorex.crypto.hash.CryptographicHash)  # <HF>
    def copy$default$1(self) -> scorex.crypto.authds.avltree.batch.ProverNodes[typing.List[int]]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def subtreeTop(self) -> scorex.crypto.authds.avltree.batch.ProverNodes[_BatchAVLProverSubtree__D]: ...
    def toString(self) -> java.lang.String: ...
    _unapply__D = typing.TypeVar('_unapply__D', bound=typing.List[int])  # <D>
    _unapply__HF = typing.TypeVar('_unapply__HF', bound=scorex.crypto.hash.CryptographicHash)  # <HF>
    @staticmethod
    def unapply(x$0: 'BatchAVLProverSubtree'[_unapply__D, _unapply__HF]) -> scala.Option[scorex.crypto.authds.avltree.batch.ProverNodes[_unapply__D]]: ...

_ProxyInternalNode__D = typing.TypeVar('_ProxyInternalNode__D', bound=typing.List[int])  # <D>
class ProxyInternalNode(scorex.crypto.authds.avltree.batch.InternalProverNode[_ProxyInternalNode__D], typing.Generic[_ProxyInternalNode__D]):
    def __init__(self, pk: typing.List[int], selfLabelOpt: scala.Option[_ProxyInternalNode__D], leftLabel: _ProxyInternalNode__D, rightLabel: _ProxyInternalNode__D, pb: int, phf: scorex.crypto.hash.CryptographicHash[_ProxyInternalNode__D]): ...
    _apply__D = typing.TypeVar('_apply__D', bound=typing.List[int])  # <D>
    @staticmethod
    def apply(node: scorex.crypto.authds.avltree.batch.InternalProverNode[_apply__D], phf: scorex.crypto.hash.CryptographicHash[_apply__D]) -> 'ProxyInternalNode'[_apply__D]: ...
    def computeLabel(self) -> _ProxyInternalNode__D: ...
    def isEmpty(self) -> bool: ...
    def label(self) -> _ProxyInternalNode__D: ...
    def leftLabel(self) -> _ProxyInternalNode__D: ...
    def mutate(self, n: scorex.crypto.authds.avltree.batch.ProverNodes[_ProxyInternalNode__D]) -> None: ...
    def pb(self) -> int: ...
    def pb_$eq(self, x$1: int) -> None: ...
    def phf(self) -> scorex.crypto.hash.CryptographicHash[_ProxyInternalNode__D]: ...
    def pk(self) -> typing.List[int]: ...
    def pk_$eq(self, x$1: typing.List[int]) -> None: ...
    def rightLabel(self) -> _ProxyInternalNode__D: ...
    def selfLabelOpt(self) -> scala.Option[_ProxyInternalNode__D]: ...
    def toString(self) -> java.lang.String: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("scorex.crypto.authds.avltree.batch.serialization")``.

    BatchAVLProverManifest: typing.Type[BatchAVLProverManifest]
    BatchAVLProverSerializer: typing.Type[BatchAVLProverSerializer]
    BatchAVLProverSubtree: typing.Type[BatchAVLProverSubtree]
    ProxyInternalNode: typing.Type[ProxyInternalNode]
