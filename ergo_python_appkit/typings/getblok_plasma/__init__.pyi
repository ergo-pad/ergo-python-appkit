import getblok_plasma.collections
import org.ergoplatform.appkit
import scala
import scala.collection
import scorex.crypto.authds.avltree.batch
import sigmastate
import typing



_ByteConversion__T = typing.TypeVar('_ByteConversion__T')  # <T>
class ByteConversion(typing.Generic[_ByteConversion__T]):
    @staticmethod
    def $init$($this: 'ByteConversion') -> None: ...
    def convertFromBytes(self, bytes: typing.List[int]) -> _ByteConversion__T: ...
    def convertToBytes(self, t: _ByteConversion__T) -> typing.List[int]: ...
    @staticmethod
    def convertsArrBytes() -> 'ByteConversion'[typing.List[int]]: ...
    @staticmethod
    def convertsErgoTree() -> 'ByteConversion'[sigmastate.Values.ErgoTree]: ...
    @staticmethod
    def convertsId() -> 'ByteConversion'[org.ergoplatform.appkit.ErgoId]: ...
    @staticmethod
    def convertsLong() -> 'ByteConversion'[typing.Any]: ...
    @staticmethod
    def convertsString() -> 'ByteConversion'[str]: ...
    def ofKey(self, pKey: 'PlasmaKey') -> _ByteConversion__T: ...
    def ofVal(self, pVal: 'PlasmaVal') -> _ByteConversion__T: ...
    def toADDigest(self, t: _ByteConversion__T) -> typing.List[int]: ...
    def toADKey(self, t: _ByteConversion__T) -> typing.List[int]: ...
    def toADVal(self, t: _ByteConversion__T) -> typing.List[int]: ...
    def toHexString(self, t: _ByteConversion__T) -> str: ...
    def toKey(self, t: _ByteConversion__T) -> 'PlasmaKey': ...
    def toVal(self, t: _ByteConversion__T) -> 'PlasmaVal': ...

class PlasmaKey(scala.Product, scala.Serializable):
    def __init__(self, key: typing.List[int]): ...
    _andThen__A = typing.TypeVar('_andThen__A')  # <A>
    @staticmethod
    def andThen(g: scala.Function1['PlasmaKey', _andThen__A]) -> scala.Function1[typing.List[int], _andThen__A]: ...
    @staticmethod
    def apply(key: typing.List[int]) -> 'PlasmaKey': ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    @staticmethod
    def compose(g: scala.Function1[_compose__A, typing.List[int]]) -> scala.Function1[_compose__A, 'PlasmaKey']: ...
    def copy(self, key: typing.List[int]) -> 'PlasmaKey': ...
    def copy$default$1(self) -> typing.List[int]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def key(self) -> typing.List[int]: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> str: ...
    def toString(self) -> str: ...
    @staticmethod
    def unapply(x$0: 'PlasmaKey') -> scala.Option[typing.List[int]]: ...

class PlasmaParameters(scala.Product, scala.Serializable):
    def __init__(self, keySize: int, valueSizeOpt: scala.Option[typing.Any]): ...
    @staticmethod
    def apply(keySize: int, valueSizeOpt: scala.Option[typing.Any]) -> 'PlasmaParameters': ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def copy(self, keySize: int, valueSizeOpt: scala.Option[typing.Any]) -> 'PlasmaParameters': ...
    def copy$default$1(self) -> int: ...
    def copy$default$2(self) -> scala.Option[typing.Any]: ...
    @staticmethod
    def default() -> 'PlasmaParameters': ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def keySize(self) -> int: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> str: ...
    def toNodeParams(self) -> scorex.crypto.authds.avltree.batch.NodeParameters: ...
    def toString(self) -> str: ...
    @staticmethod
    def unapply(x$0: 'PlasmaParameters') -> scala.Option[scala.Tuple2[typing.Any, scala.Option[typing.Any]]]: ...
    def valueSizeOpt(self) -> scala.Option[typing.Any]: ...

class PlasmaVal(scala.Product, scala.Serializable):
    def __init__(self, value: typing.List[int]): ...
    _andThen__A = typing.TypeVar('_andThen__A')  # <A>
    @staticmethod
    def andThen(g: scala.Function1['PlasmaVal', _andThen__A]) -> scala.Function1[typing.List[int], _andThen__A]: ...
    @staticmethod
    def apply(value: typing.List[int]) -> 'PlasmaVal': ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    @staticmethod
    def compose(g: scala.Function1[_compose__A, typing.List[int]]) -> scala.Function1[_compose__A, 'PlasmaVal']: ...
    def copy(self, value: typing.List[int]) -> 'PlasmaVal': ...
    def copy$default$1(self) -> typing.List[int]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> str: ...
    def toString(self) -> str: ...
    @staticmethod
    def unapply(x$0: 'PlasmaVal') -> scala.Option[typing.List[int]]: ...
    def value(self) -> typing.List[int]: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("io.getblok.getblok_plasma")``.

    ByteConversion: typing.Type[ByteConversion]
    PlasmaKey: typing.Type[PlasmaKey]
    PlasmaParameters: typing.Type[PlasmaParameters]
    PlasmaVal: typing.Type[PlasmaVal]
    collections: getblok_plasma.collections.__module_protocol__
