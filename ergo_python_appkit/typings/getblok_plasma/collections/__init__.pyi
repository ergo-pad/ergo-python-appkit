import getblok_plasma
import java.lang
import org.ergoplatform.appkit
import scala
import scala.collection
import scala.collection.immutable
import scala.util
import scorex.crypto.authds.avltree.batch
import scorex.crypto.hash
import sigmastate
import special.collection
import special.sigma
import typing



_LocalPlasmaBase__K = typing.TypeVar('_LocalPlasmaBase__K')  # <K>
_LocalPlasmaBase__V = typing.TypeVar('_LocalPlasmaBase__V')  # <V>
class LocalPlasmaBase(typing.Generic[_LocalPlasmaBase__K, _LocalPlasmaBase__V]):
    @staticmethod
    def $init$($this: 'LocalPlasmaBase') -> None: ...
    def delete(self, keys: scala.collection.Seq[_LocalPlasmaBase__K]) -> 'ProvenResult'[_LocalPlasmaBase__V]: ...
    def digest(self) -> typing.List[int]: ...
    def ergoAVLData(self) -> sigmastate.AvlTreeData: ...
    def ergoAVLTree(self) -> special.sigma.AvlTree: ...
    def ergoType(self) -> org.ergoplatform.appkit.ErgoType[special.sigma.AvlTree]: ...
    def ergoValue(self) -> org.ergoplatform.appkit.ErgoValue[special.sigma.AvlTree]: ...
    def flags(self) -> sigmastate.AvlTreeFlags: ...
    def insert(self, keyVals: scala.collection.Seq[scala.Tuple2[_LocalPlasmaBase__K, _LocalPlasmaBase__V]]) -> 'ProvenResult'[_LocalPlasmaBase__V]: ...
    def lookUp(self, keys: scala.collection.Seq[_LocalPlasmaBase__K]) -> 'ProvenResult'[_LocalPlasmaBase__V]: ...
    def params(self) -> getblok_plasma.PlasmaParameters: ...
    def persistentItems(self) -> scala.collection.Seq[scala.Tuple2[_LocalPlasmaBase__K, _LocalPlasmaBase__V]]: ...
    def prover(self) -> scorex.crypto.authds.avltree.batch.PersistentBatchAVLProver[typing.List[int], scorex.crypto.hash.Blake2b256.]: ...
    def serialize(self) -> typing.List[int]: ...
    def storage(self) -> scorex.crypto.authds.avltree.batch.VersionedAVLStorage[typing.List[int]]: ...
    def toMap(self) -> scala.collection.immutable.Map[_LocalPlasmaBase__K, _LocalPlasmaBase__V]: ...
    def toPlasmaMap(self, convertsKey: getblok_plasma.ByteConversion[_LocalPlasmaBase__K], convertsVal: getblok_plasma.ByteConversion[_LocalPlasmaBase__V]) -> 'PlasmaMap'[_LocalPlasmaBase__K, _LocalPlasmaBase__V]: ...
    def toString(self) -> str: ...
    def update(self, newKeyVals: scala.collection.Seq[scala.Tuple2[_LocalPlasmaBase__K, _LocalPlasmaBase__V]]) -> 'ProvenResult'[_LocalPlasmaBase__V]: ...

class Manifest(scala.Product, scala.Serializable):
    def __init__(self, digest: typing.List[int], bytes: typing.List[int], subTrees: scala.collection.Seq[typing.List[int]]): ...
    @staticmethod
    def apply(digest: typing.List[int], bytes: typing.List[int], subTrees: scala.collection.Seq[typing.List[int]]) -> 'Manifest': ...
    def bytes(self) -> typing.List[int]: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def copy(self, digest: typing.List[int], bytes: typing.List[int], subTrees: scala.collection.Seq[typing.List[int]]) -> 'Manifest': ...
    def copy$default$1(self) -> typing.List[int]: ...
    def copy$default$2(self) -> typing.List[int]: ...
    def copy$default$3(self) -> scala.collection.Seq[typing.List[int]]: ...
    def digest(self) -> typing.List[int]: ...
    def digestString(self) -> str: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    @staticmethod
    def fromHexStrings(digestString: str, manifestString: str, subtreeStrings: scala.collection.Seq[str]) -> 'Manifest': ...
    def hashCode(self) -> int: ...
    def manifestString(self) -> str: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> str: ...
    def subTrees(self) -> scala.collection.Seq[typing.List[int]]: ...
    def subtreeStrings(self) -> scala.collection.Seq[str]: ...
    def toHexStrings(self) -> scala.Tuple2[str, scala.collection.Seq[str]]: ...
    def toString(self) -> str: ...
    @staticmethod
    def unapply(x$0: 'Manifest') -> scala.Option[scala.Tuple3[typing.List[int], typing.List[int], scala.collection.Seq[typing.List[int]]]]: ...

class NoResultException(java.lang.RuntimeException):
    def __init__(self): ...

_OpResult__V = typing.TypeVar('_OpResult__V')  # <V>
class OpResult(scala.Product, scala.Serializable, typing.Generic[_OpResult__V]):
    def __init__(self, tryOp: scala.util.Try[scala.Option[_OpResult__V]], converter: getblok_plasma.ByteConversion[_OpResult__V]): ...
    _apply__V = typing.TypeVar('_apply__V')  # <V>
    @staticmethod
    def apply(tryOp: scala.util.Try[scala.Option[_apply__V]], converter: getblok_plasma.ByteConversion[_apply__V]) -> 'OpResult'[_apply__V]: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _copy__V = typing.TypeVar('_copy__V')  # <V>
    def copy(self, tryOp: scala.util.Try[scala.Option[typing.Any]], converter: getblok_plasma.ByteConversion[typing.Any]) -> 'OpResult'[typing.Any]: ...
    _copy$default$1__V = typing.TypeVar('_copy$default$1__V')  # <V>
    def copy$default$1(self) -> scala.util.Try[scala.Option[typing.Any]]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def ergoType(self) -> org.ergoplatform.appkit.ErgoType[int]: ...
    def ergoValue(self) -> org.ergoplatform.appkit.ErgoValue[special.collection.Coll[int]]: ...
    def hashCode(self) -> int: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> str: ...
    def toHexString(self) -> scala.Option[str]: ...
    def toString(self) -> str: ...
    def tryOp(self) -> scala.util.Try[scala.Option[_OpResult__V]]: ...
    _unapply__V = typing.TypeVar('_unapply__V')  # <V>
    @staticmethod
    def unapply(x$0: 'OpResult'[_unapply__V]) -> scala.Option[scala.util.Try[scala.Option[_unapply__V]]]: ...

_PlasmaBase__K = typing.TypeVar('_PlasmaBase__K')  # <K>
_PlasmaBase__V = typing.TypeVar('_PlasmaBase__V')  # <V>
class PlasmaBase(typing.Generic[_PlasmaBase__K, _PlasmaBase__V]):
    @staticmethod
    def $init$($this: 'PlasmaBase') -> None: ...
    def delete(self, keys: scala.collection.Seq[_PlasmaBase__K]) -> 'ProvenResult'[_PlasmaBase__V]: ...
    def digest(self) -> typing.List[int]: ...
    def ergoAVLData(self) -> sigmastate.AvlTreeData: ...
    def ergoAVLTree(self) -> special.sigma.AvlTree: ...
    def ergoType(self) -> org.ergoplatform.appkit.ErgoType[special.sigma.AvlTree]: ...
    def ergoValue(self) -> org.ergoplatform.appkit.ErgoValue[special.sigma.AvlTree]: ...
    def flags(self) -> sigmastate.AvlTreeFlags: ...
    def getManifest(self, subTreeDepth: int) -> Manifest: ...
    def getManifest$default$1(self) -> int: ...
    def insert(self, keyVals: scala.collection.Seq[scala.Tuple2[_PlasmaBase__K, _PlasmaBase__V]]) -> 'ProvenResult'[_PlasmaBase__V]: ...
    def lookUp(self, keys: scala.collection.Seq[_PlasmaBase__K]) -> 'ProvenResult'[_PlasmaBase__V]: ...
    def params(self) -> getblok_plasma.PlasmaParameters: ...
    def prover(self) -> scorex.crypto.authds.avltree.batch.BatchAVLProver[typing.List[int], scorex.crypto.hash.Blake2b256.]: ...
    def prover_$eq(self, x$1: scorex.crypto.authds.avltree.batch.BatchAVLProver[typing.List[int], scorex.crypto.hash.Blake2b256.]) -> None: ...
    def serialize(self) -> typing.List[int]: ...
    def toMap(self) -> scala.collection.immutable.Map[_PlasmaBase__K, _PlasmaBase__V]: ...
    def toString(self) -> str: ...
    def update(self, newKeyVals: scala.collection.Seq[scala.Tuple2[_PlasmaBase__K, _PlasmaBase__V]]) -> 'ProvenResult'[_PlasmaBase__V]: ...

class Proof(scala.Product, scala.Serializable):
    def __init__(self, bytes: typing.List[int]): ...
    _andThen__A = typing.TypeVar('_andThen__A')  # <A>
    @staticmethod
    def andThen(g: scala.Function1['Proof', _andThen__A]) -> scala.Function1[typing.List[int], _andThen__A]: ...
    @staticmethod
    def apply(bytes: typing.List[int]) -> 'Proof': ...
    def bytes(self) -> typing.List[int]: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    @staticmethod
    def compose(g: scala.Function1[_compose__A, typing.List[int]]) -> scala.Function1[_compose__A, 'Proof']: ...
    def copy(self, bytes: typing.List[int]) -> 'Proof': ...
    def copy$default$1(self) -> typing.List[int]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def ergoType(self) -> org.ergoplatform.appkit.ErgoType[int]: ...
    def ergoValue(self) -> org.ergoplatform.appkit.ErgoValue[special.collection.Coll[int]]: ...
    def hashCode(self) -> int: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> str: ...
    def slice(self, shardSize: int) -> scala.collection.Seq['Proof']: ...
    def toADProof(self) -> typing.List[int]: ...
    def toString(self) -> str: ...
    @staticmethod
    def unapply(x$0: 'Proof') -> scala.Option[typing.List[int]]: ...

_ProvenResult__V = typing.TypeVar('_ProvenResult__V')  # <V>
class ProvenResult(scala.Product, scala.Serializable, typing.Generic[_ProvenResult__V]):
    def __init__(self, response: scala.collection.Seq[OpResult[_ProvenResult__V]], proof: Proof): ...
    _apply__V = typing.TypeVar('_apply__V')  # <V>
    @staticmethod
    def apply(response: scala.collection.Seq[OpResult[_apply__V]], proof: Proof) -> 'ProvenResult'[_apply__V]: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _copy__V = typing.TypeVar('_copy__V')  # <V>
    def copy(self, response: scala.collection.Seq[OpResult[typing.Any]], proof: Proof) -> 'ProvenResult'[typing.Any]: ...
    _copy$default$1__V = typing.TypeVar('_copy$default$1__V')  # <V>
    def copy$default$1(self) -> scala.collection.Seq[OpResult[typing.Any]]: ...
    _copy$default$2__V = typing.TypeVar('_copy$default$2__V')  # <V>
    def copy$default$2(self) -> Proof: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> str: ...
    def proof(self) -> Proof: ...
    def response(self) -> scala.collection.Seq[OpResult[_ProvenResult__V]]: ...
    def toString(self) -> str: ...
    _unapply__V = typing.TypeVar('_unapply__V')  # <V>
    @staticmethod
    def unapply(x$0: 'ProvenResult'[_unapply__V]) -> scala.Option[scala.Tuple2[scala.collection.Seq[OpResult[_unapply__V]], Proof]]: ...

class ProverCreationException(java.lang.RuntimeException):
    def __init__(self): ...

_LocalPlasmaMap__K = typing.TypeVar('_LocalPlasmaMap__K')  # <K>
_LocalPlasmaMap__V = typing.TypeVar('_LocalPlasmaMap__V')  # <V>
class LocalPlasmaMap(LocalPlasmaBase[_LocalPlasmaMap__K, _LocalPlasmaMap__V], typing.Generic[_LocalPlasmaMap__K, _LocalPlasmaMap__V]):
    def __init__(self, store: scorex.crypto.authds.avltree.batch.VersionedAVLStorage[typing.List[int]], flags: sigmastate.AvlTreeFlags, params: getblok_plasma.PlasmaParameters, convertKey: getblok_plasma.ByteConversion[_LocalPlasmaMap__K], convertVal: getblok_plasma.ByteConversion[_LocalPlasmaMap__V]): ...
    def convertKey(self) -> getblok_plasma.ByteConversion[_LocalPlasmaMap__K]: ...
    def delete(self, keys: scala.collection.Seq[_LocalPlasmaMap__K]) -> ProvenResult[_LocalPlasmaMap__V]: ...
    def digest(self) -> typing.List[int]: ...
    def ergoAVLData(self) -> sigmastate.AvlTreeData: ...
    def ergoAVLTree(self) -> special.sigma.AvlTree: ...
    def ergoType(self) -> org.ergoplatform.appkit.ErgoType[special.sigma.AvlTree]: ...
    def ergoValue(self) -> org.ergoplatform.appkit.ErgoValue[special.sigma.AvlTree]: ...
    def flags(self) -> sigmastate.AvlTreeFlags: ...
    def insert(self, keyVals: scala.collection.Seq[scala.Tuple2[_LocalPlasmaMap__K, _LocalPlasmaMap__V]]) -> ProvenResult[_LocalPlasmaMap__V]: ...
    def lookUp(self, keys: scala.collection.Seq[_LocalPlasmaMap__K]) -> ProvenResult[_LocalPlasmaMap__V]: ...
    def params(self) -> getblok_plasma.PlasmaParameters: ...
    def persistentItems(self) -> scala.collection.Seq[scala.Tuple2[_LocalPlasmaMap__K, _LocalPlasmaMap__V]]: ...
    def prover(self) -> scorex.crypto.authds.avltree.batch.PersistentBatchAVLProver[typing.List[int], scorex.crypto.hash.Blake2b256.]: ...
    def serialize(self) -> typing.List[int]: ...
    def storage(self) -> scorex.crypto.authds.avltree.batch.VersionedAVLStorage[typing.List[int]]: ...
    def toMap(self) -> scala.collection.immutable.Map[_LocalPlasmaMap__K, _LocalPlasmaMap__V]: ...
    def toPlasmaMap(self, convertsKey: getblok_plasma.ByteConversion[_LocalPlasmaMap__K], convertsVal: getblok_plasma.ByteConversion[_LocalPlasmaMap__V]) -> 'PlasmaMap'[_LocalPlasmaMap__K, _LocalPlasmaMap__V]: ...
    def toString(self) -> str: ...
    def update(self, newKeyVals: scala.collection.Seq[scala.Tuple2[_LocalPlasmaMap__K, _LocalPlasmaMap__V]]) -> ProvenResult[_LocalPlasmaMap__V]: ...

_PlasmaMap__K = typing.TypeVar('_PlasmaMap__K')  # <K>
_PlasmaMap__V = typing.TypeVar('_PlasmaMap__V')  # <V>
class PlasmaMap(PlasmaBase[_PlasmaMap__K, _PlasmaMap__V], typing.Generic[_PlasmaMap__K, _PlasmaMap__V]):
    def __init__(self, flags: sigmastate.AvlTreeFlags, params: getblok_plasma.PlasmaParameters, initProver: scala.Option[scorex.crypto.authds.avltree.batch.BatchAVLProver[typing.List[int], scorex.crypto.hash.Blake2b256.]], convertKey: io.getblok.getblok_plasma.ByteConversion[_PlasmaMap__K], convertVal: io.getblok.getblok_plasma.ByteConversion[_PlasmaMap__V]): ...
    _$lessinit$greater$default$3__K = typing.TypeVar('_$lessinit$greater$default$3__K')  # <K>
    _$lessinit$greater$default$3__V = typing.TypeVar('_$lessinit$greater$default$3__V')  # <V>
    @staticmethod
    def $lessinit$greater$default$3() -> scala.Option[scorex.crypto.authds.avltree.batch.BatchAVLProver[typing.List[int], scorex.crypto.hash.Blake2b256.]]: ...
    def convertKey(self) -> getblok_plasma.ByteConversion[_PlasmaMap__K]: ...
    def copy(self, optFlags: scala.Option[sigmastate.AvlTreeFlags], optParams: scala.Option[getblok_plasma.PlasmaParameters]) -> 'PlasmaMap'[_PlasmaMap__K, _PlasmaMap__V]: ...
    def copy$default$1(self) -> scala.Option[sigmastate.AvlTreeFlags]: ...
    def copy$default$2(self) -> scala.Option[io.getblok.getblok_plasma.PlasmaParameters]: ...
    def delete(self, keys: scala.collection.Seq[_PlasmaMap__K]) -> ProvenResult[_PlasmaMap__V]: ...
    def digest(self) -> typing.List[int]: ...
    def ergoAVLData(self) -> sigmastate.AvlTreeData: ...
    def ergoAVLTree(self) -> special.sigma.AvlTree: ...
    def ergoType(self) -> org.ergoplatform.appkit.ErgoType[special.sigma.AvlTree]: ...
    def ergoValue(self) -> org.ergoplatform.appkit.ErgoValue[special.sigma.AvlTree]: ...
    def flags(self) -> sigmastate.AvlTreeFlags: ...
    def getManifest(self, subTreeDepth: int) -> Manifest: ...
    def getManifest$default$1(self) -> int: ...
    def insert(self, keyVals: scala.collection.Seq[scala.Tuple2[_PlasmaMap__K, _PlasmaMap__V]]) -> ProvenResult[_PlasmaMap__V]: ...
    def loadManifest(self, manifest: Manifest) -> 'PlasmaMap'[_PlasmaMap__K, _PlasmaMap__V]: ...
    def lookUp(self, keys: scala.collection.Seq[_PlasmaMap__K]) -> ProvenResult[_PlasmaMap__V]: ...
    def params(self) -> getblok_plasma.PlasmaParameters: ...
    def prover(self) -> scorex.crypto.authds.avltree.batch.BatchAVLProver[typing.List[int], scorex.crypto.hash.Blake2b256.]: ...
    def prover_$eq(self, x$1: scorex.crypto.authds.avltree.batch.BatchAVLProver[typing.List[int], scorex.crypto.hash.Blake2b256.]) -> None: ...
    def serialize(self) -> typing.List[int]: ...
    def toMap(self) -> scala.collection.immutable.Map[_PlasmaMap__K, _PlasmaMap__V]: ...
    def toString(self) -> str: ...
    def update(self, newKeyVals: scala.collection.Seq[scala.Tuple2[_PlasmaMap__K, _PlasmaMap__V]]) -> ProvenResult[_PlasmaMap__V]: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("io.getblok.getblok_plasma.collections")``.

    LocalPlasmaBase: typing.Type[LocalPlasmaBase]
    LocalPlasmaMap: typing.Type[LocalPlasmaMap]
    Manifest: typing.Type[Manifest]
    NoResultException: typing.Type[NoResultException]
    OpResult: typing.Type[OpResult]
    PlasmaBase: typing.Type[PlasmaBase]
    PlasmaMap: typing.Type[PlasmaMap]
    Proof: typing.Type[Proof]
    ProvenResult: typing.Type[ProvenResult]
    ProverCreationException: typing.Type[ProverCreationException]
