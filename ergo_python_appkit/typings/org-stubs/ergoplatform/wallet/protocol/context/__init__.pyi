import java.lang
import org.ergoplatform
import scala
import scala.collection
import sigmastate.interpreter
import special.collection
import special.sigma
import typing



class ErgoLikeParameters:
    def blockVersion(self) -> int: ...
    def dataInputCost(self) -> int: ...
    def inputCost(self) -> int: ...
    def maxBlockCost(self) -> int: ...
    def maxBlockSize(self) -> int: ...
    def minValuePerByte(self) -> int: ...
    def outputCost(self) -> int: ...
    def softForkStartingHeight(self) -> scala.Option[typing.Any]: ...
    def softForkVotesCollected(self) -> scala.Option[typing.Any]: ...
    def storageFeeFactor(self) -> int: ...
    def tokenAccessCost(self) -> int: ...

class ErgoLikeStateContext:
    def previousStateDigest(self) -> typing.List[int]: ...
    def sigmaLastHeaders(self) -> special.collection.Coll[special.sigma.Header]: ...
    def sigmaPreHeader(self) -> special.sigma.PreHeader: ...

class InputContext(scala.Product, scala.Serializable):
    def __init__(self, selfIndex: int, extension: sigmastate.interpreter.ContextExtension): ...
    @staticmethod
    def apply(selfIndex: int, extension: sigmastate.interpreter.ContextExtension) -> 'InputContext': ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def copy(self, selfIndex: int, extension: sigmastate.interpreter.ContextExtension) -> 'InputContext': ...
    def copy$default$1(self) -> int: ...
    def copy$default$2(self) -> sigmastate.interpreter.ContextExtension: ...
    @staticmethod
    def curried() -> scala.Function1[typing.Any, scala.Function1[sigmastate.interpreter.ContextExtension, 'InputContext']]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def extension(self) -> sigmastate.interpreter.ContextExtension: ...
    def hashCode(self) -> int: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def selfIndex(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def tupled() -> scala.Function1[scala.Tuple2[typing.Any, sigmastate.interpreter.ContextExtension], 'InputContext']: ...
    @staticmethod
    def unapply(x$0: 'InputContext') -> scala.Option[scala.Tuple2[typing.Any, sigmastate.interpreter.ContextExtension]]: ...

class TransactionContext(scala.Product, scala.Serializable):
    def __init__(self, boxesToSpend: scala.collection.IndexedSeq[org.ergoplatform.ErgoBox], dataBoxes: scala.collection.IndexedSeq[org.ergoplatform.ErgoBox], spendingTransaction: org.ergoplatform.ErgoLikeTransactionTemplate[org.ergoplatform.UnsignedInput]): ...
    @staticmethod
    def apply(boxesToSpend: scala.collection.IndexedSeq[org.ergoplatform.ErgoBox], dataBoxes: scala.collection.IndexedSeq[org.ergoplatform.ErgoBox], spendingTransaction: org.ergoplatform.ErgoLikeTransactionTemplate[org.ergoplatform.UnsignedInput]) -> 'TransactionContext': ...
    def boxesToSpend(self) -> scala.collection.IndexedSeq[org.ergoplatform.ErgoBox]: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def copy(self, boxesToSpend: scala.collection.IndexedSeq[org.ergoplatform.ErgoBox], dataBoxes: scala.collection.IndexedSeq[org.ergoplatform.ErgoBox], spendingTransaction: org.ergoplatform.ErgoLikeTransactionTemplate[org.ergoplatform.UnsignedInput]) -> 'TransactionContext': ...
    def copy$default$1(self) -> scala.collection.IndexedSeq[org.ergoplatform.ErgoBox]: ...
    def copy$default$2(self) -> scala.collection.IndexedSeq[org.ergoplatform.ErgoBox]: ...
    def copy$default$3(self) -> org.ergoplatform.ErgoLikeTransactionTemplate[org.ergoplatform.UnsignedInput]: ...
    @staticmethod
    def curried() -> scala.Function1[scala.collection.IndexedSeq[org.ergoplatform.ErgoBox], scala.Function1[scala.collection.IndexedSeq[org.ergoplatform.ErgoBox], scala.Function1[org.ergoplatform.ErgoLikeTransactionTemplate[org.ergoplatform.UnsignedInput], 'TransactionContext']]]: ...
    def dataBoxes(self) -> scala.collection.IndexedSeq[org.ergoplatform.ErgoBox]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def spendingTransaction(self) -> org.ergoplatform.ErgoLikeTransactionTemplate[org.ergoplatform.UnsignedInput]: ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def tupled() -> scala.Function1[scala.Tuple3[scala.collection.IndexedSeq[org.ergoplatform.ErgoBox], scala.collection.IndexedSeq[org.ergoplatform.ErgoBox], org.ergoplatform.ErgoLikeTransactionTemplate[org.ergoplatform.UnsignedInput]], 'TransactionContext']: ...
    @staticmethod
    def unapply(x$0: 'TransactionContext') -> scala.Option[scala.Tuple3[scala.collection.IndexedSeq[org.ergoplatform.ErgoBox], scala.collection.IndexedSeq[org.ergoplatform.ErgoBox], org.ergoplatform.ErgoLikeTransactionTemplate[org.ergoplatform.UnsignedInput]]]: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.ergoplatform.wallet.protocol.context")``.

    ErgoLikeParameters: typing.Type[ErgoLikeParameters]
    ErgoLikeStateContext: typing.Type[ErgoLikeStateContext]
    InputContext: typing.Type[InputContext]
    TransactionContext: typing.Type[TransactionContext]
