import java.lang
import org.ergoplatform.appkit
import org.ergoplatform.appkit.cli
import org.ergoplatform.appkit.config
import scala
import scala.collection
import scala.runtime
import typing



class AddressPType:
    @staticmethod
    def canEqual(x$1: typing.Any) -> bool: ...
    @staticmethod
    def hashCode() -> int: ...
    @staticmethod
    def productArity() -> int: ...
    @staticmethod
    def productElement(x$1: int) -> typing.Any: ...
    @staticmethod
    def productIterator() -> scala.collection.Iterator[typing.Any]: ...
    @staticmethod
    def productPrefix() -> str: ...
    @staticmethod
    def toString() -> str: ...

class BooleanPType:
    @staticmethod
    def canEqual(x$1: typing.Any) -> bool: ...
    @staticmethod
    def hashCode() -> int: ...
    @staticmethod
    def productArity() -> int: ...
    @staticmethod
    def productElement(x$1: int) -> typing.Any: ...
    @staticmethod
    def productIterator() -> scala.collection.Iterator[typing.Any]: ...
    @staticmethod
    def productPrefix() -> str: ...
    @staticmethod
    def toString() -> str: ...

class Cmd:
    def __init__(self): ...
    def apiKey(self) -> str: ...
    def apiUrl(self) -> str: ...
    def error(self, msg: str) -> scala.runtime.Nothing.: ...
    _loggedStep__T = typing.TypeVar('_loggedStep__T')  # <T>
    def loggedStep(self, msg: str, console: org.ergoplatform.appkit.cli.Console, step: scala.Function0[_loggedStep__T]) -> _loggedStep__T: ...
    def name(self) -> str: ...
    def networkType(self) -> org.ergoplatform.appkit.NetworkType: ...
    def run(self, ctx: org.ergoplatform.appkit.cli.AppContext) -> None: ...
    def toolConf(self) -> org.ergoplatform.appkit.config.ErgoToolConfig: ...

class CmdArgInput:
    def __init__(self): ...
    def input(self, ctx: org.ergoplatform.appkit.cli.AppContext, cmd: 'CmdDescriptor', parameter: 'CmdParameter') -> typing.Any: ...

class CmdArgParser:
    def __init__(self): ...
    def parse(self, cmd: 'CmdDescriptor', p: 'CmdParameter', rawArg: str) -> typing.Any: ...

class CmdDescriptor:
    def __init__(self, name: str, cmdParamSyntax: str, description: str): ...
    def BaseDocUrl(self) -> str: ...
    def cmdParamSyntax(self) -> str: ...
    def createCmd(self, ctx: org.ergoplatform.appkit.cli.AppContext) -> Cmd: ...
    def description(self) -> str: ...
    def docUrl(self) -> str: ...
    def error(self, msg: str) -> scala.runtime.Nothing.: ...
    def name(self) -> str: ...
    def parameters(self) -> scala.collection.Seq['CmdParameter']: ...
    def parseArgs(self, ctx: org.ergoplatform.appkit.cli.AppContext, args: scala.collection.Seq[str]) -> scala.collection.Seq[typing.Any]: ...
    def printUsage(self, console: org.ergoplatform.appkit.cli.Console) -> org.ergoplatform.appkit.cli.Console: ...
    def usageError(self, msg: str) -> scala.runtime.Nothing.: ...

class CmdException(java.lang.RuntimeException, scala.Product, scala.Serializable):
    def __init__(self, message: str, cmd: Cmd, cause: java.lang.Throwable): ...
    @staticmethod
    def $lessinit$greater$default$3() -> java.lang.Throwable: ...
    @staticmethod
    def apply(message: str, cmd: Cmd, cause: java.lang.Throwable) -> 'CmdException': ...
    @staticmethod
    def apply$default$3() -> java.lang.Throwable: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def cause(self) -> java.lang.Throwable: ...
    def cmd(self) -> Cmd: ...
    def copy(self, message: str, cmd: Cmd, cause: java.lang.Throwable) -> 'CmdException': ...
    def copy$default$1(self) -> str: ...
    def copy$default$2(self) -> Cmd: ...
    def copy$default$3(self) -> java.lang.Throwable: ...
    @staticmethod
    def curried() -> scala.Function1[str, scala.Function1[Cmd, scala.Function1[java.lang.Throwable, 'CmdException']]]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def message(self) -> str: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> str: ...
    @staticmethod
    def tupled() -> scala.Function1[scala.Tuple3[str, Cmd, java.lang.Throwable], 'CmdException']: ...
    @staticmethod
    def unapply(x$0: 'CmdException') -> scala.Option[scala.Tuple3[str, Cmd, java.lang.Throwable]]: ...

class CmdParameter(scala.Product, scala.Serializable):
    def __init__(self, name: str, displayName: str, tpe: 'PType', description: str, defaultValue: scala.Option[str], interactiveInput: scala.Option[CmdArgInput], argParser: scala.Option[CmdArgParser]): ...
    @typing.overload
    @staticmethod
    def apply(name: str, displayName: str, tpe: 'PType', description: str, defaultValue: scala.Option[str], interactiveInput: scala.Option[CmdArgInput], argParser: scala.Option[CmdArgParser]) -> 'CmdParameter': ...
    @typing.overload
    @staticmethod
    def apply(name: str, tpe: 'PType', description: str, defaultValue: scala.Option[str], interactiveInput: scala.Option[CmdArgInput]) -> 'CmdParameter': ...
    @staticmethod
    def apply$default$4() -> scala.Option[str]: ...
    @staticmethod
    def apply$default$5() -> scala.Option[CmdArgInput]: ...
    def argParser(self) -> scala.Option[CmdArgParser]: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def copy(self, name: str, displayName: str, tpe: 'PType', description: str, defaultValue: scala.Option[str], interactiveInput: scala.Option[CmdArgInput], argParser: scala.Option[CmdArgParser]) -> 'CmdParameter': ...
    def copy$default$1(self) -> str: ...
    def copy$default$2(self) -> str: ...
    def copy$default$3(self) -> 'PType': ...
    def copy$default$4(self) -> str: ...
    def copy$default$5(self) -> scala.Option[str]: ...
    def copy$default$6(self) -> scala.Option[CmdArgInput]: ...
    def copy$default$7(self) -> scala.Option[CmdArgParser]: ...
    def defaultValue(self) -> scala.Option[str]: ...
    def description(self) -> str: ...
    def displayName(self) -> str: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def interactiveInput(self) -> scala.Option[CmdArgInput]: ...
    def name(self) -> str: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> str: ...
    def toString(self) -> str: ...
    def tpe(self) -> 'PType': ...
    @staticmethod
    def unapply(x$0: 'CmdParameter') -> scala.Option[scala.Tuple7[str, str, 'PType', str, scala.Option[str], scala.Option[CmdArgInput], scala.Option[CmdArgParser]]]: ...

class CommandNamePType:
    @staticmethod
    def canEqual(x$1: typing.Any) -> bool: ...
    @staticmethod
    def hashCode() -> int: ...
    @staticmethod
    def productArity() -> int: ...
    @staticmethod
    def productElement(x$1: int) -> typing.Any: ...
    @staticmethod
    def productIterator() -> scala.collection.Iterator[typing.Any]: ...
    @staticmethod
    def productPrefix() -> str: ...
    @staticmethod
    def toString() -> str: ...

class DefaultCmdArgParser:
    @staticmethod
    def parse(cmd: CmdDescriptor, p: CmdParameter, rawArg: str) -> typing.Any: ...

class DefaultParameterInput:
    @staticmethod
    def input(ctx: org.ergoplatform.appkit.cli.AppContext, cmd: CmdDescriptor, parameter: CmdParameter) -> typing.Any: ...

class DirPathPType:
    @staticmethod
    def canEqual(x$1: typing.Any) -> bool: ...
    @staticmethod
    def hashCode() -> int: ...
    @staticmethod
    def productArity() -> int: ...
    @staticmethod
    def productElement(x$1: int) -> typing.Any: ...
    @staticmethod
    def productIterator() -> scala.collection.Iterator[typing.Any]: ...
    @staticmethod
    def productPrefix() -> str: ...
    @staticmethod
    def toString() -> str: ...

class ErgoIdPType:
    @staticmethod
    def canEqual(x$1: typing.Any) -> bool: ...
    @staticmethod
    def hashCode() -> int: ...
    @staticmethod
    def productArity() -> int: ...
    @staticmethod
    def productElement(x$1: int) -> typing.Any: ...
    @staticmethod
    def productIterator() -> scala.collection.Iterator[typing.Any]: ...
    @staticmethod
    def productPrefix() -> str: ...
    @staticmethod
    def toString() -> str: ...

class ErgoToolException(java.lang.RuntimeException, scala.Product, scala.Serializable):
    def __init__(self, message: str, cause: java.lang.Throwable): ...
    @staticmethod
    def $lessinit$greater$default$2() -> java.lang.Throwable: ...
    @staticmethod
    def apply(message: str, cause: java.lang.Throwable) -> 'ErgoToolException': ...
    @staticmethod
    def apply$default$2() -> java.lang.Throwable: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def cause(self) -> java.lang.Throwable: ...
    def copy(self, message: str, cause: java.lang.Throwable) -> 'ErgoToolException': ...
    def copy$default$1(self) -> str: ...
    def copy$default$2(self) -> java.lang.Throwable: ...
    @staticmethod
    def curried() -> scala.Function1[str, scala.Function1[java.lang.Throwable, 'ErgoToolException']]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def message(self) -> str: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> str: ...
    @staticmethod
    def tupled() -> scala.Function1[scala.Tuple2[str, java.lang.Throwable], 'ErgoToolException']: ...
    @staticmethod
    def unapply(x$0: 'ErgoToolException') -> scala.Option[scala.Tuple2[str, java.lang.Throwable]]: ...

class FilePType:
    @staticmethod
    def canEqual(x$1: typing.Any) -> bool: ...
    @staticmethod
    def hashCode() -> int: ...
    @staticmethod
    def productArity() -> int: ...
    @staticmethod
    def productElement(x$1: int) -> typing.Any: ...
    @staticmethod
    def productIterator() -> scala.collection.Iterator[typing.Any]: ...
    @staticmethod
    def productPrefix() -> str: ...
    @staticmethod
    def toString() -> str: ...

class FilePathPType:
    @staticmethod
    def canEqual(x$1: typing.Any) -> bool: ...
    @staticmethod
    def hashCode() -> int: ...
    @staticmethod
    def productArity() -> int: ...
    @staticmethod
    def productElement(x$1: int) -> typing.Any: ...
    @staticmethod
    def productIterator() -> scala.collection.Iterator[typing.Any]: ...
    @staticmethod
    def productPrefix() -> str: ...
    @staticmethod
    def toString() -> str: ...

class IntPType:
    @staticmethod
    def canEqual(x$1: typing.Any) -> bool: ...
    @staticmethod
    def hashCode() -> int: ...
    @staticmethod
    def productArity() -> int: ...
    @staticmethod
    def productElement(x$1: int) -> typing.Any: ...
    @staticmethod
    def productIterator() -> scala.collection.Iterator[typing.Any]: ...
    @staticmethod
    def productPrefix() -> str: ...
    @staticmethod
    def toString() -> str: ...

class LongPType:
    @staticmethod
    def canEqual(x$1: typing.Any) -> bool: ...
    @staticmethod
    def hashCode() -> int: ...
    @staticmethod
    def productArity() -> int: ...
    @staticmethod
    def productElement(x$1: int) -> typing.Any: ...
    @staticmethod
    def productIterator() -> scala.collection.Iterator[typing.Any]: ...
    @staticmethod
    def productPrefix() -> str: ...
    @staticmethod
    def toString() -> str: ...

class NanoErgPType:
    @staticmethod
    def canEqual(x$1: typing.Any) -> bool: ...
    @staticmethod
    def hashCode() -> int: ...
    @staticmethod
    def productArity() -> int: ...
    @staticmethod
    def productElement(x$1: int) -> typing.Any: ...
    @staticmethod
    def productIterator() -> scala.collection.Iterator[typing.Any]: ...
    @staticmethod
    def productPrefix() -> str: ...
    @staticmethod
    def toString() -> str: ...

class NetworkPType:
    @staticmethod
    def canEqual(x$1: typing.Any) -> bool: ...
    @staticmethod
    def hashCode() -> int: ...
    @staticmethod
    def productArity() -> int: ...
    @staticmethod
    def productElement(x$1: int) -> typing.Any: ...
    @staticmethod
    def productIterator() -> scala.collection.Iterator[typing.Any]: ...
    @staticmethod
    def productPrefix() -> str: ...
    @staticmethod
    def toString() -> str: ...

class NewPasswordInput:
    @staticmethod
    def input(ctx: org.ergoplatform.appkit.cli.AppContext, cmd: CmdDescriptor, param: CmdParameter) -> typing.Any: ...

class PType:
    def __init__(self): ...

class PasswordInput:
    @staticmethod
    def input(ctx: org.ergoplatform.appkit.cli.AppContext, cmd: CmdDescriptor, param: CmdParameter) -> typing.Any: ...

class RunWithErgoClient:
    @staticmethod
    def $init$($this: 'RunWithErgoClient') -> None: ...
    def run(self, ctx: org.ergoplatform.appkit.cli.AppContext) -> None: ...
    def runWithClient(self, ergoClient: org.ergoplatform.appkit.ErgoClient, ctx: org.ergoplatform.appkit.cli.AppContext) -> None: ...

class SecretStringPType:
    @staticmethod
    def canEqual(x$1: typing.Any) -> bool: ...
    @staticmethod
    def hashCode() -> int: ...
    @staticmethod
    def productArity() -> int: ...
    @staticmethod
    def productElement(x$1: int) -> typing.Any: ...
    @staticmethod
    def productIterator() -> scala.collection.Iterator[typing.Any]: ...
    @staticmethod
    def productPrefix() -> str: ...
    @staticmethod
    def toString() -> str: ...

class StringPType:
    @staticmethod
    def canEqual(x$1: typing.Any) -> bool: ...
    @staticmethod
    def hashCode() -> int: ...
    @staticmethod
    def productArity() -> int: ...
    @staticmethod
    def productElement(x$1: int) -> typing.Any: ...
    @staticmethod
    def productIterator() -> scala.collection.Iterator[typing.Any]: ...
    @staticmethod
    def productPrefix() -> str: ...
    @staticmethod
    def toString() -> str: ...

class UsageException(java.lang.RuntimeException, scala.Product, scala.Serializable):
    def __init__(self, message: str, cmdDescOpt: scala.Option[CmdDescriptor]): ...
    @staticmethod
    def apply(message: str, cmdDescOpt: scala.Option[CmdDescriptor]) -> 'UsageException': ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def cmdDescOpt(self) -> scala.Option[CmdDescriptor]: ...
    def copy(self, message: str, cmdDescOpt: scala.Option[CmdDescriptor]) -> 'UsageException': ...
    def copy$default$1(self) -> str: ...
    def copy$default$2(self) -> scala.Option[CmdDescriptor]: ...
    @staticmethod
    def curried() -> scala.Function1[str, scala.Function1[scala.Option[CmdDescriptor], 'UsageException']]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def message(self) -> str: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> str: ...
    @staticmethod
    def tupled() -> scala.Function1[scala.Tuple2[str, scala.Option[CmdDescriptor]], 'UsageException']: ...
    @staticmethod
    def unapply(x$0: 'UsageException') -> scala.Option[scala.Tuple2[str, scala.Option[CmdDescriptor]]]: ...

class package:
    @staticmethod
    def usageError(msg: str, cmdDescOpt: scala.Option[CmdDescriptor]) -> scala.runtime.Nothing.: ...

class EnumPType(PType, scala.Product, scala.Serializable):
    def __init__(self, values: scala.collection.Seq[scala.Tuple2[str, typing.Any]]): ...
    _andThen__A = typing.TypeVar('_andThen__A')  # <A>
    @staticmethod
    def andThen(g: scala.Function1['EnumPType', _andThen__A]) -> scala.Function1[scala.collection.Seq[scala.Tuple2[str, typing.Any]], _andThen__A]: ...
    @staticmethod
    def apply(values: scala.collection.Seq[scala.Tuple2[str, typing.Any]]) -> 'EnumPType': ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    @staticmethod
    def compose(g: scala.Function1[_compose__A, scala.collection.Seq[scala.Tuple2[str, typing.Any]]]) -> scala.Function1[_compose__A, 'EnumPType']: ...
    def copy(self, values: scala.collection.Seq[scala.Tuple2[str, typing.Any]]) -> 'EnumPType': ...
    def copy$default$1(self) -> scala.collection.Seq[scala.Tuple2[str, typing.Any]]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def getByName(self, name: str) -> scala.Option[typing.Any]: ...
    def hashCode(self) -> int: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> str: ...
    def toString(self) -> str: ...
    @staticmethod
    def unapply(x$0: 'EnumPType') -> scala.Option[scala.collection.Seq[scala.Tuple2[str, typing.Any]]]: ...
    def values(self) -> scala.collection.Seq[scala.Tuple2[str, typing.Any]]: ...

class EnumParser(CmdArgParser):
    def __init__(self, enum: EnumPType): ...
    def parse(self, cmd: CmdDescriptor, p: CmdParameter, rawArg: str) -> typing.Any: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.ergoplatform.appkit.commands")``.

    AddressPType: typing.Type[AddressPType]
    BooleanPType: typing.Type[BooleanPType]
    Cmd: typing.Type[Cmd]
    CmdArgInput: typing.Type[CmdArgInput]
    CmdArgParser: typing.Type[CmdArgParser]
    CmdDescriptor: typing.Type[CmdDescriptor]
    CmdException: typing.Type[CmdException]
    CmdParameter: typing.Type[CmdParameter]
    CommandNamePType: typing.Type[CommandNamePType]
    DefaultCmdArgParser: typing.Type[DefaultCmdArgParser]
    DefaultParameterInput: typing.Type[DefaultParameterInput]
    DirPathPType: typing.Type[DirPathPType]
    EnumPType: typing.Type[EnumPType]
    EnumParser: typing.Type[EnumParser]
    ErgoIdPType: typing.Type[ErgoIdPType]
    ErgoToolException: typing.Type[ErgoToolException]
    FilePType: typing.Type[FilePType]
    FilePathPType: typing.Type[FilePathPType]
    IntPType: typing.Type[IntPType]
    LongPType: typing.Type[LongPType]
    NanoErgPType: typing.Type[NanoErgPType]
    NetworkPType: typing.Type[NetworkPType]
    NewPasswordInput: typing.Type[NewPasswordInput]
    PType: typing.Type[PType]
    PasswordInput: typing.Type[PasswordInput]
    RunWithErgoClient: typing.Type[RunWithErgoClient]
    SecretStringPType: typing.Type[SecretStringPType]
    StringPType: typing.Type[StringPType]
    UsageException: typing.Type[UsageException]
    package: typing.Type[package]
