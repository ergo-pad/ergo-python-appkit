import java.lang
import java.util
import java.util.concurrent
import scala
import scala.collection
import typing



class package:
    class ForkJoinPool$:
        MODULE$: typing.ClassVar['package.ForkJoinPool.'] = ...
        def __init__(self): ...
        def defaultForkJoinWorkerThreadFactory(self) -> java.util.concurrent.ForkJoinPool.ForkJoinWorkerThreadFactory: ...
        def managedBlock(self, blocker: java.util.concurrent.ForkJoinPool.ManagedBlocker) -> None: ...
    class ForkJoinTask$(scala.Serializable):
        MODULE$: typing.ClassVar['package.ForkJoinTask.'] = ...
        def __init__(self): ...
        _adapt_1__T = typing.TypeVar('_adapt_1__T')  # <T>
        _adapt_2__T = typing.TypeVar('_adapt_2__T')  # <T>
        @typing.overload
        def adapt(self, runnable: typing.Union[java.lang.Runnable, typing.Callable]) -> java.util.concurrent.ForkJoinTask[typing.Any]: ...
        @typing.overload
        def adapt(self, runnable: typing.Union[java.lang.Runnable, typing.Callable], result: _adapt_1__T) -> java.util.concurrent.ForkJoinTask[_adapt_1__T]: ...
        @typing.overload
        def adapt(self, callable: typing.Union[java.util.concurrent.Callable[_adapt_2__T], typing.Callable[[], _adapt_2__T]]) -> java.util.concurrent.ForkJoinTask[_adapt_2__T]: ...
        def getPool(self) -> java.util.concurrent.ForkJoinPool: ...
        def getQueuedTaskCount(self) -> int: ...
        def getSurplusQueuedTaskCount(self) -> int: ...
        def helpQuiesce(self) -> None: ...
        def inForkJoinPool(self) -> bool: ...
        _invokeAll_0__T = typing.TypeVar('_invokeAll_0__T', bound=java.util.concurrent.ForkJoinTask)  # <T>
        _invokeAll_1__T = typing.TypeVar('_invokeAll_1__T')  # <T>
        _invokeAll_2__T = typing.TypeVar('_invokeAll_2__T')  # <T>
        @typing.overload
        def invokeAll(self, tasks: typing.Union[java.util.Collection[_invokeAll_0__T], typing.Sequence[_invokeAll_0__T], typing.Set[_invokeAll_0__T]]) -> java.util.Collection[_invokeAll_0__T]: ...
        @typing.overload
        def invokeAll(self, t1: java.util.concurrent.ForkJoinTask[_invokeAll_1__T]) -> None: ...
        @typing.overload
        def invokeAll(self, tasks: scala.collection.Seq[java.util.concurrent.ForkJoinTask[_invokeAll_2__T]]) -> None: ...
    class ThreadLocalRandom$(scala.Serializable):
        MODULE$: typing.ClassVar['package.ThreadLocalRandom.'] = ...
        def __init__(self): ...
        def current(self) -> java.util.concurrent.ThreadLocalRandom: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("scala.concurrent.forkjoin")``.

    package: typing.Type[package]
