import _jpype
import java.io
import java.lang
import java.lang.annotation
import java.lang.invoke
import java.lang.reflect
import java.util
import java.util.stream
import scala
import scala.collection
import scala.collection.generic
import scala.collection.immutable
import scala.math
import scala.reflect
import scala.util.control
import typing



_AbstractFunction0__R = typing.TypeVar('_AbstractFunction0__R')  # <R>
class AbstractFunction0(scala.Function0[_AbstractFunction0__R], typing.Generic[_AbstractFunction0__R]):
    def __init__(self): ...
    def apply$mcB$sp(self) -> int: ...
    def apply$mcC$sp(self) -> str: ...
    def apply$mcD$sp(self) -> float: ...
    def apply$mcF$sp(self) -> float: ...
    def apply$mcI$sp(self) -> int: ...
    def apply$mcJ$sp(self) -> int: ...
    def apply$mcS$sp(self) -> int: ...
    def apply$mcV$sp(self) -> None: ...
    def apply$mcZ$sp(self) -> bool: ...
    def toString(self) -> java.lang.String: ...

_AbstractFunction1__T1 = typing.TypeVar('_AbstractFunction1__T1')  # <T1>
_AbstractFunction1__R = typing.TypeVar('_AbstractFunction1__R')  # <R>
class AbstractFunction1(scala.Function1[_AbstractFunction1__T1, _AbstractFunction1__R], typing.Generic[_AbstractFunction1__T1, _AbstractFunction1__R]):
    def __init__(self): ...
    _andThen__A = typing.TypeVar('_andThen__A')  # <A>
    def andThen(self, g: scala.Function1[_AbstractFunction1__R, _andThen__A]) -> scala.Function1[_AbstractFunction1__T1, _andThen__A]: ...
    def apply$mcDD$sp(self, v1: float) -> float: ...
    def apply$mcDF$sp(self, v1: float) -> float: ...
    def apply$mcDI$sp(self, v1: int) -> float: ...
    def apply$mcDJ$sp(self, v1: int) -> float: ...
    def apply$mcFD$sp(self, v1: float) -> float: ...
    def apply$mcFF$sp(self, v1: float) -> float: ...
    def apply$mcFI$sp(self, v1: int) -> float: ...
    def apply$mcFJ$sp(self, v1: int) -> float: ...
    def apply$mcID$sp(self, v1: float) -> int: ...
    def apply$mcIF$sp(self, v1: float) -> int: ...
    def apply$mcII$sp(self, v1: int) -> int: ...
    def apply$mcIJ$sp(self, v1: int) -> int: ...
    def apply$mcJD$sp(self, v1: float) -> int: ...
    def apply$mcJF$sp(self, v1: float) -> int: ...
    def apply$mcJI$sp(self, v1: int) -> int: ...
    def apply$mcJJ$sp(self, v1: int) -> int: ...
    def apply$mcVD$sp(self, v1: float) -> None: ...
    def apply$mcVF$sp(self, v1: float) -> None: ...
    def apply$mcVI$sp(self, v1: int) -> None: ...
    def apply$mcVJ$sp(self, v1: int) -> None: ...
    def apply$mcZD$sp(self, v1: float) -> bool: ...
    def apply$mcZF$sp(self, v1: float) -> bool: ...
    def apply$mcZI$sp(self, v1: int) -> bool: ...
    def apply$mcZJ$sp(self, v1: int) -> bool: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    def compose(self, g: scala.Function1[_compose__A, _AbstractFunction1__T1]) -> scala.Function1[_compose__A, _AbstractFunction1__R]: ...
    def toString(self) -> java.lang.String: ...

_AbstractFunction10__T1 = typing.TypeVar('_AbstractFunction10__T1')  # <T1>
_AbstractFunction10__T2 = typing.TypeVar('_AbstractFunction10__T2')  # <T2>
_AbstractFunction10__T3 = typing.TypeVar('_AbstractFunction10__T3')  # <T3>
_AbstractFunction10__T4 = typing.TypeVar('_AbstractFunction10__T4')  # <T4>
_AbstractFunction10__T5 = typing.TypeVar('_AbstractFunction10__T5')  # <T5>
_AbstractFunction10__T6 = typing.TypeVar('_AbstractFunction10__T6')  # <T6>
_AbstractFunction10__T7 = typing.TypeVar('_AbstractFunction10__T7')  # <T7>
_AbstractFunction10__T8 = typing.TypeVar('_AbstractFunction10__T8')  # <T8>
_AbstractFunction10__T9 = typing.TypeVar('_AbstractFunction10__T9')  # <T9>
_AbstractFunction10__T10 = typing.TypeVar('_AbstractFunction10__T10')  # <T10>
_AbstractFunction10__R = typing.TypeVar('_AbstractFunction10__R')  # <R>
class AbstractFunction10(scala.Function10[_AbstractFunction10__T1, _AbstractFunction10__T2, _AbstractFunction10__T3, _AbstractFunction10__T4, _AbstractFunction10__T5, _AbstractFunction10__T6, _AbstractFunction10__T7, _AbstractFunction10__T8, _AbstractFunction10__T9, _AbstractFunction10__T10, _AbstractFunction10__R], typing.Generic[_AbstractFunction10__T1, _AbstractFunction10__T2, _AbstractFunction10__T3, _AbstractFunction10__T4, _AbstractFunction10__T5, _AbstractFunction10__T6, _AbstractFunction10__T7, _AbstractFunction10__T8, _AbstractFunction10__T9, _AbstractFunction10__T10, _AbstractFunction10__R]):
    def __init__(self): ...
    def curried(self) -> scala.Function1[_AbstractFunction10__T1, scala.Function1[_AbstractFunction10__T2, scala.Function1[_AbstractFunction10__T3, scala.Function1[_AbstractFunction10__T4, scala.Function1[_AbstractFunction10__T5, scala.Function1[_AbstractFunction10__T6, scala.Function1[_AbstractFunction10__T7, scala.Function1[_AbstractFunction10__T8, scala.Function1[_AbstractFunction10__T9, scala.Function1[_AbstractFunction10__T10, _AbstractFunction10__R]]]]]]]]]]: ...
    def toString(self) -> java.lang.String: ...
    def tupled(self) -> scala.Function1[scala.Tuple10[_AbstractFunction10__T1, _AbstractFunction10__T2, _AbstractFunction10__T3, _AbstractFunction10__T4, _AbstractFunction10__T5, _AbstractFunction10__T6, _AbstractFunction10__T7, _AbstractFunction10__T8, _AbstractFunction10__T9, _AbstractFunction10__T10], _AbstractFunction10__R]: ...

_AbstractFunction11__T1 = typing.TypeVar('_AbstractFunction11__T1')  # <T1>
_AbstractFunction11__T2 = typing.TypeVar('_AbstractFunction11__T2')  # <T2>
_AbstractFunction11__T3 = typing.TypeVar('_AbstractFunction11__T3')  # <T3>
_AbstractFunction11__T4 = typing.TypeVar('_AbstractFunction11__T4')  # <T4>
_AbstractFunction11__T5 = typing.TypeVar('_AbstractFunction11__T5')  # <T5>
_AbstractFunction11__T6 = typing.TypeVar('_AbstractFunction11__T6')  # <T6>
_AbstractFunction11__T7 = typing.TypeVar('_AbstractFunction11__T7')  # <T7>
_AbstractFunction11__T8 = typing.TypeVar('_AbstractFunction11__T8')  # <T8>
_AbstractFunction11__T9 = typing.TypeVar('_AbstractFunction11__T9')  # <T9>
_AbstractFunction11__T10 = typing.TypeVar('_AbstractFunction11__T10')  # <T10>
_AbstractFunction11__T11 = typing.TypeVar('_AbstractFunction11__T11')  # <T11>
_AbstractFunction11__R = typing.TypeVar('_AbstractFunction11__R')  # <R>
class AbstractFunction11(scala.Function11[_AbstractFunction11__T1, _AbstractFunction11__T2, _AbstractFunction11__T3, _AbstractFunction11__T4, _AbstractFunction11__T5, _AbstractFunction11__T6, _AbstractFunction11__T7, _AbstractFunction11__T8, _AbstractFunction11__T9, _AbstractFunction11__T10, _AbstractFunction11__T11, _AbstractFunction11__R], typing.Generic[_AbstractFunction11__T1, _AbstractFunction11__T2, _AbstractFunction11__T3, _AbstractFunction11__T4, _AbstractFunction11__T5, _AbstractFunction11__T6, _AbstractFunction11__T7, _AbstractFunction11__T8, _AbstractFunction11__T9, _AbstractFunction11__T10, _AbstractFunction11__T11, _AbstractFunction11__R]):
    def __init__(self): ...
    def curried(self) -> scala.Function1[_AbstractFunction11__T1, scala.Function1[_AbstractFunction11__T2, scala.Function1[_AbstractFunction11__T3, scala.Function1[_AbstractFunction11__T4, scala.Function1[_AbstractFunction11__T5, scala.Function1[_AbstractFunction11__T6, scala.Function1[_AbstractFunction11__T7, scala.Function1[_AbstractFunction11__T8, scala.Function1[_AbstractFunction11__T9, scala.Function1[_AbstractFunction11__T10, scala.Function1[_AbstractFunction11__T11, _AbstractFunction11__R]]]]]]]]]]]: ...
    def toString(self) -> java.lang.String: ...
    def tupled(self) -> scala.Function1[scala.Tuple11[_AbstractFunction11__T1, _AbstractFunction11__T2, _AbstractFunction11__T3, _AbstractFunction11__T4, _AbstractFunction11__T5, _AbstractFunction11__T6, _AbstractFunction11__T7, _AbstractFunction11__T8, _AbstractFunction11__T9, _AbstractFunction11__T10, _AbstractFunction11__T11], _AbstractFunction11__R]: ...

_AbstractFunction12__T1 = typing.TypeVar('_AbstractFunction12__T1')  # <T1>
_AbstractFunction12__T2 = typing.TypeVar('_AbstractFunction12__T2')  # <T2>
_AbstractFunction12__T3 = typing.TypeVar('_AbstractFunction12__T3')  # <T3>
_AbstractFunction12__T4 = typing.TypeVar('_AbstractFunction12__T4')  # <T4>
_AbstractFunction12__T5 = typing.TypeVar('_AbstractFunction12__T5')  # <T5>
_AbstractFunction12__T6 = typing.TypeVar('_AbstractFunction12__T6')  # <T6>
_AbstractFunction12__T7 = typing.TypeVar('_AbstractFunction12__T7')  # <T7>
_AbstractFunction12__T8 = typing.TypeVar('_AbstractFunction12__T8')  # <T8>
_AbstractFunction12__T9 = typing.TypeVar('_AbstractFunction12__T9')  # <T9>
_AbstractFunction12__T10 = typing.TypeVar('_AbstractFunction12__T10')  # <T10>
_AbstractFunction12__T11 = typing.TypeVar('_AbstractFunction12__T11')  # <T11>
_AbstractFunction12__T12 = typing.TypeVar('_AbstractFunction12__T12')  # <T12>
_AbstractFunction12__R = typing.TypeVar('_AbstractFunction12__R')  # <R>
class AbstractFunction12(scala.Function12[_AbstractFunction12__T1, _AbstractFunction12__T2, _AbstractFunction12__T3, _AbstractFunction12__T4, _AbstractFunction12__T5, _AbstractFunction12__T6, _AbstractFunction12__T7, _AbstractFunction12__T8, _AbstractFunction12__T9, _AbstractFunction12__T10, _AbstractFunction12__T11, _AbstractFunction12__T12, _AbstractFunction12__R], typing.Generic[_AbstractFunction12__T1, _AbstractFunction12__T2, _AbstractFunction12__T3, _AbstractFunction12__T4, _AbstractFunction12__T5, _AbstractFunction12__T6, _AbstractFunction12__T7, _AbstractFunction12__T8, _AbstractFunction12__T9, _AbstractFunction12__T10, _AbstractFunction12__T11, _AbstractFunction12__T12, _AbstractFunction12__R]):
    def __init__(self): ...
    def curried(self) -> scala.Function1[_AbstractFunction12__T1, scala.Function1[_AbstractFunction12__T2, scala.Function1[_AbstractFunction12__T3, scala.Function1[_AbstractFunction12__T4, scala.Function1[_AbstractFunction12__T5, scala.Function1[_AbstractFunction12__T6, scala.Function1[_AbstractFunction12__T7, scala.Function1[_AbstractFunction12__T8, scala.Function1[_AbstractFunction12__T9, scala.Function1[_AbstractFunction12__T10, scala.Function1[_AbstractFunction12__T11, scala.Function1[_AbstractFunction12__T12, _AbstractFunction12__R]]]]]]]]]]]]: ...
    def toString(self) -> java.lang.String: ...
    def tupled(self) -> scala.Function1[scala.Tuple12[_AbstractFunction12__T1, _AbstractFunction12__T2, _AbstractFunction12__T3, _AbstractFunction12__T4, _AbstractFunction12__T5, _AbstractFunction12__T6, _AbstractFunction12__T7, _AbstractFunction12__T8, _AbstractFunction12__T9, _AbstractFunction12__T10, _AbstractFunction12__T11, _AbstractFunction12__T12], _AbstractFunction12__R]: ...

_AbstractFunction13__T1 = typing.TypeVar('_AbstractFunction13__T1')  # <T1>
_AbstractFunction13__T2 = typing.TypeVar('_AbstractFunction13__T2')  # <T2>
_AbstractFunction13__T3 = typing.TypeVar('_AbstractFunction13__T3')  # <T3>
_AbstractFunction13__T4 = typing.TypeVar('_AbstractFunction13__T4')  # <T4>
_AbstractFunction13__T5 = typing.TypeVar('_AbstractFunction13__T5')  # <T5>
_AbstractFunction13__T6 = typing.TypeVar('_AbstractFunction13__T6')  # <T6>
_AbstractFunction13__T7 = typing.TypeVar('_AbstractFunction13__T7')  # <T7>
_AbstractFunction13__T8 = typing.TypeVar('_AbstractFunction13__T8')  # <T8>
_AbstractFunction13__T9 = typing.TypeVar('_AbstractFunction13__T9')  # <T9>
_AbstractFunction13__T10 = typing.TypeVar('_AbstractFunction13__T10')  # <T10>
_AbstractFunction13__T11 = typing.TypeVar('_AbstractFunction13__T11')  # <T11>
_AbstractFunction13__T12 = typing.TypeVar('_AbstractFunction13__T12')  # <T12>
_AbstractFunction13__T13 = typing.TypeVar('_AbstractFunction13__T13')  # <T13>
_AbstractFunction13__R = typing.TypeVar('_AbstractFunction13__R')  # <R>
class AbstractFunction13(scala.Function13[_AbstractFunction13__T1, _AbstractFunction13__T2, _AbstractFunction13__T3, _AbstractFunction13__T4, _AbstractFunction13__T5, _AbstractFunction13__T6, _AbstractFunction13__T7, _AbstractFunction13__T8, _AbstractFunction13__T9, _AbstractFunction13__T10, _AbstractFunction13__T11, _AbstractFunction13__T12, _AbstractFunction13__T13, _AbstractFunction13__R], typing.Generic[_AbstractFunction13__T1, _AbstractFunction13__T2, _AbstractFunction13__T3, _AbstractFunction13__T4, _AbstractFunction13__T5, _AbstractFunction13__T6, _AbstractFunction13__T7, _AbstractFunction13__T8, _AbstractFunction13__T9, _AbstractFunction13__T10, _AbstractFunction13__T11, _AbstractFunction13__T12, _AbstractFunction13__T13, _AbstractFunction13__R]):
    def __init__(self): ...
    def curried(self) -> scala.Function1[_AbstractFunction13__T1, scala.Function1[_AbstractFunction13__T2, scala.Function1[_AbstractFunction13__T3, scala.Function1[_AbstractFunction13__T4, scala.Function1[_AbstractFunction13__T5, scala.Function1[_AbstractFunction13__T6, scala.Function1[_AbstractFunction13__T7, scala.Function1[_AbstractFunction13__T8, scala.Function1[_AbstractFunction13__T9, scala.Function1[_AbstractFunction13__T10, scala.Function1[_AbstractFunction13__T11, scala.Function1[_AbstractFunction13__T12, scala.Function1[_AbstractFunction13__T13, _AbstractFunction13__R]]]]]]]]]]]]]: ...
    def toString(self) -> java.lang.String: ...
    def tupled(self) -> scala.Function1[scala.Tuple13[_AbstractFunction13__T1, _AbstractFunction13__T2, _AbstractFunction13__T3, _AbstractFunction13__T4, _AbstractFunction13__T5, _AbstractFunction13__T6, _AbstractFunction13__T7, _AbstractFunction13__T8, _AbstractFunction13__T9, _AbstractFunction13__T10, _AbstractFunction13__T11, _AbstractFunction13__T12, _AbstractFunction13__T13], _AbstractFunction13__R]: ...

_AbstractFunction14__T1 = typing.TypeVar('_AbstractFunction14__T1')  # <T1>
_AbstractFunction14__T2 = typing.TypeVar('_AbstractFunction14__T2')  # <T2>
_AbstractFunction14__T3 = typing.TypeVar('_AbstractFunction14__T3')  # <T3>
_AbstractFunction14__T4 = typing.TypeVar('_AbstractFunction14__T4')  # <T4>
_AbstractFunction14__T5 = typing.TypeVar('_AbstractFunction14__T5')  # <T5>
_AbstractFunction14__T6 = typing.TypeVar('_AbstractFunction14__T6')  # <T6>
_AbstractFunction14__T7 = typing.TypeVar('_AbstractFunction14__T7')  # <T7>
_AbstractFunction14__T8 = typing.TypeVar('_AbstractFunction14__T8')  # <T8>
_AbstractFunction14__T9 = typing.TypeVar('_AbstractFunction14__T9')  # <T9>
_AbstractFunction14__T10 = typing.TypeVar('_AbstractFunction14__T10')  # <T10>
_AbstractFunction14__T11 = typing.TypeVar('_AbstractFunction14__T11')  # <T11>
_AbstractFunction14__T12 = typing.TypeVar('_AbstractFunction14__T12')  # <T12>
_AbstractFunction14__T13 = typing.TypeVar('_AbstractFunction14__T13')  # <T13>
_AbstractFunction14__T14 = typing.TypeVar('_AbstractFunction14__T14')  # <T14>
_AbstractFunction14__R = typing.TypeVar('_AbstractFunction14__R')  # <R>
class AbstractFunction14(scala.Function14[_AbstractFunction14__T1, _AbstractFunction14__T2, _AbstractFunction14__T3, _AbstractFunction14__T4, _AbstractFunction14__T5, _AbstractFunction14__T6, _AbstractFunction14__T7, _AbstractFunction14__T8, _AbstractFunction14__T9, _AbstractFunction14__T10, _AbstractFunction14__T11, _AbstractFunction14__T12, _AbstractFunction14__T13, _AbstractFunction14__T14, _AbstractFunction14__R], typing.Generic[_AbstractFunction14__T1, _AbstractFunction14__T2, _AbstractFunction14__T3, _AbstractFunction14__T4, _AbstractFunction14__T5, _AbstractFunction14__T6, _AbstractFunction14__T7, _AbstractFunction14__T8, _AbstractFunction14__T9, _AbstractFunction14__T10, _AbstractFunction14__T11, _AbstractFunction14__T12, _AbstractFunction14__T13, _AbstractFunction14__T14, _AbstractFunction14__R]):
    def __init__(self): ...
    def curried(self) -> scala.Function1[_AbstractFunction14__T1, scala.Function1[_AbstractFunction14__T2, scala.Function1[_AbstractFunction14__T3, scala.Function1[_AbstractFunction14__T4, scala.Function1[_AbstractFunction14__T5, scala.Function1[_AbstractFunction14__T6, scala.Function1[_AbstractFunction14__T7, scala.Function1[_AbstractFunction14__T8, scala.Function1[_AbstractFunction14__T9, scala.Function1[_AbstractFunction14__T10, scala.Function1[_AbstractFunction14__T11, scala.Function1[_AbstractFunction14__T12, scala.Function1[_AbstractFunction14__T13, scala.Function1[_AbstractFunction14__T14, _AbstractFunction14__R]]]]]]]]]]]]]]: ...
    def toString(self) -> java.lang.String: ...
    def tupled(self) -> scala.Function1[scala.Tuple14[_AbstractFunction14__T1, _AbstractFunction14__T2, _AbstractFunction14__T3, _AbstractFunction14__T4, _AbstractFunction14__T5, _AbstractFunction14__T6, _AbstractFunction14__T7, _AbstractFunction14__T8, _AbstractFunction14__T9, _AbstractFunction14__T10, _AbstractFunction14__T11, _AbstractFunction14__T12, _AbstractFunction14__T13, _AbstractFunction14__T14], _AbstractFunction14__R]: ...

_AbstractFunction15__T1 = typing.TypeVar('_AbstractFunction15__T1')  # <T1>
_AbstractFunction15__T2 = typing.TypeVar('_AbstractFunction15__T2')  # <T2>
_AbstractFunction15__T3 = typing.TypeVar('_AbstractFunction15__T3')  # <T3>
_AbstractFunction15__T4 = typing.TypeVar('_AbstractFunction15__T4')  # <T4>
_AbstractFunction15__T5 = typing.TypeVar('_AbstractFunction15__T5')  # <T5>
_AbstractFunction15__T6 = typing.TypeVar('_AbstractFunction15__T6')  # <T6>
_AbstractFunction15__T7 = typing.TypeVar('_AbstractFunction15__T7')  # <T7>
_AbstractFunction15__T8 = typing.TypeVar('_AbstractFunction15__T8')  # <T8>
_AbstractFunction15__T9 = typing.TypeVar('_AbstractFunction15__T9')  # <T9>
_AbstractFunction15__T10 = typing.TypeVar('_AbstractFunction15__T10')  # <T10>
_AbstractFunction15__T11 = typing.TypeVar('_AbstractFunction15__T11')  # <T11>
_AbstractFunction15__T12 = typing.TypeVar('_AbstractFunction15__T12')  # <T12>
_AbstractFunction15__T13 = typing.TypeVar('_AbstractFunction15__T13')  # <T13>
_AbstractFunction15__T14 = typing.TypeVar('_AbstractFunction15__T14')  # <T14>
_AbstractFunction15__T15 = typing.TypeVar('_AbstractFunction15__T15')  # <T15>
_AbstractFunction15__R = typing.TypeVar('_AbstractFunction15__R')  # <R>
class AbstractFunction15(scala.Function15[_AbstractFunction15__T1, _AbstractFunction15__T2, _AbstractFunction15__T3, _AbstractFunction15__T4, _AbstractFunction15__T5, _AbstractFunction15__T6, _AbstractFunction15__T7, _AbstractFunction15__T8, _AbstractFunction15__T9, _AbstractFunction15__T10, _AbstractFunction15__T11, _AbstractFunction15__T12, _AbstractFunction15__T13, _AbstractFunction15__T14, _AbstractFunction15__T15, _AbstractFunction15__R], typing.Generic[_AbstractFunction15__T1, _AbstractFunction15__T2, _AbstractFunction15__T3, _AbstractFunction15__T4, _AbstractFunction15__T5, _AbstractFunction15__T6, _AbstractFunction15__T7, _AbstractFunction15__T8, _AbstractFunction15__T9, _AbstractFunction15__T10, _AbstractFunction15__T11, _AbstractFunction15__T12, _AbstractFunction15__T13, _AbstractFunction15__T14, _AbstractFunction15__T15, _AbstractFunction15__R]):
    def __init__(self): ...
    def curried(self) -> scala.Function1[_AbstractFunction15__T1, scala.Function1[_AbstractFunction15__T2, scala.Function1[_AbstractFunction15__T3, scala.Function1[_AbstractFunction15__T4, scala.Function1[_AbstractFunction15__T5, scala.Function1[_AbstractFunction15__T6, scala.Function1[_AbstractFunction15__T7, scala.Function1[_AbstractFunction15__T8, scala.Function1[_AbstractFunction15__T9, scala.Function1[_AbstractFunction15__T10, scala.Function1[_AbstractFunction15__T11, scala.Function1[_AbstractFunction15__T12, scala.Function1[_AbstractFunction15__T13, scala.Function1[_AbstractFunction15__T14, scala.Function1[_AbstractFunction15__T15, _AbstractFunction15__R]]]]]]]]]]]]]]]: ...
    def toString(self) -> java.lang.String: ...
    def tupled(self) -> scala.Function1[scala.Tuple15[_AbstractFunction15__T1, _AbstractFunction15__T2, _AbstractFunction15__T3, _AbstractFunction15__T4, _AbstractFunction15__T5, _AbstractFunction15__T6, _AbstractFunction15__T7, _AbstractFunction15__T8, _AbstractFunction15__T9, _AbstractFunction15__T10, _AbstractFunction15__T11, _AbstractFunction15__T12, _AbstractFunction15__T13, _AbstractFunction15__T14, _AbstractFunction15__T15], _AbstractFunction15__R]: ...

_AbstractFunction16__T1 = typing.TypeVar('_AbstractFunction16__T1')  # <T1>
_AbstractFunction16__T2 = typing.TypeVar('_AbstractFunction16__T2')  # <T2>
_AbstractFunction16__T3 = typing.TypeVar('_AbstractFunction16__T3')  # <T3>
_AbstractFunction16__T4 = typing.TypeVar('_AbstractFunction16__T4')  # <T4>
_AbstractFunction16__T5 = typing.TypeVar('_AbstractFunction16__T5')  # <T5>
_AbstractFunction16__T6 = typing.TypeVar('_AbstractFunction16__T6')  # <T6>
_AbstractFunction16__T7 = typing.TypeVar('_AbstractFunction16__T7')  # <T7>
_AbstractFunction16__T8 = typing.TypeVar('_AbstractFunction16__T8')  # <T8>
_AbstractFunction16__T9 = typing.TypeVar('_AbstractFunction16__T9')  # <T9>
_AbstractFunction16__T10 = typing.TypeVar('_AbstractFunction16__T10')  # <T10>
_AbstractFunction16__T11 = typing.TypeVar('_AbstractFunction16__T11')  # <T11>
_AbstractFunction16__T12 = typing.TypeVar('_AbstractFunction16__T12')  # <T12>
_AbstractFunction16__T13 = typing.TypeVar('_AbstractFunction16__T13')  # <T13>
_AbstractFunction16__T14 = typing.TypeVar('_AbstractFunction16__T14')  # <T14>
_AbstractFunction16__T15 = typing.TypeVar('_AbstractFunction16__T15')  # <T15>
_AbstractFunction16__T16 = typing.TypeVar('_AbstractFunction16__T16')  # <T16>
_AbstractFunction16__R = typing.TypeVar('_AbstractFunction16__R')  # <R>
class AbstractFunction16(scala.Function16[_AbstractFunction16__T1, _AbstractFunction16__T2, _AbstractFunction16__T3, _AbstractFunction16__T4, _AbstractFunction16__T5, _AbstractFunction16__T6, _AbstractFunction16__T7, _AbstractFunction16__T8, _AbstractFunction16__T9, _AbstractFunction16__T10, _AbstractFunction16__T11, _AbstractFunction16__T12, _AbstractFunction16__T13, _AbstractFunction16__T14, _AbstractFunction16__T15, _AbstractFunction16__T16, _AbstractFunction16__R], typing.Generic[_AbstractFunction16__T1, _AbstractFunction16__T2, _AbstractFunction16__T3, _AbstractFunction16__T4, _AbstractFunction16__T5, _AbstractFunction16__T6, _AbstractFunction16__T7, _AbstractFunction16__T8, _AbstractFunction16__T9, _AbstractFunction16__T10, _AbstractFunction16__T11, _AbstractFunction16__T12, _AbstractFunction16__T13, _AbstractFunction16__T14, _AbstractFunction16__T15, _AbstractFunction16__T16, _AbstractFunction16__R]):
    def __init__(self): ...
    def curried(self) -> scala.Function1[_AbstractFunction16__T1, scala.Function1[_AbstractFunction16__T2, scala.Function1[_AbstractFunction16__T3, scala.Function1[_AbstractFunction16__T4, scala.Function1[_AbstractFunction16__T5, scala.Function1[_AbstractFunction16__T6, scala.Function1[_AbstractFunction16__T7, scala.Function1[_AbstractFunction16__T8, scala.Function1[_AbstractFunction16__T9, scala.Function1[_AbstractFunction16__T10, scala.Function1[_AbstractFunction16__T11, scala.Function1[_AbstractFunction16__T12, scala.Function1[_AbstractFunction16__T13, scala.Function1[_AbstractFunction16__T14, scala.Function1[_AbstractFunction16__T15, scala.Function1[_AbstractFunction16__T16, _AbstractFunction16__R]]]]]]]]]]]]]]]]: ...
    def toString(self) -> java.lang.String: ...
    def tupled(self) -> scala.Function1[scala.Tuple16[_AbstractFunction16__T1, _AbstractFunction16__T2, _AbstractFunction16__T3, _AbstractFunction16__T4, _AbstractFunction16__T5, _AbstractFunction16__T6, _AbstractFunction16__T7, _AbstractFunction16__T8, _AbstractFunction16__T9, _AbstractFunction16__T10, _AbstractFunction16__T11, _AbstractFunction16__T12, _AbstractFunction16__T13, _AbstractFunction16__T14, _AbstractFunction16__T15, _AbstractFunction16__T16], _AbstractFunction16__R]: ...

_AbstractFunction17__T1 = typing.TypeVar('_AbstractFunction17__T1')  # <T1>
_AbstractFunction17__T2 = typing.TypeVar('_AbstractFunction17__T2')  # <T2>
_AbstractFunction17__T3 = typing.TypeVar('_AbstractFunction17__T3')  # <T3>
_AbstractFunction17__T4 = typing.TypeVar('_AbstractFunction17__T4')  # <T4>
_AbstractFunction17__T5 = typing.TypeVar('_AbstractFunction17__T5')  # <T5>
_AbstractFunction17__T6 = typing.TypeVar('_AbstractFunction17__T6')  # <T6>
_AbstractFunction17__T7 = typing.TypeVar('_AbstractFunction17__T7')  # <T7>
_AbstractFunction17__T8 = typing.TypeVar('_AbstractFunction17__T8')  # <T8>
_AbstractFunction17__T9 = typing.TypeVar('_AbstractFunction17__T9')  # <T9>
_AbstractFunction17__T10 = typing.TypeVar('_AbstractFunction17__T10')  # <T10>
_AbstractFunction17__T11 = typing.TypeVar('_AbstractFunction17__T11')  # <T11>
_AbstractFunction17__T12 = typing.TypeVar('_AbstractFunction17__T12')  # <T12>
_AbstractFunction17__T13 = typing.TypeVar('_AbstractFunction17__T13')  # <T13>
_AbstractFunction17__T14 = typing.TypeVar('_AbstractFunction17__T14')  # <T14>
_AbstractFunction17__T15 = typing.TypeVar('_AbstractFunction17__T15')  # <T15>
_AbstractFunction17__T16 = typing.TypeVar('_AbstractFunction17__T16')  # <T16>
_AbstractFunction17__T17 = typing.TypeVar('_AbstractFunction17__T17')  # <T17>
_AbstractFunction17__R = typing.TypeVar('_AbstractFunction17__R')  # <R>
class AbstractFunction17(scala.Function17[_AbstractFunction17__T1, _AbstractFunction17__T2, _AbstractFunction17__T3, _AbstractFunction17__T4, _AbstractFunction17__T5, _AbstractFunction17__T6, _AbstractFunction17__T7, _AbstractFunction17__T8, _AbstractFunction17__T9, _AbstractFunction17__T10, _AbstractFunction17__T11, _AbstractFunction17__T12, _AbstractFunction17__T13, _AbstractFunction17__T14, _AbstractFunction17__T15, _AbstractFunction17__T16, _AbstractFunction17__T17, _AbstractFunction17__R], typing.Generic[_AbstractFunction17__T1, _AbstractFunction17__T2, _AbstractFunction17__T3, _AbstractFunction17__T4, _AbstractFunction17__T5, _AbstractFunction17__T6, _AbstractFunction17__T7, _AbstractFunction17__T8, _AbstractFunction17__T9, _AbstractFunction17__T10, _AbstractFunction17__T11, _AbstractFunction17__T12, _AbstractFunction17__T13, _AbstractFunction17__T14, _AbstractFunction17__T15, _AbstractFunction17__T16, _AbstractFunction17__T17, _AbstractFunction17__R]):
    def __init__(self): ...
    def curried(self) -> scala.Function1[_AbstractFunction17__T1, scala.Function1[_AbstractFunction17__T2, scala.Function1[_AbstractFunction17__T3, scala.Function1[_AbstractFunction17__T4, scala.Function1[_AbstractFunction17__T5, scala.Function1[_AbstractFunction17__T6, scala.Function1[_AbstractFunction17__T7, scala.Function1[_AbstractFunction17__T8, scala.Function1[_AbstractFunction17__T9, scala.Function1[_AbstractFunction17__T10, scala.Function1[_AbstractFunction17__T11, scala.Function1[_AbstractFunction17__T12, scala.Function1[_AbstractFunction17__T13, scala.Function1[_AbstractFunction17__T14, scala.Function1[_AbstractFunction17__T15, scala.Function1[_AbstractFunction17__T16, scala.Function1[_AbstractFunction17__T17, _AbstractFunction17__R]]]]]]]]]]]]]]]]]: ...
    def toString(self) -> java.lang.String: ...
    def tupled(self) -> scala.Function1[scala.Tuple17[_AbstractFunction17__T1, _AbstractFunction17__T2, _AbstractFunction17__T3, _AbstractFunction17__T4, _AbstractFunction17__T5, _AbstractFunction17__T6, _AbstractFunction17__T7, _AbstractFunction17__T8, _AbstractFunction17__T9, _AbstractFunction17__T10, _AbstractFunction17__T11, _AbstractFunction17__T12, _AbstractFunction17__T13, _AbstractFunction17__T14, _AbstractFunction17__T15, _AbstractFunction17__T16, _AbstractFunction17__T17], _AbstractFunction17__R]: ...

_AbstractFunction18__T1 = typing.TypeVar('_AbstractFunction18__T1')  # <T1>
_AbstractFunction18__T2 = typing.TypeVar('_AbstractFunction18__T2')  # <T2>
_AbstractFunction18__T3 = typing.TypeVar('_AbstractFunction18__T3')  # <T3>
_AbstractFunction18__T4 = typing.TypeVar('_AbstractFunction18__T4')  # <T4>
_AbstractFunction18__T5 = typing.TypeVar('_AbstractFunction18__T5')  # <T5>
_AbstractFunction18__T6 = typing.TypeVar('_AbstractFunction18__T6')  # <T6>
_AbstractFunction18__T7 = typing.TypeVar('_AbstractFunction18__T7')  # <T7>
_AbstractFunction18__T8 = typing.TypeVar('_AbstractFunction18__T8')  # <T8>
_AbstractFunction18__T9 = typing.TypeVar('_AbstractFunction18__T9')  # <T9>
_AbstractFunction18__T10 = typing.TypeVar('_AbstractFunction18__T10')  # <T10>
_AbstractFunction18__T11 = typing.TypeVar('_AbstractFunction18__T11')  # <T11>
_AbstractFunction18__T12 = typing.TypeVar('_AbstractFunction18__T12')  # <T12>
_AbstractFunction18__T13 = typing.TypeVar('_AbstractFunction18__T13')  # <T13>
_AbstractFunction18__T14 = typing.TypeVar('_AbstractFunction18__T14')  # <T14>
_AbstractFunction18__T15 = typing.TypeVar('_AbstractFunction18__T15')  # <T15>
_AbstractFunction18__T16 = typing.TypeVar('_AbstractFunction18__T16')  # <T16>
_AbstractFunction18__T17 = typing.TypeVar('_AbstractFunction18__T17')  # <T17>
_AbstractFunction18__T18 = typing.TypeVar('_AbstractFunction18__T18')  # <T18>
_AbstractFunction18__R = typing.TypeVar('_AbstractFunction18__R')  # <R>
class AbstractFunction18(scala.Function18[_AbstractFunction18__T1, _AbstractFunction18__T2, _AbstractFunction18__T3, _AbstractFunction18__T4, _AbstractFunction18__T5, _AbstractFunction18__T6, _AbstractFunction18__T7, _AbstractFunction18__T8, _AbstractFunction18__T9, _AbstractFunction18__T10, _AbstractFunction18__T11, _AbstractFunction18__T12, _AbstractFunction18__T13, _AbstractFunction18__T14, _AbstractFunction18__T15, _AbstractFunction18__T16, _AbstractFunction18__T17, _AbstractFunction18__T18, _AbstractFunction18__R], typing.Generic[_AbstractFunction18__T1, _AbstractFunction18__T2, _AbstractFunction18__T3, _AbstractFunction18__T4, _AbstractFunction18__T5, _AbstractFunction18__T6, _AbstractFunction18__T7, _AbstractFunction18__T8, _AbstractFunction18__T9, _AbstractFunction18__T10, _AbstractFunction18__T11, _AbstractFunction18__T12, _AbstractFunction18__T13, _AbstractFunction18__T14, _AbstractFunction18__T15, _AbstractFunction18__T16, _AbstractFunction18__T17, _AbstractFunction18__T18, _AbstractFunction18__R]):
    def __init__(self): ...
    def curried(self) -> scala.Function1[_AbstractFunction18__T1, scala.Function1[_AbstractFunction18__T2, scala.Function1[_AbstractFunction18__T3, scala.Function1[_AbstractFunction18__T4, scala.Function1[_AbstractFunction18__T5, scala.Function1[_AbstractFunction18__T6, scala.Function1[_AbstractFunction18__T7, scala.Function1[_AbstractFunction18__T8, scala.Function1[_AbstractFunction18__T9, scala.Function1[_AbstractFunction18__T10, scala.Function1[_AbstractFunction18__T11, scala.Function1[_AbstractFunction18__T12, scala.Function1[_AbstractFunction18__T13, scala.Function1[_AbstractFunction18__T14, scala.Function1[_AbstractFunction18__T15, scala.Function1[_AbstractFunction18__T16, scala.Function1[_AbstractFunction18__T17, scala.Function1[_AbstractFunction18__T18, _AbstractFunction18__R]]]]]]]]]]]]]]]]]]: ...
    def toString(self) -> java.lang.String: ...
    def tupled(self) -> scala.Function1[scala.Tuple18[_AbstractFunction18__T1, _AbstractFunction18__T2, _AbstractFunction18__T3, _AbstractFunction18__T4, _AbstractFunction18__T5, _AbstractFunction18__T6, _AbstractFunction18__T7, _AbstractFunction18__T8, _AbstractFunction18__T9, _AbstractFunction18__T10, _AbstractFunction18__T11, _AbstractFunction18__T12, _AbstractFunction18__T13, _AbstractFunction18__T14, _AbstractFunction18__T15, _AbstractFunction18__T16, _AbstractFunction18__T17, _AbstractFunction18__T18], _AbstractFunction18__R]: ...

_AbstractFunction19__T1 = typing.TypeVar('_AbstractFunction19__T1')  # <T1>
_AbstractFunction19__T2 = typing.TypeVar('_AbstractFunction19__T2')  # <T2>
_AbstractFunction19__T3 = typing.TypeVar('_AbstractFunction19__T3')  # <T3>
_AbstractFunction19__T4 = typing.TypeVar('_AbstractFunction19__T4')  # <T4>
_AbstractFunction19__T5 = typing.TypeVar('_AbstractFunction19__T5')  # <T5>
_AbstractFunction19__T6 = typing.TypeVar('_AbstractFunction19__T6')  # <T6>
_AbstractFunction19__T7 = typing.TypeVar('_AbstractFunction19__T7')  # <T7>
_AbstractFunction19__T8 = typing.TypeVar('_AbstractFunction19__T8')  # <T8>
_AbstractFunction19__T9 = typing.TypeVar('_AbstractFunction19__T9')  # <T9>
_AbstractFunction19__T10 = typing.TypeVar('_AbstractFunction19__T10')  # <T10>
_AbstractFunction19__T11 = typing.TypeVar('_AbstractFunction19__T11')  # <T11>
_AbstractFunction19__T12 = typing.TypeVar('_AbstractFunction19__T12')  # <T12>
_AbstractFunction19__T13 = typing.TypeVar('_AbstractFunction19__T13')  # <T13>
_AbstractFunction19__T14 = typing.TypeVar('_AbstractFunction19__T14')  # <T14>
_AbstractFunction19__T15 = typing.TypeVar('_AbstractFunction19__T15')  # <T15>
_AbstractFunction19__T16 = typing.TypeVar('_AbstractFunction19__T16')  # <T16>
_AbstractFunction19__T17 = typing.TypeVar('_AbstractFunction19__T17')  # <T17>
_AbstractFunction19__T18 = typing.TypeVar('_AbstractFunction19__T18')  # <T18>
_AbstractFunction19__T19 = typing.TypeVar('_AbstractFunction19__T19')  # <T19>
_AbstractFunction19__R = typing.TypeVar('_AbstractFunction19__R')  # <R>
class AbstractFunction19(scala.Function19[_AbstractFunction19__T1, _AbstractFunction19__T2, _AbstractFunction19__T3, _AbstractFunction19__T4, _AbstractFunction19__T5, _AbstractFunction19__T6, _AbstractFunction19__T7, _AbstractFunction19__T8, _AbstractFunction19__T9, _AbstractFunction19__T10, _AbstractFunction19__T11, _AbstractFunction19__T12, _AbstractFunction19__T13, _AbstractFunction19__T14, _AbstractFunction19__T15, _AbstractFunction19__T16, _AbstractFunction19__T17, _AbstractFunction19__T18, _AbstractFunction19__T19, _AbstractFunction19__R], typing.Generic[_AbstractFunction19__T1, _AbstractFunction19__T2, _AbstractFunction19__T3, _AbstractFunction19__T4, _AbstractFunction19__T5, _AbstractFunction19__T6, _AbstractFunction19__T7, _AbstractFunction19__T8, _AbstractFunction19__T9, _AbstractFunction19__T10, _AbstractFunction19__T11, _AbstractFunction19__T12, _AbstractFunction19__T13, _AbstractFunction19__T14, _AbstractFunction19__T15, _AbstractFunction19__T16, _AbstractFunction19__T17, _AbstractFunction19__T18, _AbstractFunction19__T19, _AbstractFunction19__R]):
    def __init__(self): ...
    def curried(self) -> scala.Function1[_AbstractFunction19__T1, scala.Function1[_AbstractFunction19__T2, scala.Function1[_AbstractFunction19__T3, scala.Function1[_AbstractFunction19__T4, scala.Function1[_AbstractFunction19__T5, scala.Function1[_AbstractFunction19__T6, scala.Function1[_AbstractFunction19__T7, scala.Function1[_AbstractFunction19__T8, scala.Function1[_AbstractFunction19__T9, scala.Function1[_AbstractFunction19__T10, scala.Function1[_AbstractFunction19__T11, scala.Function1[_AbstractFunction19__T12, scala.Function1[_AbstractFunction19__T13, scala.Function1[_AbstractFunction19__T14, scala.Function1[_AbstractFunction19__T15, scala.Function1[_AbstractFunction19__T16, scala.Function1[_AbstractFunction19__T17, scala.Function1[_AbstractFunction19__T18, scala.Function1[_AbstractFunction19__T19, _AbstractFunction19__R]]]]]]]]]]]]]]]]]]]: ...
    def toString(self) -> java.lang.String: ...
    def tupled(self) -> scala.Function1[scala.Tuple19[_AbstractFunction19__T1, _AbstractFunction19__T2, _AbstractFunction19__T3, _AbstractFunction19__T4, _AbstractFunction19__T5, _AbstractFunction19__T6, _AbstractFunction19__T7, _AbstractFunction19__T8, _AbstractFunction19__T9, _AbstractFunction19__T10, _AbstractFunction19__T11, _AbstractFunction19__T12, _AbstractFunction19__T13, _AbstractFunction19__T14, _AbstractFunction19__T15, _AbstractFunction19__T16, _AbstractFunction19__T17, _AbstractFunction19__T18, _AbstractFunction19__T19], _AbstractFunction19__R]: ...

_AbstractFunction2__T1 = typing.TypeVar('_AbstractFunction2__T1')  # <T1>
_AbstractFunction2__T2 = typing.TypeVar('_AbstractFunction2__T2')  # <T2>
_AbstractFunction2__R = typing.TypeVar('_AbstractFunction2__R')  # <R>
class AbstractFunction2(scala.Function2[_AbstractFunction2__T1, _AbstractFunction2__T2, _AbstractFunction2__R], typing.Generic[_AbstractFunction2__T1, _AbstractFunction2__T2, _AbstractFunction2__R]):
    def __init__(self): ...
    def apply$mcDDD$sp(self, v1: float, v2: float) -> float: ...
    def apply$mcDDI$sp(self, v1: float, v2: int) -> float: ...
    def apply$mcDDJ$sp(self, v1: float, v2: int) -> float: ...
    def apply$mcDID$sp(self, v1: int, v2: float) -> float: ...
    def apply$mcDII$sp(self, v1: int, v2: int) -> float: ...
    def apply$mcDIJ$sp(self, v1: int, v2: int) -> float: ...
    def apply$mcDJD$sp(self, v1: int, v2: float) -> float: ...
    def apply$mcDJI$sp(self, v1: int, v2: int) -> float: ...
    def apply$mcDJJ$sp(self, v1: int, v2: int) -> float: ...
    def apply$mcFDD$sp(self, v1: float, v2: float) -> float: ...
    def apply$mcFDI$sp(self, v1: float, v2: int) -> float: ...
    def apply$mcFDJ$sp(self, v1: float, v2: int) -> float: ...
    def apply$mcFID$sp(self, v1: int, v2: float) -> float: ...
    def apply$mcFII$sp(self, v1: int, v2: int) -> float: ...
    def apply$mcFIJ$sp(self, v1: int, v2: int) -> float: ...
    def apply$mcFJD$sp(self, v1: int, v2: float) -> float: ...
    def apply$mcFJI$sp(self, v1: int, v2: int) -> float: ...
    def apply$mcFJJ$sp(self, v1: int, v2: int) -> float: ...
    def apply$mcIDD$sp(self, v1: float, v2: float) -> int: ...
    def apply$mcIDI$sp(self, v1: float, v2: int) -> int: ...
    def apply$mcIDJ$sp(self, v1: float, v2: int) -> int: ...
    def apply$mcIID$sp(self, v1: int, v2: float) -> int: ...
    def apply$mcIII$sp(self, v1: int, v2: int) -> int: ...
    def apply$mcIIJ$sp(self, v1: int, v2: int) -> int: ...
    def apply$mcIJD$sp(self, v1: int, v2: float) -> int: ...
    def apply$mcIJI$sp(self, v1: int, v2: int) -> int: ...
    def apply$mcIJJ$sp(self, v1: int, v2: int) -> int: ...
    def apply$mcJDD$sp(self, v1: float, v2: float) -> int: ...
    def apply$mcJDI$sp(self, v1: float, v2: int) -> int: ...
    def apply$mcJDJ$sp(self, v1: float, v2: int) -> int: ...
    def apply$mcJID$sp(self, v1: int, v2: float) -> int: ...
    def apply$mcJII$sp(self, v1: int, v2: int) -> int: ...
    def apply$mcJIJ$sp(self, v1: int, v2: int) -> int: ...
    def apply$mcJJD$sp(self, v1: int, v2: float) -> int: ...
    def apply$mcJJI$sp(self, v1: int, v2: int) -> int: ...
    def apply$mcJJJ$sp(self, v1: int, v2: int) -> int: ...
    def apply$mcVDD$sp(self, v1: float, v2: float) -> None: ...
    def apply$mcVDI$sp(self, v1: float, v2: int) -> None: ...
    def apply$mcVDJ$sp(self, v1: float, v2: int) -> None: ...
    def apply$mcVID$sp(self, v1: int, v2: float) -> None: ...
    def apply$mcVII$sp(self, v1: int, v2: int) -> None: ...
    def apply$mcVIJ$sp(self, v1: int, v2: int) -> None: ...
    def apply$mcVJD$sp(self, v1: int, v2: float) -> None: ...
    def apply$mcVJI$sp(self, v1: int, v2: int) -> None: ...
    def apply$mcVJJ$sp(self, v1: int, v2: int) -> None: ...
    def apply$mcZDD$sp(self, v1: float, v2: float) -> bool: ...
    def apply$mcZDI$sp(self, v1: float, v2: int) -> bool: ...
    def apply$mcZDJ$sp(self, v1: float, v2: int) -> bool: ...
    def apply$mcZID$sp(self, v1: int, v2: float) -> bool: ...
    def apply$mcZII$sp(self, v1: int, v2: int) -> bool: ...
    def apply$mcZIJ$sp(self, v1: int, v2: int) -> bool: ...
    def apply$mcZJD$sp(self, v1: int, v2: float) -> bool: ...
    def apply$mcZJI$sp(self, v1: int, v2: int) -> bool: ...
    def apply$mcZJJ$sp(self, v1: int, v2: int) -> bool: ...
    def curried(self) -> scala.Function1[_AbstractFunction2__T1, scala.Function1[_AbstractFunction2__T2, _AbstractFunction2__R]]: ...
    def toString(self) -> java.lang.String: ...
    def tupled(self) -> scala.Function1[scala.Tuple2[_AbstractFunction2__T1, _AbstractFunction2__T2], _AbstractFunction2__R]: ...

_AbstractFunction20__T1 = typing.TypeVar('_AbstractFunction20__T1')  # <T1>
_AbstractFunction20__T2 = typing.TypeVar('_AbstractFunction20__T2')  # <T2>
_AbstractFunction20__T3 = typing.TypeVar('_AbstractFunction20__T3')  # <T3>
_AbstractFunction20__T4 = typing.TypeVar('_AbstractFunction20__T4')  # <T4>
_AbstractFunction20__T5 = typing.TypeVar('_AbstractFunction20__T5')  # <T5>
_AbstractFunction20__T6 = typing.TypeVar('_AbstractFunction20__T6')  # <T6>
_AbstractFunction20__T7 = typing.TypeVar('_AbstractFunction20__T7')  # <T7>
_AbstractFunction20__T8 = typing.TypeVar('_AbstractFunction20__T8')  # <T8>
_AbstractFunction20__T9 = typing.TypeVar('_AbstractFunction20__T9')  # <T9>
_AbstractFunction20__T10 = typing.TypeVar('_AbstractFunction20__T10')  # <T10>
_AbstractFunction20__T11 = typing.TypeVar('_AbstractFunction20__T11')  # <T11>
_AbstractFunction20__T12 = typing.TypeVar('_AbstractFunction20__T12')  # <T12>
_AbstractFunction20__T13 = typing.TypeVar('_AbstractFunction20__T13')  # <T13>
_AbstractFunction20__T14 = typing.TypeVar('_AbstractFunction20__T14')  # <T14>
_AbstractFunction20__T15 = typing.TypeVar('_AbstractFunction20__T15')  # <T15>
_AbstractFunction20__T16 = typing.TypeVar('_AbstractFunction20__T16')  # <T16>
_AbstractFunction20__T17 = typing.TypeVar('_AbstractFunction20__T17')  # <T17>
_AbstractFunction20__T18 = typing.TypeVar('_AbstractFunction20__T18')  # <T18>
_AbstractFunction20__T19 = typing.TypeVar('_AbstractFunction20__T19')  # <T19>
_AbstractFunction20__T20 = typing.TypeVar('_AbstractFunction20__T20')  # <T20>
_AbstractFunction20__R = typing.TypeVar('_AbstractFunction20__R')  # <R>
class AbstractFunction20(scala.Function20[_AbstractFunction20__T1, _AbstractFunction20__T2, _AbstractFunction20__T3, _AbstractFunction20__T4, _AbstractFunction20__T5, _AbstractFunction20__T6, _AbstractFunction20__T7, _AbstractFunction20__T8, _AbstractFunction20__T9, _AbstractFunction20__T10, _AbstractFunction20__T11, _AbstractFunction20__T12, _AbstractFunction20__T13, _AbstractFunction20__T14, _AbstractFunction20__T15, _AbstractFunction20__T16, _AbstractFunction20__T17, _AbstractFunction20__T18, _AbstractFunction20__T19, _AbstractFunction20__T20, _AbstractFunction20__R], typing.Generic[_AbstractFunction20__T1, _AbstractFunction20__T2, _AbstractFunction20__T3, _AbstractFunction20__T4, _AbstractFunction20__T5, _AbstractFunction20__T6, _AbstractFunction20__T7, _AbstractFunction20__T8, _AbstractFunction20__T9, _AbstractFunction20__T10, _AbstractFunction20__T11, _AbstractFunction20__T12, _AbstractFunction20__T13, _AbstractFunction20__T14, _AbstractFunction20__T15, _AbstractFunction20__T16, _AbstractFunction20__T17, _AbstractFunction20__T18, _AbstractFunction20__T19, _AbstractFunction20__T20, _AbstractFunction20__R]):
    def __init__(self): ...
    def curried(self) -> scala.Function1[_AbstractFunction20__T1, scala.Function1[_AbstractFunction20__T2, scala.Function1[_AbstractFunction20__T3, scala.Function1[_AbstractFunction20__T4, scala.Function1[_AbstractFunction20__T5, scala.Function1[_AbstractFunction20__T6, scala.Function1[_AbstractFunction20__T7, scala.Function1[_AbstractFunction20__T8, scala.Function1[_AbstractFunction20__T9, scala.Function1[_AbstractFunction20__T10, scala.Function1[_AbstractFunction20__T11, scala.Function1[_AbstractFunction20__T12, scala.Function1[_AbstractFunction20__T13, scala.Function1[_AbstractFunction20__T14, scala.Function1[_AbstractFunction20__T15, scala.Function1[_AbstractFunction20__T16, scala.Function1[_AbstractFunction20__T17, scala.Function1[_AbstractFunction20__T18, scala.Function1[_AbstractFunction20__T19, scala.Function1[_AbstractFunction20__T20, _AbstractFunction20__R]]]]]]]]]]]]]]]]]]]]: ...
    def toString(self) -> java.lang.String: ...
    def tupled(self) -> scala.Function1[scala.Tuple20[_AbstractFunction20__T1, _AbstractFunction20__T2, _AbstractFunction20__T3, _AbstractFunction20__T4, _AbstractFunction20__T5, _AbstractFunction20__T6, _AbstractFunction20__T7, _AbstractFunction20__T8, _AbstractFunction20__T9, _AbstractFunction20__T10, _AbstractFunction20__T11, _AbstractFunction20__T12, _AbstractFunction20__T13, _AbstractFunction20__T14, _AbstractFunction20__T15, _AbstractFunction20__T16, _AbstractFunction20__T17, _AbstractFunction20__T18, _AbstractFunction20__T19, _AbstractFunction20__T20], _AbstractFunction20__R]: ...

_AbstractFunction21__T1 = typing.TypeVar('_AbstractFunction21__T1')  # <T1>
_AbstractFunction21__T2 = typing.TypeVar('_AbstractFunction21__T2')  # <T2>
_AbstractFunction21__T3 = typing.TypeVar('_AbstractFunction21__T3')  # <T3>
_AbstractFunction21__T4 = typing.TypeVar('_AbstractFunction21__T4')  # <T4>
_AbstractFunction21__T5 = typing.TypeVar('_AbstractFunction21__T5')  # <T5>
_AbstractFunction21__T6 = typing.TypeVar('_AbstractFunction21__T6')  # <T6>
_AbstractFunction21__T7 = typing.TypeVar('_AbstractFunction21__T7')  # <T7>
_AbstractFunction21__T8 = typing.TypeVar('_AbstractFunction21__T8')  # <T8>
_AbstractFunction21__T9 = typing.TypeVar('_AbstractFunction21__T9')  # <T9>
_AbstractFunction21__T10 = typing.TypeVar('_AbstractFunction21__T10')  # <T10>
_AbstractFunction21__T11 = typing.TypeVar('_AbstractFunction21__T11')  # <T11>
_AbstractFunction21__T12 = typing.TypeVar('_AbstractFunction21__T12')  # <T12>
_AbstractFunction21__T13 = typing.TypeVar('_AbstractFunction21__T13')  # <T13>
_AbstractFunction21__T14 = typing.TypeVar('_AbstractFunction21__T14')  # <T14>
_AbstractFunction21__T15 = typing.TypeVar('_AbstractFunction21__T15')  # <T15>
_AbstractFunction21__T16 = typing.TypeVar('_AbstractFunction21__T16')  # <T16>
_AbstractFunction21__T17 = typing.TypeVar('_AbstractFunction21__T17')  # <T17>
_AbstractFunction21__T18 = typing.TypeVar('_AbstractFunction21__T18')  # <T18>
_AbstractFunction21__T19 = typing.TypeVar('_AbstractFunction21__T19')  # <T19>
_AbstractFunction21__T20 = typing.TypeVar('_AbstractFunction21__T20')  # <T20>
_AbstractFunction21__T21 = typing.TypeVar('_AbstractFunction21__T21')  # <T21>
_AbstractFunction21__R = typing.TypeVar('_AbstractFunction21__R')  # <R>
class AbstractFunction21(scala.Function21[_AbstractFunction21__T1, _AbstractFunction21__T2, _AbstractFunction21__T3, _AbstractFunction21__T4, _AbstractFunction21__T5, _AbstractFunction21__T6, _AbstractFunction21__T7, _AbstractFunction21__T8, _AbstractFunction21__T9, _AbstractFunction21__T10, _AbstractFunction21__T11, _AbstractFunction21__T12, _AbstractFunction21__T13, _AbstractFunction21__T14, _AbstractFunction21__T15, _AbstractFunction21__T16, _AbstractFunction21__T17, _AbstractFunction21__T18, _AbstractFunction21__T19, _AbstractFunction21__T20, _AbstractFunction21__T21, _AbstractFunction21__R], typing.Generic[_AbstractFunction21__T1, _AbstractFunction21__T2, _AbstractFunction21__T3, _AbstractFunction21__T4, _AbstractFunction21__T5, _AbstractFunction21__T6, _AbstractFunction21__T7, _AbstractFunction21__T8, _AbstractFunction21__T9, _AbstractFunction21__T10, _AbstractFunction21__T11, _AbstractFunction21__T12, _AbstractFunction21__T13, _AbstractFunction21__T14, _AbstractFunction21__T15, _AbstractFunction21__T16, _AbstractFunction21__T17, _AbstractFunction21__T18, _AbstractFunction21__T19, _AbstractFunction21__T20, _AbstractFunction21__T21, _AbstractFunction21__R]):
    def __init__(self): ...
    def curried(self) -> scala.Function1[_AbstractFunction21__T1, scala.Function1[_AbstractFunction21__T2, scala.Function1[_AbstractFunction21__T3, scala.Function1[_AbstractFunction21__T4, scala.Function1[_AbstractFunction21__T5, scala.Function1[_AbstractFunction21__T6, scala.Function1[_AbstractFunction21__T7, scala.Function1[_AbstractFunction21__T8, scala.Function1[_AbstractFunction21__T9, scala.Function1[_AbstractFunction21__T10, scala.Function1[_AbstractFunction21__T11, scala.Function1[_AbstractFunction21__T12, scala.Function1[_AbstractFunction21__T13, scala.Function1[_AbstractFunction21__T14, scala.Function1[_AbstractFunction21__T15, scala.Function1[_AbstractFunction21__T16, scala.Function1[_AbstractFunction21__T17, scala.Function1[_AbstractFunction21__T18, scala.Function1[_AbstractFunction21__T19, scala.Function1[_AbstractFunction21__T20, scala.Function1[_AbstractFunction21__T21, _AbstractFunction21__R]]]]]]]]]]]]]]]]]]]]]: ...
    def toString(self) -> java.lang.String: ...
    def tupled(self) -> scala.Function1[scala.Tuple21[_AbstractFunction21__T1, _AbstractFunction21__T2, _AbstractFunction21__T3, _AbstractFunction21__T4, _AbstractFunction21__T5, _AbstractFunction21__T6, _AbstractFunction21__T7, _AbstractFunction21__T8, _AbstractFunction21__T9, _AbstractFunction21__T10, _AbstractFunction21__T11, _AbstractFunction21__T12, _AbstractFunction21__T13, _AbstractFunction21__T14, _AbstractFunction21__T15, _AbstractFunction21__T16, _AbstractFunction21__T17, _AbstractFunction21__T18, _AbstractFunction21__T19, _AbstractFunction21__T20, _AbstractFunction21__T21], _AbstractFunction21__R]: ...

_AbstractFunction22__T1 = typing.TypeVar('_AbstractFunction22__T1')  # <T1>
_AbstractFunction22__T2 = typing.TypeVar('_AbstractFunction22__T2')  # <T2>
_AbstractFunction22__T3 = typing.TypeVar('_AbstractFunction22__T3')  # <T3>
_AbstractFunction22__T4 = typing.TypeVar('_AbstractFunction22__T4')  # <T4>
_AbstractFunction22__T5 = typing.TypeVar('_AbstractFunction22__T5')  # <T5>
_AbstractFunction22__T6 = typing.TypeVar('_AbstractFunction22__T6')  # <T6>
_AbstractFunction22__T7 = typing.TypeVar('_AbstractFunction22__T7')  # <T7>
_AbstractFunction22__T8 = typing.TypeVar('_AbstractFunction22__T8')  # <T8>
_AbstractFunction22__T9 = typing.TypeVar('_AbstractFunction22__T9')  # <T9>
_AbstractFunction22__T10 = typing.TypeVar('_AbstractFunction22__T10')  # <T10>
_AbstractFunction22__T11 = typing.TypeVar('_AbstractFunction22__T11')  # <T11>
_AbstractFunction22__T12 = typing.TypeVar('_AbstractFunction22__T12')  # <T12>
_AbstractFunction22__T13 = typing.TypeVar('_AbstractFunction22__T13')  # <T13>
_AbstractFunction22__T14 = typing.TypeVar('_AbstractFunction22__T14')  # <T14>
_AbstractFunction22__T15 = typing.TypeVar('_AbstractFunction22__T15')  # <T15>
_AbstractFunction22__T16 = typing.TypeVar('_AbstractFunction22__T16')  # <T16>
_AbstractFunction22__T17 = typing.TypeVar('_AbstractFunction22__T17')  # <T17>
_AbstractFunction22__T18 = typing.TypeVar('_AbstractFunction22__T18')  # <T18>
_AbstractFunction22__T19 = typing.TypeVar('_AbstractFunction22__T19')  # <T19>
_AbstractFunction22__T20 = typing.TypeVar('_AbstractFunction22__T20')  # <T20>
_AbstractFunction22__T21 = typing.TypeVar('_AbstractFunction22__T21')  # <T21>
_AbstractFunction22__T22 = typing.TypeVar('_AbstractFunction22__T22')  # <T22>
_AbstractFunction22__R = typing.TypeVar('_AbstractFunction22__R')  # <R>
class AbstractFunction22(scala.Function22[_AbstractFunction22__T1, _AbstractFunction22__T2, _AbstractFunction22__T3, _AbstractFunction22__T4, _AbstractFunction22__T5, _AbstractFunction22__T6, _AbstractFunction22__T7, _AbstractFunction22__T8, _AbstractFunction22__T9, _AbstractFunction22__T10, _AbstractFunction22__T11, _AbstractFunction22__T12, _AbstractFunction22__T13, _AbstractFunction22__T14, _AbstractFunction22__T15, _AbstractFunction22__T16, _AbstractFunction22__T17, _AbstractFunction22__T18, _AbstractFunction22__T19, _AbstractFunction22__T20, _AbstractFunction22__T21, _AbstractFunction22__T22, _AbstractFunction22__R], typing.Generic[_AbstractFunction22__T1, _AbstractFunction22__T2, _AbstractFunction22__T3, _AbstractFunction22__T4, _AbstractFunction22__T5, _AbstractFunction22__T6, _AbstractFunction22__T7, _AbstractFunction22__T8, _AbstractFunction22__T9, _AbstractFunction22__T10, _AbstractFunction22__T11, _AbstractFunction22__T12, _AbstractFunction22__T13, _AbstractFunction22__T14, _AbstractFunction22__T15, _AbstractFunction22__T16, _AbstractFunction22__T17, _AbstractFunction22__T18, _AbstractFunction22__T19, _AbstractFunction22__T20, _AbstractFunction22__T21, _AbstractFunction22__T22, _AbstractFunction22__R]):
    def __init__(self): ...
    def curried(self) -> scala.Function1[_AbstractFunction22__T1, scala.Function1[_AbstractFunction22__T2, scala.Function1[_AbstractFunction22__T3, scala.Function1[_AbstractFunction22__T4, scala.Function1[_AbstractFunction22__T5, scala.Function1[_AbstractFunction22__T6, scala.Function1[_AbstractFunction22__T7, scala.Function1[_AbstractFunction22__T8, scala.Function1[_AbstractFunction22__T9, scala.Function1[_AbstractFunction22__T10, scala.Function1[_AbstractFunction22__T11, scala.Function1[_AbstractFunction22__T12, scala.Function1[_AbstractFunction22__T13, scala.Function1[_AbstractFunction22__T14, scala.Function1[_AbstractFunction22__T15, scala.Function1[_AbstractFunction22__T16, scala.Function1[_AbstractFunction22__T17, scala.Function1[_AbstractFunction22__T18, scala.Function1[_AbstractFunction22__T19, scala.Function1[_AbstractFunction22__T20, scala.Function1[_AbstractFunction22__T21, scala.Function1[_AbstractFunction22__T22, _AbstractFunction22__R]]]]]]]]]]]]]]]]]]]]]]: ...
    def toString(self) -> java.lang.String: ...
    def tupled(self) -> scala.Function1[scala.Tuple22[_AbstractFunction22__T1, _AbstractFunction22__T2, _AbstractFunction22__T3, _AbstractFunction22__T4, _AbstractFunction22__T5, _AbstractFunction22__T6, _AbstractFunction22__T7, _AbstractFunction22__T8, _AbstractFunction22__T9, _AbstractFunction22__T10, _AbstractFunction22__T11, _AbstractFunction22__T12, _AbstractFunction22__T13, _AbstractFunction22__T14, _AbstractFunction22__T15, _AbstractFunction22__T16, _AbstractFunction22__T17, _AbstractFunction22__T18, _AbstractFunction22__T19, _AbstractFunction22__T20, _AbstractFunction22__T21, _AbstractFunction22__T22], _AbstractFunction22__R]: ...

_AbstractFunction3__T1 = typing.TypeVar('_AbstractFunction3__T1')  # <T1>
_AbstractFunction3__T2 = typing.TypeVar('_AbstractFunction3__T2')  # <T2>
_AbstractFunction3__T3 = typing.TypeVar('_AbstractFunction3__T3')  # <T3>
_AbstractFunction3__R = typing.TypeVar('_AbstractFunction3__R')  # <R>
class AbstractFunction3(scala.Function3[_AbstractFunction3__T1, _AbstractFunction3__T2, _AbstractFunction3__T3, _AbstractFunction3__R], typing.Generic[_AbstractFunction3__T1, _AbstractFunction3__T2, _AbstractFunction3__T3, _AbstractFunction3__R]):
    def __init__(self): ...
    def curried(self) -> scala.Function1[_AbstractFunction3__T1, scala.Function1[_AbstractFunction3__T2, scala.Function1[_AbstractFunction3__T3, _AbstractFunction3__R]]]: ...
    def toString(self) -> java.lang.String: ...
    def tupled(self) -> scala.Function1[scala.Tuple3[_AbstractFunction3__T1, _AbstractFunction3__T2, _AbstractFunction3__T3], _AbstractFunction3__R]: ...

_AbstractFunction4__T1 = typing.TypeVar('_AbstractFunction4__T1')  # <T1>
_AbstractFunction4__T2 = typing.TypeVar('_AbstractFunction4__T2')  # <T2>
_AbstractFunction4__T3 = typing.TypeVar('_AbstractFunction4__T3')  # <T3>
_AbstractFunction4__T4 = typing.TypeVar('_AbstractFunction4__T4')  # <T4>
_AbstractFunction4__R = typing.TypeVar('_AbstractFunction4__R')  # <R>
class AbstractFunction4(scala.Function4[_AbstractFunction4__T1, _AbstractFunction4__T2, _AbstractFunction4__T3, _AbstractFunction4__T4, _AbstractFunction4__R], typing.Generic[_AbstractFunction4__T1, _AbstractFunction4__T2, _AbstractFunction4__T3, _AbstractFunction4__T4, _AbstractFunction4__R]):
    def __init__(self): ...
    def curried(self) -> scala.Function1[_AbstractFunction4__T1, scala.Function1[_AbstractFunction4__T2, scala.Function1[_AbstractFunction4__T3, scala.Function1[_AbstractFunction4__T4, _AbstractFunction4__R]]]]: ...
    def toString(self) -> java.lang.String: ...
    def tupled(self) -> scala.Function1[scala.Tuple4[_AbstractFunction4__T1, _AbstractFunction4__T2, _AbstractFunction4__T3, _AbstractFunction4__T4], _AbstractFunction4__R]: ...

_AbstractFunction5__T1 = typing.TypeVar('_AbstractFunction5__T1')  # <T1>
_AbstractFunction5__T2 = typing.TypeVar('_AbstractFunction5__T2')  # <T2>
_AbstractFunction5__T3 = typing.TypeVar('_AbstractFunction5__T3')  # <T3>
_AbstractFunction5__T4 = typing.TypeVar('_AbstractFunction5__T4')  # <T4>
_AbstractFunction5__T5 = typing.TypeVar('_AbstractFunction5__T5')  # <T5>
_AbstractFunction5__R = typing.TypeVar('_AbstractFunction5__R')  # <R>
class AbstractFunction5(scala.Function5[_AbstractFunction5__T1, _AbstractFunction5__T2, _AbstractFunction5__T3, _AbstractFunction5__T4, _AbstractFunction5__T5, _AbstractFunction5__R], typing.Generic[_AbstractFunction5__T1, _AbstractFunction5__T2, _AbstractFunction5__T3, _AbstractFunction5__T4, _AbstractFunction5__T5, _AbstractFunction5__R]):
    def __init__(self): ...
    def curried(self) -> scala.Function1[_AbstractFunction5__T1, scala.Function1[_AbstractFunction5__T2, scala.Function1[_AbstractFunction5__T3, scala.Function1[_AbstractFunction5__T4, scala.Function1[_AbstractFunction5__T5, _AbstractFunction5__R]]]]]: ...
    def toString(self) -> java.lang.String: ...
    def tupled(self) -> scala.Function1[scala.Tuple5[_AbstractFunction5__T1, _AbstractFunction5__T2, _AbstractFunction5__T3, _AbstractFunction5__T4, _AbstractFunction5__T5], _AbstractFunction5__R]: ...

_AbstractFunction6__T1 = typing.TypeVar('_AbstractFunction6__T1')  # <T1>
_AbstractFunction6__T2 = typing.TypeVar('_AbstractFunction6__T2')  # <T2>
_AbstractFunction6__T3 = typing.TypeVar('_AbstractFunction6__T3')  # <T3>
_AbstractFunction6__T4 = typing.TypeVar('_AbstractFunction6__T4')  # <T4>
_AbstractFunction6__T5 = typing.TypeVar('_AbstractFunction6__T5')  # <T5>
_AbstractFunction6__T6 = typing.TypeVar('_AbstractFunction6__T6')  # <T6>
_AbstractFunction6__R = typing.TypeVar('_AbstractFunction6__R')  # <R>
class AbstractFunction6(scala.Function6[_AbstractFunction6__T1, _AbstractFunction6__T2, _AbstractFunction6__T3, _AbstractFunction6__T4, _AbstractFunction6__T5, _AbstractFunction6__T6, _AbstractFunction6__R], typing.Generic[_AbstractFunction6__T1, _AbstractFunction6__T2, _AbstractFunction6__T3, _AbstractFunction6__T4, _AbstractFunction6__T5, _AbstractFunction6__T6, _AbstractFunction6__R]):
    def __init__(self): ...
    def curried(self) -> scala.Function1[_AbstractFunction6__T1, scala.Function1[_AbstractFunction6__T2, scala.Function1[_AbstractFunction6__T3, scala.Function1[_AbstractFunction6__T4, scala.Function1[_AbstractFunction6__T5, scala.Function1[_AbstractFunction6__T6, _AbstractFunction6__R]]]]]]: ...
    def toString(self) -> java.lang.String: ...
    def tupled(self) -> scala.Function1[scala.Tuple6[_AbstractFunction6__T1, _AbstractFunction6__T2, _AbstractFunction6__T3, _AbstractFunction6__T4, _AbstractFunction6__T5, _AbstractFunction6__T6], _AbstractFunction6__R]: ...

_AbstractFunction7__T1 = typing.TypeVar('_AbstractFunction7__T1')  # <T1>
_AbstractFunction7__T2 = typing.TypeVar('_AbstractFunction7__T2')  # <T2>
_AbstractFunction7__T3 = typing.TypeVar('_AbstractFunction7__T3')  # <T3>
_AbstractFunction7__T4 = typing.TypeVar('_AbstractFunction7__T4')  # <T4>
_AbstractFunction7__T5 = typing.TypeVar('_AbstractFunction7__T5')  # <T5>
_AbstractFunction7__T6 = typing.TypeVar('_AbstractFunction7__T6')  # <T6>
_AbstractFunction7__T7 = typing.TypeVar('_AbstractFunction7__T7')  # <T7>
_AbstractFunction7__R = typing.TypeVar('_AbstractFunction7__R')  # <R>
class AbstractFunction7(scala.Function7[_AbstractFunction7__T1, _AbstractFunction7__T2, _AbstractFunction7__T3, _AbstractFunction7__T4, _AbstractFunction7__T5, _AbstractFunction7__T6, _AbstractFunction7__T7, _AbstractFunction7__R], typing.Generic[_AbstractFunction7__T1, _AbstractFunction7__T2, _AbstractFunction7__T3, _AbstractFunction7__T4, _AbstractFunction7__T5, _AbstractFunction7__T6, _AbstractFunction7__T7, _AbstractFunction7__R]):
    def __init__(self): ...
    def curried(self) -> scala.Function1[_AbstractFunction7__T1, scala.Function1[_AbstractFunction7__T2, scala.Function1[_AbstractFunction7__T3, scala.Function1[_AbstractFunction7__T4, scala.Function1[_AbstractFunction7__T5, scala.Function1[_AbstractFunction7__T6, scala.Function1[_AbstractFunction7__T7, _AbstractFunction7__R]]]]]]]: ...
    def toString(self) -> java.lang.String: ...
    def tupled(self) -> scala.Function1[scala.Tuple7[_AbstractFunction7__T1, _AbstractFunction7__T2, _AbstractFunction7__T3, _AbstractFunction7__T4, _AbstractFunction7__T5, _AbstractFunction7__T6, _AbstractFunction7__T7], _AbstractFunction7__R]: ...

_AbstractFunction8__T1 = typing.TypeVar('_AbstractFunction8__T1')  # <T1>
_AbstractFunction8__T2 = typing.TypeVar('_AbstractFunction8__T2')  # <T2>
_AbstractFunction8__T3 = typing.TypeVar('_AbstractFunction8__T3')  # <T3>
_AbstractFunction8__T4 = typing.TypeVar('_AbstractFunction8__T4')  # <T4>
_AbstractFunction8__T5 = typing.TypeVar('_AbstractFunction8__T5')  # <T5>
_AbstractFunction8__T6 = typing.TypeVar('_AbstractFunction8__T6')  # <T6>
_AbstractFunction8__T7 = typing.TypeVar('_AbstractFunction8__T7')  # <T7>
_AbstractFunction8__T8 = typing.TypeVar('_AbstractFunction8__T8')  # <T8>
_AbstractFunction8__R = typing.TypeVar('_AbstractFunction8__R')  # <R>
class AbstractFunction8(scala.Function8[_AbstractFunction8__T1, _AbstractFunction8__T2, _AbstractFunction8__T3, _AbstractFunction8__T4, _AbstractFunction8__T5, _AbstractFunction8__T6, _AbstractFunction8__T7, _AbstractFunction8__T8, _AbstractFunction8__R], typing.Generic[_AbstractFunction8__T1, _AbstractFunction8__T2, _AbstractFunction8__T3, _AbstractFunction8__T4, _AbstractFunction8__T5, _AbstractFunction8__T6, _AbstractFunction8__T7, _AbstractFunction8__T8, _AbstractFunction8__R]):
    def __init__(self): ...
    def curried(self) -> scala.Function1[_AbstractFunction8__T1, scala.Function1[_AbstractFunction8__T2, scala.Function1[_AbstractFunction8__T3, scala.Function1[_AbstractFunction8__T4, scala.Function1[_AbstractFunction8__T5, scala.Function1[_AbstractFunction8__T6, scala.Function1[_AbstractFunction8__T7, scala.Function1[_AbstractFunction8__T8, _AbstractFunction8__R]]]]]]]]: ...
    def toString(self) -> java.lang.String: ...
    def tupled(self) -> scala.Function1[scala.Tuple8[_AbstractFunction8__T1, _AbstractFunction8__T2, _AbstractFunction8__T3, _AbstractFunction8__T4, _AbstractFunction8__T5, _AbstractFunction8__T6, _AbstractFunction8__T7, _AbstractFunction8__T8], _AbstractFunction8__R]: ...

_AbstractFunction9__T1 = typing.TypeVar('_AbstractFunction9__T1')  # <T1>
_AbstractFunction9__T2 = typing.TypeVar('_AbstractFunction9__T2')  # <T2>
_AbstractFunction9__T3 = typing.TypeVar('_AbstractFunction9__T3')  # <T3>
_AbstractFunction9__T4 = typing.TypeVar('_AbstractFunction9__T4')  # <T4>
_AbstractFunction9__T5 = typing.TypeVar('_AbstractFunction9__T5')  # <T5>
_AbstractFunction9__T6 = typing.TypeVar('_AbstractFunction9__T6')  # <T6>
_AbstractFunction9__T7 = typing.TypeVar('_AbstractFunction9__T7')  # <T7>
_AbstractFunction9__T8 = typing.TypeVar('_AbstractFunction9__T8')  # <T8>
_AbstractFunction9__T9 = typing.TypeVar('_AbstractFunction9__T9')  # <T9>
_AbstractFunction9__R = typing.TypeVar('_AbstractFunction9__R')  # <R>
class AbstractFunction9(scala.Function9[_AbstractFunction9__T1, _AbstractFunction9__T2, _AbstractFunction9__T3, _AbstractFunction9__T4, _AbstractFunction9__T5, _AbstractFunction9__T6, _AbstractFunction9__T7, _AbstractFunction9__T8, _AbstractFunction9__T9, _AbstractFunction9__R], typing.Generic[_AbstractFunction9__T1, _AbstractFunction9__T2, _AbstractFunction9__T3, _AbstractFunction9__T4, _AbstractFunction9__T5, _AbstractFunction9__T6, _AbstractFunction9__T7, _AbstractFunction9__T8, _AbstractFunction9__T9, _AbstractFunction9__R]):
    def __init__(self): ...
    def curried(self) -> scala.Function1[_AbstractFunction9__T1, scala.Function1[_AbstractFunction9__T2, scala.Function1[_AbstractFunction9__T3, scala.Function1[_AbstractFunction9__T4, scala.Function1[_AbstractFunction9__T5, scala.Function1[_AbstractFunction9__T6, scala.Function1[_AbstractFunction9__T7, scala.Function1[_AbstractFunction9__T8, scala.Function1[_AbstractFunction9__T9, _AbstractFunction9__R]]]]]]]]]: ...
    def toString(self) -> java.lang.String: ...
    def tupled(self) -> scala.Function1[scala.Tuple9[_AbstractFunction9__T1, _AbstractFunction9__T2, _AbstractFunction9__T3, _AbstractFunction9__T4, _AbstractFunction9__T5, _AbstractFunction9__T6, _AbstractFunction9__T7, _AbstractFunction9__T8, _AbstractFunction9__T9], _AbstractFunction9__R]: ...

_AbstractPartialFunction__T1 = typing.TypeVar('_AbstractPartialFunction__T1')  # <T1>
_AbstractPartialFunction__R = typing.TypeVar('_AbstractPartialFunction__R')  # <R>
class AbstractPartialFunction(scala.PartialFunction[_AbstractPartialFunction__T1, _AbstractPartialFunction__R], typing.Generic[_AbstractPartialFunction__T1, _AbstractPartialFunction__R]):
    def __init__(self): ...
    _andThen__C = typing.TypeVar('_andThen__C')  # <C>
    def andThen(self, k: scala.Function1[_AbstractPartialFunction__R, _andThen__C]) -> scala.PartialFunction[_AbstractPartialFunction__T1, _andThen__C]: ...
    def apply(self, x: _AbstractPartialFunction__T1) -> _AbstractPartialFunction__R: ...
    def apply$mcDD$sp(self, x: float) -> float: ...
    def apply$mcDF$sp(self, x: float) -> float: ...
    def apply$mcDI$sp(self, x: int) -> float: ...
    def apply$mcDJ$sp(self, x: int) -> float: ...
    def apply$mcFD$sp(self, x: float) -> float: ...
    def apply$mcFF$sp(self, x: float) -> float: ...
    def apply$mcFI$sp(self, x: int) -> float: ...
    def apply$mcFJ$sp(self, x: int) -> float: ...
    def apply$mcID$sp(self, x: float) -> int: ...
    def apply$mcIF$sp(self, x: float) -> int: ...
    def apply$mcII$sp(self, x: int) -> int: ...
    def apply$mcIJ$sp(self, x: int) -> int: ...
    def apply$mcJD$sp(self, x: float) -> int: ...
    def apply$mcJF$sp(self, x: float) -> int: ...
    def apply$mcJI$sp(self, x: int) -> int: ...
    def apply$mcJJ$sp(self, x: int) -> int: ...
    def apply$mcVD$sp(self, x: float) -> None: ...
    def apply$mcVF$sp(self, x: float) -> None: ...
    def apply$mcVI$sp(self, x: int) -> None: ...
    def apply$mcVJ$sp(self, x: int) -> None: ...
    def apply$mcZD$sp(self, x: float) -> bool: ...
    def apply$mcZF$sp(self, x: float) -> bool: ...
    def apply$mcZI$sp(self, x: int) -> bool: ...
    def apply$mcZJ$sp(self, x: int) -> bool: ...
    _applyOrElse__A1 = typing.TypeVar('_applyOrElse__A1')  # <A1>
    _applyOrElse__B1 = typing.TypeVar('_applyOrElse__B1')  # <B1>
    def applyOrElse(self, x: _applyOrElse__A1, default: scala.Function1[_applyOrElse__A1, _applyOrElse__B1]) -> _applyOrElse__B1: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    def compose(self, g: scala.Function1[_compose__A, _AbstractPartialFunction__T1]) -> scala.Function1[_compose__A, _AbstractPartialFunction__R]: ...
    def lift(self) -> scala.Function1[_AbstractPartialFunction__T1, scala.Option[_AbstractPartialFunction__R]]: ...
    _orElse__A1 = typing.TypeVar('_orElse__A1')  # <A1>
    _orElse__B1 = typing.TypeVar('_orElse__B1')  # <B1>
    def orElse(self, that: scala.PartialFunction[_orElse__A1, _orElse__B1]) -> scala.PartialFunction[_orElse__A1, _orElse__B1]: ...
    _runWith__U = typing.TypeVar('_runWith__U')  # <U>
    def runWith(self, action: scala.Function1[_AbstractPartialFunction__R, _runWith__U]) -> scala.Function1[_AbstractPartialFunction__T1, typing.Any]: ...
    def toString(self) -> java.lang.String: ...

class ArrayCharSequence(java.lang.CharSequence):
    def __init__(self, xs: typing.List[str], start: int, end: int): ...
    def charAt(self, index: int) -> str: ...
    def chars(self) -> java.util.stream.IntStream: ...
    def codePoints(self) -> java.util.stream.IntStream: ...
    def length(self) -> int: ...
    def subSequence(self, start0: int, end0: int) -> java.lang.CharSequence: ...
    def toString(self) -> java.lang.String: ...
    def xs(self) -> typing.List[str]: ...

class BooleanRef(java.io.Serializable):
    elem: bool = ...
    def __init__(self, boolean: bool): ...
    @staticmethod
    def create(boolean: bool) -> 'BooleanRef': ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def zero() -> 'BooleanRef': ...

class BoxedUnit(java.io.Serializable):
    UNIT: typing.ClassVar['BoxedUnit'] = ...
    TYPE: typing.ClassVar[typing.Type] = ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> java.lang.String: ...

class BoxesRunTime:
    def __init__(self): ...
    @staticmethod
    def add(object: typing.Any, object2: typing.Any) -> typing.Any: ...
    @staticmethod
    def boxToBoolean(boolean: bool) -> bool: ...
    @staticmethod
    def boxToByte(byte: int) -> int: ...
    @staticmethod
    def boxToCharacter(char: str) -> str: ...
    @staticmethod
    def boxToDouble(double: float) -> float: ...
    @staticmethod
    def boxToFloat(float: float) -> float: ...
    @staticmethod
    def boxToInteger(int: int) -> int: ...
    @staticmethod
    def boxToLong(long: int) -> int: ...
    @staticmethod
    def boxToShort(short: int) -> int: ...
    @staticmethod
    def complement(object: typing.Any) -> typing.Any: ...
    @staticmethod
    def divide(object: typing.Any, object2: typing.Any) -> typing.Any: ...
    @typing.overload
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(object: typing.Any, object2: typing.Any) -> bool: ...
    @staticmethod
    def equals2(object: typing.Any, object2: typing.Any) -> bool: ...
    @staticmethod
    def equalsCharObject(character: str, object: typing.Any) -> bool: ...
    @staticmethod
    def equalsNumChar(number: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat], character: str) -> bool: ...
    @staticmethod
    def equalsNumNum(number: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat], number2: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat]) -> bool: ...
    @staticmethod
    def equalsNumObject(number: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat], object: typing.Any) -> bool: ...
    @staticmethod
    def isBoxedNumber(object: typing.Any) -> bool: ...
    @staticmethod
    def isBoxedNumberOrBoolean(object: typing.Any) -> bool: ...
    @staticmethod
    def multiply(object: typing.Any, object2: typing.Any) -> typing.Any: ...
    @staticmethod
    def negate(object: typing.Any) -> typing.Any: ...
    @staticmethod
    def positive(object: typing.Any) -> typing.Any: ...
    @staticmethod
    def shiftLogicalRight(object: typing.Any, object2: typing.Any) -> typing.Any: ...
    @staticmethod
    def shiftSignedLeft(object: typing.Any, object2: typing.Any) -> typing.Any: ...
    @staticmethod
    def shiftSignedRight(object: typing.Any, object2: typing.Any) -> typing.Any: ...
    @staticmethod
    def subtract(object: typing.Any, object2: typing.Any) -> typing.Any: ...
    @staticmethod
    def takeAnd(object: typing.Any, object2: typing.Any) -> typing.Any: ...
    @staticmethod
    def takeConditionalAnd(object: typing.Any, object2: typing.Any) -> typing.Any: ...
    @staticmethod
    def takeConditionalOr(object: typing.Any, object2: typing.Any) -> typing.Any: ...
    @staticmethod
    def takeModulo(object: typing.Any, object2: typing.Any) -> typing.Any: ...
    @staticmethod
    def takeNot(object: typing.Any) -> typing.Any: ...
    @staticmethod
    def takeOr(object: typing.Any, object2: typing.Any) -> typing.Any: ...
    @staticmethod
    def takeXor(object: typing.Any, object2: typing.Any) -> typing.Any: ...
    @staticmethod
    def testEqual(object: typing.Any, object2: typing.Any) -> typing.Any: ...
    @staticmethod
    def testGreaterOrEqualThan(object: typing.Any, object2: typing.Any) -> typing.Any: ...
    @staticmethod
    def testGreaterThan(object: typing.Any, object2: typing.Any) -> typing.Any: ...
    @staticmethod
    def testLessOrEqualThan(object: typing.Any, object2: typing.Any) -> typing.Any: ...
    @staticmethod
    def testLessThan(object: typing.Any, object2: typing.Any) -> typing.Any: ...
    @staticmethod
    def testNotEqual(object: typing.Any, object2: typing.Any) -> typing.Any: ...
    @staticmethod
    def toByte(object: typing.Any) -> int: ...
    @staticmethod
    def toCharacter(object: typing.Any) -> str: ...
    @staticmethod
    def toDouble(object: typing.Any) -> float: ...
    @staticmethod
    def toFloat(object: typing.Any) -> float: ...
    @staticmethod
    def toInteger(object: typing.Any) -> int: ...
    @staticmethod
    def toLong(object: typing.Any) -> int: ...
    @staticmethod
    def toShort(object: typing.Any) -> int: ...
    @staticmethod
    def unboxToBoolean(object: typing.Any) -> bool: ...
    @staticmethod
    def unboxToByte(object: typing.Any) -> int: ...
    @staticmethod
    def unboxToChar(object: typing.Any) -> str: ...
    @staticmethod
    def unboxToDouble(object: typing.Any) -> float: ...
    @staticmethod
    def unboxToFloat(object: typing.Any) -> float: ...
    @staticmethod
    def unboxToInt(object: typing.Any) -> int: ...
    @staticmethod
    def unboxToLong(object: typing.Any) -> int: ...
    @staticmethod
    def unboxToShort(object: typing.Any) -> int: ...

class ByteRef(java.io.Serializable):
    elem: int = ...
    def __init__(self, byte: int): ...
    @staticmethod
    def create(byte: int) -> 'ByteRef': ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def zero() -> 'ByteRef': ...

class CharRef(java.io.Serializable):
    elem: str = ...
    def __init__(self, char: str): ...
    @staticmethod
    def create(char: str) -> 'CharRef': ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def zero() -> 'CharRef': ...

class DoubleRef(java.io.Serializable):
    elem: float = ...
    def __init__(self, double: float): ...
    @staticmethod
    def create(double: float) -> 'DoubleRef': ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def zero() -> 'DoubleRef': ...

class FloatRef(java.io.Serializable):
    elem: float = ...
    def __init__(self, float: float): ...
    @staticmethod
    def create(float: float) -> 'FloatRef': ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def zero() -> 'FloatRef': ...

class IntRef(java.io.Serializable):
    elem: int = ...
    def __init__(self, int: int): ...
    @staticmethod
    def create(int: int) -> 'IntRef': ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def zero() -> 'IntRef': ...

class LambdaDeserialize:
    DESERIALIZE_LAMBDA_MT: typing.ClassVar[java.lang.invoke.MethodType] = ...
    @staticmethod
    def bootstrap(lookup: java.lang.invoke.MethodHandles.Lookup, string: typing.Union[java.lang.String, str], methodType: java.lang.invoke.MethodType, *methodHandle: java.lang.invoke.MethodHandle) -> java.lang.invoke.CallSite: ...
    def deserializeLambda(self, serializedLambda: java.lang.invoke.SerializedLambda) -> typing.Any: ...
    @staticmethod
    def nameAndDescriptorKey(string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> java.lang.String: ...

class LambdaDeserializer:
    @staticmethod
    def deserializeLambda(lookup: java.lang.invoke.MethodHandles.Lookup, cache: typing.Union[java.util.Map[typing.Union[java.lang.String, str], java.lang.invoke.MethodHandle], typing.Mapping[typing.Union[java.lang.String, str], java.lang.invoke.MethodHandle]], targetMethodMap: typing.Union[java.util.Map[typing.Union[java.lang.String, str], java.lang.invoke.MethodHandle], typing.Mapping[typing.Union[java.lang.String, str], java.lang.invoke.MethodHandle]], serialized: java.lang.invoke.SerializedLambda) -> typing.Any: ...

class LazyBoolean(scala.Serializable):
    serialVersionUID: typing.ClassVar[int] = ...
    def __init__(self): ...
    def initialize(self, value: bool) -> bool: ...
    def initialized(self) -> bool: ...
    def toString(self) -> java.lang.String: ...
    def value(self) -> bool: ...

class LazyByte(scala.Serializable):
    serialVersionUID: typing.ClassVar[int] = ...
    def __init__(self): ...
    def initialize(self, value: int) -> int: ...
    def initialized(self) -> bool: ...
    def toString(self) -> java.lang.String: ...
    def value(self) -> int: ...

class LazyChar(scala.Serializable):
    serialVersionUID: typing.ClassVar[int] = ...
    def __init__(self): ...
    def initialize(self, value: str) -> str: ...
    def initialized(self) -> bool: ...
    def toString(self) -> java.lang.String: ...
    def value(self) -> str: ...

class LazyDouble(scala.Serializable):
    serialVersionUID: typing.ClassVar[int] = ...
    def __init__(self): ...
    def initialize(self, value: float) -> float: ...
    def initialized(self) -> bool: ...
    def toString(self) -> java.lang.String: ...
    def value(self) -> float: ...

class LazyFloat(scala.Serializable):
    serialVersionUID: typing.ClassVar[int] = ...
    def __init__(self): ...
    def initialize(self, value: float) -> float: ...
    def initialized(self) -> bool: ...
    def toString(self) -> java.lang.String: ...
    def value(self) -> float: ...

class LazyInt(scala.Serializable):
    serialVersionUID: typing.ClassVar[int] = ...
    def __init__(self): ...
    def initialize(self, value: int) -> int: ...
    def initialized(self) -> bool: ...
    def toString(self) -> java.lang.String: ...
    def value(self) -> int: ...

class LazyLong(scala.Serializable):
    serialVersionUID: typing.ClassVar[int] = ...
    def __init__(self): ...
    def initialize(self, value: int) -> int: ...
    def initialized(self) -> bool: ...
    def toString(self) -> java.lang.String: ...
    def value(self) -> int: ...

_LazyRef__T = typing.TypeVar('_LazyRef__T')  # <T>
class LazyRef(scala.Serializable, typing.Generic[_LazyRef__T]):
    serialVersionUID: typing.ClassVar[int] = ...
    def __init__(self): ...
    def initialize(self, value: _LazyRef__T) -> _LazyRef__T: ...
    def initialized(self) -> bool: ...
    def toString(self) -> java.lang.String: ...
    def value(self) -> _LazyRef__T: ...

class LazyShort(scala.Serializable):
    serialVersionUID: typing.ClassVar[int] = ...
    def __init__(self): ...
    def initialize(self, value: int) -> int: ...
    def initialized(self) -> bool: ...
    def toString(self) -> java.lang.String: ...
    def value(self) -> int: ...

class LazyUnit(scala.Serializable):
    serialVersionUID: typing.ClassVar[int] = ...
    def __init__(self): ...
    def initialize(self) -> None: ...
    def initialized(self) -> bool: ...
    def toString(self) -> java.lang.String: ...

class LongRef(java.io.Serializable):
    elem: int = ...
    def __init__(self, long: int): ...
    @staticmethod
    def create(long: int) -> 'LongRef': ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def zero() -> 'LongRef': ...

class MethodCache:
    def __init__(self): ...
    def add(self, forReceiver: typing.Type[typing.Any], forMethod: java.lang.reflect.Method) -> 'MethodCache': ...
    def find(self, forReceiver: typing.Type[typing.Any]) -> java.lang.reflect.Method: ...

_NonLocalReturnControl__T = typing.TypeVar('_NonLocalReturnControl__T')  # <T>
class NonLocalReturnControl(java.lang.Throwable, scala.util.control.ControlThrowable, typing.Generic[_NonLocalReturnControl__T]):
    value: typing.Any = ...
    def __init__(self, key: typing.Any, value: _NonLocalReturnControl__T): ...
    def fillInStackTrace(self) -> java.lang.Throwable: ...
    def key(self) -> typing.Any: ...
    def specInstance$(self) -> bool: ...
    def value(self) -> _NonLocalReturnControl__T: ...
    def value$mcB$sp(self) -> int: ...
    def value$mcC$sp(self) -> str: ...
    def value$mcD$sp(self) -> float: ...
    def value$mcF$sp(self) -> float: ...
    def value$mcI$sp(self) -> int: ...
    def value$mcJ$sp(self) -> int: ...
    def value$mcS$sp(self) -> int: ...
    def value$mcV$sp(self) -> None: ...
    def value$mcZ$sp(self) -> bool: ...

_ObjectRef__T = typing.TypeVar('_ObjectRef__T')  # <T>
class ObjectRef(java.io.Serializable, typing.Generic[_ObjectRef__T]):
    elem: typing.Any = ...
    def __init__(self, t: _ObjectRef__T): ...
    _create__U = typing.TypeVar('_create__U')  # <U>
    @staticmethod
    def create(u: _create__U) -> 'ObjectRef'[_create__U]: ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def zero() -> 'ObjectRef'[typing.Any]: ...

_OrderedProxy__T = typing.TypeVar('_OrderedProxy__T')  # <T>
class OrderedProxy(scala.math.Ordered[_OrderedProxy__T], scala.Proxy.Typed[_OrderedProxy__T], typing.Generic[_OrderedProxy__T]):
    @staticmethod
    def $init$($this: 'OrderedProxy') -> None: ...
    def compare(self, y: _OrderedProxy__T) -> int: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def ord(self) -> scala.math.Ordering[_OrderedProxy__T]: ...
    def toString(self) -> java.lang.String: ...

_RangedProxy__T = typing.TypeVar('_RangedProxy__T')  # <T>
class RangedProxy(scala.Proxy.Typed[_RangedProxy__T], typing.Generic[_RangedProxy__T]):
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def to(self, end: _RangedProxy__T) -> typing.Any: ...
    @typing.overload
    def to(self, end: _RangedProxy__T, step: _RangedProxy__T) -> scala.collection.immutable.IndexedSeq[_RangedProxy__T]: ...
    def toString(self) -> java.lang.String: ...
    @typing.overload
    def until(self, end: _RangedProxy__T) -> typing.Any: ...
    @typing.overload
    def until(self, end: _RangedProxy__T, step: _RangedProxy__T) -> scala.collection.immutable.IndexedSeq[_RangedProxy__T]: ...

class RichException:
    def __init__(self, exc: java.lang.Throwable): ...
    def getStackTraceString(self) -> java.lang.String: ...

class ScalaRunTime:
    @staticmethod
    def _hashCode(x: scala.Product) -> int: ...
    @staticmethod
    def _toString(x: scala.Product) -> java.lang.String: ...
    _anyValClass__T = typing.TypeVar('_anyValClass__T')  # <T>
    @staticmethod
    def anyValClass(value: _anyValClass__T, evidence$1: scala.reflect.ClassTag[_anyValClass__T]) -> typing.Type[_anyValClass__T]: ...
    @staticmethod
    def arrayClass(clazz: typing.Type[typing.Any]) -> typing.Type[typing.Any]: ...
    @staticmethod
    def array_apply(xs: typing.Any, idx: int) -> typing.Any: ...
    @staticmethod
    def array_clone(xs: typing.Any) -> typing.Any: ...
    @staticmethod
    def array_length(xs: typing.Any) -> int: ...
    @staticmethod
    def array_update(xs: typing.Any, idx: int, value: typing.Any) -> None: ...
    _drop__Repr = typing.TypeVar('_drop__Repr')  # <Repr>
    @staticmethod
    def drop(coll: _drop__Repr, num: int, traversable: scala.collection.generic.IsTraversableLike[_drop__Repr]) -> _drop__Repr: ...
    @staticmethod
    def ensureAccessible(m: java.lang.reflect.Method) -> java.lang.reflect.Method: ...
    @staticmethod
    def hash(x: typing.Any) -> int: ...
    @staticmethod
    def isArray(x: typing.Any, atLevel: int) -> bool: ...
    @staticmethod
    def isArray$default$2() -> int: ...
    @staticmethod
    def replStringOf(arg: typing.Any, maxElements: int) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def stringOf(arg: typing.Any) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def stringOf(arg: typing.Any, maxElements: int) -> java.lang.String: ...
    _toArray__T = typing.TypeVar('_toArray__T')  # <T>
    @staticmethod
    def toArray(xs: scala.collection.Seq[_toArray__T]) -> typing.List[typing.Any]: ...
    @staticmethod
    def toObjectArray(src: typing.Any) -> typing.List[typing.Any]: ...
    _typedProductIterator__T = typing.TypeVar('_typedProductIterator__T')  # <T>
    @staticmethod
    def typedProductIterator(x: scala.Product) -> scala.collection.Iterator[_typedProductIterator__T]: ...

class SeqCharSequence(java.lang.CharSequence):
    def __init__(self, xs: scala.collection.IndexedSeq[typing.Any]): ...
    def charAt(self, index: int) -> str: ...
    def chars(self) -> java.util.stream.IntStream: ...
    def codePoints(self) -> java.util.stream.IntStream: ...
    def length(self) -> int: ...
    def subSequence(self, start: int, end: int) -> java.lang.CharSequence: ...
    def toString(self) -> java.lang.String: ...
    def xs(self) -> scala.collection.IndexedSeq[typing.Any]: ...

class ShortRef(java.io.Serializable):
    elem: int = ...
    def __init__(self, short: int): ...
    @staticmethod
    def create(short: int) -> 'ShortRef': ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def zero() -> 'ShortRef': ...

class Statics:
    def __init__(self): ...
    @staticmethod
    def anyHash(object: typing.Any) -> int: ...
    @staticmethod
    def avalanche(int: int) -> int: ...
    @staticmethod
    def doubleHash(double: float) -> int: ...
    @staticmethod
    def finalizeHash(int: int, int2: int) -> int: ...
    @staticmethod
    def floatHash(float: float) -> int: ...
    @staticmethod
    def longHash(long: int) -> int: ...
    @staticmethod
    def mix(int: int, int2: int) -> int: ...
    @staticmethod
    def mixLast(int: int, int2: int) -> int: ...

class StringAdd:
    def __init__(self, self): ...
    def $plus(self, other: typing.Union[java.lang.String, str]) -> java.lang.String: ...
    @staticmethod
    def $plus$extension($this: typing.Any, other: typing.Union[java.lang.String, str]) -> java.lang.String: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    @staticmethod
    def equals$extension($this: typing.Any, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def hashCode$extension($this: typing.Any) -> int: ...
    def self(self) -> typing.Any: ...

class StringFormat:
    def __init__(self, self): ...
    def equals(self, x$1: typing.Any) -> bool: ...
    @staticmethod
    def equals$extension($this: typing.Any, x$1: typing.Any) -> bool: ...
    def formatted(self, fmtstr: typing.Union[java.lang.String, str]) -> java.lang.String: ...
    @staticmethod
    def formatted$extension($this: typing.Any, fmtstr: typing.Union[java.lang.String, str]) -> java.lang.String: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def hashCode$extension($this: typing.Any) -> int: ...
    def self(self) -> typing.Any: ...

class StructuralCallSite:
    def add(self, class_: typing.Type[typing.Any], method: java.lang.reflect.Method) -> java.lang.reflect.Method: ...
    @staticmethod
    def bootstrap(lookup: java.lang.invoke.MethodHandles.Lookup, string: typing.Union[java.lang.String, str], methodType: java.lang.invoke.MethodType, methodType2: java.lang.invoke.MethodType) -> java.lang.invoke.CallSite: ...
    def find(self, class_: typing.Type[typing.Any]) -> java.lang.reflect.Method: ...
    def get(self) -> MethodCache: ...
    def parameterTypes(self) -> typing.List[typing.Type[typing.Any]]: ...

class SymbolLiteral:
    @staticmethod
    def bootstrap(lookup: java.lang.invoke.MethodHandles.Lookup, string: typing.Union[java.lang.String, str], methodType: java.lang.invoke.MethodType, string2: typing.Union[java.lang.String, str]) -> java.lang.invoke.CallSite: ...

class TraitSetter(java.lang.annotation.Annotation):
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> java.lang.String: ...

class VolatileBooleanRef(java.io.Serializable):
    elem: bool = ...
    def __init__(self, boolean: bool): ...
    @staticmethod
    def create(boolean: bool) -> 'VolatileBooleanRef': ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def zero() -> 'VolatileBooleanRef': ...

class VolatileByteRef(java.io.Serializable):
    elem: int = ...
    def __init__(self, byte: int): ...
    @staticmethod
    def create(byte: int) -> 'VolatileByteRef': ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def zero() -> 'VolatileByteRef': ...

class VolatileCharRef(java.io.Serializable):
    elem: str = ...
    def __init__(self, char: str): ...
    @staticmethod
    def create(char: str) -> 'VolatileCharRef': ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def zero() -> 'VolatileCharRef': ...

class VolatileDoubleRef(java.io.Serializable):
    elem: float = ...
    def __init__(self, double: float): ...
    @staticmethod
    def create(double: float) -> 'VolatileDoubleRef': ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def zero() -> 'VolatileDoubleRef': ...

class VolatileFloatRef(java.io.Serializable):
    elem: float = ...
    def __init__(self, float: float): ...
    @staticmethod
    def create(float: float) -> 'VolatileFloatRef': ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def zero() -> 'VolatileFloatRef': ...

class VolatileIntRef(java.io.Serializable):
    elem: int = ...
    def __init__(self, int: int): ...
    @staticmethod
    def create(int: int) -> 'VolatileIntRef': ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def zero() -> 'VolatileIntRef': ...

class VolatileLongRef(java.io.Serializable):
    elem: int = ...
    def __init__(self, long: int): ...
    @staticmethod
    def create(long: int) -> 'VolatileLongRef': ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def zero() -> 'VolatileLongRef': ...

_VolatileObjectRef__T = typing.TypeVar('_VolatileObjectRef__T')  # <T>
class VolatileObjectRef(java.io.Serializable, typing.Generic[_VolatileObjectRef__T]):
    elem: typing.Any = ...
    def __init__(self, t: _VolatileObjectRef__T): ...
    _create__U = typing.TypeVar('_create__U')  # <U>
    @staticmethod
    def create(u: _create__U) -> 'VolatileObjectRef'[_create__U]: ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def zero() -> 'VolatileObjectRef'[typing.Any]: ...

class VolatileShortRef(java.io.Serializable):
    elem: int = ...
    def __init__(self, short: int): ...
    @staticmethod
    def create(short: int) -> 'VolatileShortRef': ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def zero() -> 'VolatileShortRef': ...

_ZippedTraversable2__El1 = typing.TypeVar('_ZippedTraversable2__El1')  # <El1>
_ZippedTraversable2__El2 = typing.TypeVar('_ZippedTraversable2__El2')  # <El2>
class ZippedTraversable2(typing.Generic[_ZippedTraversable2__El1, _ZippedTraversable2__El2]):
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function2[_ZippedTraversable2__El1, _ZippedTraversable2__El2, _foreach__U]) -> None: ...
    _zippedTraversable2ToTraversable__El1 = typing.TypeVar('_zippedTraversable2ToTraversable__El1')  # <El1>
    _zippedTraversable2ToTraversable__El2 = typing.TypeVar('_zippedTraversable2ToTraversable__El2')  # <El2>
    @staticmethod
    def zippedTraversable2ToTraversable(zz: 'ZippedTraversable2'[_zippedTraversable2ToTraversable__El1, _zippedTraversable2ToTraversable__El2]) -> scala.collection.Traversable[scala.Tuple2[_zippedTraversable2ToTraversable__El1, _zippedTraversable2ToTraversable__El2]]: ...

_ZippedTraversable3__El1 = typing.TypeVar('_ZippedTraversable3__El1')  # <El1>
_ZippedTraversable3__El2 = typing.TypeVar('_ZippedTraversable3__El2')  # <El2>
_ZippedTraversable3__El3 = typing.TypeVar('_ZippedTraversable3__El3')  # <El3>
class ZippedTraversable3(typing.Generic[_ZippedTraversable3__El1, _ZippedTraversable3__El2, _ZippedTraversable3__El3]):
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function3[_ZippedTraversable3__El1, _ZippedTraversable3__El2, _ZippedTraversable3__El3, _foreach__U]) -> None: ...
    _zippedTraversable3ToTraversable__El1 = typing.TypeVar('_zippedTraversable3ToTraversable__El1')  # <El1>
    _zippedTraversable3ToTraversable__El2 = typing.TypeVar('_zippedTraversable3ToTraversable__El2')  # <El2>
    _zippedTraversable3ToTraversable__El3 = typing.TypeVar('_zippedTraversable3ToTraversable__El3')  # <El3>
    @staticmethod
    def zippedTraversable3ToTraversable(zz: 'ZippedTraversable3'[_zippedTraversable3ToTraversable__El1, _zippedTraversable3ToTraversable__El2, _zippedTraversable3ToTraversable__El3]) -> scala.collection.Traversable[scala.Tuple3[_zippedTraversable3ToTraversable__El1, _zippedTraversable3ToTraversable__El2, _zippedTraversable3ToTraversable__El3]]: ...

class package: ...

class EmptyMethodCache(MethodCache):
    def __init__(self): ...
    def add(self, forReceiver: typing.Type[typing.Any], forMethod: java.lang.reflect.Method) -> MethodCache: ...
    def find(self, forReceiver: typing.Type[typing.Any]) -> java.lang.reflect.Method: ...

class MegaMethodCache(MethodCache):
    def __init__(self, forName: typing.Union[java.lang.String, str], forParameterTypes: typing.List[typing.Type[typing.Any]]): ...
    def add(self, forReceiver: typing.Type[typing.Any], forMethod: java.lang.reflect.Method) -> MethodCache: ...
    def find(self, forReceiver: typing.Type[typing.Any]) -> java.lang.reflect.Method: ...

class PolyMethodCache(MethodCache):
    def __init__(self, next: MethodCache, receiver: typing.Type[typing.Any], method: java.lang.reflect.Method, complexity: int): ...
    def add(self, forReceiver: typing.Type[typing.Any], forMethod: java.lang.reflect.Method) -> MethodCache: ...
    def find(self, forReceiver: typing.Type[typing.Any]) -> java.lang.reflect.Method: ...

class RichBoolean(OrderedProxy[typing.Any]):
    def __init__(self, self): ...
    def $greater(self, that: typing.Any) -> bool: ...
    def $greater$eq(self, that: typing.Any) -> bool: ...
    def $less(self, that: typing.Any) -> bool: ...
    def $less$eq(self, that: typing.Any) -> bool: ...
    def compare(self, y: typing.Any) -> int: ...
    def compareTo(self, that: typing.Any) -> int: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    @staticmethod
    def equals$extension($this: bool, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def hashCode$extension($this: bool) -> int: ...
    def ord(self) -> scala.math.Ordering.Boolean.: ...
    @staticmethod
    def ord$extension($this: bool) -> scala.math.Ordering.Boolean.: ...
    def self(self) -> bool: ...
    def toString(self) -> java.lang.String: ...

_ScalaNumberProxy__T = typing.TypeVar('_ScalaNumberProxy__T')  # <T>
class ScalaNumberProxy(scala.math.ScalaNumericAnyConversions, OrderedProxy[_ScalaNumberProxy__T], typing.Generic[_ScalaNumberProxy__T]):
    @staticmethod
    def $init$($this: 'ScalaNumberProxy') -> None: ...
    def abs(self) -> _ScalaNumberProxy__T: ...
    def byteValue(self) -> int: ...
    def doubleValue(self) -> float: ...
    def equals(self, that: typing.Any) -> bool: ...
    def floatValue(self) -> float: ...
    def hashCode(self) -> int: ...
    def intValue(self) -> int: ...
    def longValue(self) -> int: ...
    def max(self, that: _ScalaNumberProxy__T) -> _ScalaNumberProxy__T: ...
    def min(self, that: _ScalaNumberProxy__T) -> _ScalaNumberProxy__T: ...
    def num(self) -> scala.math.Numeric[_ScalaNumberProxy__T]: ...
    def shortValue(self) -> int: ...
    def signum(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    def underlying(self) -> typing.Any: ...

_Tuple2Zipped__Ops__T1 = typing.TypeVar('_Tuple2Zipped__Ops__T1')  # <T1>
_Tuple2Zipped__Ops__T2 = typing.TypeVar('_Tuple2Zipped__Ops__T2')  # <T2>
_Tuple2Zipped__El1 = typing.TypeVar('_Tuple2Zipped__El1')  # <El1>
_Tuple2Zipped__Repr1 = typing.TypeVar('_Tuple2Zipped__Repr1')  # <Repr1>
_Tuple2Zipped__El2 = typing.TypeVar('_Tuple2Zipped__El2')  # <El2>
_Tuple2Zipped__Repr2 = typing.TypeVar('_Tuple2Zipped__Repr2')  # <Repr2>
class Tuple2Zipped(ZippedTraversable2[_Tuple2Zipped__El1, _Tuple2Zipped__El2], typing.Generic[_Tuple2Zipped__El1, _Tuple2Zipped__Repr1, _Tuple2Zipped__El2, _Tuple2Zipped__Repr2]):
    def __init__(self, colls: scala.Tuple2[scala.collection.TraversableLike[_Tuple2Zipped__El1, _Tuple2Zipped__Repr1], scala.collection.IterableLike[_Tuple2Zipped__El2, _Tuple2Zipped__Repr2]]): ...
    _coll1$extension__El1 = typing.TypeVar('_coll1$extension__El1')  # <El1>
    _coll1$extension__Repr1 = typing.TypeVar('_coll1$extension__Repr1')  # <Repr1>
    _coll1$extension__El2 = typing.TypeVar('_coll1$extension__El2')  # <El2>
    _coll1$extension__Repr2 = typing.TypeVar('_coll1$extension__Repr2')  # <Repr2>
    @staticmethod
    def coll1$extension($this: scala.Tuple2[scala.collection.TraversableLike[_coll1.extension__El1, _coll1.extension__Repr1], scala.collection.IterableLike[_coll1.extension__El2, _coll1.extension__Repr2]]) -> scala.collection.TraversableLike[_coll1.extension__El1, _coll1.extension__Repr1]: ...
    _coll2$extension__El1 = typing.TypeVar('_coll2$extension__El1')  # <El1>
    _coll2$extension__Repr1 = typing.TypeVar('_coll2$extension__Repr1')  # <Repr1>
    _coll2$extension__El2 = typing.TypeVar('_coll2$extension__El2')  # <El2>
    _coll2$extension__Repr2 = typing.TypeVar('_coll2$extension__Repr2')  # <Repr2>
    @staticmethod
    def coll2$extension($this: scala.Tuple2[scala.collection.TraversableLike[_coll2.extension__El1, _coll2.extension__Repr1], scala.collection.IterableLike[_coll2.extension__El2, _coll2.extension__Repr2]]) -> scala.collection.IterableLike[_coll2.extension__El2, _coll2.extension__Repr2]: ...
    def colls(self) -> scala.Tuple2[scala.collection.TraversableLike[_Tuple2Zipped__El1, _Tuple2Zipped__Repr1], scala.collection.IterableLike[_Tuple2Zipped__El2, _Tuple2Zipped__Repr2]]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    _equals$extension__El1 = typing.TypeVar('_equals$extension__El1')  # <El1>
    _equals$extension__Repr1 = typing.TypeVar('_equals$extension__Repr1')  # <Repr1>
    _equals$extension__El2 = typing.TypeVar('_equals$extension__El2')  # <El2>
    _equals$extension__Repr2 = typing.TypeVar('_equals$extension__Repr2')  # <Repr2>
    @staticmethod
    def equals$extension($this: scala.Tuple2[scala.collection.TraversableLike[_equals.extension__El1, _equals.extension__Repr1], scala.collection.IterableLike[_equals.extension__El2, _equals.extension__Repr2]], x$1: typing.Any) -> bool: ...
    def exists(self, p: scala.Function2[_Tuple2Zipped__El1, _Tuple2Zipped__El2, typing.Any]) -> bool: ...
    _exists$extension__El1 = typing.TypeVar('_exists$extension__El1')  # <El1>
    _exists$extension__Repr1 = typing.TypeVar('_exists$extension__Repr1')  # <Repr1>
    _exists$extension__El2 = typing.TypeVar('_exists$extension__El2')  # <El2>
    _exists$extension__Repr2 = typing.TypeVar('_exists$extension__Repr2')  # <Repr2>
    @staticmethod
    def exists$extension($this: scala.Tuple2[scala.collection.TraversableLike[_exists.extension__El1, _exists.extension__Repr1], scala.collection.IterableLike[_exists.extension__El2, _exists.extension__Repr2]], p: scala.Function2[_exists.extension__El1, _exists.extension__El2, typing.Any]) -> bool: ...
    _filter__To1 = typing.TypeVar('_filter__To1')  # <To1>
    _filter__To2 = typing.TypeVar('_filter__To2')  # <To2>
    def filter(self, f: scala.Function2[_Tuple2Zipped__El1, _Tuple2Zipped__El2, typing.Any], cbf1: scala.collection.generic.CanBuildFrom[_Tuple2Zipped__Repr1, _Tuple2Zipped__El1, _filter__To1], cbf2: scala.collection.generic.CanBuildFrom[_Tuple2Zipped__Repr2, _Tuple2Zipped__El2, _filter__To2]) -> scala.Tuple2[_filter__To1, _filter__To2]: ...
    _filter$extension__To1 = typing.TypeVar('_filter$extension__To1')  # <To1>
    _filter$extension__To2 = typing.TypeVar('_filter$extension__To2')  # <To2>
    _filter$extension__El1 = typing.TypeVar('_filter$extension__El1')  # <El1>
    _filter$extension__Repr1 = typing.TypeVar('_filter$extension__Repr1')  # <Repr1>
    _filter$extension__El2 = typing.TypeVar('_filter$extension__El2')  # <El2>
    _filter$extension__Repr2 = typing.TypeVar('_filter$extension__Repr2')  # <Repr2>
    @staticmethod
    def filter$extension($this: scala.Tuple2[scala.collection.TraversableLike[_filter.extension__El1, _filter.extension__Repr1], scala.collection.IterableLike[_filter.extension__El2, _filter.extension__Repr2]], f: scala.Function2[_filter.extension__El1, _filter.extension__El2, typing.Any], cbf1: scala.collection.generic.CanBuildFrom[_filter.extension__Repr1, _filter.extension__El1, _filter.extension__To1], cbf2: scala.collection.generic.CanBuildFrom[_filter.extension__Repr2, _filter.extension__El2, _filter.extension__To2]) -> scala.Tuple2[_filter.extension__To1, _filter.extension__To2]: ...
    _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
    _flatMap__To = typing.TypeVar('_flatMap__To')  # <To>
    def flatMap(self, f: scala.Function2[_Tuple2Zipped__El1, _Tuple2Zipped__El2, scala.collection.TraversableOnce[_flatMap__B]], cbf: scala.collection.generic.CanBuildFrom[_Tuple2Zipped__Repr1, _flatMap__B, _flatMap__To]) -> _flatMap__To: ...
    _flatMap$extension__B = typing.TypeVar('_flatMap$extension__B')  # <B>
    _flatMap$extension__To = typing.TypeVar('_flatMap$extension__To')  # <To>
    _flatMap$extension__El1 = typing.TypeVar('_flatMap$extension__El1')  # <El1>
    _flatMap$extension__Repr1 = typing.TypeVar('_flatMap$extension__Repr1')  # <Repr1>
    _flatMap$extension__El2 = typing.TypeVar('_flatMap$extension__El2')  # <El2>
    _flatMap$extension__Repr2 = typing.TypeVar('_flatMap$extension__Repr2')  # <Repr2>
    @staticmethod
    def flatMap$extension($this: scala.Tuple2[scala.collection.TraversableLike[_flatMap.extension__El1, _flatMap.extension__Repr1], scala.collection.IterableLike[_flatMap.extension__El2, _flatMap.extension__Repr2]], f: scala.Function2[_flatMap.extension__El1, _flatMap.extension__El2, scala.collection.TraversableOnce[_flatMap.extension__B]], cbf: scala.collection.generic.CanBuildFrom[_flatMap.extension__Repr1, _flatMap.extension__B, _flatMap.extension__To]) -> _flatMap.extension__To: ...
    def forall(self, p: scala.Function2[_Tuple2Zipped__El1, _Tuple2Zipped__El2, typing.Any]) -> bool: ...
    _forall$extension__El1 = typing.TypeVar('_forall$extension__El1')  # <El1>
    _forall$extension__Repr1 = typing.TypeVar('_forall$extension__Repr1')  # <Repr1>
    _forall$extension__El2 = typing.TypeVar('_forall$extension__El2')  # <El2>
    _forall$extension__Repr2 = typing.TypeVar('_forall$extension__Repr2')  # <Repr2>
    @staticmethod
    def forall$extension($this: scala.Tuple2[scala.collection.TraversableLike[_forall.extension__El1, _forall.extension__Repr1], scala.collection.IterableLike[_forall.extension__El2, _forall.extension__Repr2]], p: scala.Function2[_forall.extension__El1, _forall.extension__El2, typing.Any]) -> bool: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function2[_Tuple2Zipped__El1, _Tuple2Zipped__El2, _foreach__U]) -> None: ...
    _foreach$extension__U = typing.TypeVar('_foreach$extension__U')  # <U>
    _foreach$extension__El1 = typing.TypeVar('_foreach$extension__El1')  # <El1>
    _foreach$extension__Repr1 = typing.TypeVar('_foreach$extension__Repr1')  # <Repr1>
    _foreach$extension__El2 = typing.TypeVar('_foreach$extension__El2')  # <El2>
    _foreach$extension__Repr2 = typing.TypeVar('_foreach$extension__Repr2')  # <Repr2>
    @staticmethod
    def foreach$extension($this: scala.Tuple2[scala.collection.TraversableLike[_foreach.extension__El1, _foreach.extension__Repr1], scala.collection.IterableLike[_foreach.extension__El2, _foreach.extension__Repr2]], f: scala.Function2[_foreach.extension__El1, _foreach.extension__El2, _foreach.extension__U]) -> None: ...
    def hashCode(self) -> int: ...
    _hashCode$extension__El1 = typing.TypeVar('_hashCode$extension__El1')  # <El1>
    _hashCode$extension__Repr1 = typing.TypeVar('_hashCode$extension__Repr1')  # <Repr1>
    _hashCode$extension__El2 = typing.TypeVar('_hashCode$extension__El2')  # <El2>
    _hashCode$extension__Repr2 = typing.TypeVar('_hashCode$extension__Repr2')  # <Repr2>
    @staticmethod
    def hashCode$extension($this: scala.Tuple2[scala.collection.TraversableLike[_hashCode.extension__El1, _hashCode.extension__Repr1], scala.collection.IterableLike[_hashCode.extension__El2, _hashCode.extension__Repr2]]) -> int: ...
    _map__B = typing.TypeVar('_map__B')  # <B>
    _map__To = typing.TypeVar('_map__To')  # <To>
    def map(self, f: scala.Function2[_Tuple2Zipped__El1, _Tuple2Zipped__El2, _map__B], cbf: scala.collection.generic.CanBuildFrom[_Tuple2Zipped__Repr1, _map__B, _map__To]) -> _map__To: ...
    _map$extension__B = typing.TypeVar('_map$extension__B')  # <B>
    _map$extension__To = typing.TypeVar('_map$extension__To')  # <To>
    _map$extension__El1 = typing.TypeVar('_map$extension__El1')  # <El1>
    _map$extension__Repr1 = typing.TypeVar('_map$extension__Repr1')  # <Repr1>
    _map$extension__El2 = typing.TypeVar('_map$extension__El2')  # <El2>
    _map$extension__Repr2 = typing.TypeVar('_map$extension__Repr2')  # <Repr2>
    @staticmethod
    def map$extension($this: scala.Tuple2[scala.collection.TraversableLike[_map.extension__El1, _map.extension__Repr1], scala.collection.IterableLike[_map.extension__El2, _map.extension__Repr2]], f: scala.Function2[_map.extension__El1, _map.extension__El2, _map.extension__B], cbf: scala.collection.generic.CanBuildFrom[_map.extension__Repr1, _map.extension__B, _map.extension__To]) -> _map.extension__To: ...
    def toString(self) -> java.lang.String: ...
    _toString$extension__El1 = typing.TypeVar('_toString$extension__El1')  # <El1>
    _toString$extension__Repr1 = typing.TypeVar('_toString$extension__Repr1')  # <Repr1>
    _toString$extension__El2 = typing.TypeVar('_toString$extension__El2')  # <El2>
    _toString$extension__Repr2 = typing.TypeVar('_toString$extension__Repr2')  # <Repr2>
    @staticmethod
    def toString$extension($this: scala.Tuple2[scala.collection.TraversableLike[_toString.extension__El1, _toString.extension__Repr1], scala.collection.IterableLike[_toString.extension__El2, _toString.extension__Repr2]]) -> java.lang.String: ...
    class Ops(typing.Generic[_Tuple2Zipped__Ops__T1, _Tuple2Zipped__Ops__T2]):
        def __init__(self, x: scala.Tuple2[_Tuple2Zipped__Ops__T1, _Tuple2Zipped__Ops__T2]): ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        _invert__El1 = typing.TypeVar('_invert__El1')  # <El1>
        _invert__CC1 = typing.TypeVar('_invert__CC1', bound=scala.collection.TraversableOnce)  # <CC1>
        _invert__El2 = typing.TypeVar('_invert__El2')  # <El2>
        _invert__CC2 = typing.TypeVar('_invert__CC2', bound=scala.collection.TraversableOnce)  # <CC2>
        _invert__That = typing.TypeVar('_invert__That')  # <That>
        def invert(self, w1: scala.Predef..less.colon.less[_Tuple2Zipped__Ops__T1, _invert__CC1], w2: scala.Predef..less.colon.less[_Tuple2Zipped__Ops__T2, _invert__CC2], bf: scala.collection.generic.CanBuildFrom[_invert__CC1, scala.Tuple2[_invert__El1, _invert__El2], _invert__That]) -> _invert__That: ...
        def scala$runtime$Tuple2Zipped$Ops$$x(self) -> scala.Tuple2[_Tuple2Zipped__Ops__T1, _Tuple2Zipped__Ops__T2]: ...
        _zipped__El1 = typing.TypeVar('_zipped__El1')  # <El1>
        _zipped__Repr1 = typing.TypeVar('_zipped__Repr1')  # <Repr1>
        _zipped__El2 = typing.TypeVar('_zipped__El2')  # <El2>
        _zipped__Repr2 = typing.TypeVar('_zipped__Repr2')  # <Repr2>
        def zipped(self, w1: scala.Function1[_Tuple2Zipped__Ops__T1, scala.collection.TraversableLike[_zipped__El1, _zipped__Repr1]], w2: scala.Function1[_Tuple2Zipped__Ops__T2, scala.collection.IterableLike[_zipped__El2, _zipped__Repr2]]) -> scala.Tuple2[scala.collection.TraversableLike[_zipped__El1, _zipped__Repr1], scala.collection.IterableLike[_zipped__El2, _zipped__Repr2]]: ...
    class Ops$:
        MODULE$: typing.ClassVar['Tuple2Zipped.Ops.'] = ...
        def __init__(self): ...
        _equals$extension__T1 = typing.TypeVar('_equals$extension__T1')  # <T1>
        _equals$extension__T2 = typing.TypeVar('_equals$extension__T2')  # <T2>
        def equals$extension(self, $this: scala.Tuple2[_equals.extension__T1, _equals.extension__T2], x$1: typing.Any) -> bool: ...
        _hashCode$extension__T1 = typing.TypeVar('_hashCode$extension__T1')  # <T1>
        _hashCode$extension__T2 = typing.TypeVar('_hashCode$extension__T2')  # <T2>
        def hashCode$extension(self, $this: scala.Tuple2[_hashCode.extension__T1, _hashCode.extension__T2]) -> int: ...
        _invert$extension__El1 = typing.TypeVar('_invert$extension__El1')  # <El1>
        _invert$extension__CC1 = typing.TypeVar('_invert$extension__CC1', bound=scala.collection.TraversableOnce)  # <CC1>
        _invert$extension__El2 = typing.TypeVar('_invert$extension__El2')  # <El2>
        _invert$extension__CC2 = typing.TypeVar('_invert$extension__CC2', bound=scala.collection.TraversableOnce)  # <CC2>
        _invert$extension__That = typing.TypeVar('_invert$extension__That')  # <That>
        _invert$extension__T1 = typing.TypeVar('_invert$extension__T1')  # <T1>
        _invert$extension__T2 = typing.TypeVar('_invert$extension__T2')  # <T2>
        def invert$extension(self, $this: scala.Tuple2[_invert.extension__T1, _invert.extension__T2], w1: scala.Predef..less.colon.less[_invert.extension__T1, _invert.extension__CC1], w2: scala.Predef..less.colon.less[_invert.extension__T2, _invert.extension__CC2], bf: scala.collection.generic.CanBuildFrom[_invert.extension__CC1, scala.Tuple2[_invert.extension__El1, _invert.extension__El2], _invert.extension__That]) -> _invert.extension__That: ...
        _zipped$extension__El1 = typing.TypeVar('_zipped$extension__El1')  # <El1>
        _zipped$extension__Repr1 = typing.TypeVar('_zipped$extension__Repr1')  # <Repr1>
        _zipped$extension__El2 = typing.TypeVar('_zipped$extension__El2')  # <El2>
        _zipped$extension__Repr2 = typing.TypeVar('_zipped$extension__Repr2')  # <Repr2>
        _zipped$extension__T1 = typing.TypeVar('_zipped$extension__T1')  # <T1>
        _zipped$extension__T2 = typing.TypeVar('_zipped$extension__T2')  # <T2>
        def zipped$extension(self, $this: scala.Tuple2[_zipped.extension__T1, _zipped.extension__T2], w1: scala.Function1[_zipped.extension__T1, scala.collection.TraversableLike[_zipped.extension__El1, _zipped.extension__Repr1]], w2: scala.Function1[_zipped.extension__T2, scala.collection.IterableLike[_zipped.extension__El2, _zipped.extension__Repr2]]) -> scala.Tuple2[scala.collection.TraversableLike[_zipped.extension__El1, _zipped.extension__Repr1], scala.collection.IterableLike[_zipped.extension__El2, _zipped.extension__Repr2]]: ...

_Tuple3Zipped__Ops__T1 = typing.TypeVar('_Tuple3Zipped__Ops__T1')  # <T1>
_Tuple3Zipped__Ops__T2 = typing.TypeVar('_Tuple3Zipped__Ops__T2')  # <T2>
_Tuple3Zipped__Ops__T3 = typing.TypeVar('_Tuple3Zipped__Ops__T3')  # <T3>
_Tuple3Zipped__El1 = typing.TypeVar('_Tuple3Zipped__El1')  # <El1>
_Tuple3Zipped__Repr1 = typing.TypeVar('_Tuple3Zipped__Repr1')  # <Repr1>
_Tuple3Zipped__El2 = typing.TypeVar('_Tuple3Zipped__El2')  # <El2>
_Tuple3Zipped__Repr2 = typing.TypeVar('_Tuple3Zipped__Repr2')  # <Repr2>
_Tuple3Zipped__El3 = typing.TypeVar('_Tuple3Zipped__El3')  # <El3>
_Tuple3Zipped__Repr3 = typing.TypeVar('_Tuple3Zipped__Repr3')  # <Repr3>
class Tuple3Zipped(ZippedTraversable3[_Tuple3Zipped__El1, _Tuple3Zipped__El2, _Tuple3Zipped__El3], typing.Generic[_Tuple3Zipped__El1, _Tuple3Zipped__Repr1, _Tuple3Zipped__El2, _Tuple3Zipped__Repr2, _Tuple3Zipped__El3, _Tuple3Zipped__Repr3]):
    def __init__(self, colls: scala.Tuple3[scala.collection.TraversableLike[_Tuple3Zipped__El1, _Tuple3Zipped__Repr1], scala.collection.IterableLike[_Tuple3Zipped__El2, _Tuple3Zipped__Repr2], scala.collection.IterableLike[_Tuple3Zipped__El3, _Tuple3Zipped__Repr3]]): ...
    _coll1$extension__El1 = typing.TypeVar('_coll1$extension__El1')  # <El1>
    _coll1$extension__Repr1 = typing.TypeVar('_coll1$extension__Repr1')  # <Repr1>
    _coll1$extension__El2 = typing.TypeVar('_coll1$extension__El2')  # <El2>
    _coll1$extension__Repr2 = typing.TypeVar('_coll1$extension__Repr2')  # <Repr2>
    _coll1$extension__El3 = typing.TypeVar('_coll1$extension__El3')  # <El3>
    _coll1$extension__Repr3 = typing.TypeVar('_coll1$extension__Repr3')  # <Repr3>
    @staticmethod
    def coll1$extension($this: scala.Tuple3[scala.collection.TraversableLike[_coll1.extension__El1, _coll1.extension__Repr1], scala.collection.IterableLike[_coll1.extension__El2, _coll1.extension__Repr2], scala.collection.IterableLike[_coll1.extension__El3, _coll1.extension__Repr3]]) -> scala.collection.TraversableLike[_coll1.extension__El1, _coll1.extension__Repr1]: ...
    _coll2$extension__El1 = typing.TypeVar('_coll2$extension__El1')  # <El1>
    _coll2$extension__Repr1 = typing.TypeVar('_coll2$extension__Repr1')  # <Repr1>
    _coll2$extension__El2 = typing.TypeVar('_coll2$extension__El2')  # <El2>
    _coll2$extension__Repr2 = typing.TypeVar('_coll2$extension__Repr2')  # <Repr2>
    _coll2$extension__El3 = typing.TypeVar('_coll2$extension__El3')  # <El3>
    _coll2$extension__Repr3 = typing.TypeVar('_coll2$extension__Repr3')  # <Repr3>
    @staticmethod
    def coll2$extension($this: scala.Tuple3[scala.collection.TraversableLike[_coll2.extension__El1, _coll2.extension__Repr1], scala.collection.IterableLike[_coll2.extension__El2, _coll2.extension__Repr2], scala.collection.IterableLike[_coll2.extension__El3, _coll2.extension__Repr3]]) -> scala.collection.IterableLike[_coll2.extension__El2, _coll2.extension__Repr2]: ...
    _coll3$extension__El1 = typing.TypeVar('_coll3$extension__El1')  # <El1>
    _coll3$extension__Repr1 = typing.TypeVar('_coll3$extension__Repr1')  # <Repr1>
    _coll3$extension__El2 = typing.TypeVar('_coll3$extension__El2')  # <El2>
    _coll3$extension__Repr2 = typing.TypeVar('_coll3$extension__Repr2')  # <Repr2>
    _coll3$extension__El3 = typing.TypeVar('_coll3$extension__El3')  # <El3>
    _coll3$extension__Repr3 = typing.TypeVar('_coll3$extension__Repr3')  # <Repr3>
    @staticmethod
    def coll3$extension($this: scala.Tuple3[scala.collection.TraversableLike[_coll3.extension__El1, _coll3.extension__Repr1], scala.collection.IterableLike[_coll3.extension__El2, _coll3.extension__Repr2], scala.collection.IterableLike[_coll3.extension__El3, _coll3.extension__Repr3]]) -> scala.collection.IterableLike[_coll3.extension__El3, _coll3.extension__Repr3]: ...
    def colls(self) -> scala.Tuple3[scala.collection.TraversableLike[_Tuple3Zipped__El1, _Tuple3Zipped__Repr1], scala.collection.IterableLike[_Tuple3Zipped__El2, _Tuple3Zipped__Repr2], scala.collection.IterableLike[_Tuple3Zipped__El3, _Tuple3Zipped__Repr3]]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    _equals$extension__El1 = typing.TypeVar('_equals$extension__El1')  # <El1>
    _equals$extension__Repr1 = typing.TypeVar('_equals$extension__Repr1')  # <Repr1>
    _equals$extension__El2 = typing.TypeVar('_equals$extension__El2')  # <El2>
    _equals$extension__Repr2 = typing.TypeVar('_equals$extension__Repr2')  # <Repr2>
    _equals$extension__El3 = typing.TypeVar('_equals$extension__El3')  # <El3>
    _equals$extension__Repr3 = typing.TypeVar('_equals$extension__Repr3')  # <Repr3>
    @staticmethod
    def equals$extension($this: scala.Tuple3[scala.collection.TraversableLike[_equals.extension__El1, _equals.extension__Repr1], scala.collection.IterableLike[_equals.extension__El2, _equals.extension__Repr2], scala.collection.IterableLike[_equals.extension__El3, _equals.extension__Repr3]], x$1: typing.Any) -> bool: ...
    def exists(self, p: scala.Function3[_Tuple3Zipped__El1, _Tuple3Zipped__El2, _Tuple3Zipped__El3, typing.Any]) -> bool: ...
    _exists$extension__El1 = typing.TypeVar('_exists$extension__El1')  # <El1>
    _exists$extension__Repr1 = typing.TypeVar('_exists$extension__Repr1')  # <Repr1>
    _exists$extension__El2 = typing.TypeVar('_exists$extension__El2')  # <El2>
    _exists$extension__Repr2 = typing.TypeVar('_exists$extension__Repr2')  # <Repr2>
    _exists$extension__El3 = typing.TypeVar('_exists$extension__El3')  # <El3>
    _exists$extension__Repr3 = typing.TypeVar('_exists$extension__Repr3')  # <Repr3>
    @staticmethod
    def exists$extension($this: scala.Tuple3[scala.collection.TraversableLike[_exists.extension__El1, _exists.extension__Repr1], scala.collection.IterableLike[_exists.extension__El2, _exists.extension__Repr2], scala.collection.IterableLike[_exists.extension__El3, _exists.extension__Repr3]], p: scala.Function3[_exists.extension__El1, _exists.extension__El2, _exists.extension__El3, typing.Any]) -> bool: ...
    _filter__To1 = typing.TypeVar('_filter__To1')  # <To1>
    _filter__To2 = typing.TypeVar('_filter__To2')  # <To2>
    _filter__To3 = typing.TypeVar('_filter__To3')  # <To3>
    def filter(self, f: scala.Function3[_Tuple3Zipped__El1, _Tuple3Zipped__El2, _Tuple3Zipped__El3, typing.Any], cbf1: scala.collection.generic.CanBuildFrom[_Tuple3Zipped__Repr1, _Tuple3Zipped__El1, _filter__To1], cbf2: scala.collection.generic.CanBuildFrom[_Tuple3Zipped__Repr2, _Tuple3Zipped__El2, _filter__To2], cbf3: scala.collection.generic.CanBuildFrom[_Tuple3Zipped__Repr3, _Tuple3Zipped__El3, _filter__To3]) -> scala.Tuple3[_filter__To1, _filter__To2, _filter__To3]: ...
    _filter$extension__To1 = typing.TypeVar('_filter$extension__To1')  # <To1>
    _filter$extension__To2 = typing.TypeVar('_filter$extension__To2')  # <To2>
    _filter$extension__To3 = typing.TypeVar('_filter$extension__To3')  # <To3>
    _filter$extension__El1 = typing.TypeVar('_filter$extension__El1')  # <El1>
    _filter$extension__Repr1 = typing.TypeVar('_filter$extension__Repr1')  # <Repr1>
    _filter$extension__El2 = typing.TypeVar('_filter$extension__El2')  # <El2>
    _filter$extension__Repr2 = typing.TypeVar('_filter$extension__Repr2')  # <Repr2>
    _filter$extension__El3 = typing.TypeVar('_filter$extension__El3')  # <El3>
    _filter$extension__Repr3 = typing.TypeVar('_filter$extension__Repr3')  # <Repr3>
    @staticmethod
    def filter$extension($this: scala.Tuple3[scala.collection.TraversableLike[_filter.extension__El1, _filter.extension__Repr1], scala.collection.IterableLike[_filter.extension__El2, _filter.extension__Repr2], scala.collection.IterableLike[_filter.extension__El3, _filter.extension__Repr3]], f: scala.Function3[_filter.extension__El1, _filter.extension__El2, _filter.extension__El3, typing.Any], cbf1: scala.collection.generic.CanBuildFrom[_filter.extension__Repr1, _filter.extension__El1, _filter.extension__To1], cbf2: scala.collection.generic.CanBuildFrom[_filter.extension__Repr2, _filter.extension__El2, _filter.extension__To2], cbf3: scala.collection.generic.CanBuildFrom[_filter.extension__Repr3, _filter.extension__El3, _filter.extension__To3]) -> scala.Tuple3[_filter.extension__To1, _filter.extension__To2, _filter.extension__To3]: ...
    _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
    _flatMap__To = typing.TypeVar('_flatMap__To')  # <To>
    def flatMap(self, f: scala.Function3[_Tuple3Zipped__El1, _Tuple3Zipped__El2, _Tuple3Zipped__El3, scala.collection.TraversableOnce[_flatMap__B]], cbf: scala.collection.generic.CanBuildFrom[_Tuple3Zipped__Repr1, _flatMap__B, _flatMap__To]) -> _flatMap__To: ...
    _flatMap$extension__B = typing.TypeVar('_flatMap$extension__B')  # <B>
    _flatMap$extension__To = typing.TypeVar('_flatMap$extension__To')  # <To>
    _flatMap$extension__El1 = typing.TypeVar('_flatMap$extension__El1')  # <El1>
    _flatMap$extension__Repr1 = typing.TypeVar('_flatMap$extension__Repr1')  # <Repr1>
    _flatMap$extension__El2 = typing.TypeVar('_flatMap$extension__El2')  # <El2>
    _flatMap$extension__Repr2 = typing.TypeVar('_flatMap$extension__Repr2')  # <Repr2>
    _flatMap$extension__El3 = typing.TypeVar('_flatMap$extension__El3')  # <El3>
    _flatMap$extension__Repr3 = typing.TypeVar('_flatMap$extension__Repr3')  # <Repr3>
    @staticmethod
    def flatMap$extension($this: scala.Tuple3[scala.collection.TraversableLike[_flatMap.extension__El1, _flatMap.extension__Repr1], scala.collection.IterableLike[_flatMap.extension__El2, _flatMap.extension__Repr2], scala.collection.IterableLike[_flatMap.extension__El3, _flatMap.extension__Repr3]], f: scala.Function3[_flatMap.extension__El1, _flatMap.extension__El2, _flatMap.extension__El3, scala.collection.TraversableOnce[_flatMap.extension__B]], cbf: scala.collection.generic.CanBuildFrom[_flatMap.extension__Repr1, _flatMap.extension__B, _flatMap.extension__To]) -> _flatMap.extension__To: ...
    def forall(self, p: scala.Function3[_Tuple3Zipped__El1, _Tuple3Zipped__El2, _Tuple3Zipped__El3, typing.Any]) -> bool: ...
    _forall$extension__El1 = typing.TypeVar('_forall$extension__El1')  # <El1>
    _forall$extension__Repr1 = typing.TypeVar('_forall$extension__Repr1')  # <Repr1>
    _forall$extension__El2 = typing.TypeVar('_forall$extension__El2')  # <El2>
    _forall$extension__Repr2 = typing.TypeVar('_forall$extension__Repr2')  # <Repr2>
    _forall$extension__El3 = typing.TypeVar('_forall$extension__El3')  # <El3>
    _forall$extension__Repr3 = typing.TypeVar('_forall$extension__Repr3')  # <Repr3>
    @staticmethod
    def forall$extension($this: scala.Tuple3[scala.collection.TraversableLike[_forall.extension__El1, _forall.extension__Repr1], scala.collection.IterableLike[_forall.extension__El2, _forall.extension__Repr2], scala.collection.IterableLike[_forall.extension__El3, _forall.extension__Repr3]], p: scala.Function3[_forall.extension__El1, _forall.extension__El2, _forall.extension__El3, typing.Any]) -> bool: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function3[_Tuple3Zipped__El1, _Tuple3Zipped__El2, _Tuple3Zipped__El3, _foreach__U]) -> None: ...
    _foreach$extension__U = typing.TypeVar('_foreach$extension__U')  # <U>
    _foreach$extension__El1 = typing.TypeVar('_foreach$extension__El1')  # <El1>
    _foreach$extension__Repr1 = typing.TypeVar('_foreach$extension__Repr1')  # <Repr1>
    _foreach$extension__El2 = typing.TypeVar('_foreach$extension__El2')  # <El2>
    _foreach$extension__Repr2 = typing.TypeVar('_foreach$extension__Repr2')  # <Repr2>
    _foreach$extension__El3 = typing.TypeVar('_foreach$extension__El3')  # <El3>
    _foreach$extension__Repr3 = typing.TypeVar('_foreach$extension__Repr3')  # <Repr3>
    @staticmethod
    def foreach$extension($this: scala.Tuple3[scala.collection.TraversableLike[_foreach.extension__El1, _foreach.extension__Repr1], scala.collection.IterableLike[_foreach.extension__El2, _foreach.extension__Repr2], scala.collection.IterableLike[_foreach.extension__El3, _foreach.extension__Repr3]], f: scala.Function3[_foreach.extension__El1, _foreach.extension__El2, _foreach.extension__El3, _foreach.extension__U]) -> None: ...
    def hashCode(self) -> int: ...
    _hashCode$extension__El1 = typing.TypeVar('_hashCode$extension__El1')  # <El1>
    _hashCode$extension__Repr1 = typing.TypeVar('_hashCode$extension__Repr1')  # <Repr1>
    _hashCode$extension__El2 = typing.TypeVar('_hashCode$extension__El2')  # <El2>
    _hashCode$extension__Repr2 = typing.TypeVar('_hashCode$extension__Repr2')  # <Repr2>
    _hashCode$extension__El3 = typing.TypeVar('_hashCode$extension__El3')  # <El3>
    _hashCode$extension__Repr3 = typing.TypeVar('_hashCode$extension__Repr3')  # <Repr3>
    @staticmethod
    def hashCode$extension($this: scala.Tuple3[scala.collection.TraversableLike[_hashCode.extension__El1, _hashCode.extension__Repr1], scala.collection.IterableLike[_hashCode.extension__El2, _hashCode.extension__Repr2], scala.collection.IterableLike[_hashCode.extension__El3, _hashCode.extension__Repr3]]) -> int: ...
    _map__B = typing.TypeVar('_map__B')  # <B>
    _map__To = typing.TypeVar('_map__To')  # <To>
    def map(self, f: scala.Function3[_Tuple3Zipped__El1, _Tuple3Zipped__El2, _Tuple3Zipped__El3, _map__B], cbf: scala.collection.generic.CanBuildFrom[_Tuple3Zipped__Repr1, _map__B, _map__To]) -> _map__To: ...
    _map$extension__B = typing.TypeVar('_map$extension__B')  # <B>
    _map$extension__To = typing.TypeVar('_map$extension__To')  # <To>
    _map$extension__El1 = typing.TypeVar('_map$extension__El1')  # <El1>
    _map$extension__Repr1 = typing.TypeVar('_map$extension__Repr1')  # <Repr1>
    _map$extension__El2 = typing.TypeVar('_map$extension__El2')  # <El2>
    _map$extension__Repr2 = typing.TypeVar('_map$extension__Repr2')  # <Repr2>
    _map$extension__El3 = typing.TypeVar('_map$extension__El3')  # <El3>
    _map$extension__Repr3 = typing.TypeVar('_map$extension__Repr3')  # <Repr3>
    @staticmethod
    def map$extension($this: scala.Tuple3[scala.collection.TraversableLike[_map.extension__El1, _map.extension__Repr1], scala.collection.IterableLike[_map.extension__El2, _map.extension__Repr2], scala.collection.IterableLike[_map.extension__El3, _map.extension__Repr3]], f: scala.Function3[_map.extension__El1, _map.extension__El2, _map.extension__El3, _map.extension__B], cbf: scala.collection.generic.CanBuildFrom[_map.extension__Repr1, _map.extension__B, _map.extension__To]) -> _map.extension__To: ...
    def toString(self) -> java.lang.String: ...
    _toString$extension__El1 = typing.TypeVar('_toString$extension__El1')  # <El1>
    _toString$extension__Repr1 = typing.TypeVar('_toString$extension__Repr1')  # <Repr1>
    _toString$extension__El2 = typing.TypeVar('_toString$extension__El2')  # <El2>
    _toString$extension__Repr2 = typing.TypeVar('_toString$extension__Repr2')  # <Repr2>
    _toString$extension__El3 = typing.TypeVar('_toString$extension__El3')  # <El3>
    _toString$extension__Repr3 = typing.TypeVar('_toString$extension__Repr3')  # <Repr3>
    @staticmethod
    def toString$extension($this: scala.Tuple3[scala.collection.TraversableLike[_toString.extension__El1, _toString.extension__Repr1], scala.collection.IterableLike[_toString.extension__El2, _toString.extension__Repr2], scala.collection.IterableLike[_toString.extension__El3, _toString.extension__Repr3]]) -> java.lang.String: ...
    class Ops(typing.Generic[_Tuple3Zipped__Ops__T1, _Tuple3Zipped__Ops__T2, _Tuple3Zipped__Ops__T3]):
        def __init__(self, x: scala.Tuple3[_Tuple3Zipped__Ops__T1, _Tuple3Zipped__Ops__T2, _Tuple3Zipped__Ops__T3]): ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        _invert__El1 = typing.TypeVar('_invert__El1')  # <El1>
        _invert__CC1 = typing.TypeVar('_invert__CC1', bound=scala.collection.TraversableOnce)  # <CC1>
        _invert__El2 = typing.TypeVar('_invert__El2')  # <El2>
        _invert__CC2 = typing.TypeVar('_invert__CC2', bound=scala.collection.TraversableOnce)  # <CC2>
        _invert__El3 = typing.TypeVar('_invert__El3')  # <El3>
        _invert__CC3 = typing.TypeVar('_invert__CC3', bound=scala.collection.TraversableOnce)  # <CC3>
        _invert__That = typing.TypeVar('_invert__That')  # <That>
        def invert(self, w1: scala.Predef..less.colon.less[_Tuple3Zipped__Ops__T1, _invert__CC1], w2: scala.Predef..less.colon.less[_Tuple3Zipped__Ops__T2, _invert__CC2], w3: scala.Predef..less.colon.less[_Tuple3Zipped__Ops__T3, _invert__CC3], bf: scala.collection.generic.CanBuildFrom[_invert__CC1, scala.Tuple3[_invert__El1, _invert__El2, _invert__El3], _invert__That]) -> _invert__That: ...
        def scala$runtime$Tuple3Zipped$Ops$$x(self) -> scala.Tuple3[_Tuple3Zipped__Ops__T1, _Tuple3Zipped__Ops__T2, _Tuple3Zipped__Ops__T3]: ...
        _zipped__El1 = typing.TypeVar('_zipped__El1')  # <El1>
        _zipped__Repr1 = typing.TypeVar('_zipped__Repr1')  # <Repr1>
        _zipped__El2 = typing.TypeVar('_zipped__El2')  # <El2>
        _zipped__Repr2 = typing.TypeVar('_zipped__Repr2')  # <Repr2>
        _zipped__El3 = typing.TypeVar('_zipped__El3')  # <El3>
        _zipped__Repr3 = typing.TypeVar('_zipped__Repr3')  # <Repr3>
        def zipped(self, w1: scala.Function1[_Tuple3Zipped__Ops__T1, scala.collection.TraversableLike[_zipped__El1, _zipped__Repr1]], w2: scala.Function1[_Tuple3Zipped__Ops__T2, scala.collection.IterableLike[_zipped__El2, _zipped__Repr2]], w3: scala.Function1[_Tuple3Zipped__Ops__T3, scala.collection.IterableLike[_zipped__El3, _zipped__Repr3]]) -> scala.Tuple3[scala.collection.TraversableLike[_zipped__El1, _zipped__Repr1], scala.collection.IterableLike[_zipped__El2, _zipped__Repr2], scala.collection.IterableLike[_zipped__El3, _zipped__Repr3]]: ...
    class Ops$:
        MODULE$: typing.ClassVar['Tuple3Zipped.Ops.'] = ...
        def __init__(self): ...
        _equals$extension__T1 = typing.TypeVar('_equals$extension__T1')  # <T1>
        _equals$extension__T2 = typing.TypeVar('_equals$extension__T2')  # <T2>
        _equals$extension__T3 = typing.TypeVar('_equals$extension__T3')  # <T3>
        def equals$extension(self, $this: scala.Tuple3[_equals.extension__T1, _equals.extension__T2, _equals.extension__T3], x$1: typing.Any) -> bool: ...
        _hashCode$extension__T1 = typing.TypeVar('_hashCode$extension__T1')  # <T1>
        _hashCode$extension__T2 = typing.TypeVar('_hashCode$extension__T2')  # <T2>
        _hashCode$extension__T3 = typing.TypeVar('_hashCode$extension__T3')  # <T3>
        def hashCode$extension(self, $this: scala.Tuple3[_hashCode.extension__T1, _hashCode.extension__T2, _hashCode.extension__T3]) -> int: ...
        _invert$extension__El1 = typing.TypeVar('_invert$extension__El1')  # <El1>
        _invert$extension__CC1 = typing.TypeVar('_invert$extension__CC1', bound=scala.collection.TraversableOnce)  # <CC1>
        _invert$extension__El2 = typing.TypeVar('_invert$extension__El2')  # <El2>
        _invert$extension__CC2 = typing.TypeVar('_invert$extension__CC2', bound=scala.collection.TraversableOnce)  # <CC2>
        _invert$extension__El3 = typing.TypeVar('_invert$extension__El3')  # <El3>
        _invert$extension__CC3 = typing.TypeVar('_invert$extension__CC3', bound=scala.collection.TraversableOnce)  # <CC3>
        _invert$extension__That = typing.TypeVar('_invert$extension__That')  # <That>
        _invert$extension__T1 = typing.TypeVar('_invert$extension__T1')  # <T1>
        _invert$extension__T2 = typing.TypeVar('_invert$extension__T2')  # <T2>
        _invert$extension__T3 = typing.TypeVar('_invert$extension__T3')  # <T3>
        def invert$extension(self, $this: scala.Tuple3[_invert.extension__T1, _invert.extension__T2, _invert.extension__T3], w1: scala.Predef..less.colon.less[_invert.extension__T1, _invert.extension__CC1], w2: scala.Predef..less.colon.less[_invert.extension__T2, _invert.extension__CC2], w3: scala.Predef..less.colon.less[_invert.extension__T3, _invert.extension__CC3], bf: scala.collection.generic.CanBuildFrom[_invert.extension__CC1, scala.Tuple3[_invert.extension__El1, _invert.extension__El2, _invert.extension__El3], _invert.extension__That]) -> _invert.extension__That: ...
        _zipped$extension__El1 = typing.TypeVar('_zipped$extension__El1')  # <El1>
        _zipped$extension__Repr1 = typing.TypeVar('_zipped$extension__Repr1')  # <Repr1>
        _zipped$extension__El2 = typing.TypeVar('_zipped$extension__El2')  # <El2>
        _zipped$extension__Repr2 = typing.TypeVar('_zipped$extension__Repr2')  # <Repr2>
        _zipped$extension__El3 = typing.TypeVar('_zipped$extension__El3')  # <El3>
        _zipped$extension__Repr3 = typing.TypeVar('_zipped$extension__Repr3')  # <Repr3>
        _zipped$extension__T1 = typing.TypeVar('_zipped$extension__T1')  # <T1>
        _zipped$extension__T2 = typing.TypeVar('_zipped$extension__T2')  # <T2>
        _zipped$extension__T3 = typing.TypeVar('_zipped$extension__T3')  # <T3>
        def zipped$extension(self, $this: scala.Tuple3[_zipped.extension__T1, _zipped.extension__T2, _zipped.extension__T3], w1: scala.Function1[_zipped.extension__T1, scala.collection.TraversableLike[_zipped.extension__El1, _zipped.extension__Repr1]], w2: scala.Function1[_zipped.extension__T2, scala.collection.IterableLike[_zipped.extension__El2, _zipped.extension__Repr2]], w3: scala.Function1[_zipped.extension__T3, scala.collection.IterableLike[_zipped.extension__El3, _zipped.extension__Repr3]]) -> scala.Tuple3[scala.collection.TraversableLike[_zipped.extension__El1, _zipped.extension__Repr1], scala.collection.IterableLike[_zipped.extension__El2, _zipped.extension__Repr2], scala.collection.IterableLike[_zipped.extension__El3, _zipped.extension__Repr3]]: ...

_FractionalProxy__T = typing.TypeVar('_FractionalProxy__T')  # <T>
class FractionalProxy(ScalaNumberProxy[_FractionalProxy__T], RangedProxy[_FractionalProxy__T], typing.Generic[_FractionalProxy__T]):
    @staticmethod
    def $init$($this: 'FractionalProxy') -> None: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def integralNum(self) -> scala.math.Integral[_FractionalProxy__T]: ...
    def isWhole(self) -> bool: ...
    @typing.overload
    def num(self) -> scala.math.Fractional[_FractionalProxy__T]: ...
    @typing.overload
    def num(self) -> scala.math.Numeric[_FractionalProxy__T]: ...
    @typing.overload
    def to(self, end: _FractionalProxy__T) -> typing.Any: ...
    @typing.overload
    def to(self, end: _FractionalProxy__T, step: _FractionalProxy__T) -> scala.collection.immutable.IndexedSeq[_FractionalProxy__T]: ...
    @typing.overload
    def to(self, end: _FractionalProxy__T) -> scala.Function1[_FractionalProxy__T, scala.collection.immutable.NumericRange[_FractionalProxy__T]]: ...
    @typing.overload
    def to(self, end: _FractionalProxy__T, step: _FractionalProxy__T) -> scala.collection.immutable.NumericRange.Inclusive[_FractionalProxy__T]: ...
    def toString(self) -> java.lang.String: ...
    @typing.overload
    def until(self, end: _FractionalProxy__T) -> typing.Any: ...
    @typing.overload
    def until(self, end: _FractionalProxy__T, step: _FractionalProxy__T) -> scala.collection.immutable.IndexedSeq[_FractionalProxy__T]: ...
    @typing.overload
    def until(self, end: _FractionalProxy__T) -> scala.Function1[_FractionalProxy__T, scala.collection.immutable.NumericRange[_FractionalProxy__T]]: ...
    @typing.overload
    def until(self, end: _FractionalProxy__T, step: _FractionalProxy__T) -> scala.collection.immutable.NumericRange.Exclusive[_FractionalProxy__T]: ...

class RichInt(ScalaNumberProxy[typing.Any], RangedProxy[typing.Any]):
    def __init__(self, self): ...
    def $greater(self, that: typing.Any) -> bool: ...
    def $greater$eq(self, that: typing.Any) -> bool: ...
    def $less(self, that: typing.Any) -> bool: ...
    def $less$eq(self, that: typing.Any) -> bool: ...
    def abs(self) -> int: ...
    @staticmethod
    def abs$extension($this: int) -> int: ...
    def byteValue(self) -> int: ...
    @staticmethod
    def byteValue$extension($this: int) -> int: ...
    def compare(self, y: typing.Any) -> int: ...
    def compareTo(self, that: typing.Any) -> int: ...
    def doubleValue(self) -> float: ...
    @staticmethod
    def doubleValue$extension($this: int) -> float: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    @staticmethod
    def equals$extension($this: int, x$1: typing.Any) -> bool: ...
    def floatValue(self) -> float: ...
    @staticmethod
    def floatValue$extension($this: int) -> float: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def hashCode$extension($this: int) -> int: ...
    def intValue(self) -> int: ...
    @staticmethod
    def intValue$extension($this: int) -> int: ...
    def isValidByte(self) -> bool: ...
    def isValidChar(self) -> bool: ...
    def isValidInt(self) -> bool: ...
    @staticmethod
    def isValidInt$extension($this: int) -> bool: ...
    def isValidLong(self) -> bool: ...
    @staticmethod
    def isValidLong$extension($this: int) -> bool: ...
    def isValidShort(self) -> bool: ...
    def isWhole(self) -> bool: ...
    @staticmethod
    def isWhole$extension($this: int) -> bool: ...
    def longValue(self) -> int: ...
    @staticmethod
    def longValue$extension($this: int) -> int: ...
    def max(self, that: int) -> int: ...
    @staticmethod
    def max$extension($this: int, that: int) -> int: ...
    def min(self, that: int) -> int: ...
    @staticmethod
    def min$extension($this: int, that: int) -> int: ...
    def num(self) -> scala.math.Numeric.IntIsIntegral.: ...
    @staticmethod
    def num$extension($this: int) -> scala.math.Numeric.IntIsIntegral.: ...
    def ord(self) -> scala.math.Ordering.Int.: ...
    @staticmethod
    def ord$extension($this: int) -> scala.math.Ordering.Int.: ...
    def round(self) -> int: ...
    @staticmethod
    def round$extension($this: int) -> int: ...
    def self(self) -> int: ...
    def shortValue(self) -> int: ...
    @staticmethod
    def shortValue$extension($this: int) -> int: ...
    def signum(self) -> int: ...
    @staticmethod
    def signum$extension($this: int) -> int: ...
    @typing.overload
    def to(self, end: int) -> scala.collection.immutable.Range.Inclusive: ...
    @typing.overload
    def to(self, end: int, step: int) -> scala.collection.immutable.Range.Inclusive: ...
    @staticmethod
    def to$extension0($this: int, end: int) -> scala.collection.immutable.Range.Inclusive: ...
    @staticmethod
    def to$extension1($this: int, end: int, step: int) -> scala.collection.immutable.Range.Inclusive: ...
    def toBinaryString(self) -> java.lang.String: ...
    @staticmethod
    def toBinaryString$extension($this: int) -> java.lang.String: ...
    def toByte(self) -> int: ...
    def toChar(self) -> str: ...
    def toDouble(self) -> float: ...
    def toFloat(self) -> float: ...
    def toHexString(self) -> java.lang.String: ...
    @staticmethod
    def toHexString$extension($this: int) -> java.lang.String: ...
    def toInt(self) -> int: ...
    def toLong(self) -> int: ...
    def toOctalString(self) -> java.lang.String: ...
    @staticmethod
    def toOctalString$extension($this: int) -> java.lang.String: ...
    def toShort(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    def underlying(self) -> typing.Any: ...
    def unifiedPrimitiveEquals(self, x: typing.Any) -> bool: ...
    def unifiedPrimitiveHashcode(self) -> int: ...
    @typing.overload
    def until(self, end: int) -> scala.collection.immutable.Range: ...
    @typing.overload
    def until(self, end: int, step: int) -> scala.collection.immutable.Range: ...
    @staticmethod
    def until$extension0($this: int, end: int) -> scala.collection.immutable.Range: ...
    @staticmethod
    def until$extension1($this: int, end: int, step: int) -> scala.collection.immutable.Range: ...

_ScalaWholeNumberProxy__T = typing.TypeVar('_ScalaWholeNumberProxy__T')  # <T>
class ScalaWholeNumberProxy(ScalaNumberProxy[_ScalaWholeNumberProxy__T], typing.Generic[_ScalaWholeNumberProxy__T]):
    @staticmethod
    def $init$($this: 'ScalaWholeNumberProxy') -> None: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def isWhole(self) -> bool: ...
    def toString(self) -> java.lang.String: ...

_IntegralProxy__T = typing.TypeVar('_IntegralProxy__T')  # <T>
class IntegralProxy(ScalaWholeNumberProxy[_IntegralProxy__T], RangedProxy[_IntegralProxy__T], typing.Generic[_IntegralProxy__T]):
    @staticmethod
    def $init$($this: 'IntegralProxy') -> None: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def num(self) -> scala.math.Integral[_IntegralProxy__T]: ...
    @typing.overload
    def num(self) -> scala.math.Numeric[_IntegralProxy__T]: ...
    @typing.overload
    def to(self, end: _IntegralProxy__T) -> typing.Any: ...
    @typing.overload
    def to(self, end: _IntegralProxy__T, step: _IntegralProxy__T) -> scala.collection.immutable.IndexedSeq[_IntegralProxy__T]: ...
    @typing.overload
    def to(self, end: _IntegralProxy__T) -> scala.collection.immutable.NumericRange.Inclusive[_IntegralProxy__T]: ...
    @typing.overload
    def to(self, end: _IntegralProxy__T, step: _IntegralProxy__T) -> scala.collection.immutable.NumericRange.Inclusive[_IntegralProxy__T]: ...
    def toString(self) -> java.lang.String: ...
    @typing.overload
    def until(self, end: _IntegralProxy__T) -> typing.Any: ...
    @typing.overload
    def until(self, end: _IntegralProxy__T, step: _IntegralProxy__T) -> scala.collection.immutable.IndexedSeq[_IntegralProxy__T]: ...
    @typing.overload
    def until(self, end: _IntegralProxy__T) -> scala.collection.immutable.NumericRange.Exclusive[_IntegralProxy__T]: ...
    @typing.overload
    def until(self, end: _IntegralProxy__T, step: _IntegralProxy__T) -> scala.collection.immutable.NumericRange.Exclusive[_IntegralProxy__T]: ...

class RichByte(ScalaWholeNumberProxy[typing.Any]):
    def __init__(self, self): ...
    def $greater(self, that: typing.Any) -> bool: ...
    def $greater$eq(self, that: typing.Any) -> bool: ...
    def $less(self, that: typing.Any) -> bool: ...
    def $less$eq(self, that: typing.Any) -> bool: ...
    def abs(self) -> int: ...
    @staticmethod
    def abs$extension($this: int) -> int: ...
    def byteValue(self) -> int: ...
    @staticmethod
    def byteValue$extension($this: int) -> int: ...
    def compare(self, y: typing.Any) -> int: ...
    def compareTo(self, that: typing.Any) -> int: ...
    def doubleValue(self) -> float: ...
    @staticmethod
    def doubleValue$extension($this: int) -> float: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    @staticmethod
    def equals$extension($this: int, x$1: typing.Any) -> bool: ...
    def floatValue(self) -> float: ...
    @staticmethod
    def floatValue$extension($this: int) -> float: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def hashCode$extension($this: int) -> int: ...
    def intValue(self) -> int: ...
    @staticmethod
    def intValue$extension($this: int) -> int: ...
    def isValidByte(self) -> bool: ...
    @staticmethod
    def isValidByte$extension($this: int) -> bool: ...
    def isValidChar(self) -> bool: ...
    def isValidInt(self) -> bool: ...
    def isValidShort(self) -> bool: ...
    def isWhole(self) -> bool: ...
    def longValue(self) -> int: ...
    @staticmethod
    def longValue$extension($this: int) -> int: ...
    def max(self, that: int) -> int: ...
    @staticmethod
    def max$extension($this: int, that: int) -> int: ...
    def min(self, that: int) -> int: ...
    @staticmethod
    def min$extension($this: int, that: int) -> int: ...
    def num(self) -> scala.math.Numeric.ByteIsIntegral.: ...
    @staticmethod
    def num$extension($this: int) -> scala.math.Numeric.ByteIsIntegral.: ...
    def ord(self) -> scala.math.Ordering.Byte.: ...
    @staticmethod
    def ord$extension($this: int) -> scala.math.Ordering.Byte.: ...
    def self(self) -> int: ...
    def shortValue(self) -> int: ...
    @staticmethod
    def shortValue$extension($this: int) -> int: ...
    def signum(self) -> int: ...
    @staticmethod
    def signum$extension($this: int) -> int: ...
    def toByte(self) -> int: ...
    def toChar(self) -> str: ...
    def toDouble(self) -> float: ...
    def toFloat(self) -> float: ...
    def toInt(self) -> int: ...
    def toLong(self) -> int: ...
    def toShort(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    def underlying(self) -> typing.Any: ...
    def unifiedPrimitiveEquals(self, x: typing.Any) -> bool: ...
    def unifiedPrimitiveHashcode(self) -> int: ...

class RichDouble(FractionalProxy[typing.Any]):
    def __init__(self, self): ...
    def $greater(self, that: typing.Any) -> bool: ...
    def $greater$eq(self, that: typing.Any) -> bool: ...
    def $less(self, that: typing.Any) -> bool: ...
    def $less$eq(self, that: typing.Any) -> bool: ...
    def abs(self) -> float: ...
    @staticmethod
    def abs$extension($this: float) -> float: ...
    def byteValue(self) -> int: ...
    @staticmethod
    def byteValue$extension($this: float) -> int: ...
    def ceil(self) -> float: ...
    @staticmethod
    def ceil$extension($this: float) -> float: ...
    def compare(self, y: typing.Any) -> int: ...
    def compareTo(self, that: typing.Any) -> int: ...
    def doubleValue(self) -> float: ...
    @staticmethod
    def doubleValue$extension($this: float) -> float: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    @staticmethod
    def equals$extension($this: float, x$1: typing.Any) -> bool: ...
    def floatValue(self) -> float: ...
    @staticmethod
    def floatValue$extension($this: float) -> float: ...
    def floor(self) -> float: ...
    @staticmethod
    def floor$extension($this: float) -> float: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def hashCode$extension($this: float) -> int: ...
    def intValue(self) -> int: ...
    @staticmethod
    def intValue$extension($this: float) -> int: ...
    def integralNum(self) -> scala.math.Numeric.DoubleAsIfIntegral.: ...
    @staticmethod
    def integralNum$extension($this: float) -> scala.math.Numeric.DoubleAsIfIntegral.: ...
    def isInfinity(self) -> bool: ...
    @staticmethod
    def isInfinity$extension($this: float) -> bool: ...
    def isNaN(self) -> bool: ...
    @staticmethod
    def isNaN$extension($this: float) -> bool: ...
    def isNegInfinity(self) -> bool: ...
    @staticmethod
    def isNegInfinity$extension($this: float) -> bool: ...
    def isPosInfinity(self) -> bool: ...
    @staticmethod
    def isPosInfinity$extension($this: float) -> bool: ...
    def isValidByte(self) -> bool: ...
    @staticmethod
    def isValidByte$extension($this: float) -> bool: ...
    def isValidChar(self) -> bool: ...
    @staticmethod
    def isValidChar$extension($this: float) -> bool: ...
    def isValidInt(self) -> bool: ...
    @staticmethod
    def isValidInt$extension($this: float) -> bool: ...
    def isValidShort(self) -> bool: ...
    @staticmethod
    def isValidShort$extension($this: float) -> bool: ...
    def isWhole(self) -> bool: ...
    @staticmethod
    def isWhole$extension($this: float) -> bool: ...
    def longValue(self) -> int: ...
    @staticmethod
    def longValue$extension($this: float) -> int: ...
    def max(self, that: float) -> float: ...
    @staticmethod
    def max$extension($this: float, that: float) -> float: ...
    def min(self, that: float) -> float: ...
    @staticmethod
    def min$extension($this: float, that: float) -> float: ...
    def num(self) -> scala.math.Numeric.DoubleIsFractional.: ...
    @staticmethod
    def num$extension($this: float) -> scala.math.Numeric.DoubleIsFractional.: ...
    def ord(self) -> scala.math.Ordering.Double.: ...
    @staticmethod
    def ord$extension($this: float) -> scala.math.Ordering.Double.: ...
    def round(self) -> int: ...
    @staticmethod
    def round$extension($this: float) -> int: ...
    def self(self) -> float: ...
    def shortValue(self) -> int: ...
    @staticmethod
    def shortValue$extension($this: float) -> int: ...
    def signum(self) -> int: ...
    @staticmethod
    def signum$extension($this: float) -> int: ...
    @typing.overload
    def to(self, end: typing.Any) -> scala.Function1: ...
    @typing.overload
    def to(self, end: typing.Any, step: typing.Any) -> scala.collection.immutable.NumericRange.Inclusive: ...
    def toByte(self) -> int: ...
    def toChar(self) -> str: ...
    def toDegrees(self) -> float: ...
    @staticmethod
    def toDegrees$extension($this: float) -> float: ...
    def toDouble(self) -> float: ...
    def toFloat(self) -> float: ...
    def toInt(self) -> int: ...
    def toLong(self) -> int: ...
    def toRadians(self) -> float: ...
    @staticmethod
    def toRadians$extension($this: float) -> float: ...
    def toShort(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    def underlying(self) -> typing.Any: ...
    def unifiedPrimitiveEquals(self, x: typing.Any) -> bool: ...
    def unifiedPrimitiveHashcode(self) -> int: ...
    @typing.overload
    def until(self, end: typing.Any) -> scala.Function1: ...
    @typing.overload
    def until(self, end: typing.Any, step: typing.Any) -> scala.collection.immutable.NumericRange.Exclusive: ...

class RichFloat(FractionalProxy[typing.Any]):
    def __init__(self, self): ...
    def $greater(self, that: typing.Any) -> bool: ...
    def $greater$eq(self, that: typing.Any) -> bool: ...
    def $less(self, that: typing.Any) -> bool: ...
    def $less$eq(self, that: typing.Any) -> bool: ...
    def abs(self) -> float: ...
    @staticmethod
    def abs$extension($this: float) -> float: ...
    def byteValue(self) -> int: ...
    @staticmethod
    def byteValue$extension($this: float) -> int: ...
    def ceil(self) -> float: ...
    @staticmethod
    def ceil$extension($this: float) -> float: ...
    def compare(self, y: typing.Any) -> int: ...
    def compareTo(self, that: typing.Any) -> int: ...
    def doubleValue(self) -> float: ...
    @staticmethod
    def doubleValue$extension($this: float) -> float: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    @staticmethod
    def equals$extension($this: float, x$1: typing.Any) -> bool: ...
    def floatValue(self) -> float: ...
    @staticmethod
    def floatValue$extension($this: float) -> float: ...
    def floor(self) -> float: ...
    @staticmethod
    def floor$extension($this: float) -> float: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def hashCode$extension($this: float) -> int: ...
    def intValue(self) -> int: ...
    @staticmethod
    def intValue$extension($this: float) -> int: ...
    def integralNum(self) -> scala.math.Numeric.FloatAsIfIntegral.: ...
    @staticmethod
    def integralNum$extension($this: float) -> scala.math.Numeric.FloatAsIfIntegral.: ...
    def isInfinity(self) -> bool: ...
    @staticmethod
    def isInfinity$extension($this: float) -> bool: ...
    def isNaN(self) -> bool: ...
    @staticmethod
    def isNaN$extension($this: float) -> bool: ...
    def isNegInfinity(self) -> bool: ...
    @staticmethod
    def isNegInfinity$extension($this: float) -> bool: ...
    def isPosInfinity(self) -> bool: ...
    @staticmethod
    def isPosInfinity$extension($this: float) -> bool: ...
    def isValidByte(self) -> bool: ...
    @staticmethod
    def isValidByte$extension($this: float) -> bool: ...
    def isValidChar(self) -> bool: ...
    @staticmethod
    def isValidChar$extension($this: float) -> bool: ...
    def isValidInt(self) -> bool: ...
    @staticmethod
    def isValidInt$extension($this: float) -> bool: ...
    def isValidShort(self) -> bool: ...
    @staticmethod
    def isValidShort$extension($this: float) -> bool: ...
    def isWhole(self) -> bool: ...
    @staticmethod
    def isWhole$extension($this: float) -> bool: ...
    def longValue(self) -> int: ...
    @staticmethod
    def longValue$extension($this: float) -> int: ...
    def max(self, that: float) -> float: ...
    @staticmethod
    def max$extension($this: float, that: float) -> float: ...
    def min(self, that: float) -> float: ...
    @staticmethod
    def min$extension($this: float, that: float) -> float: ...
    def num(self) -> scala.math.Numeric.FloatIsFractional.: ...
    @staticmethod
    def num$extension($this: float) -> scala.math.Numeric.FloatIsFractional.: ...
    def ord(self) -> scala.math.Ordering.Float.: ...
    @staticmethod
    def ord$extension($this: float) -> scala.math.Ordering.Float.: ...
    def round(self) -> int: ...
    @staticmethod
    def round$extension($this: float) -> int: ...
    def self(self) -> float: ...
    def shortValue(self) -> int: ...
    @staticmethod
    def shortValue$extension($this: float) -> int: ...
    def signum(self) -> int: ...
    @staticmethod
    def signum$extension($this: float) -> int: ...
    @typing.overload
    def to(self, end: typing.Any) -> scala.Function1: ...
    @typing.overload
    def to(self, end: typing.Any, step: typing.Any) -> scala.collection.immutable.NumericRange.Inclusive: ...
    def toByte(self) -> int: ...
    def toChar(self) -> str: ...
    def toDegrees(self) -> float: ...
    @staticmethod
    def toDegrees$extension($this: float) -> float: ...
    def toDouble(self) -> float: ...
    def toFloat(self) -> float: ...
    def toInt(self) -> int: ...
    def toLong(self) -> int: ...
    def toRadians(self) -> float: ...
    @staticmethod
    def toRadians$extension($this: float) -> float: ...
    def toShort(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    def underlying(self) -> typing.Any: ...
    def unifiedPrimitiveEquals(self, x: typing.Any) -> bool: ...
    def unifiedPrimitiveHashcode(self) -> int: ...
    @typing.overload
    def until(self, end: typing.Any) -> scala.Function1: ...
    @typing.overload
    def until(self, end: typing.Any, step: typing.Any) -> scala.collection.immutable.NumericRange.Exclusive: ...

class RichShort(ScalaWholeNumberProxy[typing.Any]):
    def __init__(self, self): ...
    def $greater(self, that: typing.Any) -> bool: ...
    def $greater$eq(self, that: typing.Any) -> bool: ...
    def $less(self, that: typing.Any) -> bool: ...
    def $less$eq(self, that: typing.Any) -> bool: ...
    def abs(self) -> int: ...
    @staticmethod
    def abs$extension($this: int) -> int: ...
    def byteValue(self) -> int: ...
    @staticmethod
    def byteValue$extension($this: int) -> int: ...
    def compare(self, y: typing.Any) -> int: ...
    def compareTo(self, that: typing.Any) -> int: ...
    def doubleValue(self) -> float: ...
    @staticmethod
    def doubleValue$extension($this: int) -> float: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    @staticmethod
    def equals$extension($this: int, x$1: typing.Any) -> bool: ...
    def floatValue(self) -> float: ...
    @staticmethod
    def floatValue$extension($this: int) -> float: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def hashCode$extension($this: int) -> int: ...
    def intValue(self) -> int: ...
    @staticmethod
    def intValue$extension($this: int) -> int: ...
    def isValidByte(self) -> bool: ...
    def isValidChar(self) -> bool: ...
    def isValidInt(self) -> bool: ...
    def isValidShort(self) -> bool: ...
    @staticmethod
    def isValidShort$extension($this: int) -> bool: ...
    def isWhole(self) -> bool: ...
    def longValue(self) -> int: ...
    @staticmethod
    def longValue$extension($this: int) -> int: ...
    def max(self, that: int) -> int: ...
    @staticmethod
    def max$extension($this: int, that: int) -> int: ...
    def min(self, that: int) -> int: ...
    @staticmethod
    def min$extension($this: int, that: int) -> int: ...
    def num(self) -> scala.math.Numeric.ShortIsIntegral.: ...
    @staticmethod
    def num$extension($this: int) -> scala.math.Numeric.ShortIsIntegral.: ...
    def ord(self) -> scala.math.Ordering.Short.: ...
    @staticmethod
    def ord$extension($this: int) -> scala.math.Ordering.Short.: ...
    def self(self) -> int: ...
    def shortValue(self) -> int: ...
    @staticmethod
    def shortValue$extension($this: int) -> int: ...
    def signum(self) -> int: ...
    @staticmethod
    def signum$extension($this: int) -> int: ...
    def toByte(self) -> int: ...
    def toChar(self) -> str: ...
    def toDouble(self) -> float: ...
    def toFloat(self) -> float: ...
    def toInt(self) -> int: ...
    def toLong(self) -> int: ...
    def toShort(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    def underlying(self) -> typing.Any: ...
    def unifiedPrimitiveEquals(self, x: typing.Any) -> bool: ...
    def unifiedPrimitiveHashcode(self) -> int: ...

class RichChar(IntegralProxy[typing.Any]):
    def __init__(self, self): ...
    def $greater(self, that: typing.Any) -> bool: ...
    def $greater$eq(self, that: typing.Any) -> bool: ...
    def $less(self, that: typing.Any) -> bool: ...
    def $less$eq(self, that: typing.Any) -> bool: ...
    def abs(self) -> str: ...
    @staticmethod
    def abs$extension($this: str) -> str: ...
    def asDigit(self) -> int: ...
    @staticmethod
    def asDigit$extension($this: str) -> int: ...
    def byteValue(self) -> int: ...
    @staticmethod
    def byteValue$extension($this: str) -> int: ...
    def compare(self, y: typing.Any) -> int: ...
    def compareTo(self, that: typing.Any) -> int: ...
    def doubleValue(self) -> float: ...
    @staticmethod
    def doubleValue$extension($this: str) -> float: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    @staticmethod
    def equals$extension($this: str, x$1: typing.Any) -> bool: ...
    def floatValue(self) -> float: ...
    @staticmethod
    def floatValue$extension($this: str) -> float: ...
    def getDirectionality(self) -> int: ...
    @staticmethod
    def getDirectionality$extension($this: str) -> int: ...
    def getNumericValue(self) -> int: ...
    @staticmethod
    def getNumericValue$extension($this: str) -> int: ...
    def getType(self) -> int: ...
    @staticmethod
    def getType$extension($this: str) -> int: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def hashCode$extension($this: str) -> int: ...
    def intValue(self) -> int: ...
    @staticmethod
    def intValue$extension($this: str) -> int: ...
    def isControl(self) -> bool: ...
    @staticmethod
    def isControl$extension($this: str) -> bool: ...
    def isDigit(self) -> bool: ...
    @staticmethod
    def isDigit$extension($this: str) -> bool: ...
    def isHighSurrogate(self) -> bool: ...
    @staticmethod
    def isHighSurrogate$extension($this: str) -> bool: ...
    def isIdentifierIgnorable(self) -> bool: ...
    @staticmethod
    def isIdentifierIgnorable$extension($this: str) -> bool: ...
    def isLetter(self) -> bool: ...
    @staticmethod
    def isLetter$extension($this: str) -> bool: ...
    def isLetterOrDigit(self) -> bool: ...
    @staticmethod
    def isLetterOrDigit$extension($this: str) -> bool: ...
    def isLowSurrogate(self) -> bool: ...
    @staticmethod
    def isLowSurrogate$extension($this: str) -> bool: ...
    def isLower(self) -> bool: ...
    @staticmethod
    def isLower$extension($this: str) -> bool: ...
    def isMirrored(self) -> bool: ...
    @staticmethod
    def isMirrored$extension($this: str) -> bool: ...
    def isSpaceChar(self) -> bool: ...
    @staticmethod
    def isSpaceChar$extension($this: str) -> bool: ...
    def isSurrogate(self) -> bool: ...
    @staticmethod
    def isSurrogate$extension($this: str) -> bool: ...
    def isTitleCase(self) -> bool: ...
    @staticmethod
    def isTitleCase$extension($this: str) -> bool: ...
    def isUnicodeIdentifierPart(self) -> bool: ...
    @staticmethod
    def isUnicodeIdentifierPart$extension($this: str) -> bool: ...
    def isUnicodeIdentifierStart(self) -> bool: ...
    @staticmethod
    def isUnicodeIdentifierStart$extension($this: str) -> bool: ...
    def isUpper(self) -> bool: ...
    @staticmethod
    def isUpper$extension($this: str) -> bool: ...
    def isValidByte(self) -> bool: ...
    def isValidChar(self) -> bool: ...
    @staticmethod
    def isValidChar$extension($this: str) -> bool: ...
    def isValidInt(self) -> bool: ...
    def isValidShort(self) -> bool: ...
    def isWhitespace(self) -> bool: ...
    @staticmethod
    def isWhitespace$extension($this: str) -> bool: ...
    def isWhole(self) -> bool: ...
    def longValue(self) -> int: ...
    @staticmethod
    def longValue$extension($this: str) -> int: ...
    def max(self, that: str) -> str: ...
    @staticmethod
    def max$extension($this: str, that: str) -> str: ...
    def min(self, that: str) -> str: ...
    @staticmethod
    def min$extension($this: str, that: str) -> str: ...
    def num(self) -> scala.math.Numeric.CharIsIntegral.: ...
    @staticmethod
    def num$extension($this: str) -> scala.math.Numeric.CharIsIntegral.: ...
    def ord(self) -> scala.math.Ordering.Char.: ...
    @staticmethod
    def ord$extension($this: str) -> scala.math.Ordering.Char.: ...
    def reverseBytes(self) -> str: ...
    @staticmethod
    def reverseBytes$extension($this: str) -> str: ...
    def self(self) -> str: ...
    def shortValue(self) -> int: ...
    @staticmethod
    def shortValue$extension($this: str) -> int: ...
    def signum(self) -> int: ...
    @staticmethod
    def signum$extension($this: str) -> int: ...
    @typing.overload
    def to(self, end: typing.Any) -> scala.collection.immutable.NumericRange.Inclusive: ...
    @typing.overload
    def to(self, end: typing.Any, step: typing.Any) -> scala.collection.immutable.NumericRange.Inclusive: ...
    def toByte(self) -> int: ...
    def toChar(self) -> str: ...
    def toDouble(self) -> float: ...
    def toFloat(self) -> float: ...
    def toInt(self) -> int: ...
    def toLong(self) -> int: ...
    def toLower(self) -> str: ...
    @staticmethod
    def toLower$extension($this: str) -> str: ...
    def toShort(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    def toTitleCase(self) -> str: ...
    @staticmethod
    def toTitleCase$extension($this: str) -> str: ...
    def toUpper(self) -> str: ...
    @staticmethod
    def toUpper$extension($this: str) -> str: ...
    def underlying(self) -> typing.Any: ...
    def unifiedPrimitiveEquals(self, x: typing.Any) -> bool: ...
    def unifiedPrimitiveHashcode(self) -> int: ...
    @typing.overload
    def until(self, end: typing.Any) -> scala.collection.immutable.NumericRange.Exclusive: ...
    @typing.overload
    def until(self, end: typing.Any, step: typing.Any) -> scala.collection.immutable.NumericRange.Exclusive: ...

class RichLong(IntegralProxy[typing.Any]):
    def __init__(self, self): ...
    def $greater(self, that: typing.Any) -> bool: ...
    def $greater$eq(self, that: typing.Any) -> bool: ...
    def $less(self, that: typing.Any) -> bool: ...
    def $less$eq(self, that: typing.Any) -> bool: ...
    def abs(self) -> int: ...
    @staticmethod
    def abs$extension($this: int) -> int: ...
    def byteValue(self) -> int: ...
    @staticmethod
    def byteValue$extension($this: int) -> int: ...
    def compare(self, y: typing.Any) -> int: ...
    def compareTo(self, that: typing.Any) -> int: ...
    def doubleValue(self) -> float: ...
    @staticmethod
    def doubleValue$extension($this: int) -> float: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    @staticmethod
    def equals$extension($this: int, x$1: typing.Any) -> bool: ...
    def floatValue(self) -> float: ...
    @staticmethod
    def floatValue$extension($this: int) -> float: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def hashCode$extension($this: int) -> int: ...
    def intValue(self) -> int: ...
    @staticmethod
    def intValue$extension($this: int) -> int: ...
    def isValidByte(self) -> bool: ...
    @staticmethod
    def isValidByte$extension($this: int) -> bool: ...
    def isValidChar(self) -> bool: ...
    @staticmethod
    def isValidChar$extension($this: int) -> bool: ...
    def isValidInt(self) -> bool: ...
    @staticmethod
    def isValidInt$extension($this: int) -> bool: ...
    def isValidLong(self) -> bool: ...
    @staticmethod
    def isValidLong$extension($this: int) -> bool: ...
    def isValidShort(self) -> bool: ...
    @staticmethod
    def isValidShort$extension($this: int) -> bool: ...
    def isWhole(self) -> bool: ...
    def longValue(self) -> int: ...
    @staticmethod
    def longValue$extension($this: int) -> int: ...
    def max(self, that: int) -> int: ...
    @staticmethod
    def max$extension($this: int, that: int) -> int: ...
    def min(self, that: int) -> int: ...
    @staticmethod
    def min$extension($this: int, that: int) -> int: ...
    def num(self) -> scala.math.Numeric.LongIsIntegral.: ...
    @staticmethod
    def num$extension($this: int) -> scala.math.Numeric.LongIsIntegral.: ...
    def ord(self) -> scala.math.Ordering.Long.: ...
    @staticmethod
    def ord$extension($this: int) -> scala.math.Ordering.Long.: ...
    def round(self) -> int: ...
    @staticmethod
    def round$extension($this: int) -> int: ...
    def self(self) -> int: ...
    def shortValue(self) -> int: ...
    @staticmethod
    def shortValue$extension($this: int) -> int: ...
    def signum(self) -> int: ...
    @staticmethod
    def signum$extension($this: int) -> int: ...
    @typing.overload
    def to(self, end: typing.Any) -> scala.collection.immutable.NumericRange.Inclusive: ...
    @typing.overload
    def to(self, end: typing.Any, step: typing.Any) -> scala.collection.immutable.NumericRange.Inclusive: ...
    def toBinaryString(self) -> java.lang.String: ...
    @staticmethod
    def toBinaryString$extension($this: int) -> java.lang.String: ...
    def toByte(self) -> int: ...
    def toChar(self) -> str: ...
    def toDouble(self) -> float: ...
    def toFloat(self) -> float: ...
    def toHexString(self) -> java.lang.String: ...
    @staticmethod
    def toHexString$extension($this: int) -> java.lang.String: ...
    def toInt(self) -> int: ...
    def toLong(self) -> int: ...
    def toOctalString(self) -> java.lang.String: ...
    @staticmethod
    def toOctalString$extension($this: int) -> java.lang.String: ...
    def toShort(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    def underlying(self) -> typing.Any: ...
    def unifiedPrimitiveEquals(self, x: typing.Any) -> bool: ...
    def unifiedPrimitiveHashcode(self) -> int: ...
    @typing.overload
    def until(self, end: typing.Any) -> scala.collection.immutable.NumericRange.Exclusive: ...
    @typing.overload
    def until(self, end: typing.Any, step: typing.Any) -> scala.collection.immutable.NumericRange.Exclusive: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("scala.runtime")``.

    AbstractFunction0: typing.Type[AbstractFunction0]
    AbstractFunction1: typing.Type[AbstractFunction1]
    AbstractFunction10: typing.Type[AbstractFunction10]
    AbstractFunction11: typing.Type[AbstractFunction11]
    AbstractFunction12: typing.Type[AbstractFunction12]
    AbstractFunction13: typing.Type[AbstractFunction13]
    AbstractFunction14: typing.Type[AbstractFunction14]
    AbstractFunction15: typing.Type[AbstractFunction15]
    AbstractFunction16: typing.Type[AbstractFunction16]
    AbstractFunction17: typing.Type[AbstractFunction17]
    AbstractFunction18: typing.Type[AbstractFunction18]
    AbstractFunction19: typing.Type[AbstractFunction19]
    AbstractFunction2: typing.Type[AbstractFunction2]
    AbstractFunction20: typing.Type[AbstractFunction20]
    AbstractFunction21: typing.Type[AbstractFunction21]
    AbstractFunction22: typing.Type[AbstractFunction22]
    AbstractFunction3: typing.Type[AbstractFunction3]
    AbstractFunction4: typing.Type[AbstractFunction4]
    AbstractFunction5: typing.Type[AbstractFunction5]
    AbstractFunction6: typing.Type[AbstractFunction6]
    AbstractFunction7: typing.Type[AbstractFunction7]
    AbstractFunction8: typing.Type[AbstractFunction8]
    AbstractFunction9: typing.Type[AbstractFunction9]
    AbstractPartialFunction: typing.Type[AbstractPartialFunction]
    ArrayCharSequence: typing.Type[ArrayCharSequence]
    BooleanRef: typing.Type[BooleanRef]
    BoxedUnit: typing.Type[BoxedUnit]
    BoxesRunTime: typing.Type[BoxesRunTime]
    ByteRef: typing.Type[ByteRef]
    CharRef: typing.Type[CharRef]
    DoubleRef: typing.Type[DoubleRef]
    EmptyMethodCache: typing.Type[EmptyMethodCache]
    FloatRef: typing.Type[FloatRef]
    FractionalProxy: typing.Type[FractionalProxy]
    IntRef: typing.Type[IntRef]
    IntegralProxy: typing.Type[IntegralProxy]
    LambdaDeserialize: typing.Type[LambdaDeserialize]
    LambdaDeserializer: typing.Type[LambdaDeserializer]
    LazyBoolean: typing.Type[LazyBoolean]
    LazyByte: typing.Type[LazyByte]
    LazyChar: typing.Type[LazyChar]
    LazyDouble: typing.Type[LazyDouble]
    LazyFloat: typing.Type[LazyFloat]
    LazyInt: typing.Type[LazyInt]
    LazyLong: typing.Type[LazyLong]
    LazyRef: typing.Type[LazyRef]
    LazyShort: typing.Type[LazyShort]
    LazyUnit: typing.Type[LazyUnit]
    LongRef: typing.Type[LongRef]
    MegaMethodCache: typing.Type[MegaMethodCache]
    MethodCache: typing.Type[MethodCache]
    NonLocalReturnControl: typing.Type[NonLocalReturnControl]
    ObjectRef: typing.Type[ObjectRef]
    OrderedProxy: typing.Type[OrderedProxy]
    PolyMethodCache: typing.Type[PolyMethodCache]
    RangedProxy: typing.Type[RangedProxy]
    RichBoolean: typing.Type[RichBoolean]
    RichByte: typing.Type[RichByte]
    RichChar: typing.Type[RichChar]
    RichDouble: typing.Type[RichDouble]
    RichException: typing.Type[RichException]
    RichFloat: typing.Type[RichFloat]
    RichInt: typing.Type[RichInt]
    RichLong: typing.Type[RichLong]
    RichShort: typing.Type[RichShort]
    ScalaNumberProxy: typing.Type[ScalaNumberProxy]
    ScalaRunTime: typing.Type[ScalaRunTime]
    ScalaWholeNumberProxy: typing.Type[ScalaWholeNumberProxy]
    SeqCharSequence: typing.Type[SeqCharSequence]
    ShortRef: typing.Type[ShortRef]
    Statics: typing.Type[Statics]
    StringAdd: typing.Type[StringAdd]
    StringFormat: typing.Type[StringFormat]
    StructuralCallSite: typing.Type[StructuralCallSite]
    SymbolLiteral: typing.Type[SymbolLiteral]
    TraitSetter: typing.Type[TraitSetter]
    Tuple2Zipped: typing.Type[Tuple2Zipped]
    Tuple3Zipped: typing.Type[Tuple3Zipped]
    VolatileBooleanRef: typing.Type[VolatileBooleanRef]
    VolatileByteRef: typing.Type[VolatileByteRef]
    VolatileCharRef: typing.Type[VolatileCharRef]
    VolatileDoubleRef: typing.Type[VolatileDoubleRef]
    VolatileFloatRef: typing.Type[VolatileFloatRef]
    VolatileIntRef: typing.Type[VolatileIntRef]
    VolatileLongRef: typing.Type[VolatileLongRef]
    VolatileObjectRef: typing.Type[VolatileObjectRef]
    VolatileShortRef: typing.Type[VolatileShortRef]
    ZippedTraversable2: typing.Type[ZippedTraversable2]
    ZippedTraversable3: typing.Type[ZippedTraversable3]
    package: typing.Type[package]
