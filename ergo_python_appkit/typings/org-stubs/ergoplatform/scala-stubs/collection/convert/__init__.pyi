import java.lang
import java.util
import java.util.concurrent
import java.util.function
import scala
import scala.collection
import scala.collection.concurrent
import scala.collection.generic
import scala.collection.immutable
import scala.collection.mutable
import scala.runtime
import typing



class AsJavaConverters:
    @staticmethod
    def $init$($this: 'AsJavaConverters') -> None: ...
    _asJavaCollection__A = typing.TypeVar('_asJavaCollection__A')  # <A>
    def asJavaCollection(self, i: scala.collection.Iterable[_asJavaCollection__A]) -> java.util.Collection[_asJavaCollection__A]: ...
    _asJavaDictionary__A = typing.TypeVar('_asJavaDictionary__A')  # <A>
    _asJavaDictionary__B = typing.TypeVar('_asJavaDictionary__B')  # <B>
    def asJavaDictionary(self, m: scala.collection.mutable.Map[_asJavaDictionary__A, _asJavaDictionary__B]) -> java.util.Dictionary[_asJavaDictionary__A, _asJavaDictionary__B]: ...
    _asJavaEnumeration__A = typing.TypeVar('_asJavaEnumeration__A')  # <A>
    def asJavaEnumeration(self, i: scala.collection.Iterator[_asJavaEnumeration__A]) -> java.util.Enumeration[_asJavaEnumeration__A]: ...
    _asJavaIterable__A = typing.TypeVar('_asJavaIterable__A')  # <A>
    def asJavaIterable(self, i: scala.collection.Iterable[_asJavaIterable__A]) -> java.lang.Iterable[_asJavaIterable__A]: ...
    _asJavaIterator__A = typing.TypeVar('_asJavaIterator__A')  # <A>
    def asJavaIterator(self, i: scala.collection.Iterator[_asJavaIterator__A]) -> java.util.Iterator[_asJavaIterator__A]: ...
    _bufferAsJavaList__A = typing.TypeVar('_bufferAsJavaList__A')  # <A>
    def bufferAsJavaList(self, b: scala.collection.mutable.Buffer[_bufferAsJavaList__A]) -> java.util.List[_bufferAsJavaList__A]: ...
    _mapAsJavaConcurrentMap__A = typing.TypeVar('_mapAsJavaConcurrentMap__A')  # <A>
    _mapAsJavaConcurrentMap__B = typing.TypeVar('_mapAsJavaConcurrentMap__B')  # <B>
    def mapAsJavaConcurrentMap(self, m: scala.collection.concurrent.Map[_mapAsJavaConcurrentMap__A, _mapAsJavaConcurrentMap__B]) -> java.util.concurrent.ConcurrentMap[_mapAsJavaConcurrentMap__A, _mapAsJavaConcurrentMap__B]: ...
    _mapAsJavaMap__A = typing.TypeVar('_mapAsJavaMap__A')  # <A>
    _mapAsJavaMap__B = typing.TypeVar('_mapAsJavaMap__B')  # <B>
    def mapAsJavaMap(self, m: scala.collection.Map[_mapAsJavaMap__A, _mapAsJavaMap__B]) -> java.util.Map[_mapAsJavaMap__A, _mapAsJavaMap__B]: ...
    _mutableMapAsJavaMap__A = typing.TypeVar('_mutableMapAsJavaMap__A')  # <A>
    _mutableMapAsJavaMap__B = typing.TypeVar('_mutableMapAsJavaMap__B')  # <B>
    def mutableMapAsJavaMap(self, m: scala.collection.mutable.Map[_mutableMapAsJavaMap__A, _mutableMapAsJavaMap__B]) -> java.util.Map[_mutableMapAsJavaMap__A, _mutableMapAsJavaMap__B]: ...
    _mutableSeqAsJavaList__A = typing.TypeVar('_mutableSeqAsJavaList__A')  # <A>
    def mutableSeqAsJavaList(self, s: scala.collection.mutable.Seq[_mutableSeqAsJavaList__A]) -> java.util.List[_mutableSeqAsJavaList__A]: ...
    _mutableSetAsJavaSet__A = typing.TypeVar('_mutableSetAsJavaSet__A')  # <A>
    def mutableSetAsJavaSet(self, s: scala.collection.mutable.Set[_mutableSetAsJavaSet__A]) -> java.util.Set[_mutableSetAsJavaSet__A]: ...
    _seqAsJavaList__A = typing.TypeVar('_seqAsJavaList__A')  # <A>
    def seqAsJavaList(self, s: scala.collection.Seq[_seqAsJavaList__A]) -> java.util.List[_seqAsJavaList__A]: ...
    _setAsJavaSet__A = typing.TypeVar('_setAsJavaSet__A')  # <A>
    def setAsJavaSet(self, s: scala.collection.Set[_setAsJavaSet__A]) -> java.util.Set[_setAsJavaSet__A]: ...

class AsScalaConverters:
    @staticmethod
    def $init$($this: 'AsScalaConverters') -> None: ...
    _asScalaBuffer__A = typing.TypeVar('_asScalaBuffer__A')  # <A>
    def asScalaBuffer(self, l: java.util.List[_asScalaBuffer__A]) -> scala.collection.mutable.Buffer[_asScalaBuffer__A]: ...
    _asScalaIterator__A = typing.TypeVar('_asScalaIterator__A')  # <A>
    def asScalaIterator(self, i: java.util.Iterator[_asScalaIterator__A]) -> scala.collection.Iterator[_asScalaIterator__A]: ...
    _asScalaSet__A = typing.TypeVar('_asScalaSet__A')  # <A>
    def asScalaSet(self, s: java.util.Set[_asScalaSet__A]) -> scala.collection.mutable.Set[_asScalaSet__A]: ...
    _collectionAsScalaIterable__A = typing.TypeVar('_collectionAsScalaIterable__A')  # <A>
    def collectionAsScalaIterable(self, i: typing.Union[java.util.Collection[_collectionAsScalaIterable__A], typing.Sequence[_collectionAsScalaIterable__A], typing.Set[_collectionAsScalaIterable__A]]) -> scala.collection.Iterable[_collectionAsScalaIterable__A]: ...
    _dictionaryAsScalaMap__A = typing.TypeVar('_dictionaryAsScalaMap__A')  # <A>
    _dictionaryAsScalaMap__B = typing.TypeVar('_dictionaryAsScalaMap__B')  # <B>
    def dictionaryAsScalaMap(self, p: java.util.Dictionary[_dictionaryAsScalaMap__A, _dictionaryAsScalaMap__B]) -> scala.collection.mutable.Map[_dictionaryAsScalaMap__A, _dictionaryAsScalaMap__B]: ...
    _enumerationAsScalaIterator__A = typing.TypeVar('_enumerationAsScalaIterator__A')  # <A>
    def enumerationAsScalaIterator(self, i: java.util.Enumeration[_enumerationAsScalaIterator__A]) -> scala.collection.Iterator[_enumerationAsScalaIterator__A]: ...
    _iterableAsScalaIterable__A = typing.TypeVar('_iterableAsScalaIterable__A')  # <A>
    def iterableAsScalaIterable(self, i: typing.Union[java.lang.Iterable[_iterableAsScalaIterable__A], typing.Sequence[_iterableAsScalaIterable__A], typing.Set[_iterableAsScalaIterable__A]]) -> scala.collection.Iterable[_iterableAsScalaIterable__A]: ...
    _mapAsScalaConcurrentMap__A = typing.TypeVar('_mapAsScalaConcurrentMap__A')  # <A>
    _mapAsScalaConcurrentMap__B = typing.TypeVar('_mapAsScalaConcurrentMap__B')  # <B>
    def mapAsScalaConcurrentMap(self, m: java.util.concurrent.ConcurrentMap[_mapAsScalaConcurrentMap__A, _mapAsScalaConcurrentMap__B]) -> scala.collection.concurrent.Map[_mapAsScalaConcurrentMap__A, _mapAsScalaConcurrentMap__B]: ...
    _mapAsScalaMap__A = typing.TypeVar('_mapAsScalaMap__A')  # <A>
    _mapAsScalaMap__B = typing.TypeVar('_mapAsScalaMap__B')  # <B>
    def mapAsScalaMap(self, m: typing.Union[java.util.Map[_mapAsScalaMap__A, _mapAsScalaMap__B], typing.Mapping[_mapAsScalaMap__A, _mapAsScalaMap__B]]) -> scala.collection.mutable.Map[_mapAsScalaMap__A, _mapAsScalaMap__B]: ...
    def propertiesAsScalaMap(self, p: java.util.Properties) -> scala.collection.mutable.Map[java.lang.String, java.lang.String]: ...

_Decorators__AsJava__A = typing.TypeVar('_Decorators__AsJava__A')  # <A>
_Decorators__AsJavaCollection__A = typing.TypeVar('_Decorators__AsJavaCollection__A')  # <A>
_Decorators__AsJavaDictionary__A = typing.TypeVar('_Decorators__AsJavaDictionary__A')  # <A>
_Decorators__AsJavaDictionary__B = typing.TypeVar('_Decorators__AsJavaDictionary__B')  # <B>
_Decorators__AsJavaEnumeration__A = typing.TypeVar('_Decorators__AsJavaEnumeration__A')  # <A>
_Decorators__AsScala__A = typing.TypeVar('_Decorators__AsScala__A')  # <A>
class Decorators:
    class AsJava(typing.Generic[_Decorators__AsJava__A]):
        def __init__(self, op: scala.Function0[_Decorators__AsJava__A]): ...
        def asJava(self) -> _Decorators__AsJava__A: ...
    class AsJavaCollection(typing.Generic[_Decorators__AsJavaCollection__A]):
        def __init__(self, i: scala.collection.Iterable[_Decorators__AsJavaCollection__A]): ...
        def asJavaCollection(self) -> java.util.Collection[_Decorators__AsJavaCollection__A]: ...
    class AsJavaDictionary(typing.Generic[_Decorators__AsJavaDictionary__A, _Decorators__AsJavaDictionary__B]):
        def __init__(self, m: scala.collection.mutable.Map[_Decorators__AsJavaDictionary__A, _Decorators__AsJavaDictionary__B]): ...
        def asJavaDictionary(self) -> java.util.Dictionary[_Decorators__AsJavaDictionary__A, _Decorators__AsJavaDictionary__B]: ...
    class AsJavaEnumeration(typing.Generic[_Decorators__AsJavaEnumeration__A]):
        def __init__(self, i: scala.collection.Iterator[_Decorators__AsJavaEnumeration__A]): ...
        def asJavaEnumeration(self) -> java.util.Enumeration[_Decorators__AsJavaEnumeration__A]: ...
    class AsScala(typing.Generic[_Decorators__AsScala__A]):
        def __init__(self, op: scala.Function0[_Decorators__AsScala__A]): ...
        def asScala(self) -> _Decorators__AsScala__A: ...

class ImplicitConversions:
    _buffer$u0020AsJavaList__A = typing.TypeVar('_buffer$u0020AsJavaList__A')  # <A>
    @staticmethod
    def buffer$u0020AsJavaList(b: scala.collection.mutable.Buffer[_buffer.u0020AsJavaList__A]) -> java.util.List[_buffer.u0020AsJavaList__A]: ...
    _collection$u0020AsScalaIterable__A = typing.TypeVar('_collection$u0020AsScalaIterable__A')  # <A>
    @staticmethod
    def collection$u0020AsScalaIterable(i: typing.Union[java.util.Collection[_collection.u0020AsScalaIterable__A], typing.Sequence[_collection.u0020AsScalaIterable__A], typing.Set[_collection.u0020AsScalaIterable__A]]) -> scala.collection.Iterable[_collection.u0020AsScalaIterable__A]: ...
    _collection$u0020asJava__A = typing.TypeVar('_collection$u0020asJava__A')  # <A>
    @staticmethod
    def collection$u0020asJava(it: scala.collection.Iterable[_collection.u0020asJava__A]) -> java.util.Collection[_collection.u0020asJava__A]: ...
    _dictionary$u0020AsScalaMap__A = typing.TypeVar('_dictionary$u0020AsScalaMap__A')  # <A>
    _dictionary$u0020AsScalaMap__B = typing.TypeVar('_dictionary$u0020AsScalaMap__B')  # <B>
    @staticmethod
    def dictionary$u0020AsScalaMap(p: java.util.Dictionary[_dictionary.u0020AsScalaMap__A, _dictionary.u0020AsScalaMap__B]) -> scala.collection.mutable.Map[_dictionary.u0020AsScalaMap__A, _dictionary.u0020AsScalaMap__B]: ...
    _dictionary$u0020asJava__A = typing.TypeVar('_dictionary$u0020asJava__A')  # <A>
    _dictionary$u0020asJava__B = typing.TypeVar('_dictionary$u0020asJava__B')  # <B>
    @staticmethod
    def dictionary$u0020asJava(m: scala.collection.mutable.Map[_dictionary.u0020asJava__A, _dictionary.u0020asJava__B]) -> java.util.Dictionary[_dictionary.u0020asJava__A, _dictionary.u0020asJava__B]: ...
    _enumeration$u0020AsScalaIterator__A = typing.TypeVar('_enumeration$u0020AsScalaIterator__A')  # <A>
    @staticmethod
    def enumeration$u0020AsScalaIterator(i: java.util.Enumeration[_enumeration.u0020AsScalaIterator__A]) -> scala.collection.Iterator[_enumeration.u0020AsScalaIterator__A]: ...
    _enumeration$u0020asJava__A = typing.TypeVar('_enumeration$u0020asJava__A')  # <A>
    @staticmethod
    def enumeration$u0020asJava(it: scala.collection.Iterator[_enumeration.u0020asJava__A]) -> java.util.Enumeration[_enumeration.u0020asJava__A]: ...
    _iterable$u0020AsScalaIterable__A = typing.TypeVar('_iterable$u0020AsScalaIterable__A')  # <A>
    @staticmethod
    def iterable$u0020AsScalaIterable(i: typing.Union[java.lang.Iterable[_iterable.u0020AsScalaIterable__A], typing.Sequence[_iterable.u0020AsScalaIterable__A], typing.Set[_iterable.u0020AsScalaIterable__A]]) -> scala.collection.Iterable[_iterable.u0020AsScalaIterable__A]: ...
    _iterable$u0020asJava__A = typing.TypeVar('_iterable$u0020asJava__A')  # <A>
    @staticmethod
    def iterable$u0020asJava(i: scala.collection.Iterable[_iterable.u0020asJava__A]) -> java.lang.Iterable[_iterable.u0020asJava__A]: ...
    _iterator$u0020asJava__A = typing.TypeVar('_iterator$u0020asJava__A')  # <A>
    @staticmethod
    def iterator$u0020asJava(it: scala.collection.Iterator[_iterator.u0020asJava__A]) -> java.util.Iterator[_iterator.u0020asJava__A]: ...
    _iterator$u0020asScala__A = typing.TypeVar('_iterator$u0020asScala__A')  # <A>
    @staticmethod
    def iterator$u0020asScala(it: java.util.Iterator[_iterator.u0020asScala__A]) -> scala.collection.Iterator[_iterator.u0020asScala__A]: ...
    _list$u0020asScalaBuffer__A = typing.TypeVar('_list$u0020asScalaBuffer__A')  # <A>
    @staticmethod
    def list$u0020asScalaBuffer(l: java.util.List[_list.u0020asScalaBuffer__A]) -> scala.collection.mutable.Buffer[_list.u0020asScalaBuffer__A]: ...
    _map$u0020AsJavaConcurrentMap__A = typing.TypeVar('_map$u0020AsJavaConcurrentMap__A')  # <A>
    _map$u0020AsJavaConcurrentMap__B = typing.TypeVar('_map$u0020AsJavaConcurrentMap__B')  # <B>
    @staticmethod
    def map$u0020AsJavaConcurrentMap(m: scala.collection.concurrent.Map[_map.u0020AsJavaConcurrentMap__A, _map.u0020AsJavaConcurrentMap__B]) -> java.util.concurrent.ConcurrentMap[_map.u0020AsJavaConcurrentMap__A, _map.u0020AsJavaConcurrentMap__B]: ...
    _map$u0020AsJavaMap__A = typing.TypeVar('_map$u0020AsJavaMap__A')  # <A>
    _map$u0020AsJavaMap__B = typing.TypeVar('_map$u0020AsJavaMap__B')  # <B>
    @staticmethod
    def map$u0020AsJavaMap(m: scala.collection.Map[_map.u0020AsJavaMap__A, _map.u0020AsJavaMap__B]) -> java.util.Map[_map.u0020AsJavaMap__A, _map.u0020AsJavaMap__B]: ...
    _map$u0020AsScala__A = typing.TypeVar('_map$u0020AsScala__A')  # <A>
    _map$u0020AsScala__B = typing.TypeVar('_map$u0020AsScala__B')  # <B>
    @staticmethod
    def map$u0020AsScala(m: typing.Union[java.util.Map[_map.u0020AsScala__A, _map.u0020AsScala__B], typing.Mapping[_map.u0020AsScala__A, _map.u0020AsScala__B]]) -> scala.collection.mutable.Map[_map.u0020AsScala__A, _map.u0020AsScala__B]: ...
    _map$u0020AsScalaConcurrentMap__A = typing.TypeVar('_map$u0020AsScalaConcurrentMap__A')  # <A>
    _map$u0020AsScalaConcurrentMap__B = typing.TypeVar('_map$u0020AsScalaConcurrentMap__B')  # <B>
    @staticmethod
    def map$u0020AsScalaConcurrentMap(m: java.util.concurrent.ConcurrentMap[_map.u0020AsScalaConcurrentMap__A, _map.u0020AsScalaConcurrentMap__B]) -> scala.collection.concurrent.Map[_map.u0020AsScalaConcurrentMap__A, _map.u0020AsScalaConcurrentMap__B]: ...
    _mutableMap$u0020AsJavaMap__A = typing.TypeVar('_mutableMap$u0020AsJavaMap__A')  # <A>
    _mutableMap$u0020AsJavaMap__B = typing.TypeVar('_mutableMap$u0020AsJavaMap__B')  # <B>
    @staticmethod
    def mutableMap$u0020AsJavaMap(m: scala.collection.mutable.Map[_mutableMap.u0020AsJavaMap__A, _mutableMap.u0020AsJavaMap__B]) -> java.util.Map[_mutableMap.u0020AsJavaMap__A, _mutableMap.u0020AsJavaMap__B]: ...
    _mutableSeq$u0020AsJavaList__A = typing.TypeVar('_mutableSeq$u0020AsJavaList__A')  # <A>
    @staticmethod
    def mutableSeq$u0020AsJavaList(seq: scala.collection.mutable.Seq[_mutableSeq.u0020AsJavaList__A]) -> java.util.List[_mutableSeq.u0020AsJavaList__A]: ...
    _mutableSet$u0020AsJavaSet__A = typing.TypeVar('_mutableSet$u0020AsJavaSet__A')  # <A>
    @staticmethod
    def mutableSet$u0020AsJavaSet(s: scala.collection.mutable.Set[_mutableSet.u0020AsJavaSet__A]) -> java.util.Set[_mutableSet.u0020AsJavaSet__A]: ...
    @staticmethod
    def properties$u0020AsScalaMap(p: java.util.Properties) -> scala.collection.mutable.Map[java.lang.String, java.lang.String]: ...
    _seq$u0020AsJavaList__A = typing.TypeVar('_seq$u0020AsJavaList__A')  # <A>
    @staticmethod
    def seq$u0020AsJavaList(seq: scala.collection.Seq[_seq.u0020AsJavaList__A]) -> java.util.List[_seq.u0020AsJavaList__A]: ...
    _set$u0020AsJavaSet__A = typing.TypeVar('_set$u0020AsJavaSet__A')  # <A>
    @staticmethod
    def set$u0020AsJavaSet(s: scala.collection.Set[_set.u0020AsJavaSet__A]) -> java.util.Set[_set.u0020AsJavaSet__A]: ...
    _set$u0020asScala__A = typing.TypeVar('_set$u0020asScala__A')  # <A>
    @staticmethod
    def set$u0020asScala(s: java.util.Set[_set.u0020asScala__A]) -> scala.collection.mutable.Set[_set.u0020asScala__A]: ...

class ImplicitConversionsToJava:
    _buffer$u0020AsJavaList__A = typing.TypeVar('_buffer$u0020AsJavaList__A')  # <A>
    @staticmethod
    def buffer$u0020AsJavaList(b: scala.collection.mutable.Buffer[_buffer.u0020AsJavaList__A]) -> java.util.List[_buffer.u0020AsJavaList__A]: ...
    _collection$u0020asJava__A = typing.TypeVar('_collection$u0020asJava__A')  # <A>
    @staticmethod
    def collection$u0020asJava(it: scala.collection.Iterable[_collection.u0020asJava__A]) -> java.util.Collection[_collection.u0020asJava__A]: ...
    _dictionary$u0020asJava__A = typing.TypeVar('_dictionary$u0020asJava__A')  # <A>
    _dictionary$u0020asJava__B = typing.TypeVar('_dictionary$u0020asJava__B')  # <B>
    @staticmethod
    def dictionary$u0020asJava(m: scala.collection.mutable.Map[_dictionary.u0020asJava__A, _dictionary.u0020asJava__B]) -> java.util.Dictionary[_dictionary.u0020asJava__A, _dictionary.u0020asJava__B]: ...
    _enumeration$u0020asJava__A = typing.TypeVar('_enumeration$u0020asJava__A')  # <A>
    @staticmethod
    def enumeration$u0020asJava(it: scala.collection.Iterator[_enumeration.u0020asJava__A]) -> java.util.Enumeration[_enumeration.u0020asJava__A]: ...
    _iterable$u0020asJava__A = typing.TypeVar('_iterable$u0020asJava__A')  # <A>
    @staticmethod
    def iterable$u0020asJava(i: scala.collection.Iterable[_iterable.u0020asJava__A]) -> java.lang.Iterable[_iterable.u0020asJava__A]: ...
    _iterator$u0020asJava__A = typing.TypeVar('_iterator$u0020asJava__A')  # <A>
    @staticmethod
    def iterator$u0020asJava(it: scala.collection.Iterator[_iterator.u0020asJava__A]) -> java.util.Iterator[_iterator.u0020asJava__A]: ...
    _map$u0020AsJavaConcurrentMap__A = typing.TypeVar('_map$u0020AsJavaConcurrentMap__A')  # <A>
    _map$u0020AsJavaConcurrentMap__B = typing.TypeVar('_map$u0020AsJavaConcurrentMap__B')  # <B>
    @staticmethod
    def map$u0020AsJavaConcurrentMap(m: scala.collection.concurrent.Map[_map.u0020AsJavaConcurrentMap__A, _map.u0020AsJavaConcurrentMap__B]) -> java.util.concurrent.ConcurrentMap[_map.u0020AsJavaConcurrentMap__A, _map.u0020AsJavaConcurrentMap__B]: ...
    _map$u0020AsJavaMap__A = typing.TypeVar('_map$u0020AsJavaMap__A')  # <A>
    _map$u0020AsJavaMap__B = typing.TypeVar('_map$u0020AsJavaMap__B')  # <B>
    @staticmethod
    def map$u0020AsJavaMap(m: scala.collection.Map[_map.u0020AsJavaMap__A, _map.u0020AsJavaMap__B]) -> java.util.Map[_map.u0020AsJavaMap__A, _map.u0020AsJavaMap__B]: ...
    _mutableMap$u0020AsJavaMap__A = typing.TypeVar('_mutableMap$u0020AsJavaMap__A')  # <A>
    _mutableMap$u0020AsJavaMap__B = typing.TypeVar('_mutableMap$u0020AsJavaMap__B')  # <B>
    @staticmethod
    def mutableMap$u0020AsJavaMap(m: scala.collection.mutable.Map[_mutableMap.u0020AsJavaMap__A, _mutableMap.u0020AsJavaMap__B]) -> java.util.Map[_mutableMap.u0020AsJavaMap__A, _mutableMap.u0020AsJavaMap__B]: ...
    _mutableSeq$u0020AsJavaList__A = typing.TypeVar('_mutableSeq$u0020AsJavaList__A')  # <A>
    @staticmethod
    def mutableSeq$u0020AsJavaList(seq: scala.collection.mutable.Seq[_mutableSeq.u0020AsJavaList__A]) -> java.util.List[_mutableSeq.u0020AsJavaList__A]: ...
    _mutableSet$u0020AsJavaSet__A = typing.TypeVar('_mutableSet$u0020AsJavaSet__A')  # <A>
    @staticmethod
    def mutableSet$u0020AsJavaSet(s: scala.collection.mutable.Set[_mutableSet.u0020AsJavaSet__A]) -> java.util.Set[_mutableSet.u0020AsJavaSet__A]: ...
    _seq$u0020AsJavaList__A = typing.TypeVar('_seq$u0020AsJavaList__A')  # <A>
    @staticmethod
    def seq$u0020AsJavaList(seq: scala.collection.Seq[_seq.u0020AsJavaList__A]) -> java.util.List[_seq.u0020AsJavaList__A]: ...
    _set$u0020AsJavaSet__A = typing.TypeVar('_set$u0020AsJavaSet__A')  # <A>
    @staticmethod
    def set$u0020AsJavaSet(s: scala.collection.Set[_set.u0020AsJavaSet__A]) -> java.util.Set[_set.u0020AsJavaSet__A]: ...

class ImplicitConversionsToScala:
    _collection$u0020AsScalaIterable__A = typing.TypeVar('_collection$u0020AsScalaIterable__A')  # <A>
    @staticmethod
    def collection$u0020AsScalaIterable(i: typing.Union[java.util.Collection[_collection.u0020AsScalaIterable__A], typing.Sequence[_collection.u0020AsScalaIterable__A], typing.Set[_collection.u0020AsScalaIterable__A]]) -> scala.collection.Iterable[_collection.u0020AsScalaIterable__A]: ...
    _dictionary$u0020AsScalaMap__A = typing.TypeVar('_dictionary$u0020AsScalaMap__A')  # <A>
    _dictionary$u0020AsScalaMap__B = typing.TypeVar('_dictionary$u0020AsScalaMap__B')  # <B>
    @staticmethod
    def dictionary$u0020AsScalaMap(p: java.util.Dictionary[_dictionary.u0020AsScalaMap__A, _dictionary.u0020AsScalaMap__B]) -> scala.collection.mutable.Map[_dictionary.u0020AsScalaMap__A, _dictionary.u0020AsScalaMap__B]: ...
    _enumeration$u0020AsScalaIterator__A = typing.TypeVar('_enumeration$u0020AsScalaIterator__A')  # <A>
    @staticmethod
    def enumeration$u0020AsScalaIterator(i: java.util.Enumeration[_enumeration.u0020AsScalaIterator__A]) -> scala.collection.Iterator[_enumeration.u0020AsScalaIterator__A]: ...
    _iterable$u0020AsScalaIterable__A = typing.TypeVar('_iterable$u0020AsScalaIterable__A')  # <A>
    @staticmethod
    def iterable$u0020AsScalaIterable(i: typing.Union[java.lang.Iterable[_iterable.u0020AsScalaIterable__A], typing.Sequence[_iterable.u0020AsScalaIterable__A], typing.Set[_iterable.u0020AsScalaIterable__A]]) -> scala.collection.Iterable[_iterable.u0020AsScalaIterable__A]: ...
    _iterator$u0020asScala__A = typing.TypeVar('_iterator$u0020asScala__A')  # <A>
    @staticmethod
    def iterator$u0020asScala(it: java.util.Iterator[_iterator.u0020asScala__A]) -> scala.collection.Iterator[_iterator.u0020asScala__A]: ...
    _list$u0020asScalaBuffer__A = typing.TypeVar('_list$u0020asScalaBuffer__A')  # <A>
    @staticmethod
    def list$u0020asScalaBuffer(l: java.util.List[_list.u0020asScalaBuffer__A]) -> scala.collection.mutable.Buffer[_list.u0020asScalaBuffer__A]: ...
    _map$u0020AsScala__A = typing.TypeVar('_map$u0020AsScala__A')  # <A>
    _map$u0020AsScala__B = typing.TypeVar('_map$u0020AsScala__B')  # <B>
    @staticmethod
    def map$u0020AsScala(m: typing.Union[java.util.Map[_map.u0020AsScala__A, _map.u0020AsScala__B], typing.Mapping[_map.u0020AsScala__A, _map.u0020AsScala__B]]) -> scala.collection.mutable.Map[_map.u0020AsScala__A, _map.u0020AsScala__B]: ...
    _map$u0020AsScalaConcurrentMap__A = typing.TypeVar('_map$u0020AsScalaConcurrentMap__A')  # <A>
    _map$u0020AsScalaConcurrentMap__B = typing.TypeVar('_map$u0020AsScalaConcurrentMap__B')  # <B>
    @staticmethod
    def map$u0020AsScalaConcurrentMap(m: java.util.concurrent.ConcurrentMap[_map.u0020AsScalaConcurrentMap__A, _map.u0020AsScalaConcurrentMap__B]) -> scala.collection.concurrent.Map[_map.u0020AsScalaConcurrentMap__A, _map.u0020AsScalaConcurrentMap__B]: ...
    @staticmethod
    def properties$u0020AsScalaMap(p: java.util.Properties) -> scala.collection.mutable.Map[java.lang.String, java.lang.String]: ...
    _set$u0020asScala__A = typing.TypeVar('_set$u0020asScala__A')  # <A>
    @staticmethod
    def set$u0020asScala(s: java.util.Set[_set.u0020asScala__A]) -> scala.collection.mutable.Set[_set.u0020asScala__A]: ...

class LowPriorityWrapAsJava:
    @staticmethod
    def $init$($this: 'LowPriorityWrapAsJava') -> None: ...
    _asJavaCollection__A = typing.TypeVar('_asJavaCollection__A')  # <A>
    def asJavaCollection(self, it: scala.collection.Iterable[_asJavaCollection__A]) -> java.util.Collection[_asJavaCollection__A]: ...
    _asJavaDictionary__A = typing.TypeVar('_asJavaDictionary__A')  # <A>
    _asJavaDictionary__B = typing.TypeVar('_asJavaDictionary__B')  # <B>
    def asJavaDictionary(self, m: scala.collection.mutable.Map[_asJavaDictionary__A, _asJavaDictionary__B]) -> java.util.Dictionary[_asJavaDictionary__A, _asJavaDictionary__B]: ...
    _asJavaEnumeration__A = typing.TypeVar('_asJavaEnumeration__A')  # <A>
    def asJavaEnumeration(self, it: scala.collection.Iterator[_asJavaEnumeration__A]) -> java.util.Enumeration[_asJavaEnumeration__A]: ...
    _asJavaIterable__A = typing.TypeVar('_asJavaIterable__A')  # <A>
    def asJavaIterable(self, i: scala.collection.Iterable[_asJavaIterable__A]) -> java.lang.Iterable[_asJavaIterable__A]: ...
    _asJavaIterator__A = typing.TypeVar('_asJavaIterator__A')  # <A>
    def asJavaIterator(self, it: scala.collection.Iterator[_asJavaIterator__A]) -> java.util.Iterator[_asJavaIterator__A]: ...
    _bufferAsJavaList__A = typing.TypeVar('_bufferAsJavaList__A')  # <A>
    def bufferAsJavaList(self, b: scala.collection.mutable.Buffer[_bufferAsJavaList__A]) -> java.util.List[_bufferAsJavaList__A]: ...
    _mapAsJavaConcurrentMap__A = typing.TypeVar('_mapAsJavaConcurrentMap__A')  # <A>
    _mapAsJavaConcurrentMap__B = typing.TypeVar('_mapAsJavaConcurrentMap__B')  # <B>
    def mapAsJavaConcurrentMap(self, m: scala.collection.concurrent.Map[_mapAsJavaConcurrentMap__A, _mapAsJavaConcurrentMap__B]) -> java.util.concurrent.ConcurrentMap[_mapAsJavaConcurrentMap__A, _mapAsJavaConcurrentMap__B]: ...
    _mapAsJavaMap__A = typing.TypeVar('_mapAsJavaMap__A')  # <A>
    _mapAsJavaMap__B = typing.TypeVar('_mapAsJavaMap__B')  # <B>
    def mapAsJavaMap(self, m: scala.collection.Map[_mapAsJavaMap__A, _mapAsJavaMap__B]) -> java.util.Map[_mapAsJavaMap__A, _mapAsJavaMap__B]: ...
    _mutableMapAsJavaMap__A = typing.TypeVar('_mutableMapAsJavaMap__A')  # <A>
    _mutableMapAsJavaMap__B = typing.TypeVar('_mutableMapAsJavaMap__B')  # <B>
    def mutableMapAsJavaMap(self, m: scala.collection.mutable.Map[_mutableMapAsJavaMap__A, _mutableMapAsJavaMap__B]) -> java.util.Map[_mutableMapAsJavaMap__A, _mutableMapAsJavaMap__B]: ...
    _mutableSeqAsJavaList__A = typing.TypeVar('_mutableSeqAsJavaList__A')  # <A>
    def mutableSeqAsJavaList(self, seq: scala.collection.mutable.Seq[_mutableSeqAsJavaList__A]) -> java.util.List[_mutableSeqAsJavaList__A]: ...
    _mutableSetAsJavaSet__A = typing.TypeVar('_mutableSetAsJavaSet__A')  # <A>
    def mutableSetAsJavaSet(self, s: scala.collection.mutable.Set[_mutableSetAsJavaSet__A]) -> java.util.Set[_mutableSetAsJavaSet__A]: ...
    _seqAsJavaList__A = typing.TypeVar('_seqAsJavaList__A')  # <A>
    def seqAsJavaList(self, seq: scala.collection.Seq[_seqAsJavaList__A]) -> java.util.List[_seqAsJavaList__A]: ...
    _setAsJavaSet__A = typing.TypeVar('_setAsJavaSet__A')  # <A>
    def setAsJavaSet(self, s: scala.collection.Set[_setAsJavaSet__A]) -> java.util.Set[_setAsJavaSet__A]: ...

class LowPriorityWrapAsScala:
    @staticmethod
    def $init$($this: 'LowPriorityWrapAsScala') -> None: ...
    _asScalaBuffer__A = typing.TypeVar('_asScalaBuffer__A')  # <A>
    def asScalaBuffer(self, l: java.util.List[_asScalaBuffer__A]) -> scala.collection.mutable.Buffer[_asScalaBuffer__A]: ...
    _asScalaIterator__A = typing.TypeVar('_asScalaIterator__A')  # <A>
    def asScalaIterator(self, it: java.util.Iterator[_asScalaIterator__A]) -> scala.collection.Iterator[_asScalaIterator__A]: ...
    _asScalaSet__A = typing.TypeVar('_asScalaSet__A')  # <A>
    def asScalaSet(self, s: java.util.Set[_asScalaSet__A]) -> scala.collection.mutable.Set[_asScalaSet__A]: ...
    _collectionAsScalaIterable__A = typing.TypeVar('_collectionAsScalaIterable__A')  # <A>
    def collectionAsScalaIterable(self, i: typing.Union[java.util.Collection[_collectionAsScalaIterable__A], typing.Sequence[_collectionAsScalaIterable__A], typing.Set[_collectionAsScalaIterable__A]]) -> scala.collection.Iterable[_collectionAsScalaIterable__A]: ...
    _dictionaryAsScalaMap__A = typing.TypeVar('_dictionaryAsScalaMap__A')  # <A>
    _dictionaryAsScalaMap__B = typing.TypeVar('_dictionaryAsScalaMap__B')  # <B>
    def dictionaryAsScalaMap(self, p: java.util.Dictionary[_dictionaryAsScalaMap__A, _dictionaryAsScalaMap__B]) -> scala.collection.mutable.Map[_dictionaryAsScalaMap__A, _dictionaryAsScalaMap__B]: ...
    _enumerationAsScalaIterator__A = typing.TypeVar('_enumerationAsScalaIterator__A')  # <A>
    def enumerationAsScalaIterator(self, i: java.util.Enumeration[_enumerationAsScalaIterator__A]) -> scala.collection.Iterator[_enumerationAsScalaIterator__A]: ...
    _iterableAsScalaIterable__A = typing.TypeVar('_iterableAsScalaIterable__A')  # <A>
    def iterableAsScalaIterable(self, i: typing.Union[java.lang.Iterable[_iterableAsScalaIterable__A], typing.Sequence[_iterableAsScalaIterable__A], typing.Set[_iterableAsScalaIterable__A]]) -> scala.collection.Iterable[_iterableAsScalaIterable__A]: ...
    _mapAsScalaConcurrentMap__A = typing.TypeVar('_mapAsScalaConcurrentMap__A')  # <A>
    _mapAsScalaConcurrentMap__B = typing.TypeVar('_mapAsScalaConcurrentMap__B')  # <B>
    def mapAsScalaConcurrentMap(self, m: java.util.concurrent.ConcurrentMap[_mapAsScalaConcurrentMap__A, _mapAsScalaConcurrentMap__B]) -> scala.collection.concurrent.Map[_mapAsScalaConcurrentMap__A, _mapAsScalaConcurrentMap__B]: ...
    _mapAsScalaMap__A = typing.TypeVar('_mapAsScalaMap__A')  # <A>
    _mapAsScalaMap__B = typing.TypeVar('_mapAsScalaMap__B')  # <B>
    def mapAsScalaMap(self, m: typing.Union[java.util.Map[_mapAsScalaMap__A, _mapAsScalaMap__B], typing.Mapping[_mapAsScalaMap__A, _mapAsScalaMap__B]]) -> scala.collection.mutable.Map[_mapAsScalaMap__A, _mapAsScalaMap__B]: ...
    def propertiesAsScalaMap(self, p: java.util.Properties) -> scala.collection.mutable.Map[java.lang.String, java.lang.String]: ...

class ToJavaImplicits:
    @staticmethod
    def $init$($this: 'ToJavaImplicits') -> None: ...
    _buffer$u0020AsJavaList__A = typing.TypeVar('_buffer$u0020AsJavaList__A')  # <A>
    def buffer$u0020AsJavaList(self, b: scala.collection.mutable.Buffer[_buffer.u0020AsJavaList__A]) -> java.util.List[_buffer.u0020AsJavaList__A]: ...
    _collection$u0020asJava__A = typing.TypeVar('_collection$u0020asJava__A')  # <A>
    def collection$u0020asJava(self, it: scala.collection.Iterable[_collection.u0020asJava__A]) -> java.util.Collection[_collection.u0020asJava__A]: ...
    _dictionary$u0020asJava__A = typing.TypeVar('_dictionary$u0020asJava__A')  # <A>
    _dictionary$u0020asJava__B = typing.TypeVar('_dictionary$u0020asJava__B')  # <B>
    def dictionary$u0020asJava(self, m: scala.collection.mutable.Map[_dictionary.u0020asJava__A, _dictionary.u0020asJava__B]) -> java.util.Dictionary[_dictionary.u0020asJava__A, _dictionary.u0020asJava__B]: ...
    _enumeration$u0020asJava__A = typing.TypeVar('_enumeration$u0020asJava__A')  # <A>
    def enumeration$u0020asJava(self, it: scala.collection.Iterator[_enumeration.u0020asJava__A]) -> java.util.Enumeration[_enumeration.u0020asJava__A]: ...
    _iterable$u0020asJava__A = typing.TypeVar('_iterable$u0020asJava__A')  # <A>
    def iterable$u0020asJava(self, i: scala.collection.Iterable[_iterable.u0020asJava__A]) -> java.lang.Iterable[_iterable.u0020asJava__A]: ...
    _iterator$u0020asJava__A = typing.TypeVar('_iterator$u0020asJava__A')  # <A>
    def iterator$u0020asJava(self, it: scala.collection.Iterator[_iterator.u0020asJava__A]) -> java.util.Iterator[_iterator.u0020asJava__A]: ...
    _map$u0020AsJavaConcurrentMap__A = typing.TypeVar('_map$u0020AsJavaConcurrentMap__A')  # <A>
    _map$u0020AsJavaConcurrentMap__B = typing.TypeVar('_map$u0020AsJavaConcurrentMap__B')  # <B>
    def map$u0020AsJavaConcurrentMap(self, m: scala.collection.concurrent.Map[_map.u0020AsJavaConcurrentMap__A, _map.u0020AsJavaConcurrentMap__B]) -> java.util.concurrent.ConcurrentMap[_map.u0020AsJavaConcurrentMap__A, _map.u0020AsJavaConcurrentMap__B]: ...
    _map$u0020AsJavaMap__A = typing.TypeVar('_map$u0020AsJavaMap__A')  # <A>
    _map$u0020AsJavaMap__B = typing.TypeVar('_map$u0020AsJavaMap__B')  # <B>
    def map$u0020AsJavaMap(self, m: scala.collection.Map[_map.u0020AsJavaMap__A, _map.u0020AsJavaMap__B]) -> java.util.Map[_map.u0020AsJavaMap__A, _map.u0020AsJavaMap__B]: ...
    _mutableMap$u0020AsJavaMap__A = typing.TypeVar('_mutableMap$u0020AsJavaMap__A')  # <A>
    _mutableMap$u0020AsJavaMap__B = typing.TypeVar('_mutableMap$u0020AsJavaMap__B')  # <B>
    def mutableMap$u0020AsJavaMap(self, m: scala.collection.mutable.Map[_mutableMap.u0020AsJavaMap__A, _mutableMap.u0020AsJavaMap__B]) -> java.util.Map[_mutableMap.u0020AsJavaMap__A, _mutableMap.u0020AsJavaMap__B]: ...
    _mutableSeq$u0020AsJavaList__A = typing.TypeVar('_mutableSeq$u0020AsJavaList__A')  # <A>
    def mutableSeq$u0020AsJavaList(self, seq: scala.collection.mutable.Seq[_mutableSeq.u0020AsJavaList__A]) -> java.util.List[_mutableSeq.u0020AsJavaList__A]: ...
    _mutableSet$u0020AsJavaSet__A = typing.TypeVar('_mutableSet$u0020AsJavaSet__A')  # <A>
    def mutableSet$u0020AsJavaSet(self, s: scala.collection.mutable.Set[_mutableSet.u0020AsJavaSet__A]) -> java.util.Set[_mutableSet.u0020AsJavaSet__A]: ...
    _seq$u0020AsJavaList__A = typing.TypeVar('_seq$u0020AsJavaList__A')  # <A>
    def seq$u0020AsJavaList(self, seq: scala.collection.Seq[_seq.u0020AsJavaList__A]) -> java.util.List[_seq.u0020AsJavaList__A]: ...
    _set$u0020AsJavaSet__A = typing.TypeVar('_set$u0020AsJavaSet__A')  # <A>
    def set$u0020AsJavaSet(self, s: scala.collection.Set[_set.u0020AsJavaSet__A]) -> java.util.Set[_set.u0020AsJavaSet__A]: ...

class ToScalaImplicits:
    @staticmethod
    def $init$($this: 'ToScalaImplicits') -> None: ...
    _collection$u0020AsScalaIterable__A = typing.TypeVar('_collection$u0020AsScalaIterable__A')  # <A>
    def collection$u0020AsScalaIterable(self, i: typing.Union[java.util.Collection[_collection.u0020AsScalaIterable__A], typing.Sequence[_collection.u0020AsScalaIterable__A], typing.Set[_collection.u0020AsScalaIterable__A]]) -> scala.collection.Iterable[_collection.u0020AsScalaIterable__A]: ...
    _dictionary$u0020AsScalaMap__A = typing.TypeVar('_dictionary$u0020AsScalaMap__A')  # <A>
    _dictionary$u0020AsScalaMap__B = typing.TypeVar('_dictionary$u0020AsScalaMap__B')  # <B>
    def dictionary$u0020AsScalaMap(self, p: java.util.Dictionary[_dictionary.u0020AsScalaMap__A, _dictionary.u0020AsScalaMap__B]) -> scala.collection.mutable.Map[_dictionary.u0020AsScalaMap__A, _dictionary.u0020AsScalaMap__B]: ...
    _enumeration$u0020AsScalaIterator__A = typing.TypeVar('_enumeration$u0020AsScalaIterator__A')  # <A>
    def enumeration$u0020AsScalaIterator(self, i: java.util.Enumeration[_enumeration.u0020AsScalaIterator__A]) -> scala.collection.Iterator[_enumeration.u0020AsScalaIterator__A]: ...
    _iterable$u0020AsScalaIterable__A = typing.TypeVar('_iterable$u0020AsScalaIterable__A')  # <A>
    def iterable$u0020AsScalaIterable(self, i: typing.Union[java.lang.Iterable[_iterable.u0020AsScalaIterable__A], typing.Sequence[_iterable.u0020AsScalaIterable__A], typing.Set[_iterable.u0020AsScalaIterable__A]]) -> scala.collection.Iterable[_iterable.u0020AsScalaIterable__A]: ...
    _iterator$u0020asScala__A = typing.TypeVar('_iterator$u0020asScala__A')  # <A>
    def iterator$u0020asScala(self, it: java.util.Iterator[_iterator.u0020asScala__A]) -> scala.collection.Iterator[_iterator.u0020asScala__A]: ...
    _list$u0020asScalaBuffer__A = typing.TypeVar('_list$u0020asScalaBuffer__A')  # <A>
    def list$u0020asScalaBuffer(self, l: java.util.List[_list.u0020asScalaBuffer__A]) -> scala.collection.mutable.Buffer[_list.u0020asScalaBuffer__A]: ...
    _map$u0020AsScala__A = typing.TypeVar('_map$u0020AsScala__A')  # <A>
    _map$u0020AsScala__B = typing.TypeVar('_map$u0020AsScala__B')  # <B>
    def map$u0020AsScala(self, m: typing.Union[java.util.Map[_map.u0020AsScala__A, _map.u0020AsScala__B], typing.Mapping[_map.u0020AsScala__A, _map.u0020AsScala__B]]) -> scala.collection.mutable.Map[_map.u0020AsScala__A, _map.u0020AsScala__B]: ...
    _map$u0020AsScalaConcurrentMap__A = typing.TypeVar('_map$u0020AsScalaConcurrentMap__A')  # <A>
    _map$u0020AsScalaConcurrentMap__B = typing.TypeVar('_map$u0020AsScalaConcurrentMap__B')  # <B>
    def map$u0020AsScalaConcurrentMap(self, m: java.util.concurrent.ConcurrentMap[_map.u0020AsScalaConcurrentMap__A, _map.u0020AsScalaConcurrentMap__B]) -> scala.collection.concurrent.Map[_map.u0020AsScalaConcurrentMap__A, _map.u0020AsScalaConcurrentMap__B]: ...
    def properties$u0020AsScalaMap(self, p: java.util.Properties) -> scala.collection.mutable.Map[java.lang.String, java.lang.String]: ...
    _set$u0020asScala__A = typing.TypeVar('_set$u0020asScala__A')  # <A>
    def set$u0020asScala(self, s: java.util.Set[_set.u0020asScala__A]) -> scala.collection.mutable.Set[_set.u0020asScala__A]: ...

class package:
    @staticmethod
    def decorateAll() -> scala.collection.JavaConverters.: ...
    @staticmethod
    def decorateAsJava() -> 'DecorateAsJava': ...
    @staticmethod
    def decorateAsScala() -> 'DecorateAsScala': ...
    @staticmethod
    def wrapAll() -> 'WrapAsJava': ...
    @staticmethod
    def wrapAsJava() -> 'WrapAsJava': ...
    @staticmethod
    def wrapAsScala() -> 'WrapAsScala': ...

class DecorateAsJava(AsJavaConverters):
    @staticmethod
    def $init$($this: 'DecorateAsJava') -> None: ...
    _asJavaCollectionConverter__A = typing.TypeVar('_asJavaCollectionConverter__A')  # <A>
    def asJavaCollectionConverter(self, i: scala.collection.Iterable[_asJavaCollectionConverter__A]) -> Decorators.AsJavaCollection[_asJavaCollectionConverter__A]: ...
    _asJavaDictionaryConverter__A = typing.TypeVar('_asJavaDictionaryConverter__A')  # <A>
    _asJavaDictionaryConverter__B = typing.TypeVar('_asJavaDictionaryConverter__B')  # <B>
    def asJavaDictionaryConverter(self, m: scala.collection.mutable.Map[_asJavaDictionaryConverter__A, _asJavaDictionaryConverter__B]) -> Decorators.AsJavaDictionary[_asJavaDictionaryConverter__A, _asJavaDictionaryConverter__B]: ...
    _asJavaEnumerationConverter__A = typing.TypeVar('_asJavaEnumerationConverter__A')  # <A>
    def asJavaEnumerationConverter(self, i: scala.collection.Iterator[_asJavaEnumerationConverter__A]) -> Decorators.AsJavaEnumeration[_asJavaEnumerationConverter__A]: ...
    _asJavaIterableConverter__A = typing.TypeVar('_asJavaIterableConverter__A')  # <A>
    def asJavaIterableConverter(self, i: scala.collection.Iterable[_asJavaIterableConverter__A]) -> Decorators.AsJava[java.lang.Iterable[_asJavaIterableConverter__A]]: ...
    _asJavaIteratorConverter__A = typing.TypeVar('_asJavaIteratorConverter__A')  # <A>
    def asJavaIteratorConverter(self, i: scala.collection.Iterator[_asJavaIteratorConverter__A]) -> Decorators.AsJava[java.util.Iterator[_asJavaIteratorConverter__A]]: ...
    _bufferAsJavaListConverter__A = typing.TypeVar('_bufferAsJavaListConverter__A')  # <A>
    def bufferAsJavaListConverter(self, b: scala.collection.mutable.Buffer[_bufferAsJavaListConverter__A]) -> Decorators.AsJava[java.util.List[_bufferAsJavaListConverter__A]]: ...
    _mapAsJavaConcurrentMapConverter__A = typing.TypeVar('_mapAsJavaConcurrentMapConverter__A')  # <A>
    _mapAsJavaConcurrentMapConverter__B = typing.TypeVar('_mapAsJavaConcurrentMapConverter__B')  # <B>
    def mapAsJavaConcurrentMapConverter(self, m: scala.collection.concurrent.Map[_mapAsJavaConcurrentMapConverter__A, _mapAsJavaConcurrentMapConverter__B]) -> Decorators.AsJava[java.util.concurrent.ConcurrentMap[_mapAsJavaConcurrentMapConverter__A, _mapAsJavaConcurrentMapConverter__B]]: ...
    _mapAsJavaMapConverter__A = typing.TypeVar('_mapAsJavaMapConverter__A')  # <A>
    _mapAsJavaMapConverter__B = typing.TypeVar('_mapAsJavaMapConverter__B')  # <B>
    def mapAsJavaMapConverter(self, m: scala.collection.Map[_mapAsJavaMapConverter__A, _mapAsJavaMapConverter__B]) -> Decorators.AsJava[java.util.Map[_mapAsJavaMapConverter__A, _mapAsJavaMapConverter__B]]: ...
    _mutableMapAsJavaMapConverter__A = typing.TypeVar('_mutableMapAsJavaMapConverter__A')  # <A>
    _mutableMapAsJavaMapConverter__B = typing.TypeVar('_mutableMapAsJavaMapConverter__B')  # <B>
    def mutableMapAsJavaMapConverter(self, m: scala.collection.mutable.Map[_mutableMapAsJavaMapConverter__A, _mutableMapAsJavaMapConverter__B]) -> Decorators.AsJava[java.util.Map[_mutableMapAsJavaMapConverter__A, _mutableMapAsJavaMapConverter__B]]: ...
    _mutableSeqAsJavaListConverter__A = typing.TypeVar('_mutableSeqAsJavaListConverter__A')  # <A>
    def mutableSeqAsJavaListConverter(self, b: scala.collection.mutable.Seq[_mutableSeqAsJavaListConverter__A]) -> Decorators.AsJava[java.util.List[_mutableSeqAsJavaListConverter__A]]: ...
    _mutableSetAsJavaSetConverter__A = typing.TypeVar('_mutableSetAsJavaSetConverter__A')  # <A>
    def mutableSetAsJavaSetConverter(self, s: scala.collection.mutable.Set[_mutableSetAsJavaSetConverter__A]) -> Decorators.AsJava[java.util.Set[_mutableSetAsJavaSetConverter__A]]: ...
    _seqAsJavaListConverter__A = typing.TypeVar('_seqAsJavaListConverter__A')  # <A>
    def seqAsJavaListConverter(self, b: scala.collection.Seq[_seqAsJavaListConverter__A]) -> Decorators.AsJava[java.util.List[_seqAsJavaListConverter__A]]: ...
    _setAsJavaSetConverter__A = typing.TypeVar('_setAsJavaSetConverter__A')  # <A>
    def setAsJavaSetConverter(self, s: scala.collection.Set[_setAsJavaSetConverter__A]) -> Decorators.AsJava[java.util.Set[_setAsJavaSetConverter__A]]: ...

class DecorateAsScala(AsScalaConverters):
    @staticmethod
    def $init$($this: 'DecorateAsScala') -> None: ...
    _asScalaBufferConverter__A = typing.TypeVar('_asScalaBufferConverter__A')  # <A>
    def asScalaBufferConverter(self, l: java.util.List[_asScalaBufferConverter__A]) -> Decorators.AsScala[scala.collection.mutable.Buffer[_asScalaBufferConverter__A]]: ...
    _asScalaIteratorConverter__A = typing.TypeVar('_asScalaIteratorConverter__A')  # <A>
    def asScalaIteratorConverter(self, i: java.util.Iterator[_asScalaIteratorConverter__A]) -> Decorators.AsScala[scala.collection.Iterator[_asScalaIteratorConverter__A]]: ...
    _asScalaSetConverter__A = typing.TypeVar('_asScalaSetConverter__A')  # <A>
    def asScalaSetConverter(self, s: java.util.Set[_asScalaSetConverter__A]) -> Decorators.AsScala[scala.collection.mutable.Set[_asScalaSetConverter__A]]: ...
    _collectionAsScalaIterableConverter__A = typing.TypeVar('_collectionAsScalaIterableConverter__A')  # <A>
    def collectionAsScalaIterableConverter(self, i: typing.Union[java.util.Collection[_collectionAsScalaIterableConverter__A], typing.Sequence[_collectionAsScalaIterableConverter__A], typing.Set[_collectionAsScalaIterableConverter__A]]) -> Decorators.AsScala[scala.collection.Iterable[_collectionAsScalaIterableConverter__A]]: ...
    _dictionaryAsScalaMapConverter__A = typing.TypeVar('_dictionaryAsScalaMapConverter__A')  # <A>
    _dictionaryAsScalaMapConverter__B = typing.TypeVar('_dictionaryAsScalaMapConverter__B')  # <B>
    def dictionaryAsScalaMapConverter(self, p: java.util.Dictionary[_dictionaryAsScalaMapConverter__A, _dictionaryAsScalaMapConverter__B]) -> Decorators.AsScala[scala.collection.mutable.Map[_dictionaryAsScalaMapConverter__A, _dictionaryAsScalaMapConverter__B]]: ...
    _enumerationAsScalaIteratorConverter__A = typing.TypeVar('_enumerationAsScalaIteratorConverter__A')  # <A>
    def enumerationAsScalaIteratorConverter(self, i: java.util.Enumeration[_enumerationAsScalaIteratorConverter__A]) -> Decorators.AsScala[scala.collection.Iterator[_enumerationAsScalaIteratorConverter__A]]: ...
    _iterableAsScalaIterableConverter__A = typing.TypeVar('_iterableAsScalaIterableConverter__A')  # <A>
    def iterableAsScalaIterableConverter(self, i: typing.Union[java.lang.Iterable[_iterableAsScalaIterableConverter__A], typing.Sequence[_iterableAsScalaIterableConverter__A], typing.Set[_iterableAsScalaIterableConverter__A]]) -> Decorators.AsScala[scala.collection.Iterable[_iterableAsScalaIterableConverter__A]]: ...
    _mapAsScalaConcurrentMapConverter__A = typing.TypeVar('_mapAsScalaConcurrentMapConverter__A')  # <A>
    _mapAsScalaConcurrentMapConverter__B = typing.TypeVar('_mapAsScalaConcurrentMapConverter__B')  # <B>
    def mapAsScalaConcurrentMapConverter(self, m: java.util.concurrent.ConcurrentMap[_mapAsScalaConcurrentMapConverter__A, _mapAsScalaConcurrentMapConverter__B]) -> Decorators.AsScala[scala.collection.concurrent.Map[_mapAsScalaConcurrentMapConverter__A, _mapAsScalaConcurrentMapConverter__B]]: ...
    _mapAsScalaMapConverter__A = typing.TypeVar('_mapAsScalaMapConverter__A')  # <A>
    _mapAsScalaMapConverter__B = typing.TypeVar('_mapAsScalaMapConverter__B')  # <B>
    def mapAsScalaMapConverter(self, m: typing.Union[java.util.Map[_mapAsScalaMapConverter__A, _mapAsScalaMapConverter__B], typing.Mapping[_mapAsScalaMapConverter__A, _mapAsScalaMapConverter__B]]) -> Decorators.AsScala[scala.collection.mutable.Map[_mapAsScalaMapConverter__A, _mapAsScalaMapConverter__B]]: ...
    def propertiesAsScalaMapConverter(self, p: java.util.Properties) -> Decorators.AsScala[scala.collection.mutable.Map[java.lang.String, java.lang.String]]: ...

class WrapAsJava(LowPriorityWrapAsJava):
    @staticmethod
    def $init$($this: 'WrapAsJava') -> None: ...
    _deprecated$u0020asJavaCollection__A = typing.TypeVar('_deprecated$u0020asJavaCollection__A')  # <A>
    def deprecated$u0020asJavaCollection(self, it: scala.collection.Iterable[_deprecated.u0020asJavaCollection__A]) -> java.util.Collection[_deprecated.u0020asJavaCollection__A]: ...
    _deprecated$u0020asJavaDictionary__A = typing.TypeVar('_deprecated$u0020asJavaDictionary__A')  # <A>
    _deprecated$u0020asJavaDictionary__B = typing.TypeVar('_deprecated$u0020asJavaDictionary__B')  # <B>
    def deprecated$u0020asJavaDictionary(self, m: scala.collection.mutable.Map[_deprecated.u0020asJavaDictionary__A, _deprecated.u0020asJavaDictionary__B]) -> java.util.Dictionary[_deprecated.u0020asJavaDictionary__A, _deprecated.u0020asJavaDictionary__B]: ...
    _deprecated$u0020asJavaEnumeration__A = typing.TypeVar('_deprecated$u0020asJavaEnumeration__A')  # <A>
    def deprecated$u0020asJavaEnumeration(self, it: scala.collection.Iterator[_deprecated.u0020asJavaEnumeration__A]) -> java.util.Enumeration[_deprecated.u0020asJavaEnumeration__A]: ...
    _deprecated$u0020asJavaIterable__A = typing.TypeVar('_deprecated$u0020asJavaIterable__A')  # <A>
    def deprecated$u0020asJavaIterable(self, i: scala.collection.Iterable[_deprecated.u0020asJavaIterable__A]) -> java.lang.Iterable[_deprecated.u0020asJavaIterable__A]: ...
    _deprecated$u0020asJavaIterator__A = typing.TypeVar('_deprecated$u0020asJavaIterator__A')  # <A>
    def deprecated$u0020asJavaIterator(self, it: scala.collection.Iterator[_deprecated.u0020asJavaIterator__A]) -> java.util.Iterator[_deprecated.u0020asJavaIterator__A]: ...
    _deprecated$u0020bufferAsJavaList__A = typing.TypeVar('_deprecated$u0020bufferAsJavaList__A')  # <A>
    def deprecated$u0020bufferAsJavaList(self, b: scala.collection.mutable.Buffer[_deprecated.u0020bufferAsJavaList__A]) -> java.util.List[_deprecated.u0020bufferAsJavaList__A]: ...
    _deprecated$u0020mapAsJavaConcurrentMap__A = typing.TypeVar('_deprecated$u0020mapAsJavaConcurrentMap__A')  # <A>
    _deprecated$u0020mapAsJavaConcurrentMap__B = typing.TypeVar('_deprecated$u0020mapAsJavaConcurrentMap__B')  # <B>
    def deprecated$u0020mapAsJavaConcurrentMap(self, m: scala.collection.concurrent.Map[_deprecated.u0020mapAsJavaConcurrentMap__A, _deprecated.u0020mapAsJavaConcurrentMap__B]) -> java.util.concurrent.ConcurrentMap[_deprecated.u0020mapAsJavaConcurrentMap__A, _deprecated.u0020mapAsJavaConcurrentMap__B]: ...
    _deprecated$u0020mapAsJavaMap__A = typing.TypeVar('_deprecated$u0020mapAsJavaMap__A')  # <A>
    _deprecated$u0020mapAsJavaMap__B = typing.TypeVar('_deprecated$u0020mapAsJavaMap__B')  # <B>
    def deprecated$u0020mapAsJavaMap(self, m: scala.collection.Map[_deprecated.u0020mapAsJavaMap__A, _deprecated.u0020mapAsJavaMap__B]) -> java.util.Map[_deprecated.u0020mapAsJavaMap__A, _deprecated.u0020mapAsJavaMap__B]: ...
    _deprecated$u0020mutableMapAsJavaMap__A = typing.TypeVar('_deprecated$u0020mutableMapAsJavaMap__A')  # <A>
    _deprecated$u0020mutableMapAsJavaMap__B = typing.TypeVar('_deprecated$u0020mutableMapAsJavaMap__B')  # <B>
    def deprecated$u0020mutableMapAsJavaMap(self, m: scala.collection.mutable.Map[_deprecated.u0020mutableMapAsJavaMap__A, _deprecated.u0020mutableMapAsJavaMap__B]) -> java.util.Map[_deprecated.u0020mutableMapAsJavaMap__A, _deprecated.u0020mutableMapAsJavaMap__B]: ...
    _deprecated$u0020mutableSeqAsJavaList__A = typing.TypeVar('_deprecated$u0020mutableSeqAsJavaList__A')  # <A>
    def deprecated$u0020mutableSeqAsJavaList(self, seq: scala.collection.mutable.Seq[_deprecated.u0020mutableSeqAsJavaList__A]) -> java.util.List[_deprecated.u0020mutableSeqAsJavaList__A]: ...
    _deprecated$u0020mutableSetAsJavaSet__A = typing.TypeVar('_deprecated$u0020mutableSetAsJavaSet__A')  # <A>
    def deprecated$u0020mutableSetAsJavaSet(self, s: scala.collection.mutable.Set[_deprecated.u0020mutableSetAsJavaSet__A]) -> java.util.Set[_deprecated.u0020mutableSetAsJavaSet__A]: ...
    _deprecated$u0020seqAsJavaList__A = typing.TypeVar('_deprecated$u0020seqAsJavaList__A')  # <A>
    def deprecated$u0020seqAsJavaList(self, seq: scala.collection.Seq[_deprecated.u0020seqAsJavaList__A]) -> java.util.List[_deprecated.u0020seqAsJavaList__A]: ...
    _deprecated$u0020setAsJavaSet__A = typing.TypeVar('_deprecated$u0020setAsJavaSet__A')  # <A>
    def deprecated$u0020setAsJavaSet(self, s: scala.collection.Set[_deprecated.u0020setAsJavaSet__A]) -> java.util.Set[_deprecated.u0020setAsJavaSet__A]: ...

class WrapAsScala(LowPriorityWrapAsScala):
    @staticmethod
    def $init$($this: 'WrapAsScala') -> None: ...
    _deprecated$u0020asScalaBuffer__A = typing.TypeVar('_deprecated$u0020asScalaBuffer__A')  # <A>
    def deprecated$u0020asScalaBuffer(self, l: java.util.List[_deprecated.u0020asScalaBuffer__A]) -> scala.collection.mutable.Buffer[_deprecated.u0020asScalaBuffer__A]: ...
    _deprecated$u0020asScalaIterator__A = typing.TypeVar('_deprecated$u0020asScalaIterator__A')  # <A>
    def deprecated$u0020asScalaIterator(self, it: java.util.Iterator[_deprecated.u0020asScalaIterator__A]) -> scala.collection.Iterator[_deprecated.u0020asScalaIterator__A]: ...
    _deprecated$u0020asScalaSet__A = typing.TypeVar('_deprecated$u0020asScalaSet__A')  # <A>
    def deprecated$u0020asScalaSet(self, s: java.util.Set[_deprecated.u0020asScalaSet__A]) -> scala.collection.mutable.Set[_deprecated.u0020asScalaSet__A]: ...
    _deprecated$u0020collectionAsScalaIterable__A = typing.TypeVar('_deprecated$u0020collectionAsScalaIterable__A')  # <A>
    def deprecated$u0020collectionAsScalaIterable(self, i: typing.Union[java.util.Collection[_deprecated.u0020collectionAsScalaIterable__A], typing.Sequence[_deprecated.u0020collectionAsScalaIterable__A], typing.Set[_deprecated.u0020collectionAsScalaIterable__A]]) -> scala.collection.Iterable[_deprecated.u0020collectionAsScalaIterable__A]: ...
    _deprecated$u0020dictionaryAsScalaMap__A = typing.TypeVar('_deprecated$u0020dictionaryAsScalaMap__A')  # <A>
    _deprecated$u0020dictionaryAsScalaMap__B = typing.TypeVar('_deprecated$u0020dictionaryAsScalaMap__B')  # <B>
    def deprecated$u0020dictionaryAsScalaMap(self, p: java.util.Dictionary[_deprecated.u0020dictionaryAsScalaMap__A, _deprecated.u0020dictionaryAsScalaMap__B]) -> scala.collection.mutable.Map[_deprecated.u0020dictionaryAsScalaMap__A, _deprecated.u0020dictionaryAsScalaMap__B]: ...
    _deprecated$u0020enumerationAsScalaIterator__A = typing.TypeVar('_deprecated$u0020enumerationAsScalaIterator__A')  # <A>
    def deprecated$u0020enumerationAsScalaIterator(self, i: java.util.Enumeration[_deprecated.u0020enumerationAsScalaIterator__A]) -> scala.collection.Iterator[_deprecated.u0020enumerationAsScalaIterator__A]: ...
    _deprecated$u0020iterableAsScalaIterable__A = typing.TypeVar('_deprecated$u0020iterableAsScalaIterable__A')  # <A>
    def deprecated$u0020iterableAsScalaIterable(self, i: typing.Union[java.lang.Iterable[_deprecated.u0020iterableAsScalaIterable__A], typing.Sequence[_deprecated.u0020iterableAsScalaIterable__A], typing.Set[_deprecated.u0020iterableAsScalaIterable__A]]) -> scala.collection.Iterable[_deprecated.u0020iterableAsScalaIterable__A]: ...
    _deprecated$u0020mapAsScalaConcurrentMap__A = typing.TypeVar('_deprecated$u0020mapAsScalaConcurrentMap__A')  # <A>
    _deprecated$u0020mapAsScalaConcurrentMap__B = typing.TypeVar('_deprecated$u0020mapAsScalaConcurrentMap__B')  # <B>
    def deprecated$u0020mapAsScalaConcurrentMap(self, m: java.util.concurrent.ConcurrentMap[_deprecated.u0020mapAsScalaConcurrentMap__A, _deprecated.u0020mapAsScalaConcurrentMap__B]) -> scala.collection.concurrent.Map[_deprecated.u0020mapAsScalaConcurrentMap__A, _deprecated.u0020mapAsScalaConcurrentMap__B]: ...
    _deprecated$u0020mapAsScalaMap__A = typing.TypeVar('_deprecated$u0020mapAsScalaMap__A')  # <A>
    _deprecated$u0020mapAsScalaMap__B = typing.TypeVar('_deprecated$u0020mapAsScalaMap__B')  # <B>
    def deprecated$u0020mapAsScalaMap(self, m: typing.Union[java.util.Map[_deprecated.u0020mapAsScalaMap__A, _deprecated.u0020mapAsScalaMap__B], typing.Mapping[_deprecated.u0020mapAsScalaMap__A, _deprecated.u0020mapAsScalaMap__B]]) -> scala.collection.mutable.Map[_deprecated.u0020mapAsScalaMap__A, _deprecated.u0020mapAsScalaMap__B]: ...
    def deprecated$u0020propertiesAsScalaMap(self, p: java.util.Properties) -> scala.collection.mutable.Map[java.lang.String, java.lang.String]: ...

_Wrappers__ConcurrentMapWrapper__A = typing.TypeVar('_Wrappers__ConcurrentMapWrapper__A')  # <A>
_Wrappers__ConcurrentMapWrapper__B = typing.TypeVar('_Wrappers__ConcurrentMapWrapper__B')  # <B>
_Wrappers__DictionaryWrapper__A = typing.TypeVar('_Wrappers__DictionaryWrapper__A')  # <A>
_Wrappers__DictionaryWrapper__B = typing.TypeVar('_Wrappers__DictionaryWrapper__B')  # <B>
_Wrappers__IterableWrapper__A = typing.TypeVar('_Wrappers__IterableWrapper__A')  # <A>
_Wrappers__IterableWrapperTrait__A = typing.TypeVar('_Wrappers__IterableWrapperTrait__A')  # <A>
_Wrappers__IteratorWrapper__A = typing.TypeVar('_Wrappers__IteratorWrapper__A')  # <A>
_Wrappers__JCollectionWrapper__A = typing.TypeVar('_Wrappers__JCollectionWrapper__A')  # <A>
_Wrappers__JConcurrentMapWrapper__A = typing.TypeVar('_Wrappers__JConcurrentMapWrapper__A')  # <A>
_Wrappers__JConcurrentMapWrapper__B = typing.TypeVar('_Wrappers__JConcurrentMapWrapper__B')  # <B>
_Wrappers__JDictionaryWrapper__A = typing.TypeVar('_Wrappers__JDictionaryWrapper__A')  # <A>
_Wrappers__JDictionaryWrapper__B = typing.TypeVar('_Wrappers__JDictionaryWrapper__B')  # <B>
_Wrappers__JEnumerationWrapper__A = typing.TypeVar('_Wrappers__JEnumerationWrapper__A')  # <A>
_Wrappers__JIterableWrapper__A = typing.TypeVar('_Wrappers__JIterableWrapper__A')  # <A>
_Wrappers__JIteratorWrapper__A = typing.TypeVar('_Wrappers__JIteratorWrapper__A')  # <A>
_Wrappers__JListWrapper__A = typing.TypeVar('_Wrappers__JListWrapper__A')  # <A>
_Wrappers__JMapWrapper__A = typing.TypeVar('_Wrappers__JMapWrapper__A')  # <A>
_Wrappers__JMapWrapper__B = typing.TypeVar('_Wrappers__JMapWrapper__B')  # <B>
_Wrappers__JMapWrapperLike__A = typing.TypeVar('_Wrappers__JMapWrapperLike__A')  # <A>
_Wrappers__JMapWrapperLike__B = typing.TypeVar('_Wrappers__JMapWrapperLike__B')  # <B>
_Wrappers__JMapWrapperLike__Repr = typing.TypeVar('_Wrappers__JMapWrapperLike__Repr', bound=scala.collection.mutable.MapLike)  # <Repr>
_Wrappers__JSetWrapper__A = typing.TypeVar('_Wrappers__JSetWrapper__A')  # <A>
_Wrappers__MapWrapper__A = typing.TypeVar('_Wrappers__MapWrapper__A')  # <A>
_Wrappers__MapWrapper__B = typing.TypeVar('_Wrappers__MapWrapper__B')  # <B>
_Wrappers__MutableBufferWrapper__A = typing.TypeVar('_Wrappers__MutableBufferWrapper__A')  # <A>
_Wrappers__MutableMapWrapper__A = typing.TypeVar('_Wrappers__MutableMapWrapper__A')  # <A>
_Wrappers__MutableMapWrapper__B = typing.TypeVar('_Wrappers__MutableMapWrapper__B')  # <B>
_Wrappers__MutableSeqWrapper__A = typing.TypeVar('_Wrappers__MutableSeqWrapper__A')  # <A>
_Wrappers__MutableSetWrapper__A = typing.TypeVar('_Wrappers__MutableSetWrapper__A')  # <A>
_Wrappers__SeqWrapper__A = typing.TypeVar('_Wrappers__SeqWrapper__A')  # <A>
_Wrappers__SetWrapper__A = typing.TypeVar('_Wrappers__SetWrapper__A')  # <A>
_Wrappers__ToIteratorWrapper__A = typing.TypeVar('_Wrappers__ToIteratorWrapper__A')  # <A>
class Wrappers:
    @staticmethod
    def $init$($this: 'Wrappers') -> None: ...
    class ConcurrentMapWrapper(scala.collection.convert.Wrappers.MutableMapWrapper[_Wrappers__ConcurrentMapWrapper__A, _Wrappers__ConcurrentMapWrapper__B], java.util.concurrent.ConcurrentMap[_Wrappers__ConcurrentMapWrapper__A, _Wrappers__ConcurrentMapWrapper__B], typing.Generic[_Wrappers__ConcurrentMapWrapper__A, _Wrappers__ConcurrentMapWrapper__B]):
        def __init__(self, $outer: 'Wrappers', underlying: scala.collection.concurrent.Map[_Wrappers__ConcurrentMapWrapper__A, _Wrappers__ConcurrentMapWrapper__B]): ...
        def compute(self, x$1: _Wrappers__ConcurrentMapWrapper__A, x$2: typing.Union[java.util.function.BiFunction[_Wrappers__ConcurrentMapWrapper__A, _Wrappers__ConcurrentMapWrapper__B, _Wrappers__ConcurrentMapWrapper__B], typing.Callable[[_Wrappers__ConcurrentMapWrapper__A, _Wrappers__ConcurrentMapWrapper__B], _Wrappers__ConcurrentMapWrapper__B]]) -> _Wrappers__ConcurrentMapWrapper__B: ...
        def computeIfAbsent(self, x$1: _Wrappers__ConcurrentMapWrapper__A, x$2: typing.Union[java.util.function.Function[_Wrappers__ConcurrentMapWrapper__A, _Wrappers__ConcurrentMapWrapper__B], typing.Callable[[_Wrappers__ConcurrentMapWrapper__A], _Wrappers__ConcurrentMapWrapper__B]]) -> _Wrappers__ConcurrentMapWrapper__B: ...
        def computeIfPresent(self, x$1: _Wrappers__ConcurrentMapWrapper__A, x$2: typing.Union[java.util.function.BiFunction[_Wrappers__ConcurrentMapWrapper__A, _Wrappers__ConcurrentMapWrapper__B, _Wrappers__ConcurrentMapWrapper__B], typing.Callable[[_Wrappers__ConcurrentMapWrapper__A, _Wrappers__ConcurrentMapWrapper__B], _Wrappers__ConcurrentMapWrapper__B]]) -> _Wrappers__ConcurrentMapWrapper__B: ...
        def forEach(self, x$1: typing.Union[java.util.function.BiConsumer[_Wrappers__ConcurrentMapWrapper__A, _Wrappers__ConcurrentMapWrapper__B], typing.Callable[[_Wrappers__ConcurrentMapWrapper__A, _Wrappers__ConcurrentMapWrapper__B], None]]) -> None: ...
        def getOrDefault(self, x$1: typing.Any, x$2: _Wrappers__ConcurrentMapWrapper__B) -> _Wrappers__ConcurrentMapWrapper__B: ...
        def merge(self, x$1: _Wrappers__ConcurrentMapWrapper__A, x$2: _Wrappers__ConcurrentMapWrapper__B, x$3: typing.Union[java.util.function.BiFunction[_Wrappers__ConcurrentMapWrapper__B, _Wrappers__ConcurrentMapWrapper__B, _Wrappers__ConcurrentMapWrapper__B], typing.Callable[[_Wrappers__ConcurrentMapWrapper__B, _Wrappers__ConcurrentMapWrapper__B], _Wrappers__ConcurrentMapWrapper__B]]) -> _Wrappers__ConcurrentMapWrapper__B: ...
        def putIfAbsent(self, k: _Wrappers__ConcurrentMapWrapper__A, v: _Wrappers__ConcurrentMapWrapper__B) -> _Wrappers__ConcurrentMapWrapper__B: ...
        @typing.overload
        def remove(self, k: typing.Any, v: typing.Any) -> bool: ...
        @typing.overload
        def remove(self, k: typing.Any) -> _Wrappers__ConcurrentMapWrapper__B: ...
        @typing.overload
        def replace(self, k: _Wrappers__ConcurrentMapWrapper__A, oldval: _Wrappers__ConcurrentMapWrapper__B, newval: _Wrappers__ConcurrentMapWrapper__B) -> bool: ...
        @typing.overload
        def replace(self, k: _Wrappers__ConcurrentMapWrapper__A, v: _Wrappers__ConcurrentMapWrapper__B) -> _Wrappers__ConcurrentMapWrapper__B: ...
        def replaceAll(self, x$1: typing.Union[java.util.function.BiFunction[_Wrappers__ConcurrentMapWrapper__A, _Wrappers__ConcurrentMapWrapper__B, _Wrappers__ConcurrentMapWrapper__B], typing.Callable[[_Wrappers__ConcurrentMapWrapper__A, _Wrappers__ConcurrentMapWrapper__B], _Wrappers__ConcurrentMapWrapper__B]]) -> None: ...
        def underlying(self) -> scala.collection.concurrent.Map[_Wrappers__ConcurrentMapWrapper__A, _Wrappers__ConcurrentMapWrapper__B]: ...
    class DictionaryWrapper(java.util.Dictionary[_Wrappers__DictionaryWrapper__A, _Wrappers__DictionaryWrapper__B], scala.Product, scala.Serializable, typing.Generic[_Wrappers__DictionaryWrapper__A, _Wrappers__DictionaryWrapper__B]):
        $outer: 'Wrappers' = ...
        def __init__(self, $outer: 'Wrappers', underlying: scala.collection.mutable.Map[_Wrappers__DictionaryWrapper__A, _Wrappers__DictionaryWrapper__B]): ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        _copy__A = typing.TypeVar('_copy__A')  # <A>
        _copy__B = typing.TypeVar('_copy__B')  # <B>
        def copy(self, underlying: scala.collection.mutable.Map[typing.Any, typing.Any]) -> 'Wrappers.DictionaryWrapper'[typing.Any, typing.Any]: ...
        _copy$default$1__A = typing.TypeVar('_copy$default$1__A')  # <A>
        _copy$default$1__B = typing.TypeVar('_copy$default$1__B')  # <B>
        def copy$default$1(self) -> scala.collection.mutable.Map[typing.Any, typing.Any]: ...
        def elements(self) -> java.util.Enumeration[_Wrappers__DictionaryWrapper__B]: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def get(self, key: typing.Any) -> _Wrappers__DictionaryWrapper__B: ...
        def hashCode(self) -> int: ...
        def isEmpty(self) -> bool: ...
        def keys(self) -> java.util.Enumeration[_Wrappers__DictionaryWrapper__A]: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def put(self, key: _Wrappers__DictionaryWrapper__A, value: _Wrappers__DictionaryWrapper__B) -> _Wrappers__DictionaryWrapper__B: ...
        def remove(self, key: typing.Any) -> _Wrappers__DictionaryWrapper__B: ...
        def size(self) -> int: ...
        def toString(self) -> java.lang.String: ...
        def underlying(self) -> scala.collection.mutable.Map[_Wrappers__DictionaryWrapper__A, _Wrappers__DictionaryWrapper__B]: ...
    class DictionaryWrapper$(scala.Serializable):
        def __init__(self, $outer: 'Wrappers'): ...
        _apply__A = typing.TypeVar('_apply__A')  # <A>
        _apply__B = typing.TypeVar('_apply__B')  # <B>
        def apply(self, underlying: scala.collection.mutable.Map[_apply__A, _apply__B]) -> 'Wrappers.DictionaryWrapper'[_apply__A, _apply__B]: ...
        def toString(self) -> java.lang.String: ...
        _unapply__A = typing.TypeVar('_unapply__A')  # <A>
        _unapply__B = typing.TypeVar('_unapply__B')  # <B>
        def unapply(self, x$0: 'Wrappers.DictionaryWrapper'[_unapply__A, _unapply__B]) -> scala.Option[scala.collection.mutable.Map[_unapply__A, _unapply__B]]: ...
    class IterableWrapper(java.util.AbstractCollection[_Wrappers__IterableWrapper__A], scala.collection.convert.Wrappers.IterableWrapperTrait[_Wrappers__IterableWrapper__A], scala.Product, scala.Serializable, typing.Generic[_Wrappers__IterableWrapper__A]):
        $outer: 'Wrappers' = ...
        def __init__(self, $outer: 'Wrappers', underlying: scala.collection.Iterable[_Wrappers__IterableWrapper__A]): ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        _copy__A = typing.TypeVar('_copy__A')  # <A>
        def copy(self, underlying: scala.collection.Iterable[typing.Any]) -> 'Wrappers.IterableWrapper'[typing.Any]: ...
        _copy$default$1__A = typing.TypeVar('_copy$default$1__A')  # <A>
        def copy$default$1(self) -> scala.collection.Iterable[typing.Any]: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def isEmpty(self) -> bool: ...
        def iterator(self) -> 'Wrappers.IteratorWrapper'[_Wrappers__IterableWrapper__A]: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def size(self) -> int: ...
        def underlying(self) -> scala.collection.Iterable[_Wrappers__IterableWrapper__A]: ...
    class IterableWrapper$(scala.Serializable):
        def __init__(self, $outer: 'Wrappers'): ...
        _apply__A = typing.TypeVar('_apply__A')  # <A>
        def apply(self, underlying: scala.collection.Iterable[_apply__A]) -> 'Wrappers.IterableWrapper'[_apply__A]: ...
        def toString(self) -> java.lang.String: ...
        _unapply__A = typing.TypeVar('_unapply__A')  # <A>
        def unapply(self, x$0: 'Wrappers.IterableWrapper'[_unapply__A]) -> scala.Option[scala.collection.Iterable[_unapply__A]]: ...
    class IterableWrapperTrait(typing.Generic[_Wrappers__IterableWrapperTrait__A]):
        @staticmethod
        def $init$($this: 'Wrappers.IterableWrapperTrait') -> None: ...
        def isEmpty(self) -> bool: ...
        def iterator(self) -> 'Wrappers.IteratorWrapper'[_Wrappers__IterableWrapperTrait__A]: ...
        def size(self) -> int: ...
        def underlying(self) -> scala.collection.Iterable[_Wrappers__IterableWrapperTrait__A]: ...
    class IteratorWrapper(java.util.Iterator[_Wrappers__IteratorWrapper__A], java.util.Enumeration[_Wrappers__IteratorWrapper__A], scala.Product, scala.Serializable, typing.Generic[_Wrappers__IteratorWrapper__A]):
        $outer: 'Wrappers' = ...
        def __init__(self, $outer: 'Wrappers', underlying: scala.collection.Iterator[_Wrappers__IteratorWrapper__A]): ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        _copy__A = typing.TypeVar('_copy__A')  # <A>
        def copy(self, underlying: scala.collection.Iterator[typing.Any]) -> 'Wrappers.IteratorWrapper'[typing.Any]: ...
        _copy$default$1__A = typing.TypeVar('_copy$default$1__A')  # <A>
        def copy$default$1(self) -> scala.collection.Iterator[typing.Any]: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def forEachRemaining(self, x$1: typing.Union[java.util.function.Consumer[_Wrappers__IteratorWrapper__A], typing.Callable[[_Wrappers__IteratorWrapper__A], None]]) -> None: ...
        def hasMoreElements(self) -> bool: ...
        def hasNext(self) -> bool: ...
        def hashCode(self) -> int: ...
        def next(self) -> _Wrappers__IteratorWrapper__A: ...
        def nextElement(self) -> _Wrappers__IteratorWrapper__A: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def remove(self) -> scala.runtime.Nothing.: ...
        def toString(self) -> java.lang.String: ...
        def underlying(self) -> scala.collection.Iterator[_Wrappers__IteratorWrapper__A]: ...
    class IteratorWrapper$(scala.Serializable):
        def __init__(self, $outer: 'Wrappers'): ...
        _apply__A = typing.TypeVar('_apply__A')  # <A>
        def apply(self, underlying: scala.collection.Iterator[_apply__A]) -> 'Wrappers.IteratorWrapper'[_apply__A]: ...
        def toString(self) -> java.lang.String: ...
        _unapply__A = typing.TypeVar('_unapply__A')  # <A>
        def unapply(self, x$0: 'Wrappers.IteratorWrapper'[_unapply__A]) -> scala.Option[scala.collection.Iterator[_unapply__A]]: ...
    class JCollectionWrapper(scala.collection.AbstractIterable[_Wrappers__JCollectionWrapper__A], scala.Product, scala.Serializable, typing.Generic[_Wrappers__JCollectionWrapper__A]):
        $outer: 'Wrappers' = ...
        def __init__(self, $outer: 'Wrappers', underlying: typing.Union[java.util.Collection[_Wrappers__JCollectionWrapper__A], typing.Sequence[_Wrappers__JCollectionWrapper__A], typing.Set[_Wrappers__JCollectionWrapper__A]]): ...
        _copy__A = typing.TypeVar('_copy__A')  # <A>
        def copy(self, underlying: typing.Union[java.util.Collection[typing.Any], typing.Sequence[typing.Any], typing.Set[typing.Any]]) -> 'Wrappers.JCollectionWrapper'[typing.Any]: ...
        _copy$default$1__A = typing.TypeVar('_copy$default$1__A')  # <A>
        def copy$default$1(self) -> java.util.Collection[typing.Any]: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def isEmpty(self) -> bool: ...
        def iterator(self) -> scala.collection.Iterator[_Wrappers__JCollectionWrapper__A]: ...
        _newBuilder_0__B = typing.TypeVar('_newBuilder_0__B')  # <B>
        @typing.overload
        def newBuilder(self) -> scala.collection.mutable.ArrayBuffer[_newBuilder_0__B]: ...
        @typing.overload
        def newBuilder(self) -> scala.collection.mutable.Builder[_Wrappers__JCollectionWrapper__A, scala.collection.Traversable[_Wrappers__JCollectionWrapper__A]]: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def size(self) -> int: ...
        def underlying(self) -> java.util.Collection[_Wrappers__JCollectionWrapper__A]: ...
    class JCollectionWrapper$(scala.Serializable):
        def __init__(self, $outer: 'Wrappers'): ...
        _apply__A = typing.TypeVar('_apply__A')  # <A>
        def apply(self, underlying: typing.Union[java.util.Collection[_apply__A], typing.Sequence[_apply__A], typing.Set[_apply__A]]) -> 'Wrappers.JCollectionWrapper'[_apply__A]: ...
        def toString(self) -> java.lang.String: ...
        _unapply__A = typing.TypeVar('_unapply__A')  # <A>
        def unapply(self, x$0: 'Wrappers.JCollectionWrapper'[_unapply__A]) -> scala.Option[java.util.Collection[_unapply__A]]: ...
    class JConcurrentMapWrapper(scala.collection.mutable.AbstractMap[_Wrappers__JConcurrentMapWrapper__A, _Wrappers__JConcurrentMapWrapper__B], scala.collection.convert.Wrappers.JMapWrapperLike[_Wrappers__JConcurrentMapWrapper__A, _Wrappers__JConcurrentMapWrapper__B, 'Wrappers.JConcurrentMapWrapper'[_Wrappers__JConcurrentMapWrapper__A, _Wrappers__JConcurrentMapWrapper__B]], scala.collection.concurrent.Map[_Wrappers__JConcurrentMapWrapper__A, _Wrappers__JConcurrentMapWrapper__B], scala.Product, scala.Serializable, typing.Generic[_Wrappers__JConcurrentMapWrapper__A, _Wrappers__JConcurrentMapWrapper__B]):
        $outer: 'Wrappers' = ...
        def __init__(self, $outer: 'Wrappers', underlying: java.util.concurrent.ConcurrentMap[_Wrappers__JConcurrentMapWrapper__A, _Wrappers__JConcurrentMapWrapper__B]): ...
        @typing.overload
        def $minus(self, key: typing.Any) -> scala.collection.mutable.Map[typing.Any, typing.Any]: ...
        @typing.overload
        def $minus(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> scala.collection.mutable.Map[typing.Any, typing.Any]: ...
        @typing.overload
        def $minus$eq(self, key: _Wrappers__JConcurrentMapWrapper__A) -> 'Wrappers.JMapWrapperLike'[_Wrappers__JConcurrentMapWrapper__A, _Wrappers__JConcurrentMapWrapper__B, 'Wrappers.JConcurrentMapWrapper'[_Wrappers__JConcurrentMapWrapper__A, _Wrappers__JConcurrentMapWrapper__B]]: ...
        @typing.overload
        def $minus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> scala.collection.generic.Shrinkable[typing.Any]: ...
        def $minus$minus(self, xs: scala.collection.GenTraversableOnce[typing.Any]) -> scala.collection.mutable.Map[typing.Any, typing.Any]: ...
        _$plus_0__V1 = typing.TypeVar('_$plus_0__V1')  # <V1>
        _$plus_1__V1 = typing.TypeVar('_$plus_1__V1')  # <V1>
        @typing.overload
        def $plus(self, kv: scala.Tuple2[typing.Any, _.plus_0__V1]) -> scala.collection.mutable.Map[typing.Any, _.plus_0__V1]: ...
        @typing.overload
        def $plus(self, elem1: scala.Tuple2[typing.Any, _.plus_1__V1], elem2: scala.Tuple2[typing.Any, _.plus_1__V1], elems: scala.collection.Seq[scala.Tuple2[typing.Any, _.plus_1__V1]]) -> scala.collection.mutable.Map[typing.Any, _.plus_1__V1]: ...
        @typing.overload
        def $plus$eq(self, kv: scala.Tuple2[_Wrappers__JConcurrentMapWrapper__A, _Wrappers__JConcurrentMapWrapper__B]) -> 'Wrappers.JMapWrapperLike'[_Wrappers__JConcurrentMapWrapper__A, _Wrappers__JConcurrentMapWrapper__B, 'Wrappers.JConcurrentMapWrapper'[_Wrappers__JConcurrentMapWrapper__A, _Wrappers__JConcurrentMapWrapper__B]]: ...
        @typing.overload
        def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq) -> scala.collection.generic.Growable: ...
        _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
        _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
        _$plus$plus_1__V1 = typing.TypeVar('_$plus$plus_1__V1')  # <V1>
        @typing.overload
        def $plus$plus(self, that: scala.collection.GenTraversableOnce[typing.Any], bf: scala.collection.generic.CanBuildFrom[scala.collection.Traversable[_Wrappers__JConcurrentMapWrapper__A], typing.Any, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
        @typing.overload
        def $plus$plus(self, xs: scala.collection.GenTraversableOnce[scala.Tuple2[typing.Any, _.plus.plus_1__V1]]) -> scala.collection.mutable.Map[typing.Any, _.plus.plus_1__V1]: ...
        def clear(self) -> None: ...
        def clone(self) -> scala.collection.mutable.Map[typing.Any, typing.Any]: ...
        _copy__A = typing.TypeVar('_copy__A')  # <A>
        _copy__B = typing.TypeVar('_copy__B')  # <B>
        def copy(self, underlying: java.util.concurrent.ConcurrentMap[typing.Any, typing.Any]) -> 'Wrappers.JConcurrentMapWrapper'[typing.Any, typing.Any]: ...
        _copy$default$1__A = typing.TypeVar('_copy$default$1__A')  # <A>
        _copy$default$1__B = typing.TypeVar('_copy$default$1__B')  # <B>
        def copy$default$1(self) -> java.util.concurrent.ConcurrentMap[typing.Any, typing.Any]: ...
        def empty(self) -> 'Wrappers.JConcurrentMapWrapper'[_Wrappers__JConcurrentMapWrapper__A, _Wrappers__JConcurrentMapWrapper__B]: ...
        def filterKeys(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.collection.Map[typing.Any, typing.Any]: ...
        def filterNot(self, p: scala.Function1[scala.Tuple2[typing.Any, typing.Any], typing.Any]) -> scala.collection.Map[typing.Any, typing.Any]: ...
        def get(self, k: _Wrappers__JConcurrentMapWrapper__A) -> scala.Option[_Wrappers__JConcurrentMapWrapper__B]: ...
        def getOrElseUpdate(self, key: _Wrappers__JConcurrentMapWrapper__A, op: scala.Function0[_Wrappers__JConcurrentMapWrapper__B]) -> _Wrappers__JConcurrentMapWrapper__B: ...
        _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
        def groupBy(self, f: scala.Function1[_Wrappers__JConcurrentMapWrapper__A, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[_Wrappers__JConcurrentMapWrapper__A]]: ...
        def iterator(self) -> scala.collection.Iterator[scala.Tuple2[_Wrappers__JConcurrentMapWrapper__A, _Wrappers__JConcurrentMapWrapper__B]]: ...
        def keySet(self) -> scala.collection.Set[typing.Any]: ...
        def keys(self) -> scala.collection.Iterable[typing.Any]: ...
        _mapValues__W = typing.TypeVar('_mapValues__W')  # <W>
        def mapValues(self, f: scala.Function1[typing.Any, _mapValues__W]) -> scala.collection.Map[typing.Any, _mapValues__W]: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def put(self, k: _Wrappers__JConcurrentMapWrapper__A, v: _Wrappers__JConcurrentMapWrapper__B) -> scala.Option[_Wrappers__JConcurrentMapWrapper__B]: ...
        def putIfAbsent(self, k: _Wrappers__JConcurrentMapWrapper__A, v: _Wrappers__JConcurrentMapWrapper__B) -> scala.Option[_Wrappers__JConcurrentMapWrapper__B]: ...
        @typing.overload
        def remove(self, k: _Wrappers__JConcurrentMapWrapper__A, v: _Wrappers__JConcurrentMapWrapper__B) -> bool: ...
        @typing.overload
        def remove(self, k: _Wrappers__JConcurrentMapWrapper__A) -> scala.Option[_Wrappers__JConcurrentMapWrapper__B]: ...
        @typing.overload
        def replace(self, k: _Wrappers__JConcurrentMapWrapper__A, oldvalue: _Wrappers__JConcurrentMapWrapper__B, newvalue: _Wrappers__JConcurrentMapWrapper__B) -> bool: ...
        @typing.overload
        def replace(self, k: _Wrappers__JConcurrentMapWrapper__A, v: _Wrappers__JConcurrentMapWrapper__B) -> scala.Option[_Wrappers__JConcurrentMapWrapper__B]: ...
        def repr(self) -> typing.Any: ...
        def result(self) -> scala.collection.mutable.Map[typing.Any, typing.Any]: ...
        def seq(self) -> scala.collection.mutable.Map[typing.Any, typing.Any]: ...
        def size(self) -> int: ...
        def thisCollection(self) -> scala.collection.Iterable[_Wrappers__JConcurrentMapWrapper__A]: ...
        def toCollection(self, repr: typing.Any) -> scala.collection.Iterable: ...
        def toIterable(self) -> scala.collection.Iterable[_Wrappers__JConcurrentMapWrapper__A]: ...
        def toSeq(self) -> scala.collection.Seq[scala.Tuple2[typing.Any, typing.Any]]: ...
        def toTraversable(self) -> scala.collection.Traversable[_Wrappers__JConcurrentMapWrapper__A]: ...
        def underlying(self) -> java.util.concurrent.ConcurrentMap[_Wrappers__JConcurrentMapWrapper__A, _Wrappers__JConcurrentMapWrapper__B]: ...
        def update(self, k: _Wrappers__JConcurrentMapWrapper__A, v: _Wrappers__JConcurrentMapWrapper__B) -> None: ...
        _updated__V1 = typing.TypeVar('_updated__V1')  # <V1>
        def updated(self, key: typing.Any, value: _updated__V1) -> scala.collection.mutable.Map[typing.Any, _updated__V1]: ...
        def values(self) -> scala.collection.Iterable[typing.Any]: ...
        @typing.overload
        def view(self) -> scala.collection.IterableView[_Wrappers__JConcurrentMapWrapper__A, scala.collection.Iterable[_Wrappers__JConcurrentMapWrapper__A]]: ...
        @typing.overload
        def view(self, from_: int, until: int) -> scala.collection.IterableView[_Wrappers__JConcurrentMapWrapper__A, scala.collection.Iterable[_Wrappers__JConcurrentMapWrapper__A]]: ...
    class JConcurrentMapWrapper$(scala.Serializable):
        def __init__(self, $outer: 'Wrappers'): ...
        _apply__A = typing.TypeVar('_apply__A')  # <A>
        _apply__B = typing.TypeVar('_apply__B')  # <B>
        def apply(self, underlying: java.util.concurrent.ConcurrentMap[_apply__A, _apply__B]) -> 'Wrappers.JConcurrentMapWrapper'[_apply__A, _apply__B]: ...
        def toString(self) -> java.lang.String: ...
        _unapply__A = typing.TypeVar('_unapply__A')  # <A>
        _unapply__B = typing.TypeVar('_unapply__B')  # <B>
        def unapply(self, x$0: 'Wrappers.JConcurrentMapWrapper'[_unapply__A, _unapply__B]) -> scala.Option[java.util.concurrent.ConcurrentMap[_unapply__A, _unapply__B]]: ...
    class JDictionaryWrapper(scala.collection.mutable.AbstractMap[_Wrappers__JDictionaryWrapper__A, _Wrappers__JDictionaryWrapper__B], scala.Product, scala.Serializable, typing.Generic[_Wrappers__JDictionaryWrapper__A, _Wrappers__JDictionaryWrapper__B]):
        $outer: 'Wrappers' = ...
        def __init__(self, $outer: 'Wrappers', underlying: java.util.Dictionary[_Wrappers__JDictionaryWrapper__A, _Wrappers__JDictionaryWrapper__B]): ...
        @typing.overload
        def $minus$eq(self, key: _Wrappers__JDictionaryWrapper__A) -> 'Wrappers.JDictionaryWrapper'[_Wrappers__JDictionaryWrapper__A, _Wrappers__JDictionaryWrapper__B]: ...
        @typing.overload
        def $minus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> scala.collection.generic.Shrinkable[typing.Any]: ...
        @typing.overload
        def $plus$eq(self, kv: scala.Tuple2[_Wrappers__JDictionaryWrapper__A, _Wrappers__JDictionaryWrapper__B]) -> 'Wrappers.JDictionaryWrapper'[_Wrappers__JDictionaryWrapper__A, _Wrappers__JDictionaryWrapper__B]: ...
        @typing.overload
        def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq) -> scala.collection.generic.Growable: ...
        def clear(self) -> None: ...
        _copy__A = typing.TypeVar('_copy__A')  # <A>
        _copy__B = typing.TypeVar('_copy__B')  # <B>
        def copy(self, underlying: java.util.Dictionary[typing.Any, typing.Any]) -> 'Wrappers.JDictionaryWrapper'[typing.Any, typing.Any]: ...
        _copy$default$1__A = typing.TypeVar('_copy$default$1__A')  # <A>
        _copy$default$1__B = typing.TypeVar('_copy$default$1__B')  # <B>
        def copy$default$1(self) -> java.util.Dictionary[typing.Any, typing.Any]: ...
        def get(self, k: _Wrappers__JDictionaryWrapper__A) -> scala.Option[_Wrappers__JDictionaryWrapper__B]: ...
        def iterator(self) -> scala.collection.Iterator[scala.Tuple2[_Wrappers__JDictionaryWrapper__A, _Wrappers__JDictionaryWrapper__B]]: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def put(self, k: _Wrappers__JDictionaryWrapper__A, v: _Wrappers__JDictionaryWrapper__B) -> scala.Option[_Wrappers__JDictionaryWrapper__B]: ...
        def remove(self, k: _Wrappers__JDictionaryWrapper__A) -> scala.Option[_Wrappers__JDictionaryWrapper__B]: ...
        def size(self) -> int: ...
        def underlying(self) -> java.util.Dictionary[_Wrappers__JDictionaryWrapper__A, _Wrappers__JDictionaryWrapper__B]: ...
        def update(self, k: _Wrappers__JDictionaryWrapper__A, v: _Wrappers__JDictionaryWrapper__B) -> None: ...
    class JDictionaryWrapper$(scala.Serializable):
        def __init__(self, $outer: 'Wrappers'): ...
        _apply__A = typing.TypeVar('_apply__A')  # <A>
        _apply__B = typing.TypeVar('_apply__B')  # <B>
        def apply(self, underlying: java.util.Dictionary[_apply__A, _apply__B]) -> 'Wrappers.JDictionaryWrapper'[_apply__A, _apply__B]: ...
        def toString(self) -> java.lang.String: ...
        _unapply__A = typing.TypeVar('_unapply__A')  # <A>
        _unapply__B = typing.TypeVar('_unapply__B')  # <B>
        def unapply(self, x$0: 'Wrappers.JDictionaryWrapper'[_unapply__A, _unapply__B]) -> scala.Option[java.util.Dictionary[_unapply__A, _unapply__B]]: ...
    class JEnumerationWrapper(scala.collection.AbstractIterator[_Wrappers__JEnumerationWrapper__A], scala.Product, scala.Serializable, typing.Generic[_Wrappers__JEnumerationWrapper__A]):
        $outer: 'Wrappers' = ...
        def __init__(self, $outer: 'Wrappers', underlying: java.util.Enumeration[_Wrappers__JEnumerationWrapper__A]): ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        _copy__A = typing.TypeVar('_copy__A')  # <A>
        def copy(self, underlying: java.util.Enumeration[typing.Any]) -> 'Wrappers.JEnumerationWrapper'[typing.Any]: ...
        _copy$default$1__A = typing.TypeVar('_copy$default$1__A')  # <A>
        def copy$default$1(self) -> java.util.Enumeration[typing.Any]: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def hasNext(self) -> bool: ...
        def hashCode(self) -> int: ...
        def next(self) -> _Wrappers__JEnumerationWrapper__A: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def underlying(self) -> java.util.Enumeration[_Wrappers__JEnumerationWrapper__A]: ...
    class JEnumerationWrapper$(scala.Serializable):
        def __init__(self, $outer: 'Wrappers'): ...
        _apply__A = typing.TypeVar('_apply__A')  # <A>
        def apply(self, underlying: java.util.Enumeration[_apply__A]) -> 'Wrappers.JEnumerationWrapper'[_apply__A]: ...
        def toString(self) -> java.lang.String: ...
        _unapply__A = typing.TypeVar('_unapply__A')  # <A>
        def unapply(self, x$0: 'Wrappers.JEnumerationWrapper'[_unapply__A]) -> scala.Option[java.util.Enumeration[_unapply__A]]: ...
    class JIterableWrapper(scala.collection.AbstractIterable[_Wrappers__JIterableWrapper__A], scala.Product, scala.Serializable, typing.Generic[_Wrappers__JIterableWrapper__A]):
        $outer: 'Wrappers' = ...
        def __init__(self, $outer: 'Wrappers', underlying: typing.Union[java.lang.Iterable[_Wrappers__JIterableWrapper__A], typing.Sequence[_Wrappers__JIterableWrapper__A], typing.Set[_Wrappers__JIterableWrapper__A]]): ...
        _copy__A = typing.TypeVar('_copy__A')  # <A>
        def copy(self, underlying: typing.Union[java.lang.Iterable[typing.Any], typing.Sequence[typing.Any], typing.Set[typing.Any]]) -> 'Wrappers.JIterableWrapper'[typing.Any]: ...
        _copy$default$1__A = typing.TypeVar('_copy$default$1__A')  # <A>
        def copy$default$1(self) -> java.lang.Iterable[typing.Any]: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def iterator(self) -> scala.collection.Iterator[_Wrappers__JIterableWrapper__A]: ...
        _newBuilder_0__B = typing.TypeVar('_newBuilder_0__B')  # <B>
        @typing.overload
        def newBuilder(self) -> scala.collection.mutable.ArrayBuffer[_newBuilder_0__B]: ...
        @typing.overload
        def newBuilder(self) -> scala.collection.mutable.Builder[_Wrappers__JIterableWrapper__A, scala.collection.Traversable[_Wrappers__JIterableWrapper__A]]: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def underlying(self) -> java.lang.Iterable[_Wrappers__JIterableWrapper__A]: ...
    class JIterableWrapper$(scala.Serializable):
        def __init__(self, $outer: 'Wrappers'): ...
        _apply__A = typing.TypeVar('_apply__A')  # <A>
        def apply(self, underlying: typing.Union[java.lang.Iterable[_apply__A], typing.Sequence[_apply__A], typing.Set[_apply__A]]) -> 'Wrappers.JIterableWrapper'[_apply__A]: ...
        def toString(self) -> java.lang.String: ...
        _unapply__A = typing.TypeVar('_unapply__A')  # <A>
        def unapply(self, x$0: 'Wrappers.JIterableWrapper'[_unapply__A]) -> scala.Option[java.lang.Iterable[_unapply__A]]: ...
    class JIteratorWrapper(scala.collection.AbstractIterator[_Wrappers__JIteratorWrapper__A], scala.Product, scala.Serializable, typing.Generic[_Wrappers__JIteratorWrapper__A]):
        $outer: 'Wrappers' = ...
        def __init__(self, $outer: 'Wrappers', underlying: java.util.Iterator[_Wrappers__JIteratorWrapper__A]): ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        _copy__A = typing.TypeVar('_copy__A')  # <A>
        def copy(self, underlying: java.util.Iterator[typing.Any]) -> 'Wrappers.JIteratorWrapper'[typing.Any]: ...
        _copy$default$1__A = typing.TypeVar('_copy$default$1__A')  # <A>
        def copy$default$1(self) -> java.util.Iterator[typing.Any]: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def hasNext(self) -> bool: ...
        def hashCode(self) -> int: ...
        def next(self) -> _Wrappers__JIteratorWrapper__A: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def underlying(self) -> java.util.Iterator[_Wrappers__JIteratorWrapper__A]: ...
    class JIteratorWrapper$(scala.Serializable):
        def __init__(self, $outer: 'Wrappers'): ...
        _apply__A = typing.TypeVar('_apply__A')  # <A>
        def apply(self, underlying: java.util.Iterator[_apply__A]) -> 'Wrappers.JIteratorWrapper'[_apply__A]: ...
        def toString(self) -> java.lang.String: ...
        _unapply__A = typing.TypeVar('_unapply__A')  # <A>
        def unapply(self, x$0: 'Wrappers.JIteratorWrapper'[_unapply__A]) -> scala.Option[java.util.Iterator[_unapply__A]]: ...
    class JListWrapper(scala.collection.mutable.AbstractBuffer[_Wrappers__JListWrapper__A], scala.Product, scala.Serializable, typing.Generic[_Wrappers__JListWrapper__A]):
        $outer: 'Wrappers' = ...
        def __init__(self, $outer: 'Wrappers', underlying: java.util.List[_Wrappers__JListWrapper__A]): ...
        @typing.overload
        def $plus$eq(self, elem: _Wrappers__JListWrapper__A) -> 'Wrappers.JListWrapper'[_Wrappers__JListWrapper__A]: ...
        @typing.overload
        def $plus$eq(self, elem1: _Wrappers__JListWrapper__A, elem2: _Wrappers__JListWrapper__A, elems: scala.collection.Seq[_Wrappers__JListWrapper__A]) -> scala.collection.generic.Growable[_Wrappers__JListWrapper__A]: ...
        def $plus$eq$colon(self, elem: _Wrappers__JListWrapper__A) -> 'Wrappers.JListWrapper'[_Wrappers__JListWrapper__A]: ...
        def apply(self, i: int) -> _Wrappers__JListWrapper__A: ...
        def clear(self) -> None: ...
        def clone(self) -> 'Wrappers.JListWrapper'[_Wrappers__JListWrapper__A]: ...
        _copy__A = typing.TypeVar('_copy__A')  # <A>
        def copy(self, underlying: java.util.List[typing.Any]) -> 'Wrappers.JListWrapper'[typing.Any]: ...
        _copy$default$1__A = typing.TypeVar('_copy$default$1__A')  # <A>
        def copy$default$1(self) -> java.util.List[typing.Any]: ...
        def insertAll(self, i: int, elems: scala.collection.Traversable[_Wrappers__JListWrapper__A]) -> None: ...
        def isEmpty(self) -> bool: ...
        def iterator(self) -> scala.collection.Iterator[_Wrappers__JListWrapper__A]: ...
        def length(self) -> int: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        @typing.overload
        def remove(self, i: int) -> _Wrappers__JListWrapper__A: ...
        @typing.overload
        def remove(self, n: int, count: int) -> None: ...
        def result(self) -> 'Wrappers.JListWrapper'[_Wrappers__JListWrapper__A]: ...
        def underlying(self) -> java.util.List[_Wrappers__JListWrapper__A]: ...
        def update(self, i: int, elem: _Wrappers__JListWrapper__A) -> None: ...
    class JListWrapper$(scala.Serializable):
        def __init__(self, $outer: 'Wrappers'): ...
        _apply__A = typing.TypeVar('_apply__A')  # <A>
        def apply(self, underlying: java.util.List[_apply__A]) -> 'Wrappers.JListWrapper'[_apply__A]: ...
        def toString(self) -> java.lang.String: ...
        _unapply__A = typing.TypeVar('_unapply__A')  # <A>
        def unapply(self, x$0: 'Wrappers.JListWrapper'[_unapply__A]) -> scala.Option[java.util.List[_unapply__A]]: ...
    class JMapWrapper(scala.collection.mutable.AbstractMap[_Wrappers__JMapWrapper__A, _Wrappers__JMapWrapper__B], scala.collection.convert.Wrappers.JMapWrapperLike[_Wrappers__JMapWrapper__A, _Wrappers__JMapWrapper__B, 'Wrappers.JMapWrapper'[_Wrappers__JMapWrapper__A, _Wrappers__JMapWrapper__B]], scala.Product, scala.Serializable, typing.Generic[_Wrappers__JMapWrapper__A, _Wrappers__JMapWrapper__B]):
        $outer: 'Wrappers' = ...
        def __init__(self, $outer: 'Wrappers', underlying: typing.Union[java.util.Map[_Wrappers__JMapWrapper__A, _Wrappers__JMapWrapper__B], typing.Mapping[_Wrappers__JMapWrapper__A, _Wrappers__JMapWrapper__B]]): ...
        @typing.overload
        def $minus(self, key: typing.Any) -> scala.collection.mutable.Map[typing.Any, typing.Any]: ...
        @typing.overload
        def $minus(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> scala.collection.mutable.Map[typing.Any, typing.Any]: ...
        @typing.overload
        def $minus$eq(self, key: _Wrappers__JMapWrapper__A) -> 'Wrappers.JMapWrapperLike'[_Wrappers__JMapWrapper__A, _Wrappers__JMapWrapper__B, 'Wrappers.JMapWrapper'[_Wrappers__JMapWrapper__A, _Wrappers__JMapWrapper__B]]: ...
        @typing.overload
        def $minus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> scala.collection.generic.Shrinkable[typing.Any]: ...
        def $minus$minus(self, xs: scala.collection.GenTraversableOnce[typing.Any]) -> scala.collection.mutable.Map[typing.Any, typing.Any]: ...
        _$plus_0__V1 = typing.TypeVar('_$plus_0__V1')  # <V1>
        _$plus_1__V1 = typing.TypeVar('_$plus_1__V1')  # <V1>
        @typing.overload
        def $plus(self, kv: scala.Tuple2[typing.Any, _.plus_0__V1]) -> scala.collection.mutable.Map[typing.Any, _.plus_0__V1]: ...
        @typing.overload
        def $plus(self, elem1: scala.Tuple2[typing.Any, _.plus_1__V1], elem2: scala.Tuple2[typing.Any, _.plus_1__V1], elems: scala.collection.Seq[scala.Tuple2[typing.Any, _.plus_1__V1]]) -> scala.collection.mutable.Map[typing.Any, _.plus_1__V1]: ...
        @typing.overload
        def $plus$eq(self, kv: scala.Tuple2[_Wrappers__JMapWrapper__A, _Wrappers__JMapWrapper__B]) -> 'Wrappers.JMapWrapperLike'[_Wrappers__JMapWrapper__A, _Wrappers__JMapWrapper__B, 'Wrappers.JMapWrapper'[_Wrappers__JMapWrapper__A, _Wrappers__JMapWrapper__B]]: ...
        @typing.overload
        def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq) -> scala.collection.generic.Growable: ...
        _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
        _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
        _$plus$plus_1__V1 = typing.TypeVar('_$plus$plus_1__V1')  # <V1>
        @typing.overload
        def $plus$plus(self, that: scala.collection.GenTraversableOnce[typing.Any], bf: scala.collection.generic.CanBuildFrom[scala.collection.Traversable[_Wrappers__JMapWrapper__A], typing.Any, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
        @typing.overload
        def $plus$plus(self, xs: scala.collection.GenTraversableOnce[scala.Tuple2[typing.Any, _.plus.plus_1__V1]]) -> scala.collection.mutable.Map[typing.Any, _.plus.plus_1__V1]: ...
        def clear(self) -> None: ...
        def clone(self) -> scala.collection.mutable.Map[typing.Any, typing.Any]: ...
        _copy__A = typing.TypeVar('_copy__A')  # <A>
        _copy__B = typing.TypeVar('_copy__B')  # <B>
        def copy(self, underlying: typing.Union[java.util.Map[typing.Any, typing.Any], typing.Mapping[typing.Any, typing.Any]]) -> 'Wrappers.JMapWrapper'[typing.Any, typing.Any]: ...
        _copy$default$1__A = typing.TypeVar('_copy$default$1__A')  # <A>
        _copy$default$1__B = typing.TypeVar('_copy$default$1__B')  # <B>
        def copy$default$1(self) -> java.util.Map[typing.Any, typing.Any]: ...
        def empty(self) -> 'Wrappers.JMapWrapper'[_Wrappers__JMapWrapper__A, _Wrappers__JMapWrapper__B]: ...
        def filterKeys(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.collection.Map[typing.Any, typing.Any]: ...
        def filterNot(self, p: scala.Function1[scala.Tuple2[typing.Any, typing.Any], typing.Any]) -> scala.collection.Map[typing.Any, typing.Any]: ...
        def get(self, k: _Wrappers__JMapWrapper__A) -> scala.Option[_Wrappers__JMapWrapper__B]: ...
        _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
        def groupBy(self, f: scala.Function1[_Wrappers__JMapWrapper__A, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[_Wrappers__JMapWrapper__A]]: ...
        def iterator(self) -> scala.collection.Iterator[scala.Tuple2[_Wrappers__JMapWrapper__A, _Wrappers__JMapWrapper__B]]: ...
        def keySet(self) -> scala.collection.Set[typing.Any]: ...
        def keys(self) -> scala.collection.Iterable[typing.Any]: ...
        _mapValues__W = typing.TypeVar('_mapValues__W')  # <W>
        def mapValues(self, f: scala.Function1[typing.Any, _mapValues__W]) -> scala.collection.Map[typing.Any, _mapValues__W]: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def put(self, k: _Wrappers__JMapWrapper__A, v: _Wrappers__JMapWrapper__B) -> scala.Option[_Wrappers__JMapWrapper__B]: ...
        def remove(self, k: _Wrappers__JMapWrapper__A) -> scala.Option[_Wrappers__JMapWrapper__B]: ...
        def repr(self) -> typing.Any: ...
        def result(self) -> scala.collection.mutable.Map[typing.Any, typing.Any]: ...
        def seq(self) -> scala.collection.mutable.Map[typing.Any, typing.Any]: ...
        def size(self) -> int: ...
        def thisCollection(self) -> scala.collection.Iterable[_Wrappers__JMapWrapper__A]: ...
        def toCollection(self, repr: typing.Any) -> scala.collection.Iterable: ...
        def toIterable(self) -> scala.collection.Iterable[_Wrappers__JMapWrapper__A]: ...
        def toSeq(self) -> scala.collection.Seq[scala.Tuple2[typing.Any, typing.Any]]: ...
        def toTraversable(self) -> scala.collection.Traversable[_Wrappers__JMapWrapper__A]: ...
        def underlying(self) -> java.util.Map[_Wrappers__JMapWrapper__A, _Wrappers__JMapWrapper__B]: ...
        def update(self, k: _Wrappers__JMapWrapper__A, v: _Wrappers__JMapWrapper__B) -> None: ...
        _updated__V1 = typing.TypeVar('_updated__V1')  # <V1>
        def updated(self, key: typing.Any, value: _updated__V1) -> scala.collection.mutable.Map[typing.Any, _updated__V1]: ...
        def values(self) -> scala.collection.Iterable[typing.Any]: ...
        @typing.overload
        def view(self) -> scala.collection.IterableView[_Wrappers__JMapWrapper__A, scala.collection.Iterable[_Wrappers__JMapWrapper__A]]: ...
        @typing.overload
        def view(self, from_: int, until: int) -> scala.collection.IterableView[_Wrappers__JMapWrapper__A, scala.collection.Iterable[_Wrappers__JMapWrapper__A]]: ...
    class JMapWrapper$(scala.Serializable):
        def __init__(self, $outer: 'Wrappers'): ...
        _apply__A = typing.TypeVar('_apply__A')  # <A>
        _apply__B = typing.TypeVar('_apply__B')  # <B>
        def apply(self, underlying: typing.Union[java.util.Map[_apply__A, _apply__B], typing.Mapping[_apply__A, _apply__B]]) -> 'Wrappers.JMapWrapper'[_apply__A, _apply__B]: ...
        def toString(self) -> java.lang.String: ...
        _unapply__A = typing.TypeVar('_unapply__A')  # <A>
        _unapply__B = typing.TypeVar('_unapply__B')  # <B>
        def unapply(self, x$0: 'Wrappers.JMapWrapper'[_unapply__A, _unapply__B]) -> scala.Option[java.util.Map[_unapply__A, _unapply__B]]: ...
    class JMapWrapperLike(scala.collection.mutable.Map[_Wrappers__JMapWrapperLike__A, _Wrappers__JMapWrapperLike__B], typing.Generic[_Wrappers__JMapWrapperLike__A, _Wrappers__JMapWrapperLike__B, _Wrappers__JMapWrapperLike__Repr]):
        @staticmethod
        def $init$($this: 'Wrappers.JMapWrapperLike') -> None: ...
        @typing.overload
        def $minus$eq(self, elem: _Wrappers__JMapWrapperLike__A) -> scala.collection.generic.Shrinkable[_Wrappers__JMapWrapperLike__A]: ...
        @typing.overload
        def $minus$eq(self, key: typing.Any) -> scala.collection.mutable.MapLike[typing.Any, typing.Any, scala.collection.mutable.MapLike]: ...
        @typing.overload
        def $minus$eq(self, key: _Wrappers__JMapWrapperLike__A) -> 'Wrappers.JMapWrapperLike'[_Wrappers__JMapWrapperLike__A, _Wrappers__JMapWrapperLike__B, _Wrappers__JMapWrapperLike__Repr]: ...
        @typing.overload
        def $minus$eq(self, elem1: _Wrappers__JMapWrapperLike__A, elem2: _Wrappers__JMapWrapperLike__A, elems: scala.collection.Seq[_Wrappers__JMapWrapperLike__A]) -> scala.collection.generic.Shrinkable[_Wrappers__JMapWrapperLike__A]: ...
        @typing.overload
        def $plus$eq(self, elem: _Wrappers__JMapWrapperLike__A) -> scala.collection.generic.Growable[_Wrappers__JMapWrapperLike__A]: ...
        @typing.overload
        def $plus$eq(self, elem: typing.Any) -> scala.collection.mutable.Builder[typing.Any, typing.Any]: ...
        @typing.overload
        def $plus$eq(self, kv: scala.Tuple2[typing.Any, typing.Any]) -> scala.collection.mutable.MapLike[typing.Any, typing.Any, scala.collection.mutable.MapLike]: ...
        @typing.overload
        def $plus$eq(self, kv: scala.Tuple2[_Wrappers__JMapWrapperLike__A, _Wrappers__JMapWrapperLike__B]) -> 'Wrappers.JMapWrapperLike'[_Wrappers__JMapWrapperLike__A, _Wrappers__JMapWrapperLike__B, _Wrappers__JMapWrapperLike__Repr]: ...
        @typing.overload
        def $plus$eq(self, elem1: _Wrappers__JMapWrapperLike__A, elem2: _Wrappers__JMapWrapperLike__A, elems: scala.collection.Seq[_Wrappers__JMapWrapperLike__A]) -> scala.collection.generic.Growable[_Wrappers__JMapWrapperLike__A]: ...
        def clear(self) -> None: ...
        @typing.overload
        def empty(self) -> scala.collection.Map[typing.Any, typing.Any]: ...
        @typing.overload
        def empty(self) -> _Wrappers__JMapWrapperLike__Repr: ...
        def equals(self, that: typing.Any) -> bool: ...
        def get(self, k: _Wrappers__JMapWrapperLike__A) -> scala.Option[_Wrappers__JMapWrapperLike__B]: ...
        def hashCode(self) -> int: ...
        def iterator(self) -> scala.collection.Iterator[scala.Tuple2[_Wrappers__JMapWrapperLike__A, _Wrappers__JMapWrapperLike__B]]: ...
        def put(self, k: _Wrappers__JMapWrapperLike__A, v: _Wrappers__JMapWrapperLike__B) -> scala.Option[_Wrappers__JMapWrapperLike__B]: ...
        def remove(self, k: _Wrappers__JMapWrapperLike__A) -> scala.Option[_Wrappers__JMapWrapperLike__B]: ...
        def size(self) -> int: ...
        def toString(self) -> java.lang.String: ...
        def underlying(self) -> java.util.Map[_Wrappers__JMapWrapperLike__A, _Wrappers__JMapWrapperLike__B]: ...
        def update(self, k: _Wrappers__JMapWrapperLike__A, v: _Wrappers__JMapWrapperLike__B) -> None: ...
    class JPropertiesWrapper(scala.collection.mutable.AbstractMap[java.lang.String, java.lang.String], scala.Product, scala.Serializable):
        $outer: 'Wrappers' = ...
        def __init__(self, $outer: 'Wrappers', underlying: java.util.Properties): ...
        @typing.overload
        def $minus(self, key: typing.Any) -> scala.collection.mutable.Map[typing.Any, typing.Any]: ...
        @typing.overload
        def $minus(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> scala.collection.mutable.Map[typing.Any, typing.Any]: ...
        @typing.overload
        def $minus$eq(self, key: typing.Union[java.lang.String, str]) -> 'Wrappers.JPropertiesWrapper': ...
        @typing.overload
        def $minus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq[typing.Any]) -> scala.collection.generic.Shrinkable[typing.Any]: ...
        def $minus$minus(self, xs: scala.collection.GenTraversableOnce[typing.Any]) -> scala.collection.mutable.Map[typing.Any, typing.Any]: ...
        _$plus_0__V1 = typing.TypeVar('_$plus_0__V1')  # <V1>
        _$plus_1__V1 = typing.TypeVar('_$plus_1__V1')  # <V1>
        @typing.overload
        def $plus(self, kv: scala.Tuple2[typing.Any, _.plus_0__V1]) -> scala.collection.mutable.Map[typing.Any, _.plus_0__V1]: ...
        @typing.overload
        def $plus(self, elem1: scala.Tuple2[typing.Any, _.plus_1__V1], elem2: scala.Tuple2[typing.Any, _.plus_1__V1], elems: scala.collection.Seq[scala.Tuple2[typing.Any, _.plus_1__V1]]) -> scala.collection.mutable.Map[typing.Any, _.plus_1__V1]: ...
        @typing.overload
        def $plus$eq(self, kv: scala.Tuple2[typing.Union[java.lang.String, str], typing.Union[java.lang.String, str]]) -> 'Wrappers.JPropertiesWrapper': ...
        @typing.overload
        def $plus$eq(self, elem1: typing.Any, elem2: typing.Any, elems: scala.collection.Seq) -> scala.collection.generic.Growable: ...
        _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
        _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
        _$plus$plus_1__V1 = typing.TypeVar('_$plus$plus_1__V1')  # <V1>
        @typing.overload
        def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus_0__B], bf: scala.collection.generic.CanBuildFrom[scala.collection.Traversable[typing.Any], _.plus.plus_0__B, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
        @typing.overload
        def $plus$plus(self, xs: scala.collection.GenTraversableOnce[scala.Tuple2[typing.Any, _.plus.plus_1__V1]]) -> scala.collection.mutable.Map[typing.Any, _.plus.plus_1__V1]: ...
        def clear(self) -> None: ...
        def clone(self) -> scala.collection.mutable.Map[typing.Any, typing.Any]: ...
        def copy(self, underlying: java.util.Properties) -> 'Wrappers.JPropertiesWrapper': ...
        def copy$default$1(self) -> java.util.Properties: ...
        def empty(self) -> 'Wrappers.JPropertiesWrapper': ...
        def filterKeys(self, p: scala.Function1[typing.Any, typing.Any]) -> scala.collection.Map[typing.Any, typing.Any]: ...
        def filterNot(self, p: scala.Function1[scala.Tuple2[typing.Any, typing.Any], typing.Any]) -> scala.collection.Map[typing.Any, typing.Any]: ...
        def get(self, k: typing.Union[java.lang.String, str]) -> scala.Option[java.lang.String]: ...
        @typing.overload
        def getProperty(self, key: typing.Union[java.lang.String, str]) -> java.lang.String: ...
        @typing.overload
        def getProperty(self, key: typing.Union[java.lang.String, str], defaultValue: typing.Union[java.lang.String, str]) -> java.lang.String: ...
        _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
        def groupBy(self, f: scala.Function1[typing.Any, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[typing.Any]]: ...
        def iterator(self) -> scala.collection.Iterator[scala.Tuple2[java.lang.String, java.lang.String]]: ...
        def keySet(self) -> scala.collection.Set[typing.Any]: ...
        def keys(self) -> scala.collection.Iterable[typing.Any]: ...
        _mapValues__W = typing.TypeVar('_mapValues__W')  # <W>
        def mapValues(self, f: scala.Function1[typing.Any, _mapValues__W]) -> scala.collection.Map[typing.Any, _mapValues__W]: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def put(self, k: typing.Union[java.lang.String, str], v: typing.Union[java.lang.String, str]) -> scala.Option[java.lang.String]: ...
        def remove(self, k: typing.Union[java.lang.String, str]) -> scala.Option[java.lang.String]: ...
        def repr(self) -> typing.Any: ...
        def result(self) -> scala.collection.mutable.Map[typing.Any, typing.Any]: ...
        def seq(self) -> scala.collection.mutable.Map[typing.Any, typing.Any]: ...
        def setProperty(self, key: typing.Union[java.lang.String, str], value: typing.Union[java.lang.String, str]) -> typing.Any: ...
        def size(self) -> int: ...
        def thisCollection(self) -> scala.collection.Iterable[typing.Any]: ...
        def toCollection(self, repr: typing.Any) -> scala.collection.Iterable: ...
        def toIterable(self) -> scala.collection.Iterable[typing.Any]: ...
        def toSeq(self) -> scala.collection.Seq[scala.Tuple2[typing.Any, typing.Any]]: ...
        def toTraversable(self) -> scala.collection.Traversable[typing.Any]: ...
        def underlying(self) -> java.util.Properties: ...
        def update(self, k: typing.Union[java.lang.String, str], v: typing.Union[java.lang.String, str]) -> None: ...
        _updated__V1 = typing.TypeVar('_updated__V1')  # <V1>
        def updated(self, key: typing.Any, value: _updated__V1) -> scala.collection.mutable.Map[typing.Any, _updated__V1]: ...
        def values(self) -> scala.collection.Iterable[typing.Any]: ...
        @typing.overload
        def view(self) -> scala.collection.IterableView[typing.Any, scala.collection.Iterable[typing.Any]]: ...
        @typing.overload
        def view(self, from_: int, until: int) -> scala.collection.IterableView[typing.Any, scala.collection.Iterable[typing.Any]]: ...
    class JPropertiesWrapper$(scala.runtime.AbstractFunction1[java.util.Properties, 'Wrappers.JPropertiesWrapper'], scala.Serializable):
        def __init__(self, $outer: 'Wrappers'): ...
        def apply(self, underlying: java.util.Properties) -> 'Wrappers.JPropertiesWrapper': ...
        def toString(self) -> java.lang.String: ...
        def unapply(self, x$0: 'Wrappers.JPropertiesWrapper') -> scala.Option[java.util.Properties]: ...
    class JSetWrapper(scala.collection.mutable.AbstractSet[_Wrappers__JSetWrapper__A], scala.Product, scala.Serializable, typing.Generic[_Wrappers__JSetWrapper__A]):
        $outer: 'Wrappers' = ...
        def __init__(self, $outer: 'Wrappers', underlying: java.util.Set[_Wrappers__JSetWrapper__A]): ...
        @typing.overload
        def $minus(self, elem: _Wrappers__JSetWrapper__A) -> scala.collection.mutable.Set[_Wrappers__JSetWrapper__A]: ...
        @typing.overload
        def $minus(self, elem1: _Wrappers__JSetWrapper__A, elem2: _Wrappers__JSetWrapper__A, elems: scala.collection.Seq[_Wrappers__JSetWrapper__A]) -> scala.collection.mutable.Set[_Wrappers__JSetWrapper__A]: ...
        @typing.overload
        def $minus$eq(self, elem: _Wrappers__JSetWrapper__A) -> 'Wrappers.JSetWrapper'[_Wrappers__JSetWrapper__A]: ...
        @typing.overload
        def $minus$eq(self, elem1: _Wrappers__JSetWrapper__A, elem2: _Wrappers__JSetWrapper__A, elems: scala.collection.Seq[_Wrappers__JSetWrapper__A]) -> scala.collection.generic.Shrinkable[_Wrappers__JSetWrapper__A]: ...
        def $minus$minus(self, xs: scala.collection.GenTraversableOnce[_Wrappers__JSetWrapper__A]) -> scala.collection.mutable.Set[_Wrappers__JSetWrapper__A]: ...
        @typing.overload
        def $plus(self, elem: _Wrappers__JSetWrapper__A) -> scala.collection.mutable.Set[_Wrappers__JSetWrapper__A]: ...
        @typing.overload
        def $plus(self, elem1: _Wrappers__JSetWrapper__A, elem2: _Wrappers__JSetWrapper__A, elems: scala.collection.Seq[_Wrappers__JSetWrapper__A]) -> scala.collection.mutable.Set[_Wrappers__JSetWrapper__A]: ...
        @typing.overload
        def $plus$eq(self, elem: _Wrappers__JSetWrapper__A) -> 'Wrappers.JSetWrapper'[_Wrappers__JSetWrapper__A]: ...
        @typing.overload
        def $plus$eq(self, elem1: _Wrappers__JSetWrapper__A, elem2: _Wrappers__JSetWrapper__A, elems: scala.collection.Seq[_Wrappers__JSetWrapper__A]) -> scala.collection.generic.Growable[_Wrappers__JSetWrapper__A]: ...
        _$plus$plus_0__B = typing.TypeVar('_$plus$plus_0__B')  # <B>
        _$plus$plus_0__That = typing.TypeVar('_$plus$plus_0__That')  # <That>
        @typing.overload
        def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus_0__B], bf: scala.collection.generic.CanBuildFrom[scala.collection.Traversable[_Wrappers__JSetWrapper__A], _.plus.plus_0__B, _.plus.plus_0__That]) -> _.plus.plus_0__That: ...
        @typing.overload
        def $plus$plus(self, xs: scala.collection.GenTraversableOnce[_Wrappers__JSetWrapper__A]) -> scala.collection.mutable.Set[_Wrappers__JSetWrapper__A]: ...
        def add(self, elem: _Wrappers__JSetWrapper__A) -> bool: ...
        def apply(self, elem: _Wrappers__JSetWrapper__A) -> bool: ...
        def clear(self) -> None: ...
        def clone(self) -> 'Wrappers.JSetWrapper'[_Wrappers__JSetWrapper__A]: ...
        def contains(self, elem: _Wrappers__JSetWrapper__A) -> bool: ...
        _copy__A = typing.TypeVar('_copy__A')  # <A>
        def copy(self, underlying: java.util.Set[typing.Any]) -> 'Wrappers.JSetWrapper'[typing.Any]: ...
        _copy$default$1__A = typing.TypeVar('_copy$default$1__A')  # <A>
        def copy$default$1(self) -> java.util.Set[typing.Any]: ...
        def diff(self, that: scala.collection.GenSet) -> scala.collection.Set: ...
        def empty(self) -> 'Wrappers.JSetWrapper'[_Wrappers__JSetWrapper__A]: ...
        _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
        def groupBy(self, f: scala.Function1[_Wrappers__JSetWrapper__A, _groupBy__K]) -> scala.collection.immutable.Map[_groupBy__K, scala.collection.Traversable[_Wrappers__JSetWrapper__A]]: ...
        def iterator(self) -> scala.collection.Iterator[_Wrappers__JSetWrapper__A]: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def remove(self, elem: _Wrappers__JSetWrapper__A) -> bool: ...
        def repr(self) -> typing.Any: ...
        def result(self) -> scala.collection.mutable.Set[_Wrappers__JSetWrapper__A]: ...
        def seq(self) -> scala.collection.mutable.Set[_Wrappers__JSetWrapper__A]: ...
        def size(self) -> int: ...
        def thisCollection(self) -> scala.collection.Iterable[_Wrappers__JSetWrapper__A]: ...
        def toCollection(self, repr: typing.Any) -> scala.collection.Iterable: ...
        def toIterable(self) -> scala.collection.Iterable[_Wrappers__JSetWrapper__A]: ...
        def toSeq(self) -> scala.collection.Seq[_Wrappers__JSetWrapper__A]: ...
        def toTraversable(self) -> scala.collection.Traversable[_Wrappers__JSetWrapper__A]: ...
        def underlying(self) -> java.util.Set[_Wrappers__JSetWrapper__A]: ...
        def union(self, that: scala.collection.GenSet) -> scala.collection.Set: ...
        @typing.overload
        def view(self) -> scala.collection.IterableView[_Wrappers__JSetWrapper__A, scala.collection.Iterable[_Wrappers__JSetWrapper__A]]: ...
        @typing.overload
        def view(self, from_: int, until: int) -> scala.collection.IterableView[_Wrappers__JSetWrapper__A, scala.collection.Iterable[_Wrappers__JSetWrapper__A]]: ...
    class JSetWrapper$(scala.Serializable):
        def __init__(self, $outer: 'Wrappers'): ...
        _apply__A = typing.TypeVar('_apply__A')  # <A>
        def apply(self, underlying: java.util.Set[_apply__A]) -> 'Wrappers.JSetWrapper'[_apply__A]: ...
        def toString(self) -> java.lang.String: ...
        _unapply__A = typing.TypeVar('_unapply__A')  # <A>
        def unapply(self, x$0: 'Wrappers.JSetWrapper'[_unapply__A]) -> scala.Option[java.util.Set[_unapply__A]]: ...
    class MapWrapper(java.util.AbstractMap[_Wrappers__MapWrapper__A, _Wrappers__MapWrapper__B], scala.Serializable, typing.Generic[_Wrappers__MapWrapper__A, _Wrappers__MapWrapper__B]):
        serialVersionUID: typing.ClassVar[int] = ...
        scala$collection$convert$Wrappers$MapWrapper$$underlying: scala.collection.Map = ...
        $outer: 'Wrappers' = ...
        def __init__(self, $outer: 'Wrappers', underlying: scala.collection.Map[_Wrappers__MapWrapper__A, _Wrappers__MapWrapper__B]): ...
        def containsKey(self, key: typing.Any) -> bool: ...
        def entrySet(self) -> java.util.Set[java.util.Map.Entry[_Wrappers__MapWrapper__A, _Wrappers__MapWrapper__B]]: ...
        def get(self, key: typing.Any) -> _Wrappers__MapWrapper__B: ...
        def size(self) -> int: ...
    class MutableBufferWrapper(java.util.AbstractList[_Wrappers__MutableBufferWrapper__A], scala.collection.convert.Wrappers.IterableWrapperTrait[_Wrappers__MutableBufferWrapper__A], scala.Product, scala.Serializable, typing.Generic[_Wrappers__MutableBufferWrapper__A]):
        $outer: 'Wrappers' = ...
        def __init__(self, $outer: 'Wrappers', underlying: scala.collection.mutable.Buffer[_Wrappers__MutableBufferWrapper__A]): ...
        @typing.overload
        def add(self, elem: _Wrappers__MutableBufferWrapper__A) -> bool: ...
        @typing.overload
        def add(self, int: int, e: typing.Any) -> None: ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        _copy__A = typing.TypeVar('_copy__A')  # <A>
        def copy(self, underlying: scala.collection.mutable.Buffer[typing.Any]) -> 'Wrappers.MutableBufferWrapper'[typing.Any]: ...
        _copy$default$1__A = typing.TypeVar('_copy$default$1__A')  # <A>
        def copy$default$1(self) -> scala.collection.mutable.Buffer[typing.Any]: ...
        def get(self, i: int) -> _Wrappers__MutableBufferWrapper__A: ...
        def isEmpty(self) -> bool: ...
        def iterator(self) -> 'Wrappers.IteratorWrapper'[_Wrappers__MutableBufferWrapper__A]: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def set(self, i: int, elem: _Wrappers__MutableBufferWrapper__A) -> _Wrappers__MutableBufferWrapper__A: ...
        def size(self) -> int: ...
        def underlying(self) -> scala.collection.mutable.Buffer[_Wrappers__MutableBufferWrapper__A]: ...
    class MutableBufferWrapper$(scala.Serializable):
        def __init__(self, $outer: 'Wrappers'): ...
        _apply__A = typing.TypeVar('_apply__A')  # <A>
        def apply(self, underlying: scala.collection.mutable.Buffer[_apply__A]) -> 'Wrappers.MutableBufferWrapper'[_apply__A]: ...
        def toString(self) -> java.lang.String: ...
        _unapply__A = typing.TypeVar('_unapply__A')  # <A>
        def unapply(self, x$0: 'Wrappers.MutableBufferWrapper'[_unapply__A]) -> scala.Option[scala.collection.mutable.Buffer[_unapply__A]]: ...
    class MutableMapWrapper(scala.collection.convert.Wrappers.MapWrapper[_Wrappers__MutableMapWrapper__A, _Wrappers__MutableMapWrapper__B], scala.Product, typing.Generic[_Wrappers__MutableMapWrapper__A, _Wrappers__MutableMapWrapper__B]):
        def __init__(self, $outer: 'Wrappers', underlying: scala.collection.mutable.Map[_Wrappers__MutableMapWrapper__A, _Wrappers__MutableMapWrapper__B]): ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        def clear(self) -> None: ...
        _copy__A = typing.TypeVar('_copy__A')  # <A>
        _copy__B = typing.TypeVar('_copy__B')  # <B>
        def copy(self, underlying: scala.collection.mutable.Map[typing.Any, typing.Any]) -> 'Wrappers.MutableMapWrapper'[typing.Any, typing.Any]: ...
        _copy$default$1__A = typing.TypeVar('_copy$default$1__A')  # <A>
        _copy$default$1__B = typing.TypeVar('_copy$default$1__B')  # <B>
        def copy$default$1(self) -> scala.collection.mutable.Map[typing.Any, typing.Any]: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def put(self, k: _Wrappers__MutableMapWrapper__A, v: _Wrappers__MutableMapWrapper__B) -> _Wrappers__MutableMapWrapper__B: ...
        @typing.overload
        def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
        @typing.overload
        def remove(self, k: typing.Any) -> _Wrappers__MutableMapWrapper__B: ...
        def underlying(self) -> scala.collection.mutable.Map[_Wrappers__MutableMapWrapper__A, _Wrappers__MutableMapWrapper__B]: ...
    class MutableMapWrapper$(scala.Serializable):
        def __init__(self, $outer: 'Wrappers'): ...
        _apply__A = typing.TypeVar('_apply__A')  # <A>
        _apply__B = typing.TypeVar('_apply__B')  # <B>
        def apply(self, underlying: scala.collection.mutable.Map[_apply__A, _apply__B]) -> 'Wrappers.MutableMapWrapper'[_apply__A, _apply__B]: ...
        def toString(self) -> java.lang.String: ...
        _unapply__A = typing.TypeVar('_unapply__A')  # <A>
        _unapply__B = typing.TypeVar('_unapply__B')  # <B>
        def unapply(self, x$0: 'Wrappers.MutableMapWrapper'[_unapply__A, _unapply__B]) -> scala.Option[scala.collection.mutable.Map[_unapply__A, _unapply__B]]: ...
    class MutableSeqWrapper(java.util.AbstractList[_Wrappers__MutableSeqWrapper__A], scala.collection.convert.Wrappers.IterableWrapperTrait[_Wrappers__MutableSeqWrapper__A], scala.Product, scala.Serializable, typing.Generic[_Wrappers__MutableSeqWrapper__A]):
        $outer: 'Wrappers' = ...
        def __init__(self, $outer: 'Wrappers', underlying: scala.collection.mutable.Seq[_Wrappers__MutableSeqWrapper__A]): ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        _copy__A = typing.TypeVar('_copy__A')  # <A>
        def copy(self, underlying: scala.collection.mutable.Seq[typing.Any]) -> 'Wrappers.MutableSeqWrapper'[typing.Any]: ...
        _copy$default$1__A = typing.TypeVar('_copy$default$1__A')  # <A>
        def copy$default$1(self) -> scala.collection.mutable.Seq[typing.Any]: ...
        def get(self, i: int) -> _Wrappers__MutableSeqWrapper__A: ...
        def isEmpty(self) -> bool: ...
        def iterator(self) -> 'Wrappers.IteratorWrapper'[_Wrappers__MutableSeqWrapper__A]: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def set(self, i: int, elem: _Wrappers__MutableSeqWrapper__A) -> _Wrappers__MutableSeqWrapper__A: ...
        def size(self) -> int: ...
        def underlying(self) -> scala.collection.mutable.Seq[_Wrappers__MutableSeqWrapper__A]: ...
    class MutableSeqWrapper$(scala.Serializable):
        def __init__(self, $outer: 'Wrappers'): ...
        _apply__A = typing.TypeVar('_apply__A')  # <A>
        def apply(self, underlying: scala.collection.mutable.Seq[_apply__A]) -> 'Wrappers.MutableSeqWrapper'[_apply__A]: ...
        def toString(self) -> java.lang.String: ...
        _unapply__A = typing.TypeVar('_unapply__A')  # <A>
        def unapply(self, x$0: 'Wrappers.MutableSeqWrapper'[_unapply__A]) -> scala.Option[scala.collection.mutable.Seq[_unapply__A]]: ...
    class MutableSetWrapper(scala.collection.convert.Wrappers.SetWrapper[_Wrappers__MutableSetWrapper__A], scala.Product, typing.Generic[_Wrappers__MutableSetWrapper__A]):
        def __init__(self, $outer: 'Wrappers', underlying: scala.collection.mutable.Set[_Wrappers__MutableSetWrapper__A]): ...
        def add(self, elem: _Wrappers__MutableSetWrapper__A) -> bool: ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        def clear(self) -> None: ...
        _copy__A = typing.TypeVar('_copy__A')  # <A>
        def copy(self, underlying: scala.collection.mutable.Set[typing.Any]) -> 'Wrappers.MutableSetWrapper'[typing.Any]: ...
        _copy$default$1__A = typing.TypeVar('_copy$default$1__A')  # <A>
        def copy$default$1(self) -> scala.collection.mutable.Set[typing.Any]: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def remove(self, elem: typing.Any) -> bool: ...
        def underlying(self) -> scala.collection.mutable.Set[_Wrappers__MutableSetWrapper__A]: ...
    class MutableSetWrapper$(scala.Serializable):
        def __init__(self, $outer: 'Wrappers'): ...
        _apply__A = typing.TypeVar('_apply__A')  # <A>
        def apply(self, underlying: scala.collection.mutable.Set[_apply__A]) -> 'Wrappers.MutableSetWrapper'[_apply__A]: ...
        def toString(self) -> java.lang.String: ...
        _unapply__A = typing.TypeVar('_unapply__A')  # <A>
        def unapply(self, x$0: 'Wrappers.MutableSetWrapper'[_unapply__A]) -> scala.Option[scala.collection.mutable.Set[_unapply__A]]: ...
    class SeqWrapper(java.util.AbstractList[_Wrappers__SeqWrapper__A], scala.collection.convert.Wrappers.IterableWrapperTrait[_Wrappers__SeqWrapper__A], scala.Product, scala.Serializable, typing.Generic[_Wrappers__SeqWrapper__A]):
        $outer: 'Wrappers' = ...
        def __init__(self, $outer: 'Wrappers', underlying: scala.collection.Seq[_Wrappers__SeqWrapper__A]): ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        _copy__A = typing.TypeVar('_copy__A')  # <A>
        def copy(self, underlying: scala.collection.Seq[typing.Any]) -> 'Wrappers.SeqWrapper'[typing.Any]: ...
        _copy$default$1__A = typing.TypeVar('_copy$default$1__A')  # <A>
        def copy$default$1(self) -> scala.collection.Seq[typing.Any]: ...
        def get(self, i: int) -> _Wrappers__SeqWrapper__A: ...
        def isEmpty(self) -> bool: ...
        def iterator(self) -> 'Wrappers.IteratorWrapper'[_Wrappers__SeqWrapper__A]: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def size(self) -> int: ...
        def underlying(self) -> scala.collection.Seq[_Wrappers__SeqWrapper__A]: ...
    class SeqWrapper$(scala.Serializable):
        def __init__(self, $outer: 'Wrappers'): ...
        _apply__A = typing.TypeVar('_apply__A')  # <A>
        def apply(self, underlying: scala.collection.Seq[_apply__A]) -> 'Wrappers.SeqWrapper'[_apply__A]: ...
        def toString(self) -> java.lang.String: ...
        _unapply__A = typing.TypeVar('_unapply__A')  # <A>
        def unapply(self, x$0: 'Wrappers.SeqWrapper'[_unapply__A]) -> scala.Option[scala.collection.Seq[_unapply__A]]: ...
    class SetWrapper(java.util.AbstractSet[_Wrappers__SetWrapper__A], scala.Serializable, typing.Generic[_Wrappers__SetWrapper__A]):
        serialVersionUID: typing.ClassVar[int] = ...
        scala$collection$convert$Wrappers$SetWrapper$$underlying: scala.collection.Set = ...
        $outer: 'Wrappers' = ...
        def __init__(self, $outer: 'Wrappers', underlying: scala.collection.Set[_Wrappers__SetWrapper__A]): ...
        def contains(self, o: typing.Any) -> bool: ...
        def isEmpty(self) -> bool: ...
        def iterator(self) -> java.util.Iterator[_Wrappers__SetWrapper__A]: ...
        def size(self) -> int: ...
    class ToIteratorWrapper(typing.Generic[_Wrappers__ToIteratorWrapper__A]):
        $outer: 'Wrappers' = ...
        def __init__(self, $outer: 'Wrappers', underlying: scala.collection.Iterator[_Wrappers__ToIteratorWrapper__A]): ...
        def asJava(self) -> 'Wrappers.IteratorWrapper'[_Wrappers__ToIteratorWrapper__A]: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("scala.collection.convert")``.

    AsJavaConverters: typing.Type[AsJavaConverters]
    AsScalaConverters: typing.Type[AsScalaConverters]
    DecorateAsJava: typing.Type[DecorateAsJava]
    DecorateAsScala: typing.Type[DecorateAsScala]
    Decorators: typing.Type[Decorators]
    ImplicitConversions: typing.Type[ImplicitConversions]
    ImplicitConversionsToJava: typing.Type[ImplicitConversionsToJava]
    ImplicitConversionsToScala: typing.Type[ImplicitConversionsToScala]
    LowPriorityWrapAsJava: typing.Type[LowPriorityWrapAsJava]
    LowPriorityWrapAsScala: typing.Type[LowPriorityWrapAsScala]
    ToJavaImplicits: typing.Type[ToJavaImplicits]
    ToScalaImplicits: typing.Type[ToScalaImplicits]
    WrapAsJava: typing.Type[WrapAsJava]
    WrapAsScala: typing.Type[WrapAsScala]
    Wrappers: typing.Type[Wrappers]
    package: typing.Type[package]
