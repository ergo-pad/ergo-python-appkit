import java.lang
import java.util.concurrent
import java.util.concurrent.atomic
import scala
import scala.collection
import scala.collection.generic
import scala.collection.immutable
import scala.collection.mutable
import scala.collection.parallel.immutable
import scala.collection.parallel.mutable
import scala.concurrent
import scala.math
import scala.reflect
import scala.runtime
import typing



_Combiner__Elem = typing.TypeVar('_Combiner__Elem')  # <Elem>
_Combiner__To = typing.TypeVar('_Combiner__To')  # <To>
class Combiner(scala.collection.mutable.Builder[_Combiner__Elem, _Combiner__To], scala.collection.generic.Sizing, scala.collection.Parallel, typing.Generic[_Combiner__Elem, _Combiner__To]):
    @staticmethod
    def $init$($this: 'Combiner') -> None: ...
    def _combinerTaskSupport(self) -> 'TaskSupport': ...
    def _combinerTaskSupport_$eq(self, x$1: 'TaskSupport') -> None: ...
    def canBeShared(self) -> bool: ...
    _combine__N = typing.TypeVar('_combine__N')  # <N>
    _combine__NewTo = typing.TypeVar('_combine__NewTo')  # <NewTo>
    def combine(self, other: 'Combiner'[_combine__N, _combine__NewTo]) -> 'Combiner'[_combine__N, _combine__NewTo]: ...
    def combinerTaskSupport(self) -> 'TaskSupport': ...
    def combinerTaskSupport_$eq(self, cts: 'TaskSupport') -> None: ...
    def resultWithTaskSupport(self) -> _Combiner__To: ...

_CombinerFactory__U = typing.TypeVar('_CombinerFactory__U')  # <U>
_CombinerFactory__Repr = typing.TypeVar('_CombinerFactory__Repr')  # <Repr>
class CombinerFactory(typing.Generic[_CombinerFactory__U, _CombinerFactory__Repr]):
    def apply(self) -> Combiner[_CombinerFactory__U, _CombinerFactory__Repr]: ...
    def doesShareCombiners(self) -> bool: ...

class CompositeThrowable(java.lang.Exception, scala.Product, scala.Serializable):
    def __init__(self, throwables: scala.collection.Set[java.lang.Throwable]): ...
    _andThen__A = typing.TypeVar('_andThen__A')  # <A>
    @staticmethod
    def andThen(g: scala.Function1['CompositeThrowable', _andThen__A]) -> scala.Function1[scala.collection.Set[java.lang.Throwable], _andThen__A]: ...
    @staticmethod
    def apply(throwables: scala.collection.Set[java.lang.Throwable]) -> 'CompositeThrowable': ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    @staticmethod
    def compose(g: scala.Function1[_compose__A, scala.collection.Set[java.lang.Throwable]]) -> scala.Function1[_compose__A, 'CompositeThrowable']: ...
    def copy(self, throwables: scala.collection.Set[java.lang.Throwable]) -> 'CompositeThrowable': ...
    def copy$default$1(self) -> scala.collection.Set[java.lang.Throwable]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def throwables(self) -> scala.collection.Set[java.lang.Throwable]: ...
    @staticmethod
    def unapply(x$0: 'CompositeThrowable') -> scala.Option[scala.collection.Set[java.lang.Throwable]]: ...

_FactoryOps__Otherwise__R = typing.TypeVar('_FactoryOps__Otherwise__R')  # <R>
_FactoryOps__From = typing.TypeVar('_FactoryOps__From')  # <From>
_FactoryOps__Elem = typing.TypeVar('_FactoryOps__Elem')  # <Elem>
_FactoryOps__To = typing.TypeVar('_FactoryOps__To')  # <To>
class FactoryOps(typing.Generic[_FactoryOps__From, _FactoryOps__Elem, _FactoryOps__To]):
    @staticmethod
    def $init$($this: 'FactoryOps') -> None: ...
    def asParallel(self) -> scala.collection.generic.CanCombineFrom[_FactoryOps__From, _FactoryOps__Elem, _FactoryOps__To]: ...
    _ifParallel__R = typing.TypeVar('_ifParallel__R')  # <R>
    def ifParallel(self, isbody: scala.Function1[scala.collection.generic.CanCombineFrom[_FactoryOps__From, _FactoryOps__Elem, _FactoryOps__To], _ifParallel__R]) -> 'FactoryOps.Otherwise'[_ifParallel__R]: ...
    def isParallel(self) -> bool: ...
    class Otherwise(typing.Generic[_FactoryOps__Otherwise__R]):
        def otherwise(self, notbody: scala.Function0[_FactoryOps__Otherwise__R]) -> _FactoryOps__Otherwise__R: ...

class FutureThreadPoolTasks:
    @staticmethod
    def defaultThreadPool() -> java.util.concurrent.ExecutorService: ...
    @staticmethod
    def numCores() -> int: ...
    @staticmethod
    def tcount() -> java.util.concurrent.atomic.AtomicLong: ...

class HavingForkJoinPool:
    def forkJoinPool(self) -> java.util.concurrent.ForkJoinPool: ...

class ParallelCollectionImplicits:
    _factory2ops__From = typing.TypeVar('_factory2ops__From')  # <From>
    _factory2ops__Elem = typing.TypeVar('_factory2ops__Elem')  # <Elem>
    _factory2ops__To = typing.TypeVar('_factory2ops__To')  # <To>
    @staticmethod
    def factory2ops(bf: scala.collection.generic.CanBuildFrom[_factory2ops__From, _factory2ops__Elem, _factory2ops__To]) -> FactoryOps[_factory2ops__From, _factory2ops__Elem, _factory2ops__To]: ...
    @staticmethod
    def throwable2ops(self) -> 'ThrowableOps': ...
    _traversable2ops__T = typing.TypeVar('_traversable2ops__T')  # <T>
    @staticmethod
    def traversable2ops(t: scala.collection.GenTraversableOnce[_traversable2ops__T]) -> 'TraversableOps'[_traversable2ops__T]: ...

_RemainsIterator__T = typing.TypeVar('_RemainsIterator__T')  # <T>
class RemainsIterator(scala.collection.Iterator[_RemainsIterator__T], typing.Generic[_RemainsIterator__T]):
    @staticmethod
    def $init$($this: 'RemainsIterator') -> None: ...
    def isRemainingCheap(self) -> bool: ...
    def remaining(self) -> int: ...
    def toString(self) -> java.lang.String: ...

_Splitter__T = typing.TypeVar('_Splitter__T')  # <T>
class Splitter(scala.collection.Iterator[_Splitter__T], typing.Generic[_Splitter__T]):
    _empty__T = typing.TypeVar('_empty__T')  # <T>
    @staticmethod
    def empty() -> 'Splitter'[_empty__T]: ...
    def split(self) -> scala.collection.Seq['Splitter'[_Splitter__T]]: ...
    def toString(self) -> java.lang.String: ...

_Task__R = typing.TypeVar('_Task__R')  # <R>
_Task__Tp = typing.TypeVar('_Task__Tp')  # <Tp>
class Task(typing.Generic[_Task__R, _Task__Tp]):
    @staticmethod
    def $init$($this: 'Task') -> None: ...
    def forwardThrowable(self) -> None: ...
    def leaf(self, result: scala.Option[_Task__R]) -> None: ...
    def merge(self, that: _Task__Tp) -> None: ...
    def mergeThrowables(self, that: 'Task'[typing.Any, typing.Any]) -> None: ...
    def repr(self) -> _Task__Tp: ...
    def result(self) -> _Task__R: ...
    def result_$eq(self, x$1: _Task__R) -> None: ...
    def shouldSplitFurther(self) -> bool: ...
    def signalAbort(self) -> None: ...
    def split(self) -> scala.collection.Seq['Task'[_Task__R, _Task__Tp]]: ...
    def throwable(self) -> java.lang.Throwable: ...
    def throwable_$eq(self, x$1: java.lang.Throwable) -> None: ...
    def tryLeaf(self, lastres: scala.Option[_Task__R]) -> None: ...
    def tryMerge(self, t: _Task__Tp) -> None: ...

_Tasks__WrappedTask__R = typing.TypeVar('_Tasks__WrappedTask__R')  # <R>
_Tasks__WrappedTask__Tp = typing.TypeVar('_Tasks__WrappedTask__Tp')  # <Tp>
class Tasks:
    @staticmethod
    def $init$($this: 'Tasks') -> None: ...
    def debugMessages(self) -> scala.collection.mutable.ArrayBuffer[java.lang.String]: ...
    def debuglog(self, s: typing.Union[java.lang.String, str]) -> scala.collection.mutable.ArrayBuffer[java.lang.String]: ...
    def environment(self) -> typing.Any: ...
    _execute__R = typing.TypeVar('_execute__R')  # <R>
    _execute__Tp = typing.TypeVar('_execute__Tp')  # <Tp>
    def execute(self, fjtask: Task[_execute__R, _execute__Tp]) -> scala.Function0[_execute__R]: ...
    _executeAndWaitResult__R = typing.TypeVar('_executeAndWaitResult__R')  # <R>
    _executeAndWaitResult__Tp = typing.TypeVar('_executeAndWaitResult__Tp')  # <Tp>
    def executeAndWaitResult(self, task: Task[_executeAndWaitResult__R, _executeAndWaitResult__Tp]) -> _executeAndWaitResult__R: ...
    def parallelismLevel(self) -> int: ...
    def scala$collection$parallel$Tasks$_setter_$debugMessages_$eq(self, x$1: scala.collection.mutable.ArrayBuffer[typing.Union[java.lang.String, str]]) -> None: ...
    class WrappedTask(typing.Generic[_Tasks__WrappedTask__R, _Tasks__WrappedTask__Tp]):
        @staticmethod
        def $init$($this: 'Tasks.WrappedTask') -> None: ...
        def body(self) -> Task[_Tasks__WrappedTask__R, _Tasks__WrappedTask__Tp]: ...
        def compute(self) -> None: ...
        def release(self) -> None: ...
        def split(self) -> scala.collection.Seq['Tasks.WrappedTask'[_Tasks__WrappedTask__R, _Tasks__WrappedTask__Tp]]: ...
        def start(self) -> None: ...
        def sync(self) -> None: ...
        def tryCancel(self) -> bool: ...

class ThrowableOps:
    def alongWith(self, that: java.lang.Throwable) -> java.lang.Throwable: ...

_TraversableOps__Otherwise__R = typing.TypeVar('_TraversableOps__Otherwise__R')  # <R>
_TraversableOps__T = typing.TypeVar('_TraversableOps__T')  # <T>
class TraversableOps(typing.Generic[_TraversableOps__T]):
    @staticmethod
    def $init$($this: 'TraversableOps') -> None: ...
    def asParIterable(self) -> 'ParIterable'[_TraversableOps__T]: ...
    def asParSeq(self) -> 'ParSeq'[_TraversableOps__T]: ...
    _ifParSeq__R = typing.TypeVar('_ifParSeq__R')  # <R>
    def ifParSeq(self, isbody: scala.Function1['ParSeq'[_TraversableOps__T], _ifParSeq__R]) -> 'TraversableOps.Otherwise'[_ifParSeq__R]: ...
    def isParIterable(self) -> bool: ...
    def isParSeq(self) -> bool: ...
    def isParallel(self) -> bool: ...
    class Otherwise(typing.Generic[_TraversableOps__Otherwise__R]):
        def otherwise(self, notbody: scala.Function0[_TraversableOps__Otherwise__R]) -> _TraversableOps__Otherwise__R: ...

_package__CollectionsHaveToParArray__C = typing.TypeVar('_package__CollectionsHaveToParArray__C')  # <C>
_package__CollectionsHaveToParArray__T = typing.TypeVar('_package__CollectionsHaveToParArray__T')  # <T>
class package:
    @staticmethod
    def CHECK_RATE() -> int: ...
    @staticmethod
    def MIN_FOR_COPY() -> int: ...
    @staticmethod
    def SQRT2() -> float: ...
    @staticmethod
    def availableProcessors() -> int: ...
    @staticmethod
    def defaultTaskSupport() -> 'TaskSupport': ...
    _setTaskSupport__Coll = typing.TypeVar('_setTaskSupport__Coll')  # <Coll>
    @staticmethod
    def setTaskSupport(c: _setTaskSupport__Coll, t: 'TaskSupport') -> _setTaskSupport__Coll: ...
    @staticmethod
    def thresholdFromSize(sz: int, parallelismLevel: int) -> int: ...
    class CollectionsHaveToParArray(typing.Generic[_package__CollectionsHaveToParArray__C, _package__CollectionsHaveToParArray__T]):
        def __init__(self, c: _package__CollectionsHaveToParArray__C, asGto: scala.Function1[_package__CollectionsHaveToParArray__C, scala.collection.GenTraversableOnce[_package__CollectionsHaveToParArray__T]]): ...
        def toParArray(self) -> scala.collection.parallel.mutable.ParArray[_package__CollectionsHaveToParArray__T]: ...

_AdaptiveWorkStealingTasks__WrappedTask__R = typing.TypeVar('_AdaptiveWorkStealingTasks__WrappedTask__R')  # <R>
_AdaptiveWorkStealingTasks__WrappedTask__Tp = typing.TypeVar('_AdaptiveWorkStealingTasks__WrappedTask__Tp')  # <Tp>
class AdaptiveWorkStealingTasks(Tasks):
    @staticmethod
    def $init$($this: 'AdaptiveWorkStealingTasks') -> None: ...
    _newWrappedTask__R = typing.TypeVar('_newWrappedTask__R')  # <R>
    _newWrappedTask__Tp = typing.TypeVar('_newWrappedTask__Tp')  # <Tp>
    def newWrappedTask(self, b: Task[_newWrappedTask__R, _newWrappedTask__Tp]) -> 'AdaptiveWorkStealingTasks.WrappedTask'[_newWrappedTask__R, _newWrappedTask__Tp]: ...
    class WrappedTask(Tasks.WrappedTask[_AdaptiveWorkStealingTasks__WrappedTask__R, _AdaptiveWorkStealingTasks__WrappedTask__Tp], typing.Generic[_AdaptiveWorkStealingTasks__WrappedTask__R, _AdaptiveWorkStealingTasks__WrappedTask__Tp]):
        @staticmethod
        def $init$($this: 'AdaptiveWorkStealingTasks.WrappedTask') -> None: ...
        def compute(self) -> None: ...
        def internal(self) -> None: ...
        def next(self) -> 'AdaptiveWorkStealingTasks.WrappedTask'[_AdaptiveWorkStealingTasks__WrappedTask__R, _AdaptiveWorkStealingTasks__WrappedTask__Tp]: ...
        def next_$eq(self, x$1: 'AdaptiveWorkStealingTasks.WrappedTask'[_AdaptiveWorkStealingTasks__WrappedTask__R, _AdaptiveWorkStealingTasks__WrappedTask__Tp]) -> None: ...
        def printChain(self) -> None: ...
        def shouldWaitFor(self) -> bool: ...
        def shouldWaitFor_$eq(self, x$1: bool) -> None: ...
        def spawnSubtasks(self) -> 'AdaptiveWorkStealingTasks.WrappedTask'[_AdaptiveWorkStealingTasks__WrappedTask__R, _AdaptiveWorkStealingTasks__WrappedTask__Tp]: ...
        def split(self) -> scala.collection.Seq['AdaptiveWorkStealingTasks.WrappedTask'[_AdaptiveWorkStealingTasks__WrappedTask__R, _AdaptiveWorkStealingTasks__WrappedTask__Tp]]: ...

_AugmentedIterableIterator__T = typing.TypeVar('_AugmentedIterableIterator__T')  # <T>
class AugmentedIterableIterator(RemainsIterator[_AugmentedIterableIterator__T], typing.Generic[_AugmentedIterableIterator__T]):
    @staticmethod
    def $init$($this: 'AugmentedIterableIterator') -> None: ...
    _collect2combiner__S = typing.TypeVar('_collect2combiner__S')  # <S>
    _collect2combiner__That = typing.TypeVar('_collect2combiner__That')  # <That>
    def collect2combiner(self, pf: scala.PartialFunction[_AugmentedIterableIterator__T, _collect2combiner__S], cb: Combiner[_collect2combiner__S, _collect2combiner__That]) -> Combiner[_collect2combiner__S, _collect2combiner__That]: ...
    _copy2builder__U = typing.TypeVar('_copy2builder__U')  # <U>
    _copy2builder__Coll = typing.TypeVar('_copy2builder__Coll')  # <Coll>
    _copy2builder__Bld = typing.TypeVar('_copy2builder__Bld', bound=scala.collection.mutable.Builder)  # <Bld>
    def copy2builder(self, b: _copy2builder__Bld) -> _copy2builder__Bld: ...
    _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
    _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
    _copyToArray_2__U = typing.TypeVar('_copyToArray_2__U')  # <U>
    @typing.overload
    def copyToArray(self, xs: typing.Any) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int) -> None: ...
    @typing.overload
    def copyToArray(self, array: typing.Any, from_: int, len: int) -> None: ...
    def count(self, p: scala.Function1[_AugmentedIterableIterator__T, typing.Any]) -> int: ...
    _drop2combiner__U = typing.TypeVar('_drop2combiner__U')  # <U>
    _drop2combiner__This = typing.TypeVar('_drop2combiner__This')  # <This>
    def drop2combiner(self, n: int, cb: Combiner[_drop2combiner__U, _drop2combiner__This]) -> Combiner[_drop2combiner__U, _drop2combiner__This]: ...
    _filter2combiner__U = typing.TypeVar('_filter2combiner__U')  # <U>
    _filter2combiner__This = typing.TypeVar('_filter2combiner__This')  # <This>
    def filter2combiner(self, pred: scala.Function1[_AugmentedIterableIterator__T, typing.Any], cb: Combiner[_filter2combiner__U, _filter2combiner__This]) -> Combiner[_filter2combiner__U, _filter2combiner__This]: ...
    _filterNot2combiner__U = typing.TypeVar('_filterNot2combiner__U')  # <U>
    _filterNot2combiner__This = typing.TypeVar('_filterNot2combiner__This')  # <This>
    def filterNot2combiner(self, pred: scala.Function1[_AugmentedIterableIterator__T, typing.Any], cb: Combiner[_filterNot2combiner__U, _filterNot2combiner__This]) -> Combiner[_filterNot2combiner__U, _filterNot2combiner__This]: ...
    _flatmap2combiner__S = typing.TypeVar('_flatmap2combiner__S')  # <S>
    _flatmap2combiner__That = typing.TypeVar('_flatmap2combiner__That')  # <That>
    def flatmap2combiner(self, f: scala.Function1[_AugmentedIterableIterator__T, scala.collection.GenTraversableOnce[_flatmap2combiner__S]], cb: Combiner[_flatmap2combiner__S, _flatmap2combiner__That]) -> Combiner[_flatmap2combiner__S, _flatmap2combiner__That]: ...
    _fold__U = typing.TypeVar('_fold__U')  # <U>
    def fold(self, z: _fold__U, op: scala.Function2[_fold__U, _fold__U, _fold__U]) -> _fold__U: ...
    _map2combiner__S = typing.TypeVar('_map2combiner__S')  # <S>
    _map2combiner__That = typing.TypeVar('_map2combiner__That')  # <That>
    def map2combiner(self, f: scala.Function1[_AugmentedIterableIterator__T, _map2combiner__S], cb: Combiner[_map2combiner__S, _map2combiner__That]) -> Combiner[_map2combiner__S, _map2combiner__That]: ...
    _max__U = typing.TypeVar('_max__U')  # <U>
    def max(self, ord: scala.math.Ordering[_max__U]) -> _AugmentedIterableIterator__T: ...
    _min__U = typing.TypeVar('_min__U')  # <U>
    def min(self, ord: scala.math.Ordering[_min__U]) -> _AugmentedIterableIterator__T: ...
    _partition2combiners__U = typing.TypeVar('_partition2combiners__U')  # <U>
    _partition2combiners__This = typing.TypeVar('_partition2combiners__This')  # <This>
    def partition2combiners(self, pred: scala.Function1[_AugmentedIterableIterator__T, typing.Any], btrue: Combiner[_partition2combiners__U, _partition2combiners__This], bfalse: Combiner[_partition2combiners__U, _partition2combiners__This]) -> scala.Tuple2[Combiner[_partition2combiners__U, _partition2combiners__This], Combiner[_partition2combiners__U, _partition2combiners__This]]: ...
    _product__U = typing.TypeVar('_product__U')  # <U>
    def product(self, num: scala.math.Numeric[_product__U]) -> _product__U: ...
    _reduce__U = typing.TypeVar('_reduce__U')  # <U>
    def reduce(self, op: scala.Function2[_reduce__U, _reduce__U, _reduce__U]) -> _reduce__U: ...
    _reduceLeft_0__B = typing.TypeVar('_reduceLeft_0__B')  # <B>
    _reduceLeft_1__U = typing.TypeVar('_reduceLeft_1__U')  # <U>
    @typing.overload
    def reduceLeft(self, op: scala.Function2[_reduceLeft_0__B, typing.Any, _reduceLeft_0__B]) -> _reduceLeft_0__B: ...
    @typing.overload
    def reduceLeft(self, howmany: int, op: scala.Function2[_reduceLeft_1__U, _reduceLeft_1__U, _reduceLeft_1__U]) -> _reduceLeft_1__U: ...
    _scanToArray__U = typing.TypeVar('_scanToArray__U')  # <U>
    _scanToArray__A = typing.TypeVar('_scanToArray__A')  # <A>
    def scanToArray(self, z: _scanToArray__U, op: scala.Function2[_scanToArray__U, _scanToArray__U, _scanToArray__U], array: typing.Any, from_: int) -> None: ...
    _scanToCombiner_0__U = typing.TypeVar('_scanToCombiner_0__U')  # <U>
    _scanToCombiner_0__That = typing.TypeVar('_scanToCombiner_0__That')  # <That>
    _scanToCombiner_1__U = typing.TypeVar('_scanToCombiner_1__U')  # <U>
    _scanToCombiner_1__That = typing.TypeVar('_scanToCombiner_1__That')  # <That>
    @typing.overload
    def scanToCombiner(self, howmany: int, startValue: _scanToCombiner_0__U, op: scala.Function2[_scanToCombiner_0__U, _scanToCombiner_0__U, _scanToCombiner_0__U], cb: Combiner[_scanToCombiner_0__U, _scanToCombiner_0__That]) -> Combiner[_scanToCombiner_0__U, _scanToCombiner_0__That]: ...
    @typing.overload
    def scanToCombiner(self, startValue: _scanToCombiner_1__U, op: scala.Function2[_scanToCombiner_1__U, _scanToCombiner_1__U, _scanToCombiner_1__U], cb: Combiner[_scanToCombiner_1__U, _scanToCombiner_1__That]) -> Combiner[_scanToCombiner_1__U, _scanToCombiner_1__That]: ...
    _slice2combiner__U = typing.TypeVar('_slice2combiner__U')  # <U>
    _slice2combiner__This = typing.TypeVar('_slice2combiner__This')  # <This>
    def slice2combiner(self, from_: int, until: int, cb: Combiner[_slice2combiner__U, _slice2combiner__This]) -> Combiner[_slice2combiner__U, _slice2combiner__This]: ...
    _span2combiners__U = typing.TypeVar('_span2combiners__U')  # <U>
    _span2combiners__This = typing.TypeVar('_span2combiners__This')  # <This>
    def span2combiners(self, p: scala.Function1[_AugmentedIterableIterator__T, typing.Any], before: Combiner[_span2combiners__U, _span2combiners__This], after: Combiner[_span2combiners__U, _span2combiners__This]) -> scala.Tuple2[Combiner[_span2combiners__U, _span2combiners__This], Combiner[_span2combiners__U, _span2combiners__This]]: ...
    _splitAt2combiners__U = typing.TypeVar('_splitAt2combiners__U')  # <U>
    _splitAt2combiners__This = typing.TypeVar('_splitAt2combiners__This')  # <This>
    def splitAt2combiners(self, at: int, before: Combiner[_splitAt2combiners__U, _splitAt2combiners__This], after: Combiner[_splitAt2combiners__U, _splitAt2combiners__This]) -> scala.Tuple2[Combiner[_splitAt2combiners__U, _splitAt2combiners__This], Combiner[_splitAt2combiners__U, _splitAt2combiners__This]]: ...
    _sum__U = typing.TypeVar('_sum__U')  # <U>
    def sum(self, num: scala.math.Numeric[_sum__U]) -> _sum__U: ...
    _take2combiner__U = typing.TypeVar('_take2combiner__U')  # <U>
    _take2combiner__This = typing.TypeVar('_take2combiner__This')  # <This>
    def take2combiner(self, n: int, cb: Combiner[_take2combiner__U, _take2combiner__This]) -> Combiner[_take2combiner__U, _take2combiner__This]: ...
    _takeWhile2combiner__U = typing.TypeVar('_takeWhile2combiner__U')  # <U>
    _takeWhile2combiner__This = typing.TypeVar('_takeWhile2combiner__This')  # <This>
    def takeWhile2combiner(self, p: scala.Function1[_AugmentedIterableIterator__T, typing.Any], cb: Combiner[_takeWhile2combiner__U, _takeWhile2combiner__This]) -> scala.Tuple2[Combiner[_takeWhile2combiner__U, _takeWhile2combiner__This], typing.Any]: ...
    def toString(self) -> java.lang.String: ...
    _zip2combiner__U = typing.TypeVar('_zip2combiner__U')  # <U>
    _zip2combiner__S = typing.TypeVar('_zip2combiner__S')  # <S>
    _zip2combiner__That = typing.TypeVar('_zip2combiner__That')  # <That>
    def zip2combiner(self, otherpit: RemainsIterator[_zip2combiner__S], cb: Combiner[scala.Tuple2[_zip2combiner__U, _zip2combiner__S], _zip2combiner__That]) -> Combiner[scala.Tuple2[_zip2combiner__U, _zip2combiner__S], _zip2combiner__That]: ...
    _zipAll2combiner__U = typing.TypeVar('_zipAll2combiner__U')  # <U>
    _zipAll2combiner__S = typing.TypeVar('_zipAll2combiner__S')  # <S>
    _zipAll2combiner__That = typing.TypeVar('_zipAll2combiner__That')  # <That>
    def zipAll2combiner(self, that: RemainsIterator[_zipAll2combiner__S], thiselem: _zipAll2combiner__U, thatelem: _zipAll2combiner__S, cb: Combiner[scala.Tuple2[_zipAll2combiner__U, _zipAll2combiner__S], _zipAll2combiner__That]) -> Combiner[scala.Tuple2[_zipAll2combiner__U, _zipAll2combiner__S], _zipAll2combiner__That]: ...

_BucketCombiner__Elem = typing.TypeVar('_BucketCombiner__Elem')  # <Elem>
_BucketCombiner__To = typing.TypeVar('_BucketCombiner__To')  # <To>
_BucketCombiner__Buck = typing.TypeVar('_BucketCombiner__Buck')  # <Buck>
_BucketCombiner__CombinerType = typing.TypeVar('_BucketCombiner__CombinerType', bound='BucketCombiner')  # <CombinerType>
class BucketCombiner(Combiner[_BucketCombiner__Elem, _BucketCombiner__To], typing.Generic[_BucketCombiner__Elem, _BucketCombiner__To, _BucketCombiner__Buck, _BucketCombiner__CombinerType]):
    def __init__(self, bucketnumber: int): ...
    @typing.overload
    def $plus$eq(self, elem: typing.Any) -> scala.collection.generic.Growable[typing.Any]: ...
    @typing.overload
    def $plus$eq(self, elem: _BucketCombiner__Elem) -> scala.collection.mutable.Builder[_BucketCombiner__Elem, _BucketCombiner__To]: ...
    @typing.overload
    def $plus$eq(self, elem1: _BucketCombiner__Elem, elem2: _BucketCombiner__Elem, elems: scala.collection.Seq[_BucketCombiner__Elem]) -> scala.collection.generic.Growable[_BucketCombiner__Elem]: ...
    def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[_BucketCombiner__Elem]) -> scala.collection.generic.Growable[_BucketCombiner__Elem]: ...
    def _combinerTaskSupport(self) -> 'TaskSupport': ...
    def _combinerTaskSupport_$eq(self, x$1: 'TaskSupport') -> None: ...
    _afterCombine__N = typing.TypeVar('_afterCombine__N')  # <N>
    _afterCombine__NewTo = typing.TypeVar('_afterCombine__NewTo')  # <NewTo>
    def afterCombine(self, other: Combiner[_afterCombine__N, _afterCombine__NewTo]) -> None: ...
    _beforeCombine__N = typing.TypeVar('_beforeCombine__N')  # <N>
    _beforeCombine__NewTo = typing.TypeVar('_beforeCombine__NewTo')  # <NewTo>
    def beforeCombine(self, other: Combiner[_beforeCombine__N, _beforeCombine__NewTo]) -> None: ...
    def buckets(self) -> typing.List[scala.collection.mutable.UnrolledBuffer[_BucketCombiner__Buck]]: ...
    def buckets_$eq(self, x$1: typing.List[scala.collection.mutable.UnrolledBuffer[_BucketCombiner__Buck]]) -> None: ...
    def canBeShared(self) -> bool: ...
    def clear(self) -> None: ...
    _combine__N = typing.TypeVar('_combine__N')  # <N>
    _combine__NewTo = typing.TypeVar('_combine__NewTo')  # <NewTo>
    def combine(self, other: Combiner[_combine__N, _combine__NewTo]) -> Combiner[_combine__N, _combine__NewTo]: ...
    def combinerTaskSupport(self) -> 'TaskSupport': ...
    def combinerTaskSupport_$eq(self, cts: 'TaskSupport') -> None: ...
    _mapResult__NewTo = typing.TypeVar('_mapResult__NewTo')  # <NewTo>
    def mapResult(self, f: scala.Function1[_BucketCombiner__To, _mapResult__NewTo]) -> scala.collection.mutable.Builder[_BucketCombiner__Elem, _mapResult__NewTo]: ...
    def resultWithTaskSupport(self) -> _BucketCombiner__To: ...
    def size(self) -> int: ...
    @typing.overload
    def sizeHint(self, size: int) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
    @typing.overload
    def sizeHint(self, coll: scala.collection.TraversableLike[typing.Any, typing.Any], delta: int) -> None: ...
    def sizeHintBounded(self, size: int, boundingColl: scala.collection.TraversableLike[typing.Any, typing.Any]) -> None: ...
    def sz(self) -> int: ...
    def sz_$eq(self, x$1: int) -> None: ...

class ExecutionContextTasks(Tasks):
    @staticmethod
    def $init$($this: 'ExecutionContextTasks') -> None: ...
    @typing.overload
    def environment(self) -> typing.Any: ...
    @typing.overload
    def environment(self) -> scala.concurrent.ExecutionContext: ...
    _execute__R = typing.TypeVar('_execute__R')  # <R>
    _execute__Tp = typing.TypeVar('_execute__Tp')  # <Tp>
    def execute(self, task: Task[_execute__R, _execute__Tp]) -> scala.Function0[_execute__R]: ...
    _executeAndWaitResult__R = typing.TypeVar('_executeAndWaitResult__R')  # <R>
    _executeAndWaitResult__Tp = typing.TypeVar('_executeAndWaitResult__Tp')  # <Tp>
    def executeAndWaitResult(self, task: Task[_executeAndWaitResult__R, _executeAndWaitResult__Tp]) -> _executeAndWaitResult__R: ...
    def executionContext(self) -> scala.concurrent.ExecutionContext: ...
    def parallelismLevel(self) -> int: ...
    def scala$collection$parallel$ExecutionContextTasks$$driver(self) -> Tasks: ...
    def scala$collection$parallel$ExecutionContextTasks$_setter_$scala$collection$parallel$ExecutionContextTasks$$driver_$eq(self, x$1: Tasks) -> None: ...

_ForkJoinTasks__WrappedTask__R = typing.TypeVar('_ForkJoinTasks__WrappedTask__R')  # <R>
_ForkJoinTasks__WrappedTask__Tp = typing.TypeVar('_ForkJoinTasks__WrappedTask__Tp')  # <Tp>
class ForkJoinTasks(Tasks, HavingForkJoinPool):
    @staticmethod
    def $init$($this: 'ForkJoinTasks') -> None: ...
    @staticmethod
    def defaultForkJoinPool() -> java.util.concurrent.ForkJoinPool: ...
    @typing.overload
    def environment(self) -> typing.Any: ...
    @typing.overload
    def environment(self) -> java.util.concurrent.ForkJoinPool: ...
    _execute__R = typing.TypeVar('_execute__R')  # <R>
    _execute__Tp = typing.TypeVar('_execute__Tp')  # <Tp>
    def execute(self, task: Task[_execute__R, _execute__Tp]) -> scala.Function0[_execute__R]: ...
    _executeAndWaitResult__R = typing.TypeVar('_executeAndWaitResult__R')  # <R>
    _executeAndWaitResult__Tp = typing.TypeVar('_executeAndWaitResult__Tp')  # <Tp>
    def executeAndWaitResult(self, task: Task[_executeAndWaitResult__R, _executeAndWaitResult__Tp]) -> _executeAndWaitResult__R: ...
    def forkJoinPool(self) -> java.util.concurrent.ForkJoinPool: ...
    _newWrappedTask__R = typing.TypeVar('_newWrappedTask__R')  # <R>
    _newWrappedTask__Tp = typing.TypeVar('_newWrappedTask__Tp')  # <Tp>
    def newWrappedTask(self, b: Task[_newWrappedTask__R, _newWrappedTask__Tp]) -> 'ForkJoinTasks.WrappedTask'[_newWrappedTask__R, _newWrappedTask__Tp]: ...
    def parallelismLevel(self) -> int: ...
    class WrappedTask(Tasks.WrappedTask[_ForkJoinTasks__WrappedTask__R, _ForkJoinTasks__WrappedTask__Tp], typing.Generic[_ForkJoinTasks__WrappedTask__R, _ForkJoinTasks__WrappedTask__Tp]):
        @staticmethod
        def $init$($this: 'ForkJoinTasks.WrappedTask') -> None: ...
        def start(self) -> None: ...
        def sync(self) -> None: ...
        def tryCancel(self) -> bool: ...

class FutureTasks(Tasks):
    def __init__(self, executor: scala.concurrent.ExecutionContext): ...
    def debugMessages(self) -> scala.collection.mutable.ArrayBuffer[java.lang.String]: ...
    def debuglog(self, s: typing.Union[java.lang.String, str]) -> scala.collection.mutable.ArrayBuffer[java.lang.String]: ...
    def environment(self) -> scala.concurrent.ExecutionContext: ...
    _execute__R = typing.TypeVar('_execute__R')  # <R>
    _execute__Tp = typing.TypeVar('_execute__Tp')  # <Tp>
    def execute(self, task: Task[_execute__R, _execute__Tp]) -> scala.Function0[_execute__R]: ...
    _executeAndWaitResult__R = typing.TypeVar('_executeAndWaitResult__R')  # <R>
    _executeAndWaitResult__Tp = typing.TypeVar('_executeAndWaitResult__Tp')  # <Tp>
    def executeAndWaitResult(self, task: Task[_executeAndWaitResult__R, _executeAndWaitResult__Tp]) -> _executeAndWaitResult__R: ...
    def parallelismLevel(self) -> int: ...
    def scala$collection$parallel$Tasks$_setter_$debugMessages_$eq(self, x$1: scala.collection.mutable.ArrayBuffer[typing.Union[java.lang.String, str]]) -> None: ...

_PreciseSplitter__T = typing.TypeVar('_PreciseSplitter__T')  # <T>
class PreciseSplitter(Splitter[_PreciseSplitter__T], typing.Generic[_PreciseSplitter__T]):
    def psplit(self, sizes: scala.collection.Seq[typing.Any]) -> scala.collection.Seq['PreciseSplitter'[_PreciseSplitter__T]]: ...
    def split(self) -> scala.collection.Seq['PreciseSplitter'[_PreciseSplitter__T]]: ...
    def toString(self) -> java.lang.String: ...

class TaskSupport(Tasks): ...

_ThreadPoolTasks__WrappedTask__R = typing.TypeVar('_ThreadPoolTasks__WrappedTask__R')  # <R>
_ThreadPoolTasks__WrappedTask__Tp = typing.TypeVar('_ThreadPoolTasks__WrappedTask__Tp')  # <Tp>
class ThreadPoolTasks(Tasks):
    @staticmethod
    def $init$($this: 'ThreadPoolTasks') -> None: ...
    @staticmethod
    def defaultThreadPool() -> java.util.concurrent.ThreadPoolExecutor: ...
    @typing.overload
    def environment(self) -> typing.Any: ...
    @typing.overload
    def environment(self) -> java.util.concurrent.ThreadPoolExecutor: ...
    _execute__R = typing.TypeVar('_execute__R')  # <R>
    _execute__Tp = typing.TypeVar('_execute__Tp')  # <Tp>
    def execute(self, task: Task[_execute__R, _execute__Tp]) -> scala.Function0[_execute__R]: ...
    _executeAndWaitResult__R = typing.TypeVar('_executeAndWaitResult__R')  # <R>
    _executeAndWaitResult__Tp = typing.TypeVar('_executeAndWaitResult__Tp')  # <Tp>
    def executeAndWaitResult(self, task: Task[_executeAndWaitResult__R, _executeAndWaitResult__Tp]) -> _executeAndWaitResult__R: ...
    def executor(self) -> java.util.concurrent.ThreadPoolExecutor: ...
    _newWrappedTask__R = typing.TypeVar('_newWrappedTask__R')  # <R>
    _newWrappedTask__Tp = typing.TypeVar('_newWrappedTask__Tp')  # <Tp>
    def newWrappedTask(self, b: Task[_newWrappedTask__R, _newWrappedTask__Tp]) -> 'ThreadPoolTasks.WrappedTask'[_newWrappedTask__R, _newWrappedTask__Tp]: ...
    @staticmethod
    def numCores() -> int: ...
    def parallelismLevel(self) -> int: ...
    def queue(self) -> java.util.concurrent.LinkedBlockingQueue[java.lang.Runnable]: ...
    def scala$collection$parallel$ThreadPoolTasks$$decrTasks(self) -> None: ...
    def scala$collection$parallel$ThreadPoolTasks$$incrTasks(self) -> None: ...
    @staticmethod
    def tcount() -> java.util.concurrent.atomic.AtomicLong: ...
    def totaltasks(self) -> int: ...
    def totaltasks_$eq(self, x$1: int) -> None: ...
    class WrappedTask(java.lang.Runnable, Tasks.WrappedTask[_ThreadPoolTasks__WrappedTask__R, _ThreadPoolTasks__WrappedTask__Tp], typing.Generic[_ThreadPoolTasks__WrappedTask__R, _ThreadPoolTasks__WrappedTask__Tp]):
        @staticmethod
        def $init$($this: 'ThreadPoolTasks.WrappedTask') -> None: ...
        def completed(self) -> bool: ...
        def completed_$eq(self, x$1: bool) -> None: ...
        def owned(self) -> bool: ...
        def owned_$eq(self, x$1: bool) -> None: ...
        def release(self) -> None: ...
        def run(self) -> None: ...
        def start(self) -> None: ...
        def sync(self) -> None: ...
        def tryCancel(self) -> bool: ...

_AdaptiveWorkStealingForkJoinTasks__WrappedTask__R = typing.TypeVar('_AdaptiveWorkStealingForkJoinTasks__WrappedTask__R')  # <R>
_AdaptiveWorkStealingForkJoinTasks__WrappedTask__Tp = typing.TypeVar('_AdaptiveWorkStealingForkJoinTasks__WrappedTask__Tp')  # <Tp>
class AdaptiveWorkStealingForkJoinTasks(ForkJoinTasks, AdaptiveWorkStealingTasks):
    @staticmethod
    def $init$($this: 'AdaptiveWorkStealingForkJoinTasks') -> None: ...
    _newWrappedTask_0__R = typing.TypeVar('_newWrappedTask_0__R')  # <R>
    _newWrappedTask_0__Tp = typing.TypeVar('_newWrappedTask_0__Tp')  # <Tp>
    _newWrappedTask_1__R = typing.TypeVar('_newWrappedTask_1__R')  # <R>
    _newWrappedTask_1__Tp = typing.TypeVar('_newWrappedTask_1__Tp')  # <Tp>
    _newWrappedTask_2__R = typing.TypeVar('_newWrappedTask_2__R')  # <R>
    _newWrappedTask_2__Tp = typing.TypeVar('_newWrappedTask_2__Tp')  # <Tp>
    @typing.overload
    def newWrappedTask(self, b: Task[_newWrappedTask_0__R, _newWrappedTask_0__Tp]) -> AdaptiveWorkStealingTasks.WrappedTask[_newWrappedTask_0__R, _newWrappedTask_0__Tp]: ...
    @typing.overload
    def newWrappedTask(self, b: Task[_newWrappedTask_1__R, _newWrappedTask_1__Tp]) -> ForkJoinTasks.WrappedTask[_newWrappedTask_1__R, _newWrappedTask_1__Tp]: ...
    @typing.overload
    def newWrappedTask(self, b: Task[_newWrappedTask_2__R, _newWrappedTask_2__Tp]) -> 'AdaptiveWorkStealingForkJoinTasks.WrappedTask'[_newWrappedTask_2__R, _newWrappedTask_2__Tp]: ...
    class WrappedTask(java.util.concurrent.RecursiveAction, ForkJoinTasks.WrappedTask[_AdaptiveWorkStealingForkJoinTasks__WrappedTask__R, _AdaptiveWorkStealingForkJoinTasks__WrappedTask__Tp], AdaptiveWorkStealingTasks.WrappedTask[_AdaptiveWorkStealingForkJoinTasks__WrappedTask__R, _AdaptiveWorkStealingForkJoinTasks__WrappedTask__Tp], typing.Generic[_AdaptiveWorkStealingForkJoinTasks__WrappedTask__R, _AdaptiveWorkStealingForkJoinTasks__WrappedTask__Tp]):
        $outer: 'AdaptiveWorkStealingForkJoinTasks' = ...
        def __init__(self, $outer: 'AdaptiveWorkStealingForkJoinTasks', body: Task[_AdaptiveWorkStealingForkJoinTasks__WrappedTask__R, _AdaptiveWorkStealingForkJoinTasks__WrappedTask__Tp]): ...
        def body(self) -> Task[_AdaptiveWorkStealingForkJoinTasks__WrappedTask__R, _AdaptiveWorkStealingForkJoinTasks__WrappedTask__Tp]: ...
        def compute(self) -> None: ...
        def internal(self) -> None: ...
        def next(self) -> AdaptiveWorkStealingTasks.WrappedTask[_AdaptiveWorkStealingForkJoinTasks__WrappedTask__R, _AdaptiveWorkStealingForkJoinTasks__WrappedTask__Tp]: ...
        def next_$eq(self, x$1: AdaptiveWorkStealingTasks.WrappedTask[_AdaptiveWorkStealingForkJoinTasks__WrappedTask__R, _AdaptiveWorkStealingForkJoinTasks__WrappedTask__Tp]) -> None: ...
        def printChain(self) -> None: ...
        def release(self) -> None: ...
        def shouldWaitFor(self) -> bool: ...
        def shouldWaitFor_$eq(self, x$1: bool) -> None: ...
        def spawnSubtasks(self) -> AdaptiveWorkStealingTasks.WrappedTask[_AdaptiveWorkStealingForkJoinTasks__WrappedTask__R, _AdaptiveWorkStealingForkJoinTasks__WrappedTask__Tp]: ...
        def split(self) -> scala.collection.Seq[AdaptiveWorkStealingTasks.WrappedTask[_AdaptiveWorkStealingForkJoinTasks__WrappedTask__R, _AdaptiveWorkStealingForkJoinTasks__WrappedTask__Tp]]: ...
        def start(self) -> None: ...
        def sync(self) -> None: ...
        def tryCancel(self) -> bool: ...

_AdaptiveWorkStealingThreadPoolTasks__WrappedTask__R = typing.TypeVar('_AdaptiveWorkStealingThreadPoolTasks__WrappedTask__R')  # <R>
_AdaptiveWorkStealingThreadPoolTasks__WrappedTask__Tp = typing.TypeVar('_AdaptiveWorkStealingThreadPoolTasks__WrappedTask__Tp')  # <Tp>
class AdaptiveWorkStealingThreadPoolTasks(ThreadPoolTasks, AdaptiveWorkStealingTasks):
    @staticmethod
    def $init$($this: 'AdaptiveWorkStealingThreadPoolTasks') -> None: ...
    _newWrappedTask_0__R = typing.TypeVar('_newWrappedTask_0__R')  # <R>
    _newWrappedTask_0__Tp = typing.TypeVar('_newWrappedTask_0__Tp')  # <Tp>
    _newWrappedTask_1__R = typing.TypeVar('_newWrappedTask_1__R')  # <R>
    _newWrappedTask_1__Tp = typing.TypeVar('_newWrappedTask_1__Tp')  # <Tp>
    _newWrappedTask_2__R = typing.TypeVar('_newWrappedTask_2__R')  # <R>
    _newWrappedTask_2__Tp = typing.TypeVar('_newWrappedTask_2__Tp')  # <Tp>
    @typing.overload
    def newWrappedTask(self, b: Task[_newWrappedTask_0__R, _newWrappedTask_0__Tp]) -> AdaptiveWorkStealingTasks.WrappedTask[_newWrappedTask_0__R, _newWrappedTask_0__Tp]: ...
    @typing.overload
    def newWrappedTask(self, b: Task[_newWrappedTask_1__R, _newWrappedTask_1__Tp]) -> ThreadPoolTasks.WrappedTask[_newWrappedTask_1__R, _newWrappedTask_1__Tp]: ...
    @typing.overload
    def newWrappedTask(self, b: Task[_newWrappedTask_2__R, _newWrappedTask_2__Tp]) -> 'AdaptiveWorkStealingThreadPoolTasks.WrappedTask'[_newWrappedTask_2__R, _newWrappedTask_2__Tp]: ...
    class WrappedTask(ThreadPoolTasks.WrappedTask[_AdaptiveWorkStealingThreadPoolTasks__WrappedTask__R, _AdaptiveWorkStealingThreadPoolTasks__WrappedTask__Tp], AdaptiveWorkStealingTasks.WrappedTask[_AdaptiveWorkStealingThreadPoolTasks__WrappedTask__R, _AdaptiveWorkStealingThreadPoolTasks__WrappedTask__Tp], typing.Generic[_AdaptiveWorkStealingThreadPoolTasks__WrappedTask__R, _AdaptiveWorkStealingThreadPoolTasks__WrappedTask__Tp]):
        $outer: 'AdaptiveWorkStealingThreadPoolTasks' = ...
        def __init__(self, $outer: 'AdaptiveWorkStealingThreadPoolTasks', body: Task[_AdaptiveWorkStealingThreadPoolTasks__WrappedTask__R, _AdaptiveWorkStealingThreadPoolTasks__WrappedTask__Tp]): ...
        def body(self) -> Task[_AdaptiveWorkStealingThreadPoolTasks__WrappedTask__R, _AdaptiveWorkStealingThreadPoolTasks__WrappedTask__Tp]: ...
        def completed(self) -> bool: ...
        def completed_$eq(self, x$1: bool) -> None: ...
        def compute(self) -> None: ...
        def internal(self) -> None: ...
        def next(self) -> AdaptiveWorkStealingTasks.WrappedTask[_AdaptiveWorkStealingThreadPoolTasks__WrappedTask__R, _AdaptiveWorkStealingThreadPoolTasks__WrappedTask__Tp]: ...
        def next_$eq(self, x$1: AdaptiveWorkStealingTasks.WrappedTask[_AdaptiveWorkStealingThreadPoolTasks__WrappedTask__R, _AdaptiveWorkStealingThreadPoolTasks__WrappedTask__Tp]) -> None: ...
        def owned(self) -> bool: ...
        def owned_$eq(self, x$1: bool) -> None: ...
        def printChain(self) -> None: ...
        def release(self) -> None: ...
        def run(self) -> None: ...
        def shouldWaitFor(self) -> bool: ...
        def shouldWaitFor_$eq(self, x$1: bool) -> None: ...
        def spawnSubtasks(self) -> AdaptiveWorkStealingTasks.WrappedTask[_AdaptiveWorkStealingThreadPoolTasks__WrappedTask__R, _AdaptiveWorkStealingThreadPoolTasks__WrappedTask__Tp]: ...
        def split(self) -> scala.collection.Seq[AdaptiveWorkStealingTasks.WrappedTask[_AdaptiveWorkStealingThreadPoolTasks__WrappedTask__R, _AdaptiveWorkStealingThreadPoolTasks__WrappedTask__Tp]]: ...
        def start(self) -> None: ...
        def sync(self) -> None: ...
        def tryCancel(self) -> bool: ...

_AugmentedSeqIterator__T = typing.TypeVar('_AugmentedSeqIterator__T')  # <T>
class AugmentedSeqIterator(AugmentedIterableIterator[_AugmentedSeqIterator__T], typing.Generic[_AugmentedSeqIterator__T]):
    @staticmethod
    def $init$($this: 'AugmentedSeqIterator') -> None: ...
    _corresponds_0__B = typing.TypeVar('_corresponds_0__B')  # <B>
    _corresponds_1__S = typing.TypeVar('_corresponds_1__S')  # <S>
    @typing.overload
    def corresponds(self, that: scala.collection.GenTraversableOnce[_corresponds_0__B], p: scala.Function2[typing.Any, _corresponds_0__B, typing.Any]) -> bool: ...
    @typing.overload
    def corresponds(self, corr: scala.Function2[_AugmentedSeqIterator__T, _corresponds_1__S, typing.Any], that: scala.collection.Iterator[_corresponds_1__S]) -> bool: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[typing.Any, typing.Any], from_: int) -> int: ...
    @typing.overload
    def indexWhere(self, pred: scala.Function1[_AugmentedSeqIterator__T, typing.Any]) -> int: ...
    def lastIndexWhere(self, pred: scala.Function1[_AugmentedSeqIterator__T, typing.Any]) -> int: ...
    def prefixLength(self, pred: scala.Function1[_AugmentedSeqIterator__T, typing.Any]) -> int: ...
    def remaining(self) -> int: ...
    _reverse2combiner__U = typing.TypeVar('_reverse2combiner__U')  # <U>
    _reverse2combiner__This = typing.TypeVar('_reverse2combiner__This')  # <This>
    def reverse2combiner(self, cb: Combiner[_reverse2combiner__U, _reverse2combiner__This]) -> Combiner[_reverse2combiner__U, _reverse2combiner__This]: ...
    _reverseMap2combiner__S = typing.TypeVar('_reverseMap2combiner__S')  # <S>
    _reverseMap2combiner__That = typing.TypeVar('_reverseMap2combiner__That')  # <That>
    def reverseMap2combiner(self, f: scala.Function1[_AugmentedSeqIterator__T, _reverseMap2combiner__S], cb: Combiner[_reverseMap2combiner__S, _reverseMap2combiner__That]) -> Combiner[_reverseMap2combiner__S, _reverseMap2combiner__That]: ...
    def toString(self) -> java.lang.String: ...
    _updated2combiner__U = typing.TypeVar('_updated2combiner__U')  # <U>
    _updated2combiner__That = typing.TypeVar('_updated2combiner__That')  # <That>
    def updated2combiner(self, index: int, elem: _updated2combiner__U, cb: Combiner[_updated2combiner__U, _updated2combiner__That]) -> Combiner[_updated2combiner__U, _updated2combiner__That]: ...

class ExecutionContextTaskSupport(TaskSupport, ExecutionContextTasks):
    def __init__(self, environment: scala.concurrent.ExecutionContext): ...
    @staticmethod
    def $lessinit$greater$default$1() -> scala.concurrent.ExecutionContext: ...
    def debugMessages(self) -> scala.collection.mutable.ArrayBuffer[java.lang.String]: ...
    def debuglog(self, s: typing.Union[java.lang.String, str]) -> scala.collection.mutable.ArrayBuffer[java.lang.String]: ...
    def environment(self) -> scala.concurrent.ExecutionContext: ...
    _execute__R = typing.TypeVar('_execute__R')  # <R>
    _execute__Tp = typing.TypeVar('_execute__Tp')  # <Tp>
    def execute(self, task: Task[_execute__R, _execute__Tp]) -> scala.Function0[_execute__R]: ...
    _executeAndWaitResult__R = typing.TypeVar('_executeAndWaitResult__R')  # <R>
    _executeAndWaitResult__Tp = typing.TypeVar('_executeAndWaitResult__Tp')  # <Tp>
    def executeAndWaitResult(self, task: Task[_executeAndWaitResult__R, _executeAndWaitResult__Tp]) -> _executeAndWaitResult__R: ...
    def executionContext(self) -> scala.concurrent.ExecutionContext: ...
    def parallelismLevel(self) -> int: ...
    def scala$collection$parallel$ExecutionContextTasks$$driver(self) -> Tasks: ...
    def scala$collection$parallel$ExecutionContextTasks$_setter_$scala$collection$parallel$ExecutionContextTasks$$driver_$eq(self, x$1: Tasks) -> None: ...
    def scala$collection$parallel$Tasks$_setter_$debugMessages_$eq(self, x$1: scala.collection.mutable.ArrayBuffer[typing.Union[java.lang.String, str]]) -> None: ...

class ForkJoinTaskSupport(TaskSupport, AdaptiveWorkStealingForkJoinTasks):
    def __init__(self, environment: java.util.concurrent.ForkJoinPool): ...
    @staticmethod
    def $lessinit$greater$default$1() -> java.util.concurrent.ForkJoinPool: ...
    def debugMessages(self) -> scala.collection.mutable.ArrayBuffer[java.lang.String]: ...
    def debuglog(self, s: typing.Union[java.lang.String, str]) -> scala.collection.mutable.ArrayBuffer[java.lang.String]: ...
    def environment(self) -> java.util.concurrent.ForkJoinPool: ...
    _execute__R = typing.TypeVar('_execute__R')  # <R>
    _execute__Tp = typing.TypeVar('_execute__Tp')  # <Tp>
    def execute(self, task: Task[_execute__R, _execute__Tp]) -> scala.Function0[_execute__R]: ...
    _executeAndWaitResult__R = typing.TypeVar('_executeAndWaitResult__R')  # <R>
    _executeAndWaitResult__Tp = typing.TypeVar('_executeAndWaitResult__Tp')  # <Tp>
    def executeAndWaitResult(self, task: Task[_executeAndWaitResult__R, _executeAndWaitResult__Tp]) -> _executeAndWaitResult__R: ...
    def forkJoinPool(self) -> java.util.concurrent.ForkJoinPool: ...
    _newWrappedTask__R = typing.TypeVar('_newWrappedTask__R')  # <R>
    _newWrappedTask__Tp = typing.TypeVar('_newWrappedTask__Tp')  # <Tp>
    def newWrappedTask(self, b: Task[_newWrappedTask__R, _newWrappedTask__Tp]) -> AdaptiveWorkStealingForkJoinTasks.WrappedTask[_newWrappedTask__R, _newWrappedTask__Tp]: ...
    def parallelismLevel(self) -> int: ...
    def scala$collection$parallel$Tasks$_setter_$debugMessages_$eq(self, x$1: scala.collection.mutable.ArrayBuffer[typing.Union[java.lang.String, str]]) -> None: ...

class ThreadPoolTaskSupport(TaskSupport, AdaptiveWorkStealingThreadPoolTasks):
    def __init__(self, environment: java.util.concurrent.ThreadPoolExecutor): ...
    @staticmethod
    def $lessinit$greater$default$1() -> java.util.concurrent.ThreadPoolExecutor: ...
    def debugMessages(self) -> scala.collection.mutable.ArrayBuffer[java.lang.String]: ...
    def debuglog(self, s: typing.Union[java.lang.String, str]) -> scala.collection.mutable.ArrayBuffer[java.lang.String]: ...
    def environment(self) -> java.util.concurrent.ThreadPoolExecutor: ...
    _execute__R = typing.TypeVar('_execute__R')  # <R>
    _execute__Tp = typing.TypeVar('_execute__Tp')  # <Tp>
    def execute(self, task: Task[_execute__R, _execute__Tp]) -> scala.Function0[_execute__R]: ...
    _executeAndWaitResult__R = typing.TypeVar('_executeAndWaitResult__R')  # <R>
    _executeAndWaitResult__Tp = typing.TypeVar('_executeAndWaitResult__Tp')  # <Tp>
    def executeAndWaitResult(self, task: Task[_executeAndWaitResult__R, _executeAndWaitResult__Tp]) -> _executeAndWaitResult__R: ...
    def executor(self) -> java.util.concurrent.ThreadPoolExecutor: ...
    _newWrappedTask__R = typing.TypeVar('_newWrappedTask__R')  # <R>
    _newWrappedTask__Tp = typing.TypeVar('_newWrappedTask__Tp')  # <Tp>
    def newWrappedTask(self, b: Task[_newWrappedTask__R, _newWrappedTask__Tp]) -> AdaptiveWorkStealingThreadPoolTasks.WrappedTask[_newWrappedTask__R, _newWrappedTask__Tp]: ...
    def parallelismLevel(self) -> int: ...
    def queue(self) -> java.util.concurrent.LinkedBlockingQueue[java.lang.Runnable]: ...
    def scala$collection$parallel$Tasks$_setter_$debugMessages_$eq(self, x$1: scala.collection.mutable.ArrayBuffer[typing.Union[java.lang.String, str]]) -> None: ...
    def totaltasks(self) -> int: ...
    def totaltasks_$eq(self, x$1: int) -> None: ...

_BufferSplitter__T = typing.TypeVar('_BufferSplitter__T')  # <T>
class BufferSplitter(scala.collection.parallel.IterableSplitter[_BufferSplitter__T], typing.Generic[_BufferSplitter__T]):
    def __init__(self, buffer: scala.collection.mutable.ArrayBuffer[_BufferSplitter__T], index: int, until: int, _sigdel: scala.collection.generic.Signalling): ...
    _$colon$bslash__B = typing.TypeVar('_$colon$bslash__B')  # <B>
    def $colon$bslash(self, z: _.colon.bslash__B, op: scala.Function2[_BufferSplitter__T, _.colon.bslash__B, _.colon.bslash__B]) -> _.colon.bslash__B: ...
    _$div$colon__B = typing.TypeVar('_$div$colon__B')  # <B>
    def $div$colon(self, z: _.div.colon__B, op: scala.Function2[_.div.colon__B, _BufferSplitter__T, _.div.colon__B]) -> _.div.colon__B: ...
    _$plus$plus__B = typing.TypeVar('_$plus$plus__B')  # <B>
    def $plus$plus(self, that: scala.Function0[scala.collection.GenTraversableOnce[_.plus.plus__B]]) -> scala.collection.Iterator[_.plus.plus__B]: ...
    def abort(self) -> None: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder) -> scala.collection.mutable.StringBuilder: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder, sep: typing.Union[java.lang.String, str]) -> scala.collection.mutable.StringBuilder: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder, start: typing.Union[java.lang.String, str], sep: typing.Union[java.lang.String, str], end: typing.Union[java.lang.String, str]) -> scala.collection.mutable.StringBuilder: ...
    _aggregate__B = typing.TypeVar('_aggregate__B')  # <B>
    def aggregate(self, z: scala.Function0[_aggregate__B], seqop: scala.Function2[_aggregate__B, _BufferSplitter__T, _aggregate__B], combop: scala.Function2[_aggregate__B, _aggregate__B, _aggregate__B]) -> _aggregate__B: ...
    _appendParIterable__U = typing.TypeVar('_appendParIterable__U')  # <U>
    _appendParIterable__PI = typing.TypeVar('_appendParIterable__PI', bound='IterableSplitter')  # <PI>
    def appendParIterable(self, that: _appendParIterable__PI) -> 'IterableSplitter.Appended'[_appendParIterable__U, _appendParIterable__PI]: ...
    def buffered(self) -> scala.collection.BufferedIterator[_BufferSplitter__T]: ...
    def buildString(self, closure: scala.Function1[scala.Function1[typing.Union[java.lang.String, str], scala.runtime.BoxedUnit], scala.runtime.BoxedUnit]) -> java.lang.String: ...
    _collect__B = typing.TypeVar('_collect__B')  # <B>
    def collect(self, pf: scala.PartialFunction[_BufferSplitter__T, _collect__B]) -> scala.collection.Iterator[_collect__B]: ...
    _collect2combiner__S = typing.TypeVar('_collect2combiner__S')  # <S>
    _collect2combiner__That = typing.TypeVar('_collect2combiner__That')  # <That>
    def collect2combiner(self, pf: scala.PartialFunction[_BufferSplitter__T, _collect2combiner__S], cb: Combiner[_collect2combiner__S, _collect2combiner__That]) -> Combiner[_collect2combiner__S, _collect2combiner__That]: ...
    _collectFirst__B = typing.TypeVar('_collectFirst__B')  # <B>
    def collectFirst(self, pf: scala.PartialFunction[_BufferSplitter__T, _collectFirst__B]) -> scala.Option[_collectFirst__B]: ...
    def contains(self, elem: typing.Any) -> bool: ...
    _copy2builder__U = typing.TypeVar('_copy2builder__U')  # <U>
    _copy2builder__Coll = typing.TypeVar('_copy2builder__Coll')  # <Coll>
    _copy2builder__Bld = typing.TypeVar('_copy2builder__Bld', bound=scala.collection.mutable.Builder)  # <Bld>
    def copy2builder(self, b: _copy2builder__Bld) -> _copy2builder__Bld: ...
    _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
    _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
    _copyToArray_2__U = typing.TypeVar('_copyToArray_2__U')  # <U>
    @typing.overload
    def copyToArray(self, xs: typing.Any) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int) -> None: ...
    @typing.overload
    def copyToArray(self, array: typing.Any, from_: int, len: int) -> None: ...
    _copyToBuffer__B = typing.TypeVar('_copyToBuffer__B')  # <B>
    def copyToBuffer(self, dest: scala.collection.mutable.Buffer[_copyToBuffer__B]) -> None: ...
    _corresponds__B = typing.TypeVar('_corresponds__B')  # <B>
    def corresponds(self, that: scala.collection.GenTraversableOnce[_corresponds__B], p: scala.Function2[_BufferSplitter__T, _corresponds__B, typing.Any]) -> bool: ...
    def count(self, p: scala.Function1[_BufferSplitter__T, typing.Any]) -> int: ...
    def debugInformation(self) -> java.lang.String: ...
    def drop(self, n: int) -> 'IterableSplitter'[_BufferSplitter__T]: ...
    _drop2combiner__U = typing.TypeVar('_drop2combiner__U')  # <U>
    _drop2combiner__This = typing.TypeVar('_drop2combiner__This')  # <This>
    def drop2combiner(self, n: int, cb: Combiner[_drop2combiner__U, _drop2combiner__This]) -> Combiner[_drop2combiner__U, _drop2combiner__This]: ...
    def dropWhile(self, p: scala.Function1[_BufferSplitter__T, typing.Any]) -> scala.collection.Iterator[_BufferSplitter__T]: ...
    def dup(self) -> 'BufferSplitter'[_BufferSplitter__T]: ...
    def duplicate(self) -> scala.Tuple2[scala.collection.Iterator[_BufferSplitter__T], scala.collection.Iterator[_BufferSplitter__T]]: ...
    def exists(self, p: scala.Function1[_BufferSplitter__T, typing.Any]) -> bool: ...
    def filter(self, p: scala.Function1[_BufferSplitter__T, typing.Any]) -> scala.collection.Iterator[_BufferSplitter__T]: ...
    _filter2combiner__U = typing.TypeVar('_filter2combiner__U')  # <U>
    _filter2combiner__This = typing.TypeVar('_filter2combiner__This')  # <This>
    def filter2combiner(self, pred: scala.Function1[_BufferSplitter__T, typing.Any], cb: Combiner[_filter2combiner__U, _filter2combiner__This]) -> Combiner[_filter2combiner__U, _filter2combiner__This]: ...
    def filterNot(self, p: scala.Function1[_BufferSplitter__T, typing.Any]) -> scala.collection.Iterator[_BufferSplitter__T]: ...
    _filterNot2combiner__U = typing.TypeVar('_filterNot2combiner__U')  # <U>
    _filterNot2combiner__This = typing.TypeVar('_filterNot2combiner__This')  # <This>
    def filterNot2combiner(self, pred: scala.Function1[_BufferSplitter__T, typing.Any], cb: Combiner[_filterNot2combiner__U, _filterNot2combiner__This]) -> Combiner[_filterNot2combiner__U, _filterNot2combiner__This]: ...
    def find(self, p: scala.Function1[_BufferSplitter__T, typing.Any]) -> scala.Option[_BufferSplitter__T]: ...
    _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
    def flatMap(self, f: scala.Function1[_BufferSplitter__T, scala.collection.GenTraversableOnce[_flatMap__B]]) -> scala.collection.Iterator[_flatMap__B]: ...
    _flatmap2combiner__S = typing.TypeVar('_flatmap2combiner__S')  # <S>
    _flatmap2combiner__That = typing.TypeVar('_flatmap2combiner__That')  # <That>
    def flatmap2combiner(self, f: scala.Function1[_BufferSplitter__T, scala.collection.GenTraversableOnce[_flatmap2combiner__S]], cb: Combiner[_flatmap2combiner__S, _flatmap2combiner__That]) -> Combiner[_flatmap2combiner__S, _flatmap2combiner__That]: ...
    _fold__U = typing.TypeVar('_fold__U')  # <U>
    def fold(self, z: _fold__U, op: scala.Function2[_fold__U, _fold__U, _fold__U]) -> _fold__U: ...
    _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
    def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, _BufferSplitter__T, _foldLeft__B]) -> _foldLeft__B: ...
    _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
    def foldRight(self, z: _foldRight__B, op: scala.Function2[_BufferSplitter__T, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
    def forall(self, p: scala.Function1[_BufferSplitter__T, typing.Any]) -> bool: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_BufferSplitter__T, _foreach__U]) -> None: ...
    _grouped__B = typing.TypeVar('_grouped__B')  # <B>
    def grouped(self, size: int) -> scala.collection.Iterator.GroupedIterator[_grouped__B]: ...
    def hasDefiniteSize(self) -> bool: ...
    def hasNext(self) -> bool: ...
    def indexFlag(self) -> int: ...
    _indexOf_0__B = typing.TypeVar('_indexOf_0__B')  # <B>
    _indexOf_1__B = typing.TypeVar('_indexOf_1__B')  # <B>
    @typing.overload
    def indexOf(self, elem: _indexOf_0__B) -> int: ...
    @typing.overload
    def indexOf(self, elem: _indexOf_1__B, from_: int) -> int: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[_BufferSplitter__T, typing.Any]) -> int: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[_BufferSplitter__T, typing.Any], from_: int) -> int: ...
    def isAborted(self) -> bool: ...
    def isEmpty(self) -> bool: ...
    def isRemainingCheap(self) -> bool: ...
    def isTraversableAgain(self) -> bool: ...
    def length(self) -> int: ...
    _map__S = typing.TypeVar('_map__S')  # <S>
    def map(self, f: scala.Function1[_BufferSplitter__T, _map__S]) -> 'IterableSplitter.Mapped'[_map__S]: ...
    _map2combiner__S = typing.TypeVar('_map2combiner__S')  # <S>
    _map2combiner__That = typing.TypeVar('_map2combiner__That')  # <That>
    def map2combiner(self, f: scala.Function1[_BufferSplitter__T, _map2combiner__S], cb: Combiner[_map2combiner__S, _map2combiner__That]) -> Combiner[_map2combiner__S, _map2combiner__That]: ...
    _max__U = typing.TypeVar('_max__U')  # <U>
    def max(self, ord: scala.math.Ordering[_max__U]) -> _BufferSplitter__T: ...
    _maxBy__B = typing.TypeVar('_maxBy__B')  # <B>
    def maxBy(self, f: scala.Function1[_BufferSplitter__T, _maxBy__B], cmp: scala.math.Ordering[_maxBy__B]) -> _BufferSplitter__T: ...
    _min__U = typing.TypeVar('_min__U')  # <U>
    def min(self, ord: scala.math.Ordering[_min__U]) -> _BufferSplitter__T: ...
    _minBy__B = typing.TypeVar('_minBy__B')  # <B>
    def minBy(self, f: scala.Function1[_BufferSplitter__T, _minBy__B], cmp: scala.math.Ordering[_minBy__B]) -> _BufferSplitter__T: ...
    @typing.overload
    def mkString(self) -> java.lang.String: ...
    @typing.overload
    def mkString(self, sep: typing.Union[java.lang.String, str]) -> java.lang.String: ...
    @typing.overload
    def mkString(self, start: typing.Union[java.lang.String, str], sep: typing.Union[java.lang.String, str], end: typing.Union[java.lang.String, str]) -> java.lang.String: ...
    _newSliceInternal__U = typing.TypeVar('_newSliceInternal__U', bound='IterableSplitter.Taken')  # <U>
    def newSliceInternal(self, it: _newSliceInternal__U, from1: int) -> _newSliceInternal__U: ...
    def newTaken(self, until: int) -> 'IterableSplitter.Taken': ...
    def next(self) -> _BufferSplitter__T: ...
    def nonEmpty(self) -> bool: ...
    _padTo__A1 = typing.TypeVar('_padTo__A1')  # <A1>
    def padTo(self, len: int, elem: _padTo__A1) -> scala.collection.Iterator[_padTo__A1]: ...
    def partition(self, p: scala.Function1[_BufferSplitter__T, typing.Any]) -> scala.Tuple2[scala.collection.Iterator[_BufferSplitter__T], scala.collection.Iterator[_BufferSplitter__T]]: ...
    _partition2combiners__U = typing.TypeVar('_partition2combiners__U')  # <U>
    _partition2combiners__This = typing.TypeVar('_partition2combiners__This')  # <This>
    def partition2combiners(self, pred: scala.Function1[_BufferSplitter__T, typing.Any], btrue: Combiner[_partition2combiners__U, _partition2combiners__This], bfalse: Combiner[_partition2combiners__U, _partition2combiners__This]) -> scala.Tuple2[Combiner[_partition2combiners__U, _partition2combiners__This], Combiner[_partition2combiners__U, _partition2combiners__This]]: ...
    _patch__B = typing.TypeVar('_patch__B')  # <B>
    def patch(self, from_: int, patchElems: scala.collection.Iterator[_patch__B], replaced: int) -> scala.collection.Iterator[_patch__B]: ...
    _product__U = typing.TypeVar('_product__U')  # <U>
    def product(self, num: scala.math.Numeric[_product__U]) -> _product__U: ...
    _reduce__U = typing.TypeVar('_reduce__U')  # <U>
    def reduce(self, op: scala.Function2[_reduce__U, _reduce__U, _reduce__U]) -> _reduce__U: ...
    _reduceLeft_0__U = typing.TypeVar('_reduceLeft_0__U')  # <U>
    _reduceLeft_1__B = typing.TypeVar('_reduceLeft_1__B')  # <B>
    @typing.overload
    def reduceLeft(self, howmany: int, op: scala.Function2[_reduceLeft_0__U, _reduceLeft_0__U, _reduceLeft_0__U]) -> _reduceLeft_0__U: ...
    @typing.overload
    def reduceLeft(self, op: scala.Function2[_reduceLeft_1__B, _BufferSplitter__T, _reduceLeft_1__B]) -> _reduceLeft_1__B: ...
    _reduceLeftOption__B = typing.TypeVar('_reduceLeftOption__B')  # <B>
    def reduceLeftOption(self, op: scala.Function2[_reduceLeftOption__B, _BufferSplitter__T, _reduceLeftOption__B]) -> scala.Option[_reduceLeftOption__B]: ...
    _reduceOption__A1 = typing.TypeVar('_reduceOption__A1')  # <A1>
    def reduceOption(self, op: scala.Function2[_reduceOption__A1, _reduceOption__A1, _reduceOption__A1]) -> scala.Option[_reduceOption__A1]: ...
    _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
    def reduceRight(self, op: scala.Function2[_BufferSplitter__T, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
    _reduceRightOption__B = typing.TypeVar('_reduceRightOption__B')  # <B>
    def reduceRightOption(self, op: scala.Function2[_BufferSplitter__T, _reduceRightOption__B, _reduceRightOption__B]) -> scala.Option[_reduceRightOption__B]: ...
    def remaining(self) -> int: ...
    def reversed(self) -> scala.collection.immutable.List[_BufferSplitter__T]: ...
    def sameElements(self, that: scala.collection.Iterator[typing.Any]) -> bool: ...
    _scanLeft__B = typing.TypeVar('_scanLeft__B')  # <B>
    def scanLeft(self, z: _scanLeft__B, op: scala.Function2[_scanLeft__B, _BufferSplitter__T, _scanLeft__B]) -> scala.collection.Iterator[_scanLeft__B]: ...
    _scanRight__B = typing.TypeVar('_scanRight__B')  # <B>
    def scanRight(self, z: _scanRight__B, op: scala.Function2[_BufferSplitter__T, _scanRight__B, _scanRight__B]) -> scala.collection.Iterator[_scanRight__B]: ...
    _scanToArray__U = typing.TypeVar('_scanToArray__U')  # <U>
    _scanToArray__A = typing.TypeVar('_scanToArray__A')  # <A>
    def scanToArray(self, z: _scanToArray__U, op: scala.Function2[_scanToArray__U, _scanToArray__U, _scanToArray__U], array: typing.Any, from_: int) -> None: ...
    _scanToCombiner_0__U = typing.TypeVar('_scanToCombiner_0__U')  # <U>
    _scanToCombiner_0__That = typing.TypeVar('_scanToCombiner_0__That')  # <That>
    _scanToCombiner_1__U = typing.TypeVar('_scanToCombiner_1__U')  # <U>
    _scanToCombiner_1__That = typing.TypeVar('_scanToCombiner_1__That')  # <That>
    @typing.overload
    def scanToCombiner(self, howmany: int, startValue: _scanToCombiner_0__U, op: scala.Function2[_scanToCombiner_0__U, _scanToCombiner_0__U, _scanToCombiner_0__U], cb: Combiner[_scanToCombiner_0__U, _scanToCombiner_0__That]) -> Combiner[_scanToCombiner_0__U, _scanToCombiner_0__That]: ...
    @typing.overload
    def scanToCombiner(self, startValue: _scanToCombiner_1__U, op: scala.Function2[_scanToCombiner_1__U, _scanToCombiner_1__U, _scanToCombiner_1__U], cb: Combiner[_scanToCombiner_1__U, _scanToCombiner_1__That]) -> Combiner[_scanToCombiner_1__U, _scanToCombiner_1__That]: ...
    def seq(self) -> scala.collection.Iterator[_BufferSplitter__T]: ...
    def setIndexFlag(self, f: int) -> None: ...
    def setIndexFlagIfGreater(self, f: int) -> None: ...
    def setIndexFlagIfLesser(self, f: int) -> None: ...
    _shouldSplitFurther__S = typing.TypeVar('_shouldSplitFurther__S')  # <S>
    def shouldSplitFurther(self, coll: 'ParIterable'[_shouldSplitFurther__S], parallelismLevel: int) -> bool: ...
    def signalDelegate(self) -> scala.collection.generic.Signalling: ...
    def signalDelegate_$eq(self, x$1: scala.collection.generic.Signalling) -> None: ...
    def size(self) -> int: ...
    def sizeHintIfCheap(self) -> int: ...
    def slice(self, from1: int, until1: int) -> 'IterableSplitter'[_BufferSplitter__T]: ...
    _slice2combiner__U = typing.TypeVar('_slice2combiner__U')  # <U>
    _slice2combiner__This = typing.TypeVar('_slice2combiner__This')  # <This>
    def slice2combiner(self, from_: int, until: int, cb: Combiner[_slice2combiner__U, _slice2combiner__This]) -> Combiner[_slice2combiner__U, _slice2combiner__This]: ...
    def sliceIterator(self, from_: int, until: int) -> scala.collection.Iterator[_BufferSplitter__T]: ...
    _sliding__B = typing.TypeVar('_sliding__B')  # <B>
    def sliding(self, size: int, step: int) -> scala.collection.Iterator.GroupedIterator[_sliding__B]: ...
    _sliding$default$2__B = typing.TypeVar('_sliding$default$2__B')  # <B>
    def sliding$default$2(self) -> int: ...
    def span(self, p: scala.Function1[_BufferSplitter__T, typing.Any]) -> scala.Tuple2[scala.collection.Iterator[_BufferSplitter__T], scala.collection.Iterator[_BufferSplitter__T]]: ...
    _span2combiners__U = typing.TypeVar('_span2combiners__U')  # <U>
    _span2combiners__This = typing.TypeVar('_span2combiners__This')  # <This>
    def span2combiners(self, p: scala.Function1[_BufferSplitter__T, typing.Any], before: Combiner[_span2combiners__U, _span2combiners__This], after: Combiner[_span2combiners__U, _span2combiners__This]) -> scala.Tuple2[Combiner[_span2combiners__U, _span2combiners__This], Combiner[_span2combiners__U, _span2combiners__This]]: ...
    def split(self) -> scala.collection.Seq['IterableSplitter'[_BufferSplitter__T]]: ...
    _splitAt2combiners__U = typing.TypeVar('_splitAt2combiners__U')  # <U>
    _splitAt2combiners__This = typing.TypeVar('_splitAt2combiners__This')  # <This>
    def splitAt2combiners(self, at: int, before: Combiner[_splitAt2combiners__U, _splitAt2combiners__This], after: Combiner[_splitAt2combiners__U, _splitAt2combiners__This]) -> scala.Tuple2[Combiner[_splitAt2combiners__U, _splitAt2combiners__This], Combiner[_splitAt2combiners__U, _splitAt2combiners__This]]: ...
    def splitWithSignalling(self) -> scala.collection.Seq['IterableSplitter'[_BufferSplitter__T]]: ...
    _sum__U = typing.TypeVar('_sum__U')  # <U>
    def sum(self, num: scala.math.Numeric[_sum__U]) -> _sum__U: ...
    def tag(self) -> int: ...
    def take(self, n: int) -> 'IterableSplitter'[_BufferSplitter__T]: ...
    _take2combiner__U = typing.TypeVar('_take2combiner__U')  # <U>
    _take2combiner__This = typing.TypeVar('_take2combiner__This')  # <This>
    def take2combiner(self, n: int, cb: Combiner[_take2combiner__U, _take2combiner__This]) -> Combiner[_take2combiner__U, _take2combiner__This]: ...
    def takeWhile(self, p: scala.Function1[_BufferSplitter__T, typing.Any]) -> scala.collection.Iterator[_BufferSplitter__T]: ...
    _takeWhile2combiner__U = typing.TypeVar('_takeWhile2combiner__U')  # <U>
    _takeWhile2combiner__This = typing.TypeVar('_takeWhile2combiner__This')  # <This>
    def takeWhile2combiner(self, p: scala.Function1[_BufferSplitter__T, typing.Any], cb: Combiner[_takeWhile2combiner__U, _takeWhile2combiner__This]) -> scala.Tuple2[Combiner[_takeWhile2combiner__U, _takeWhile2combiner__This], typing.Any]: ...
    _to__Col = typing.TypeVar('_to__Col')  # <Col>
    def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., _BufferSplitter__T, _to__Col]) -> _to__Col: ...
    _toArray__B = typing.TypeVar('_toArray__B')  # <B>
    def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__B]) -> typing.Any: ...
    _toBuffer__B = typing.TypeVar('_toBuffer__B')  # <B>
    def toBuffer(self) -> scala.collection.mutable.Buffer[_toBuffer__B]: ...
    def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq[_BufferSplitter__T]: ...
    def toIterable(self) -> scala.collection.Iterable[_BufferSplitter__T]: ...
    def toIterator(self) -> scala.collection.Iterator[_BufferSplitter__T]: ...
    def toList(self) -> scala.collection.immutable.List[_BufferSplitter__T]: ...
    _toMap__T = typing.TypeVar('_toMap__T')  # <T>
    _toMap__U = typing.TypeVar('_toMap__U')  # <U>
    def toMap(self, ev: scala.Predef..less.colon.less[typing.Any, scala.Tuple2[typing.Any, _toMap__U]]) -> scala.collection.immutable.Map[typing.Any, _toMap__U]: ...
    def toSeq(self) -> scala.collection.Seq[_BufferSplitter__T]: ...
    _toSet__B = typing.TypeVar('_toSet__B')  # <B>
    def toSet(self) -> scala.collection.immutable.Set[_toSet__B]: ...
    def toStream(self) -> scala.collection.immutable.Stream[_BufferSplitter__T]: ...
    def toString(self) -> java.lang.String: ...
    def toTraversable(self) -> scala.collection.Traversable[_BufferSplitter__T]: ...
    def toVector(self) -> scala.collection.immutable.Vector[_BufferSplitter__T]: ...
    def withFilter(self, p: scala.Function1[_BufferSplitter__T, typing.Any]) -> scala.collection.Iterator[_BufferSplitter__T]: ...
    _zip__B = typing.TypeVar('_zip__B')  # <B>
    def zip(self, that: scala.collection.Iterator[_zip__B]) -> scala.collection.Iterator[scala.Tuple2[_BufferSplitter__T, _zip__B]]: ...
    _zip2combiner__U = typing.TypeVar('_zip2combiner__U')  # <U>
    _zip2combiner__S = typing.TypeVar('_zip2combiner__S')  # <S>
    _zip2combiner__That = typing.TypeVar('_zip2combiner__That')  # <That>
    def zip2combiner(self, otherpit: RemainsIterator[_zip2combiner__S], cb: Combiner[scala.Tuple2[_zip2combiner__U, _zip2combiner__S], _zip2combiner__That]) -> Combiner[scala.Tuple2[_zip2combiner__U, _zip2combiner__S], _zip2combiner__That]: ...
    _zipAll__B = typing.TypeVar('_zipAll__B')  # <B>
    _zipAll__A1 = typing.TypeVar('_zipAll__A1')  # <A1>
    _zipAll__B1 = typing.TypeVar('_zipAll__B1')  # <B1>
    def zipAll(self, that: scala.collection.Iterator[_zipAll__B], thisElem: _zipAll__A1, thatElem: _zipAll__B1) -> scala.collection.Iterator[scala.Tuple2[_zipAll__A1, _zipAll__B1]]: ...
    _zipAll2combiner__U = typing.TypeVar('_zipAll2combiner__U')  # <U>
    _zipAll2combiner__S = typing.TypeVar('_zipAll2combiner__S')  # <S>
    _zipAll2combiner__That = typing.TypeVar('_zipAll2combiner__That')  # <That>
    def zipAll2combiner(self, that: RemainsIterator[_zipAll2combiner__S], thiselem: _zipAll2combiner__U, thatelem: _zipAll2combiner__S, cb: Combiner[scala.Tuple2[_zipAll2combiner__U, _zipAll2combiner__S], _zipAll2combiner__That]) -> Combiner[scala.Tuple2[_zipAll2combiner__U, _zipAll2combiner__S], _zipAll2combiner__That]: ...
    _zipAllParSeq__S = typing.TypeVar('_zipAllParSeq__S')  # <S>
    _zipAllParSeq__U = typing.TypeVar('_zipAllParSeq__U')  # <U>
    _zipAllParSeq__R = typing.TypeVar('_zipAllParSeq__R')  # <R>
    def zipAllParSeq(self, that: 'SeqSplitter'[_zipAllParSeq__S], thisElem: _zipAllParSeq__U, thatElem: _zipAllParSeq__R) -> 'IterableSplitter.ZippedAll'[_zipAllParSeq__U, _zipAllParSeq__R]: ...
    _zipParSeq__S = typing.TypeVar('_zipParSeq__S')  # <S>
    def zipParSeq(self, that: 'SeqSplitter'[_zipParSeq__S]) -> 'IterableSplitter.Zipped'[_zipParSeq__S]: ...
    def zipWithIndex(self) -> scala.collection.Iterator[scala.Tuple2[_BufferSplitter__T, typing.Any]]: ...

_IterableSplitter__Appended__U = typing.TypeVar('_IterableSplitter__Appended__U')  # <U>
_IterableSplitter__Appended__PI = typing.TypeVar('_IterableSplitter__Appended__PI', bound='IterableSplitter')  # <PI>
_IterableSplitter__Mapped__S = typing.TypeVar('_IterableSplitter__Mapped__S')  # <S>
_IterableSplitter__Zipped__S = typing.TypeVar('_IterableSplitter__Zipped__S')  # <S>
_IterableSplitter__ZippedAll__U = typing.TypeVar('_IterableSplitter__ZippedAll__U')  # <U>
_IterableSplitter__ZippedAll__S = typing.TypeVar('_IterableSplitter__ZippedAll__S')  # <S>
_IterableSplitter__T = typing.TypeVar('_IterableSplitter__T')  # <T>
class IterableSplitter(AugmentedIterableIterator[_IterableSplitter__T], Splitter[_IterableSplitter__T], scala.collection.generic.DelegatedSignalling, typing.Generic[_IterableSplitter__T]):
    @staticmethod
    def $init$($this: 'IterableSplitter') -> None: ...
    _appendParIterable__U = typing.TypeVar('_appendParIterable__U')  # <U>
    _appendParIterable__PI = typing.TypeVar('_appendParIterable__PI', bound='IterableSplitter')  # <PI>
    def appendParIterable(self, that: _appendParIterable__PI) -> 'IterableSplitter.Appended'[_appendParIterable__U, _appendParIterable__PI]: ...
    def buildString(self, closure: scala.Function1[scala.Function1[typing.Union[java.lang.String, str], scala.runtime.BoxedUnit], scala.runtime.BoxedUnit]) -> java.lang.String: ...
    def debugInformation(self) -> java.lang.String: ...
    @typing.overload
    def drop(self, n: int) -> scala.collection.Iterator[typing.Any]: ...
    @typing.overload
    def drop(self, n: int) -> 'IterableSplitter'[_IterableSplitter__T]: ...
    def dup(self) -> 'IterableSplitter'[_IterableSplitter__T]: ...
    _map_0__B = typing.TypeVar('_map_0__B')  # <B>
    _map_1__S = typing.TypeVar('_map_1__S')  # <S>
    @typing.overload
    def map(self, f: scala.Function1[typing.Any, _map_0__B]) -> scala.collection.Iterator[_map_0__B]: ...
    @typing.overload
    def map(self, f: scala.Function1[_IterableSplitter__T, _map_1__S]) -> 'IterableSplitter.Mapped'[_map_1__S]: ...
    _newSliceInternal__U = typing.TypeVar('_newSliceInternal__U', bound='IterableSplitter.Taken')  # <U>
    def newSliceInternal(self, it: _newSliceInternal__U, from1: int) -> _newSliceInternal__U: ...
    def newTaken(self, until: int) -> 'IterableSplitter.Taken': ...
    def remaining(self) -> int: ...
    _shouldSplitFurther__S = typing.TypeVar('_shouldSplitFurther__S')  # <S>
    def shouldSplitFurther(self, coll: 'ParIterable'[_shouldSplitFurther__S], parallelismLevel: int) -> bool: ...
    def signalDelegate(self) -> scala.collection.generic.Signalling: ...
    def signalDelegate_$eq(self, x$1: scala.collection.generic.Signalling) -> None: ...
    @typing.overload
    def slice(self, from_: int, until: int) -> scala.collection.Iterator[typing.Any]: ...
    @typing.overload
    def slice(self, from1: int, until1: int) -> 'IterableSplitter'[_IterableSplitter__T]: ...
    def split(self) -> scala.collection.Seq['IterableSplitter'[_IterableSplitter__T]]: ...
    def splitWithSignalling(self) -> scala.collection.Seq['IterableSplitter'[_IterableSplitter__T]]: ...
    @typing.overload
    def take(self, n: int) -> scala.collection.Iterator[typing.Any]: ...
    @typing.overload
    def take(self, n: int) -> 'IterableSplitter'[_IterableSplitter__T]: ...
    def toString(self) -> java.lang.String: ...
    _zipAllParSeq__S = typing.TypeVar('_zipAllParSeq__S')  # <S>
    _zipAllParSeq__U = typing.TypeVar('_zipAllParSeq__U')  # <U>
    _zipAllParSeq__R = typing.TypeVar('_zipAllParSeq__R')  # <R>
    def zipAllParSeq(self, that: 'SeqSplitter'[_zipAllParSeq__S], thisElem: _zipAllParSeq__U, thatElem: _zipAllParSeq__R) -> 'IterableSplitter.ZippedAll'[_zipAllParSeq__U, _zipAllParSeq__R]: ...
    _zipParSeq__S = typing.TypeVar('_zipParSeq__S')  # <S>
    def zipParSeq(self, that: 'SeqSplitter'[_zipParSeq__S]) -> 'IterableSplitter.Zipped'[_zipParSeq__S]: ...
    class Appended(scala.collection.parallel.IterableSplitter[_IterableSplitter__Appended__U], typing.Generic[_IterableSplitter__Appended__U, _IterableSplitter__Appended__PI]):
        $outer: 'IterableSplitter' = ...
        def __init__(self, $outer: 'IterableSplitter', that: _IterableSplitter__Appended__PI): ...
        _$colon$bslash__B = typing.TypeVar('_$colon$bslash__B')  # <B>
        def $colon$bslash(self, z: _.colon.bslash__B, op: scala.Function2[_IterableSplitter__Appended__U, _.colon.bslash__B, _.colon.bslash__B]) -> _.colon.bslash__B: ...
        _$div$colon__B = typing.TypeVar('_$div$colon__B')  # <B>
        def $div$colon(self, z: _.div.colon__B, op: scala.Function2[_.div.colon__B, _IterableSplitter__Appended__U, _.div.colon__B]) -> _.div.colon__B: ...
        _$plus$plus__B = typing.TypeVar('_$plus$plus__B')  # <B>
        def $plus$plus(self, that: scala.Function0[scala.collection.GenTraversableOnce[_.plus.plus__B]]) -> scala.collection.Iterator[_.plus.plus__B]: ...
        def abort(self) -> None: ...
        @typing.overload
        def addString(self, b: scala.collection.mutable.StringBuilder) -> scala.collection.mutable.StringBuilder: ...
        @typing.overload
        def addString(self, b: scala.collection.mutable.StringBuilder, sep: typing.Union[java.lang.String, str]) -> scala.collection.mutable.StringBuilder: ...
        @typing.overload
        def addString(self, b: scala.collection.mutable.StringBuilder, start: typing.Union[java.lang.String, str], sep: typing.Union[java.lang.String, str], end: typing.Union[java.lang.String, str]) -> scala.collection.mutable.StringBuilder: ...
        _aggregate__B = typing.TypeVar('_aggregate__B')  # <B>
        def aggregate(self, z: scala.Function0[_aggregate__B], seqop: scala.Function2[_aggregate__B, _IterableSplitter__Appended__U, _aggregate__B], combop: scala.Function2[_aggregate__B, _aggregate__B, _aggregate__B]) -> _aggregate__B: ...
        _appendParIterable__U = typing.TypeVar('_appendParIterable__U')  # <U>
        _appendParIterable__PI = typing.TypeVar('_appendParIterable__PI', bound='IterableSplitter')  # <PI>
        def appendParIterable(self, that: 'IterableSplitter') -> 'IterableSplitter.Appended'[typing.Any, 'IterableSplitter']: ...
        def buffered(self) -> scala.collection.BufferedIterator[_IterableSplitter__Appended__U]: ...
        def buildString(self, closure: scala.Function1[scala.Function1[typing.Union[java.lang.String, str], scala.runtime.BoxedUnit], scala.runtime.BoxedUnit]) -> java.lang.String: ...
        _collect__B = typing.TypeVar('_collect__B')  # <B>
        def collect(self, pf: scala.PartialFunction[_IterableSplitter__Appended__U, _collect__B]) -> scala.collection.Iterator[_collect__B]: ...
        _collect2combiner__S = typing.TypeVar('_collect2combiner__S')  # <S>
        _collect2combiner__That = typing.TypeVar('_collect2combiner__That')  # <That>
        def collect2combiner(self, pf: scala.PartialFunction[_IterableSplitter__Appended__U, _collect2combiner__S], cb: Combiner[_collect2combiner__S, _collect2combiner__That]) -> Combiner[_collect2combiner__S, _collect2combiner__That]: ...
        _collectFirst__B = typing.TypeVar('_collectFirst__B')  # <B>
        def collectFirst(self, pf: scala.PartialFunction[_IterableSplitter__Appended__U, _collectFirst__B]) -> scala.Option[_collectFirst__B]: ...
        def contains(self, elem: typing.Any) -> bool: ...
        _copy2builder__U = typing.TypeVar('_copy2builder__U')  # <U>
        _copy2builder__Coll = typing.TypeVar('_copy2builder__Coll')  # <Coll>
        _copy2builder__Bld = typing.TypeVar('_copy2builder__Bld', bound=scala.collection.mutable.Builder)  # <Bld>
        def copy2builder(self, b: _copy2builder__Bld) -> _copy2builder__Bld: ...
        _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
        _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
        _copyToArray_2__U = typing.TypeVar('_copyToArray_2__U')  # <U>
        @typing.overload
        def copyToArray(self, xs: typing.Any) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int) -> None: ...
        @typing.overload
        def copyToArray(self, array: typing.Any, from_: int, len: int) -> None: ...
        _copyToBuffer__B = typing.TypeVar('_copyToBuffer__B')  # <B>
        def copyToBuffer(self, dest: scala.collection.mutable.Buffer[_copyToBuffer__B]) -> None: ...
        _corresponds__B = typing.TypeVar('_corresponds__B')  # <B>
        def corresponds(self, that: scala.collection.GenTraversableOnce[_corresponds__B], p: scala.Function2[_IterableSplitter__Appended__U, _corresponds__B, typing.Any]) -> bool: ...
        def count(self, p: scala.Function1[_IterableSplitter__Appended__U, typing.Any]) -> int: ...
        def curr(self) -> 'IterableSplitter'[_IterableSplitter__Appended__U]: ...
        def curr_$eq(self, x$1: 'IterableSplitter'[_IterableSplitter__Appended__U]) -> None: ...
        def debugInformation(self) -> java.lang.String: ...
        def drop(self, n: int) -> 'IterableSplitter'[_IterableSplitter__Appended__U]: ...
        _drop2combiner__U = typing.TypeVar('_drop2combiner__U')  # <U>
        _drop2combiner__This = typing.TypeVar('_drop2combiner__This')  # <This>
        def drop2combiner(self, n: int, cb: Combiner[typing.Any, _drop2combiner__This]) -> Combiner[typing.Any, _drop2combiner__This]: ...
        def dropWhile(self, p: scala.Function1[_IterableSplitter__Appended__U, typing.Any]) -> scala.collection.Iterator[_IterableSplitter__Appended__U]: ...
        def dup(self) -> 'IterableSplitter'[_IterableSplitter__Appended__U]: ...
        def duplicate(self) -> scala.Tuple2[scala.collection.Iterator[_IterableSplitter__Appended__U], scala.collection.Iterator[_IterableSplitter__Appended__U]]: ...
        def exists(self, p: scala.Function1[_IterableSplitter__Appended__U, typing.Any]) -> bool: ...
        def filter(self, p: scala.Function1[_IterableSplitter__Appended__U, typing.Any]) -> scala.collection.Iterator[_IterableSplitter__Appended__U]: ...
        _filter2combiner__U = typing.TypeVar('_filter2combiner__U')  # <U>
        _filter2combiner__This = typing.TypeVar('_filter2combiner__This')  # <This>
        def filter2combiner(self, pred: scala.Function1[typing.Any, typing.Any], cb: Combiner[typing.Any, _filter2combiner__This]) -> Combiner[typing.Any, _filter2combiner__This]: ...
        def filterNot(self, p: scala.Function1[_IterableSplitter__Appended__U, typing.Any]) -> scala.collection.Iterator[_IterableSplitter__Appended__U]: ...
        _filterNot2combiner__U = typing.TypeVar('_filterNot2combiner__U')  # <U>
        _filterNot2combiner__This = typing.TypeVar('_filterNot2combiner__This')  # <This>
        def filterNot2combiner(self, pred: scala.Function1[typing.Any, typing.Any], cb: Combiner[typing.Any, _filterNot2combiner__This]) -> Combiner[typing.Any, _filterNot2combiner__This]: ...
        def find(self, p: scala.Function1[_IterableSplitter__Appended__U, typing.Any]) -> scala.Option[_IterableSplitter__Appended__U]: ...
        def firstNonEmpty(self) -> bool: ...
        _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
        def flatMap(self, f: scala.Function1[_IterableSplitter__Appended__U, scala.collection.GenTraversableOnce[_flatMap__B]]) -> scala.collection.Iterator[_flatMap__B]: ...
        _flatmap2combiner__S = typing.TypeVar('_flatmap2combiner__S')  # <S>
        _flatmap2combiner__That = typing.TypeVar('_flatmap2combiner__That')  # <That>
        def flatmap2combiner(self, f: scala.Function1[_IterableSplitter__Appended__U, scala.collection.GenTraversableOnce[_flatmap2combiner__S]], cb: Combiner[_flatmap2combiner__S, _flatmap2combiner__That]) -> Combiner[_flatmap2combiner__S, _flatmap2combiner__That]: ...
        _fold__U = typing.TypeVar('_fold__U')  # <U>
        def fold(self, z: typing.Any, op: scala.Function2[typing.Any, typing.Any, typing.Any]) -> typing.Any: ...
        _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
        def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, _IterableSplitter__Appended__U, _foldLeft__B]) -> _foldLeft__B: ...
        _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
        def foldRight(self, z: _foldRight__B, op: scala.Function2[_IterableSplitter__Appended__U, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
        def forall(self, p: scala.Function1[_IterableSplitter__Appended__U, typing.Any]) -> bool: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[typing.Any, typing.Any]) -> None: ...
        _grouped__B = typing.TypeVar('_grouped__B')  # <B>
        def grouped(self, size: int) -> scala.collection.Iterator.GroupedIterator[_grouped__B]: ...
        def hasDefiniteSize(self) -> bool: ...
        def hasNext(self) -> bool: ...
        def indexFlag(self) -> int: ...
        _indexOf_0__B = typing.TypeVar('_indexOf_0__B')  # <B>
        _indexOf_1__B = typing.TypeVar('_indexOf_1__B')  # <B>
        @typing.overload
        def indexOf(self, elem: _indexOf_0__B) -> int: ...
        @typing.overload
        def indexOf(self, elem: _indexOf_1__B, from_: int) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[_IterableSplitter__Appended__U, typing.Any]) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[_IterableSplitter__Appended__U, typing.Any], from_: int) -> int: ...
        def isAborted(self) -> bool: ...
        def isEmpty(self) -> bool: ...
        def isRemainingCheap(self) -> bool: ...
        def isTraversableAgain(self) -> bool: ...
        def length(self) -> int: ...
        _map__S = typing.TypeVar('_map__S')  # <S>
        def map(self, f: scala.Function1[_IterableSplitter__Appended__U, _map__S]) -> 'IterableSplitter.Mapped'[_map__S]: ...
        _map2combiner__S = typing.TypeVar('_map2combiner__S')  # <S>
        _map2combiner__That = typing.TypeVar('_map2combiner__That')  # <That>
        def map2combiner(self, f: scala.Function1[_IterableSplitter__Appended__U, _map2combiner__S], cb: Combiner[_map2combiner__S, _map2combiner__That]) -> Combiner[_map2combiner__S, _map2combiner__That]: ...
        _max__U = typing.TypeVar('_max__U')  # <U>
        def max(self, ord: scala.math.Ordering[typing.Any]) -> typing.Any: ...
        _maxBy__B = typing.TypeVar('_maxBy__B')  # <B>
        def maxBy(self, f: scala.Function1[_IterableSplitter__Appended__U, _maxBy__B], cmp: scala.math.Ordering[_maxBy__B]) -> _IterableSplitter__Appended__U: ...
        _min__U = typing.TypeVar('_min__U')  # <U>
        def min(self, ord: scala.math.Ordering[typing.Any]) -> typing.Any: ...
        _minBy__B = typing.TypeVar('_minBy__B')  # <B>
        def minBy(self, f: scala.Function1[_IterableSplitter__Appended__U, _minBy__B], cmp: scala.math.Ordering[_minBy__B]) -> _IterableSplitter__Appended__U: ...
        @typing.overload
        def mkString(self) -> java.lang.String: ...
        @typing.overload
        def mkString(self, sep: typing.Union[java.lang.String, str]) -> java.lang.String: ...
        @typing.overload
        def mkString(self, start: typing.Union[java.lang.String, str], sep: typing.Union[java.lang.String, str], end: typing.Union[java.lang.String, str]) -> java.lang.String: ...
        _newSliceInternal__U = typing.TypeVar('_newSliceInternal__U', bound='IterableSplitter.Taken')  # <U>
        def newSliceInternal(self, it: 'IterableSplitter.Taken', from1: int) -> 'IterableSplitter.Taken': ...
        def newTaken(self, until: int) -> 'IterableSplitter.Taken': ...
        def next(self) -> _IterableSplitter__Appended__U: ...
        def nonEmpty(self) -> bool: ...
        _padTo__A1 = typing.TypeVar('_padTo__A1')  # <A1>
        def padTo(self, len: int, elem: _padTo__A1) -> scala.collection.Iterator[_padTo__A1]: ...
        def partition(self, p: scala.Function1[_IterableSplitter__Appended__U, typing.Any]) -> scala.Tuple2[scala.collection.Iterator[_IterableSplitter__Appended__U], scala.collection.Iterator[_IterableSplitter__Appended__U]]: ...
        _partition2combiners__U = typing.TypeVar('_partition2combiners__U')  # <U>
        _partition2combiners__This = typing.TypeVar('_partition2combiners__This')  # <This>
        def partition2combiners(self, pred: scala.Function1[typing.Any, typing.Any], btrue: Combiner[typing.Any, _partition2combiners__This], bfalse: Combiner[typing.Any, _partition2combiners__This]) -> scala.Tuple2[Combiner[typing.Any, _partition2combiners__This], Combiner[typing.Any, _partition2combiners__This]]: ...
        _patch__B = typing.TypeVar('_patch__B')  # <B>
        def patch(self, from_: int, patchElems: scala.collection.Iterator[_patch__B], replaced: int) -> scala.collection.Iterator[_patch__B]: ...
        _product__U = typing.TypeVar('_product__U')  # <U>
        def product(self, num: scala.math.Numeric[typing.Any]) -> typing.Any: ...
        _reduce__U = typing.TypeVar('_reduce__U')  # <U>
        def reduce(self, op: scala.Function2[typing.Any, typing.Any, typing.Any]) -> typing.Any: ...
        _reduceLeft_0__U = typing.TypeVar('_reduceLeft_0__U')  # <U>
        _reduceLeft_1__B = typing.TypeVar('_reduceLeft_1__B')  # <B>
        @typing.overload
        def reduceLeft(self, howmany: int, op: scala.Function2[typing.Any, typing.Any, typing.Any]) -> typing.Any: ...
        @typing.overload
        def reduceLeft(self, op: scala.Function2[_reduceLeft_1__B, _IterableSplitter__Appended__U, _reduceLeft_1__B]) -> _reduceLeft_1__B: ...
        _reduceLeftOption__B = typing.TypeVar('_reduceLeftOption__B')  # <B>
        def reduceLeftOption(self, op: scala.Function2[_reduceLeftOption__B, _IterableSplitter__Appended__U, _reduceLeftOption__B]) -> scala.Option[_reduceLeftOption__B]: ...
        _reduceOption__A1 = typing.TypeVar('_reduceOption__A1')  # <A1>
        def reduceOption(self, op: scala.Function2[_reduceOption__A1, _reduceOption__A1, _reduceOption__A1]) -> scala.Option[_reduceOption__A1]: ...
        _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
        def reduceRight(self, op: scala.Function2[_IterableSplitter__Appended__U, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
        _reduceRightOption__B = typing.TypeVar('_reduceRightOption__B')  # <B>
        def reduceRightOption(self, op: scala.Function2[_IterableSplitter__Appended__U, _reduceRightOption__B, _reduceRightOption__B]) -> scala.Option[_reduceRightOption__B]: ...
        def remaining(self) -> int: ...
        def reversed(self) -> scala.collection.immutable.List[_IterableSplitter__Appended__U]: ...
        def sameElements(self, that: scala.collection.Iterator[typing.Any]) -> bool: ...
        _scanLeft__B = typing.TypeVar('_scanLeft__B')  # <B>
        def scanLeft(self, z: _scanLeft__B, op: scala.Function2[_scanLeft__B, _IterableSplitter__Appended__U, _scanLeft__B]) -> scala.collection.Iterator[_scanLeft__B]: ...
        _scanRight__B = typing.TypeVar('_scanRight__B')  # <B>
        def scanRight(self, z: _scanRight__B, op: scala.Function2[_IterableSplitter__Appended__U, _scanRight__B, _scanRight__B]) -> scala.collection.Iterator[_scanRight__B]: ...
        _scanToArray__U = typing.TypeVar('_scanToArray__U')  # <U>
        _scanToArray__A = typing.TypeVar('_scanToArray__A')  # <A>
        def scanToArray(self, z: typing.Any, op: scala.Function2[typing.Any, typing.Any, typing.Any], array: typing.Any, from_: int) -> None: ...
        _scanToCombiner_0__U = typing.TypeVar('_scanToCombiner_0__U')  # <U>
        _scanToCombiner_0__That = typing.TypeVar('_scanToCombiner_0__That')  # <That>
        _scanToCombiner_1__U = typing.TypeVar('_scanToCombiner_1__U')  # <U>
        _scanToCombiner_1__That = typing.TypeVar('_scanToCombiner_1__That')  # <That>
        @typing.overload
        def scanToCombiner(self, howmany: int, startValue: typing.Any, op: scala.Function2[typing.Any, typing.Any, typing.Any], cb: Combiner[typing.Any, _scanToCombiner_0__That]) -> Combiner[typing.Any, _scanToCombiner_0__That]: ...
        @typing.overload
        def scanToCombiner(self, startValue: typing.Any, op: scala.Function2[typing.Any, typing.Any, typing.Any], cb: Combiner[typing.Any, _scanToCombiner_1__That]) -> Combiner[typing.Any, _scanToCombiner_1__That]: ...
        def seq(self) -> scala.collection.Iterator[_IterableSplitter__Appended__U]: ...
        def setIndexFlag(self, f: int) -> None: ...
        def setIndexFlagIfGreater(self, f: int) -> None: ...
        def setIndexFlagIfLesser(self, f: int) -> None: ...
        _shouldSplitFurther__S = typing.TypeVar('_shouldSplitFurther__S')  # <S>
        def shouldSplitFurther(self, coll: 'ParIterable'[_shouldSplitFurther__S], parallelismLevel: int) -> bool: ...
        def signalDelegate(self) -> scala.collection.generic.Signalling: ...
        def signalDelegate_$eq(self, x$1: scala.collection.generic.Signalling) -> None: ...
        def size(self) -> int: ...
        def sizeHintIfCheap(self) -> int: ...
        def slice(self, from1: int, until1: int) -> 'IterableSplitter'[_IterableSplitter__Appended__U]: ...
        _slice2combiner__U = typing.TypeVar('_slice2combiner__U')  # <U>
        _slice2combiner__This = typing.TypeVar('_slice2combiner__This')  # <This>
        def slice2combiner(self, from_: int, until: int, cb: Combiner[typing.Any, _slice2combiner__This]) -> Combiner[typing.Any, _slice2combiner__This]: ...
        def sliceIterator(self, from_: int, until: int) -> scala.collection.Iterator[_IterableSplitter__Appended__U]: ...
        _sliding__B = typing.TypeVar('_sliding__B')  # <B>
        def sliding(self, size: int, step: int) -> scala.collection.Iterator.GroupedIterator[_sliding__B]: ...
        _sliding$default$2__B = typing.TypeVar('_sliding$default$2__B')  # <B>
        def sliding$default$2(self) -> int: ...
        def span(self, p: scala.Function1[_IterableSplitter__Appended__U, typing.Any]) -> scala.Tuple2[scala.collection.Iterator[_IterableSplitter__Appended__U], scala.collection.Iterator[_IterableSplitter__Appended__U]]: ...
        _span2combiners__U = typing.TypeVar('_span2combiners__U')  # <U>
        _span2combiners__This = typing.TypeVar('_span2combiners__This')  # <This>
        def span2combiners(self, p: scala.Function1[typing.Any, typing.Any], before: Combiner[typing.Any, _span2combiners__This], after: Combiner[typing.Any, _span2combiners__This]) -> scala.Tuple2[Combiner[typing.Any, _span2combiners__This], Combiner[typing.Any, _span2combiners__This]]: ...
        def split(self) -> scala.collection.Seq['IterableSplitter'[_IterableSplitter__Appended__U]]: ...
        _splitAt2combiners__U = typing.TypeVar('_splitAt2combiners__U')  # <U>
        _splitAt2combiners__This = typing.TypeVar('_splitAt2combiners__This')  # <This>
        def splitAt2combiners(self, at: int, before: Combiner[typing.Any, _splitAt2combiners__This], after: Combiner[typing.Any, _splitAt2combiners__This]) -> scala.Tuple2[Combiner[typing.Any, _splitAt2combiners__This], Combiner[typing.Any, _splitAt2combiners__This]]: ...
        def splitWithSignalling(self) -> scala.collection.Seq['IterableSplitter'[_IterableSplitter__Appended__U]]: ...
        _sum__U = typing.TypeVar('_sum__U')  # <U>
        def sum(self, num: scala.math.Numeric[typing.Any]) -> typing.Any: ...
        def tag(self) -> int: ...
        def take(self, n: int) -> 'IterableSplitter'[_IterableSplitter__Appended__U]: ...
        _take2combiner__U = typing.TypeVar('_take2combiner__U')  # <U>
        _take2combiner__This = typing.TypeVar('_take2combiner__This')  # <This>
        def take2combiner(self, n: int, cb: Combiner[typing.Any, _take2combiner__This]) -> Combiner[typing.Any, _take2combiner__This]: ...
        def takeWhile(self, p: scala.Function1[_IterableSplitter__Appended__U, typing.Any]) -> scala.collection.Iterator[_IterableSplitter__Appended__U]: ...
        _takeWhile2combiner__U = typing.TypeVar('_takeWhile2combiner__U')  # <U>
        _takeWhile2combiner__This = typing.TypeVar('_takeWhile2combiner__This')  # <This>
        def takeWhile2combiner(self, p: scala.Function1[typing.Any, typing.Any], cb: Combiner[typing.Any, _takeWhile2combiner__This]) -> scala.Tuple2[Combiner[typing.Any, _takeWhile2combiner__This], typing.Any]: ...
        def that(self) -> _IterableSplitter__Appended__PI: ...
        _to__Col = typing.TypeVar('_to__Col')  # <Col>
        def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., _IterableSplitter__Appended__U, _to__Col]) -> _to__Col: ...
        _toArray__B = typing.TypeVar('_toArray__B')  # <B>
        def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__B]) -> typing.Any: ...
        _toBuffer__B = typing.TypeVar('_toBuffer__B')  # <B>
        def toBuffer(self) -> scala.collection.mutable.Buffer[_toBuffer__B]: ...
        def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq[_IterableSplitter__Appended__U]: ...
        def toIterable(self) -> scala.collection.Iterable[_IterableSplitter__Appended__U]: ...
        def toIterator(self) -> scala.collection.Iterator[_IterableSplitter__Appended__U]: ...
        def toList(self) -> scala.collection.immutable.List[_IterableSplitter__Appended__U]: ...
        _toMap__T = typing.TypeVar('_toMap__T')  # <T>
        _toMap__U = typing.TypeVar('_toMap__U')  # <U>
        def toMap(self, ev: scala.Predef..less.colon.less[typing.Any, scala.Tuple2[typing.Any, typing.Any]]) -> scala.collection.immutable.Map[typing.Any, typing.Any]: ...
        def toSeq(self) -> scala.collection.Seq[_IterableSplitter__Appended__U]: ...
        _toSet__B = typing.TypeVar('_toSet__B')  # <B>
        def toSet(self) -> scala.collection.immutable.Set[_toSet__B]: ...
        def toStream(self) -> scala.collection.immutable.Stream[_IterableSplitter__Appended__U]: ...
        def toString(self) -> java.lang.String: ...
        def toTraversable(self) -> scala.collection.Traversable[_IterableSplitter__Appended__U]: ...
        def toVector(self) -> scala.collection.immutable.Vector[_IterableSplitter__Appended__U]: ...
        def withFilter(self, p: scala.Function1[_IterableSplitter__Appended__U, typing.Any]) -> scala.collection.Iterator[_IterableSplitter__Appended__U]: ...
        _zip__B = typing.TypeVar('_zip__B')  # <B>
        def zip(self, that: scala.collection.Iterator[_zip__B]) -> scala.collection.Iterator[scala.Tuple2[_IterableSplitter__Appended__U, _zip__B]]: ...
        _zip2combiner__U = typing.TypeVar('_zip2combiner__U')  # <U>
        _zip2combiner__S = typing.TypeVar('_zip2combiner__S')  # <S>
        _zip2combiner__That = typing.TypeVar('_zip2combiner__That')  # <That>
        def zip2combiner(self, otherpit: RemainsIterator[_zip2combiner__S], cb: Combiner[scala.Tuple2[typing.Any, _zip2combiner__S], _zip2combiner__That]) -> Combiner[scala.Tuple2[typing.Any, _zip2combiner__S], _zip2combiner__That]: ...
        _zipAll__B = typing.TypeVar('_zipAll__B')  # <B>
        _zipAll__A1 = typing.TypeVar('_zipAll__A1')  # <A1>
        _zipAll__B1 = typing.TypeVar('_zipAll__B1')  # <B1>
        def zipAll(self, that: scala.collection.Iterator[_zipAll__B], thisElem: _zipAll__A1, thatElem: _zipAll__B1) -> scala.collection.Iterator[scala.Tuple2[_zipAll__A1, _zipAll__B1]]: ...
        _zipAll2combiner__U = typing.TypeVar('_zipAll2combiner__U')  # <U>
        _zipAll2combiner__S = typing.TypeVar('_zipAll2combiner__S')  # <S>
        _zipAll2combiner__That = typing.TypeVar('_zipAll2combiner__That')  # <That>
        def zipAll2combiner(self, that: RemainsIterator[_zipAll2combiner__S], thiselem: typing.Any, thatelem: _zipAll2combiner__S, cb: Combiner[scala.Tuple2[typing.Any, _zipAll2combiner__S], _zipAll2combiner__That]) -> Combiner[scala.Tuple2[typing.Any, _zipAll2combiner__S], _zipAll2combiner__That]: ...
        _zipAllParSeq__S = typing.TypeVar('_zipAllParSeq__S')  # <S>
        _zipAllParSeq__U = typing.TypeVar('_zipAllParSeq__U')  # <U>
        _zipAllParSeq__R = typing.TypeVar('_zipAllParSeq__R')  # <R>
        def zipAllParSeq(self, that: 'SeqSplitter'[_zipAllParSeq__S], thisElem: typing.Any, thatElem: _zipAllParSeq__R) -> 'IterableSplitter.ZippedAll'[typing.Any, _zipAllParSeq__R]: ...
        _zipParSeq__S = typing.TypeVar('_zipParSeq__S')  # <S>
        def zipParSeq(self, that: 'SeqSplitter'[_zipParSeq__S]) -> 'IterableSplitter.Zipped'[_zipParSeq__S]: ...
        def zipWithIndex(self) -> scala.collection.Iterator[scala.Tuple2[_IterableSplitter__Appended__U, typing.Any]]: ...
    class Mapped(scala.collection.parallel.IterableSplitter[_IterableSplitter__Mapped__S], typing.Generic[_IterableSplitter__Mapped__S]):
        $outer: 'IterableSplitter' = ...
        def __init__(self, $outer: 'IterableSplitter', f: scala.Function1[_IterableSplitter__T, _IterableSplitter__Mapped__S]): ...
        _$colon$bslash__B = typing.TypeVar('_$colon$bslash__B')  # <B>
        def $colon$bslash(self, z: _.colon.bslash__B, op: scala.Function2[_IterableSplitter__Mapped__S, _.colon.bslash__B, _.colon.bslash__B]) -> _.colon.bslash__B: ...
        _$div$colon__B = typing.TypeVar('_$div$colon__B')  # <B>
        def $div$colon(self, z: _.div.colon__B, op: scala.Function2[_.div.colon__B, _IterableSplitter__Mapped__S, _.div.colon__B]) -> _.div.colon__B: ...
        _$plus$plus__B = typing.TypeVar('_$plus$plus__B')  # <B>
        def $plus$plus(self, that: scala.Function0[scala.collection.GenTraversableOnce[_.plus.plus__B]]) -> scala.collection.Iterator[_.plus.plus__B]: ...
        def abort(self) -> None: ...
        @typing.overload
        def addString(self, b: scala.collection.mutable.StringBuilder) -> scala.collection.mutable.StringBuilder: ...
        @typing.overload
        def addString(self, b: scala.collection.mutable.StringBuilder, sep: typing.Union[java.lang.String, str]) -> scala.collection.mutable.StringBuilder: ...
        @typing.overload
        def addString(self, b: scala.collection.mutable.StringBuilder, start: typing.Union[java.lang.String, str], sep: typing.Union[java.lang.String, str], end: typing.Union[java.lang.String, str]) -> scala.collection.mutable.StringBuilder: ...
        _aggregate__B = typing.TypeVar('_aggregate__B')  # <B>
        def aggregate(self, z: scala.Function0[_aggregate__B], seqop: scala.Function2[_aggregate__B, _IterableSplitter__Mapped__S, _aggregate__B], combop: scala.Function2[_aggregate__B, _aggregate__B, _aggregate__B]) -> _aggregate__B: ...
        _appendParIterable__U = typing.TypeVar('_appendParIterable__U')  # <U>
        _appendParIterable__PI = typing.TypeVar('_appendParIterable__PI', bound='IterableSplitter')  # <PI>
        def appendParIterable(self, that: _appendParIterable__PI) -> 'IterableSplitter.Appended'[_appendParIterable__U, _appendParIterable__PI]: ...
        def buffered(self) -> scala.collection.BufferedIterator[_IterableSplitter__Mapped__S]: ...
        def buildString(self, closure: scala.Function1[scala.Function1[typing.Union[java.lang.String, str], scala.runtime.BoxedUnit], scala.runtime.BoxedUnit]) -> java.lang.String: ...
        _collect__B = typing.TypeVar('_collect__B')  # <B>
        def collect(self, pf: scala.PartialFunction[_IterableSplitter__Mapped__S, _collect__B]) -> scala.collection.Iterator[_collect__B]: ...
        _collect2combiner__S = typing.TypeVar('_collect2combiner__S')  # <S>
        _collect2combiner__That = typing.TypeVar('_collect2combiner__That')  # <That>
        def collect2combiner(self, pf: scala.PartialFunction[typing.Any, typing.Any], cb: Combiner[typing.Any, _collect2combiner__That]) -> Combiner[typing.Any, _collect2combiner__That]: ...
        _collectFirst__B = typing.TypeVar('_collectFirst__B')  # <B>
        def collectFirst(self, pf: scala.PartialFunction[_IterableSplitter__Mapped__S, _collectFirst__B]) -> scala.Option[_collectFirst__B]: ...
        def contains(self, elem: typing.Any) -> bool: ...
        _copy2builder__U = typing.TypeVar('_copy2builder__U')  # <U>
        _copy2builder__Coll = typing.TypeVar('_copy2builder__Coll')  # <Coll>
        _copy2builder__Bld = typing.TypeVar('_copy2builder__Bld', bound=scala.collection.mutable.Builder)  # <Bld>
        def copy2builder(self, b: _copy2builder__Bld) -> _copy2builder__Bld: ...
        _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
        _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
        _copyToArray_2__U = typing.TypeVar('_copyToArray_2__U')  # <U>
        @typing.overload
        def copyToArray(self, xs: typing.Any) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int) -> None: ...
        @typing.overload
        def copyToArray(self, array: typing.Any, from_: int, len: int) -> None: ...
        _copyToBuffer__B = typing.TypeVar('_copyToBuffer__B')  # <B>
        def copyToBuffer(self, dest: scala.collection.mutable.Buffer[_copyToBuffer__B]) -> None: ...
        _corresponds__B = typing.TypeVar('_corresponds__B')  # <B>
        def corresponds(self, that: scala.collection.GenTraversableOnce[_corresponds__B], p: scala.Function2[_IterableSplitter__Mapped__S, _corresponds__B, typing.Any]) -> bool: ...
        def count(self, p: scala.Function1[_IterableSplitter__Mapped__S, typing.Any]) -> int: ...
        def debugInformation(self) -> java.lang.String: ...
        def drop(self, n: int) -> 'IterableSplitter'[_IterableSplitter__Mapped__S]: ...
        _drop2combiner__U = typing.TypeVar('_drop2combiner__U')  # <U>
        _drop2combiner__This = typing.TypeVar('_drop2combiner__This')  # <This>
        def drop2combiner(self, n: int, cb: Combiner[_drop2combiner__U, _drop2combiner__This]) -> Combiner[_drop2combiner__U, _drop2combiner__This]: ...
        def dropWhile(self, p: scala.Function1[_IterableSplitter__Mapped__S, typing.Any]) -> scala.collection.Iterator[_IterableSplitter__Mapped__S]: ...
        def dup(self) -> 'IterableSplitter'[_IterableSplitter__Mapped__S]: ...
        def duplicate(self) -> scala.Tuple2[scala.collection.Iterator[_IterableSplitter__Mapped__S], scala.collection.Iterator[_IterableSplitter__Mapped__S]]: ...
        def exists(self, p: scala.Function1[_IterableSplitter__Mapped__S, typing.Any]) -> bool: ...
        def filter(self, p: scala.Function1[_IterableSplitter__Mapped__S, typing.Any]) -> scala.collection.Iterator[_IterableSplitter__Mapped__S]: ...
        _filter2combiner__U = typing.TypeVar('_filter2combiner__U')  # <U>
        _filter2combiner__This = typing.TypeVar('_filter2combiner__This')  # <This>
        def filter2combiner(self, pred: scala.Function1[_IterableSplitter__Mapped__S, typing.Any], cb: Combiner[_filter2combiner__U, _filter2combiner__This]) -> Combiner[_filter2combiner__U, _filter2combiner__This]: ...
        def filterNot(self, p: scala.Function1[_IterableSplitter__Mapped__S, typing.Any]) -> scala.collection.Iterator[_IterableSplitter__Mapped__S]: ...
        _filterNot2combiner__U = typing.TypeVar('_filterNot2combiner__U')  # <U>
        _filterNot2combiner__This = typing.TypeVar('_filterNot2combiner__This')  # <This>
        def filterNot2combiner(self, pred: scala.Function1[_IterableSplitter__Mapped__S, typing.Any], cb: Combiner[_filterNot2combiner__U, _filterNot2combiner__This]) -> Combiner[_filterNot2combiner__U, _filterNot2combiner__This]: ...
        def find(self, p: scala.Function1[_IterableSplitter__Mapped__S, typing.Any]) -> scala.Option[_IterableSplitter__Mapped__S]: ...
        _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
        def flatMap(self, f: scala.Function1[_IterableSplitter__Mapped__S, scala.collection.GenTraversableOnce[_flatMap__B]]) -> scala.collection.Iterator[_flatMap__B]: ...
        _flatmap2combiner__S = typing.TypeVar('_flatmap2combiner__S')  # <S>
        _flatmap2combiner__That = typing.TypeVar('_flatmap2combiner__That')  # <That>
        def flatmap2combiner(self, f: scala.Function1[typing.Any, scala.collection.GenTraversableOnce[typing.Any]], cb: Combiner[typing.Any, _flatmap2combiner__That]) -> Combiner[typing.Any, _flatmap2combiner__That]: ...
        _fold__U = typing.TypeVar('_fold__U')  # <U>
        def fold(self, z: _fold__U, op: scala.Function2[_fold__U, _fold__U, _fold__U]) -> _fold__U: ...
        _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
        def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, _IterableSplitter__Mapped__S, _foldLeft__B]) -> _foldLeft__B: ...
        _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
        def foldRight(self, z: _foldRight__B, op: scala.Function2[_IterableSplitter__Mapped__S, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
        def forall(self, p: scala.Function1[_IterableSplitter__Mapped__S, typing.Any]) -> bool: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[_IterableSplitter__Mapped__S, _foreach__U]) -> None: ...
        _grouped__B = typing.TypeVar('_grouped__B')  # <B>
        def grouped(self, size: int) -> scala.collection.Iterator.GroupedIterator[_grouped__B]: ...
        def hasDefiniteSize(self) -> bool: ...
        def hasNext(self) -> bool: ...
        def indexFlag(self) -> int: ...
        _indexOf_0__B = typing.TypeVar('_indexOf_0__B')  # <B>
        _indexOf_1__B = typing.TypeVar('_indexOf_1__B')  # <B>
        @typing.overload
        def indexOf(self, elem: _indexOf_0__B) -> int: ...
        @typing.overload
        def indexOf(self, elem: _indexOf_1__B, from_: int) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[_IterableSplitter__Mapped__S, typing.Any]) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[_IterableSplitter__Mapped__S, typing.Any], from_: int) -> int: ...
        def isAborted(self) -> bool: ...
        def isEmpty(self) -> bool: ...
        def isRemainingCheap(self) -> bool: ...
        def isTraversableAgain(self) -> bool: ...
        def length(self) -> int: ...
        _map__S = typing.TypeVar('_map__S')  # <S>
        def map(self, f: scala.Function1[typing.Any, typing.Any]) -> 'IterableSplitter.Mapped'[typing.Any]: ...
        _map2combiner__S = typing.TypeVar('_map2combiner__S')  # <S>
        _map2combiner__That = typing.TypeVar('_map2combiner__That')  # <That>
        def map2combiner(self, f: scala.Function1[typing.Any, typing.Any], cb: Combiner[typing.Any, _map2combiner__That]) -> Combiner[typing.Any, _map2combiner__That]: ...
        _max__U = typing.TypeVar('_max__U')  # <U>
        def max(self, ord: scala.math.Ordering[_max__U]) -> _IterableSplitter__Mapped__S: ...
        _maxBy__B = typing.TypeVar('_maxBy__B')  # <B>
        def maxBy(self, f: scala.Function1[_IterableSplitter__Mapped__S, _maxBy__B], cmp: scala.math.Ordering[_maxBy__B]) -> _IterableSplitter__Mapped__S: ...
        _min__U = typing.TypeVar('_min__U')  # <U>
        def min(self, ord: scala.math.Ordering[_min__U]) -> _IterableSplitter__Mapped__S: ...
        _minBy__B = typing.TypeVar('_minBy__B')  # <B>
        def minBy(self, f: scala.Function1[_IterableSplitter__Mapped__S, _minBy__B], cmp: scala.math.Ordering[_minBy__B]) -> _IterableSplitter__Mapped__S: ...
        @typing.overload
        def mkString(self) -> java.lang.String: ...
        @typing.overload
        def mkString(self, sep: typing.Union[java.lang.String, str]) -> java.lang.String: ...
        @typing.overload
        def mkString(self, start: typing.Union[java.lang.String, str], sep: typing.Union[java.lang.String, str], end: typing.Union[java.lang.String, str]) -> java.lang.String: ...
        _newSliceInternal__U = typing.TypeVar('_newSliceInternal__U', bound='IterableSplitter.Taken')  # <U>
        def newSliceInternal(self, it: _newSliceInternal__U, from1: int) -> _newSliceInternal__U: ...
        def newTaken(self, until: int) -> 'IterableSplitter.Taken': ...
        def next(self) -> _IterableSplitter__Mapped__S: ...
        def nonEmpty(self) -> bool: ...
        _padTo__A1 = typing.TypeVar('_padTo__A1')  # <A1>
        def padTo(self, len: int, elem: _padTo__A1) -> scala.collection.Iterator[_padTo__A1]: ...
        def partition(self, p: scala.Function1[_IterableSplitter__Mapped__S, typing.Any]) -> scala.Tuple2[scala.collection.Iterator[_IterableSplitter__Mapped__S], scala.collection.Iterator[_IterableSplitter__Mapped__S]]: ...
        _partition2combiners__U = typing.TypeVar('_partition2combiners__U')  # <U>
        _partition2combiners__This = typing.TypeVar('_partition2combiners__This')  # <This>
        def partition2combiners(self, pred: scala.Function1[_IterableSplitter__Mapped__S, typing.Any], btrue: Combiner[_partition2combiners__U, _partition2combiners__This], bfalse: Combiner[_partition2combiners__U, _partition2combiners__This]) -> scala.Tuple2[Combiner[_partition2combiners__U, _partition2combiners__This], Combiner[_partition2combiners__U, _partition2combiners__This]]: ...
        _patch__B = typing.TypeVar('_patch__B')  # <B>
        def patch(self, from_: int, patchElems: scala.collection.Iterator[_patch__B], replaced: int) -> scala.collection.Iterator[_patch__B]: ...
        _product__U = typing.TypeVar('_product__U')  # <U>
        def product(self, num: scala.math.Numeric[_product__U]) -> _product__U: ...
        _reduce__U = typing.TypeVar('_reduce__U')  # <U>
        def reduce(self, op: scala.Function2[_reduce__U, _reduce__U, _reduce__U]) -> _reduce__U: ...
        _reduceLeft_0__U = typing.TypeVar('_reduceLeft_0__U')  # <U>
        _reduceLeft_1__B = typing.TypeVar('_reduceLeft_1__B')  # <B>
        @typing.overload
        def reduceLeft(self, howmany: int, op: scala.Function2[_reduceLeft_0__U, _reduceLeft_0__U, _reduceLeft_0__U]) -> _reduceLeft_0__U: ...
        @typing.overload
        def reduceLeft(self, op: scala.Function2[_reduceLeft_1__B, _IterableSplitter__Mapped__S, _reduceLeft_1__B]) -> _reduceLeft_1__B: ...
        _reduceLeftOption__B = typing.TypeVar('_reduceLeftOption__B')  # <B>
        def reduceLeftOption(self, op: scala.Function2[_reduceLeftOption__B, _IterableSplitter__Mapped__S, _reduceLeftOption__B]) -> scala.Option[_reduceLeftOption__B]: ...
        _reduceOption__A1 = typing.TypeVar('_reduceOption__A1')  # <A1>
        def reduceOption(self, op: scala.Function2[_reduceOption__A1, _reduceOption__A1, _reduceOption__A1]) -> scala.Option[_reduceOption__A1]: ...
        _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
        def reduceRight(self, op: scala.Function2[_IterableSplitter__Mapped__S, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
        _reduceRightOption__B = typing.TypeVar('_reduceRightOption__B')  # <B>
        def reduceRightOption(self, op: scala.Function2[_IterableSplitter__Mapped__S, _reduceRightOption__B, _reduceRightOption__B]) -> scala.Option[_reduceRightOption__B]: ...
        def remaining(self) -> int: ...
        def reversed(self) -> scala.collection.immutable.List[_IterableSplitter__Mapped__S]: ...
        def sameElements(self, that: scala.collection.Iterator[typing.Any]) -> bool: ...
        _scanLeft__B = typing.TypeVar('_scanLeft__B')  # <B>
        def scanLeft(self, z: _scanLeft__B, op: scala.Function2[_scanLeft__B, _IterableSplitter__Mapped__S, _scanLeft__B]) -> scala.collection.Iterator[_scanLeft__B]: ...
        _scanRight__B = typing.TypeVar('_scanRight__B')  # <B>
        def scanRight(self, z: _scanRight__B, op: scala.Function2[_IterableSplitter__Mapped__S, _scanRight__B, _scanRight__B]) -> scala.collection.Iterator[_scanRight__B]: ...
        _scanToArray__U = typing.TypeVar('_scanToArray__U')  # <U>
        _scanToArray__A = typing.TypeVar('_scanToArray__A')  # <A>
        def scanToArray(self, z: _scanToArray__U, op: scala.Function2[_scanToArray__U, _scanToArray__U, _scanToArray__U], array: typing.Any, from_: int) -> None: ...
        _scanToCombiner_0__U = typing.TypeVar('_scanToCombiner_0__U')  # <U>
        _scanToCombiner_0__That = typing.TypeVar('_scanToCombiner_0__That')  # <That>
        _scanToCombiner_1__U = typing.TypeVar('_scanToCombiner_1__U')  # <U>
        _scanToCombiner_1__That = typing.TypeVar('_scanToCombiner_1__That')  # <That>
        @typing.overload
        def scanToCombiner(self, howmany: int, startValue: _scanToCombiner_0__U, op: scala.Function2[_scanToCombiner_0__U, _scanToCombiner_0__U, _scanToCombiner_0__U], cb: Combiner[_scanToCombiner_0__U, _scanToCombiner_0__That]) -> Combiner[_scanToCombiner_0__U, _scanToCombiner_0__That]: ...
        @typing.overload
        def scanToCombiner(self, startValue: _scanToCombiner_1__U, op: scala.Function2[_scanToCombiner_1__U, _scanToCombiner_1__U, _scanToCombiner_1__U], cb: Combiner[_scanToCombiner_1__U, _scanToCombiner_1__That]) -> Combiner[_scanToCombiner_1__U, _scanToCombiner_1__That]: ...
        def seq(self) -> scala.collection.Iterator[_IterableSplitter__Mapped__S]: ...
        def setIndexFlag(self, f: int) -> None: ...
        def setIndexFlagIfGreater(self, f: int) -> None: ...
        def setIndexFlagIfLesser(self, f: int) -> None: ...
        _shouldSplitFurther__S = typing.TypeVar('_shouldSplitFurther__S')  # <S>
        def shouldSplitFurther(self, coll: 'ParIterable'[typing.Any], parallelismLevel: int) -> bool: ...
        def signalDelegate(self) -> scala.collection.generic.Signalling: ...
        def signalDelegate_$eq(self, x$1: scala.collection.generic.Signalling) -> None: ...
        def size(self) -> int: ...
        def sizeHintIfCheap(self) -> int: ...
        def slice(self, from1: int, until1: int) -> 'IterableSplitter'[_IterableSplitter__Mapped__S]: ...
        _slice2combiner__U = typing.TypeVar('_slice2combiner__U')  # <U>
        _slice2combiner__This = typing.TypeVar('_slice2combiner__This')  # <This>
        def slice2combiner(self, from_: int, until: int, cb: Combiner[_slice2combiner__U, _slice2combiner__This]) -> Combiner[_slice2combiner__U, _slice2combiner__This]: ...
        def sliceIterator(self, from_: int, until: int) -> scala.collection.Iterator[_IterableSplitter__Mapped__S]: ...
        _sliding__B = typing.TypeVar('_sliding__B')  # <B>
        def sliding(self, size: int, step: int) -> scala.collection.Iterator.GroupedIterator[_sliding__B]: ...
        _sliding$default$2__B = typing.TypeVar('_sliding$default$2__B')  # <B>
        def sliding$default$2(self) -> int: ...
        def span(self, p: scala.Function1[_IterableSplitter__Mapped__S, typing.Any]) -> scala.Tuple2[scala.collection.Iterator[_IterableSplitter__Mapped__S], scala.collection.Iterator[_IterableSplitter__Mapped__S]]: ...
        _span2combiners__U = typing.TypeVar('_span2combiners__U')  # <U>
        _span2combiners__This = typing.TypeVar('_span2combiners__This')  # <This>
        def span2combiners(self, p: scala.Function1[_IterableSplitter__Mapped__S, typing.Any], before: Combiner[_span2combiners__U, _span2combiners__This], after: Combiner[_span2combiners__U, _span2combiners__This]) -> scala.Tuple2[Combiner[_span2combiners__U, _span2combiners__This], Combiner[_span2combiners__U, _span2combiners__This]]: ...
        def split(self) -> scala.collection.Seq['IterableSplitter'[_IterableSplitter__Mapped__S]]: ...
        _splitAt2combiners__U = typing.TypeVar('_splitAt2combiners__U')  # <U>
        _splitAt2combiners__This = typing.TypeVar('_splitAt2combiners__This')  # <This>
        def splitAt2combiners(self, at: int, before: Combiner[_splitAt2combiners__U, _splitAt2combiners__This], after: Combiner[_splitAt2combiners__U, _splitAt2combiners__This]) -> scala.Tuple2[Combiner[_splitAt2combiners__U, _splitAt2combiners__This], Combiner[_splitAt2combiners__U, _splitAt2combiners__This]]: ...
        def splitWithSignalling(self) -> scala.collection.Seq['IterableSplitter'[_IterableSplitter__Mapped__S]]: ...
        _sum__U = typing.TypeVar('_sum__U')  # <U>
        def sum(self, num: scala.math.Numeric[_sum__U]) -> _sum__U: ...
        def tag(self) -> int: ...
        def take(self, n: int) -> 'IterableSplitter'[_IterableSplitter__Mapped__S]: ...
        _take2combiner__U = typing.TypeVar('_take2combiner__U')  # <U>
        _take2combiner__This = typing.TypeVar('_take2combiner__This')  # <This>
        def take2combiner(self, n: int, cb: Combiner[_take2combiner__U, _take2combiner__This]) -> Combiner[_take2combiner__U, _take2combiner__This]: ...
        def takeWhile(self, p: scala.Function1[_IterableSplitter__Mapped__S, typing.Any]) -> scala.collection.Iterator[_IterableSplitter__Mapped__S]: ...
        _takeWhile2combiner__U = typing.TypeVar('_takeWhile2combiner__U')  # <U>
        _takeWhile2combiner__This = typing.TypeVar('_takeWhile2combiner__This')  # <This>
        def takeWhile2combiner(self, p: scala.Function1[_IterableSplitter__Mapped__S, typing.Any], cb: Combiner[_takeWhile2combiner__U, _takeWhile2combiner__This]) -> scala.Tuple2[Combiner[_takeWhile2combiner__U, _takeWhile2combiner__This], typing.Any]: ...
        _to__Col = typing.TypeVar('_to__Col')  # <Col>
        def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., _IterableSplitter__Mapped__S, _to__Col]) -> _to__Col: ...
        _toArray__B = typing.TypeVar('_toArray__B')  # <B>
        def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__B]) -> typing.Any: ...
        _toBuffer__B = typing.TypeVar('_toBuffer__B')  # <B>
        def toBuffer(self) -> scala.collection.mutable.Buffer[_toBuffer__B]: ...
        def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq[_IterableSplitter__Mapped__S]: ...
        def toIterable(self) -> scala.collection.Iterable[_IterableSplitter__Mapped__S]: ...
        def toIterator(self) -> scala.collection.Iterator[_IterableSplitter__Mapped__S]: ...
        def toList(self) -> scala.collection.immutable.List[_IterableSplitter__Mapped__S]: ...
        _toMap__T = typing.TypeVar('_toMap__T')  # <T>
        _toMap__U = typing.TypeVar('_toMap__U')  # <U>
        def toMap(self, ev: scala.Predef..less.colon.less[_IterableSplitter__Mapped__S, scala.Tuple2[typing.Any, _toMap__U]]) -> scala.collection.immutable.Map[typing.Any, _toMap__U]: ...
        def toSeq(self) -> scala.collection.Seq[_IterableSplitter__Mapped__S]: ...
        _toSet__B = typing.TypeVar('_toSet__B')  # <B>
        def toSet(self) -> scala.collection.immutable.Set[_toSet__B]: ...
        def toStream(self) -> scala.collection.immutable.Stream[_IterableSplitter__Mapped__S]: ...
        def toString(self) -> java.lang.String: ...
        def toTraversable(self) -> scala.collection.Traversable[_IterableSplitter__Mapped__S]: ...
        def toVector(self) -> scala.collection.immutable.Vector[_IterableSplitter__Mapped__S]: ...
        def withFilter(self, p: scala.Function1[_IterableSplitter__Mapped__S, typing.Any]) -> scala.collection.Iterator[_IterableSplitter__Mapped__S]: ...
        _zip__B = typing.TypeVar('_zip__B')  # <B>
        def zip(self, that: scala.collection.Iterator[_zip__B]) -> scala.collection.Iterator[scala.Tuple2[_IterableSplitter__Mapped__S, _zip__B]]: ...
        _zip2combiner__U = typing.TypeVar('_zip2combiner__U')  # <U>
        _zip2combiner__S = typing.TypeVar('_zip2combiner__S')  # <S>
        _zip2combiner__That = typing.TypeVar('_zip2combiner__That')  # <That>
        def zip2combiner(self, otherpit: RemainsIterator[typing.Any], cb: Combiner[scala.Tuple2[_zip2combiner__U, typing.Any], _zip2combiner__That]) -> Combiner[scala.Tuple2[_zip2combiner__U, typing.Any], _zip2combiner__That]: ...
        _zipAll__B = typing.TypeVar('_zipAll__B')  # <B>
        _zipAll__A1 = typing.TypeVar('_zipAll__A1')  # <A1>
        _zipAll__B1 = typing.TypeVar('_zipAll__B1')  # <B1>
        def zipAll(self, that: scala.collection.Iterator[_zipAll__B], thisElem: _zipAll__A1, thatElem: _zipAll__B1) -> scala.collection.Iterator[scala.Tuple2[_zipAll__A1, _zipAll__B1]]: ...
        _zipAll2combiner__U = typing.TypeVar('_zipAll2combiner__U')  # <U>
        _zipAll2combiner__S = typing.TypeVar('_zipAll2combiner__S')  # <S>
        _zipAll2combiner__That = typing.TypeVar('_zipAll2combiner__That')  # <That>
        def zipAll2combiner(self, that: RemainsIterator[typing.Any], thiselem: _zipAll2combiner__U, thatelem: typing.Any, cb: Combiner[scala.Tuple2[_zipAll2combiner__U, typing.Any], _zipAll2combiner__That]) -> Combiner[scala.Tuple2[_zipAll2combiner__U, typing.Any], _zipAll2combiner__That]: ...
        _zipAllParSeq__S = typing.TypeVar('_zipAllParSeq__S')  # <S>
        _zipAllParSeq__U = typing.TypeVar('_zipAllParSeq__U')  # <U>
        _zipAllParSeq__R = typing.TypeVar('_zipAllParSeq__R')  # <R>
        def zipAllParSeq(self, that: 'SeqSplitter'[typing.Any], thisElem: _zipAllParSeq__U, thatElem: _zipAllParSeq__R) -> 'IterableSplitter.ZippedAll'[_zipAllParSeq__U, _zipAllParSeq__R]: ...
        _zipParSeq__S = typing.TypeVar('_zipParSeq__S')  # <S>
        def zipParSeq(self, that: 'SeqSplitter'[typing.Any]) -> 'IterableSplitter.Zipped'[typing.Any]: ...
        def zipWithIndex(self) -> scala.collection.Iterator[scala.Tuple2[_IterableSplitter__Mapped__S, typing.Any]]: ...
    class Taken(scala.collection.parallel.IterableSplitter[_IterableSplitter__T]):
        $outer: 'IterableSplitter' = ...
        def __init__(self, $outer: 'IterableSplitter', taken: int): ...
        _$colon$bslash__B = typing.TypeVar('_$colon$bslash__B')  # <B>
        def $colon$bslash(self, z: _.colon.bslash__B, op: scala.Function2[_IterableSplitter__T, _.colon.bslash__B, _.colon.bslash__B]) -> _.colon.bslash__B: ...
        _$div$colon__B = typing.TypeVar('_$div$colon__B')  # <B>
        def $div$colon(self, z: _.div.colon__B, op: scala.Function2[_.div.colon__B, _IterableSplitter__T, _.div.colon__B]) -> _.div.colon__B: ...
        _$plus$plus__B = typing.TypeVar('_$plus$plus__B')  # <B>
        def $plus$plus(self, that: scala.Function0[scala.collection.GenTraversableOnce[_.plus.plus__B]]) -> scala.collection.Iterator[_.plus.plus__B]: ...
        def abort(self) -> None: ...
        @typing.overload
        def addString(self, b: scala.collection.mutable.StringBuilder) -> scala.collection.mutable.StringBuilder: ...
        @typing.overload
        def addString(self, b: scala.collection.mutable.StringBuilder, sep: typing.Union[java.lang.String, str]) -> scala.collection.mutable.StringBuilder: ...
        @typing.overload
        def addString(self, b: scala.collection.mutable.StringBuilder, start: typing.Union[java.lang.String, str], sep: typing.Union[java.lang.String, str], end: typing.Union[java.lang.String, str]) -> scala.collection.mutable.StringBuilder: ...
        _aggregate__B = typing.TypeVar('_aggregate__B')  # <B>
        def aggregate(self, z: scala.Function0[_aggregate__B], seqop: scala.Function2[_aggregate__B, _IterableSplitter__T, _aggregate__B], combop: scala.Function2[_aggregate__B, _aggregate__B, _aggregate__B]) -> _aggregate__B: ...
        _appendParIterable__U = typing.TypeVar('_appendParIterable__U')  # <U>
        _appendParIterable__PI = typing.TypeVar('_appendParIterable__PI', bound='IterableSplitter')  # <PI>
        def appendParIterable(self, that: _appendParIterable__PI) -> 'IterableSplitter.Appended'[_appendParIterable__U, _appendParIterable__PI]: ...
        def buffered(self) -> scala.collection.BufferedIterator[_IterableSplitter__T]: ...
        def buildString(self, closure: scala.Function1[scala.Function1[typing.Union[java.lang.String, str], scala.runtime.BoxedUnit], scala.runtime.BoxedUnit]) -> java.lang.String: ...
        _collect__B = typing.TypeVar('_collect__B')  # <B>
        def collect(self, pf: scala.PartialFunction[_IterableSplitter__T, _collect__B]) -> scala.collection.Iterator[_collect__B]: ...
        _collect2combiner__S = typing.TypeVar('_collect2combiner__S')  # <S>
        _collect2combiner__That = typing.TypeVar('_collect2combiner__That')  # <That>
        def collect2combiner(self, pf: scala.PartialFunction[_IterableSplitter__T, _collect2combiner__S], cb: Combiner[_collect2combiner__S, _collect2combiner__That]) -> Combiner[_collect2combiner__S, _collect2combiner__That]: ...
        _collectFirst__B = typing.TypeVar('_collectFirst__B')  # <B>
        def collectFirst(self, pf: scala.PartialFunction[_IterableSplitter__T, _collectFirst__B]) -> scala.Option[_collectFirst__B]: ...
        def contains(self, elem: typing.Any) -> bool: ...
        _copy2builder__U = typing.TypeVar('_copy2builder__U')  # <U>
        _copy2builder__Coll = typing.TypeVar('_copy2builder__Coll')  # <Coll>
        _copy2builder__Bld = typing.TypeVar('_copy2builder__Bld', bound=scala.collection.mutable.Builder)  # <Bld>
        def copy2builder(self, b: _copy2builder__Bld) -> _copy2builder__Bld: ...
        _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
        _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
        _copyToArray_2__U = typing.TypeVar('_copyToArray_2__U')  # <U>
        @typing.overload
        def copyToArray(self, xs: typing.Any) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int) -> None: ...
        @typing.overload
        def copyToArray(self, array: typing.Any, from_: int, len: int) -> None: ...
        _copyToBuffer__B = typing.TypeVar('_copyToBuffer__B')  # <B>
        def copyToBuffer(self, dest: scala.collection.mutable.Buffer[_copyToBuffer__B]) -> None: ...
        _corresponds__B = typing.TypeVar('_corresponds__B')  # <B>
        def corresponds(self, that: scala.collection.GenTraversableOnce[_corresponds__B], p: scala.Function2[_IterableSplitter__T, _corresponds__B, typing.Any]) -> bool: ...
        def count(self, p: scala.Function1[_IterableSplitter__T, typing.Any]) -> int: ...
        def debugInformation(self) -> java.lang.String: ...
        def drop(self, n: int) -> 'IterableSplitter'[_IterableSplitter__T]: ...
        _drop2combiner__U = typing.TypeVar('_drop2combiner__U')  # <U>
        _drop2combiner__This = typing.TypeVar('_drop2combiner__This')  # <This>
        def drop2combiner(self, n: int, cb: Combiner[_drop2combiner__U, _drop2combiner__This]) -> Combiner[_drop2combiner__U, _drop2combiner__This]: ...
        def dropWhile(self, p: scala.Function1[_IterableSplitter__T, typing.Any]) -> scala.collection.Iterator[_IterableSplitter__T]: ...
        def dup(self) -> 'IterableSplitter'[_IterableSplitter__T]: ...
        def duplicate(self) -> scala.Tuple2[scala.collection.Iterator[_IterableSplitter__T], scala.collection.Iterator[_IterableSplitter__T]]: ...
        def exists(self, p: scala.Function1[_IterableSplitter__T, typing.Any]) -> bool: ...
        def filter(self, p: scala.Function1[_IterableSplitter__T, typing.Any]) -> scala.collection.Iterator[_IterableSplitter__T]: ...
        _filter2combiner__U = typing.TypeVar('_filter2combiner__U')  # <U>
        _filter2combiner__This = typing.TypeVar('_filter2combiner__This')  # <This>
        def filter2combiner(self, pred: scala.Function1[_IterableSplitter__T, typing.Any], cb: Combiner[_filter2combiner__U, _filter2combiner__This]) -> Combiner[_filter2combiner__U, _filter2combiner__This]: ...
        def filterNot(self, p: scala.Function1[_IterableSplitter__T, typing.Any]) -> scala.collection.Iterator[_IterableSplitter__T]: ...
        _filterNot2combiner__U = typing.TypeVar('_filterNot2combiner__U')  # <U>
        _filterNot2combiner__This = typing.TypeVar('_filterNot2combiner__This')  # <This>
        def filterNot2combiner(self, pred: scala.Function1[_IterableSplitter__T, typing.Any], cb: Combiner[_filterNot2combiner__U, _filterNot2combiner__This]) -> Combiner[_filterNot2combiner__U, _filterNot2combiner__This]: ...
        def find(self, p: scala.Function1[_IterableSplitter__T, typing.Any]) -> scala.Option[_IterableSplitter__T]: ...
        _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
        def flatMap(self, f: scala.Function1[_IterableSplitter__T, scala.collection.GenTraversableOnce[_flatMap__B]]) -> scala.collection.Iterator[_flatMap__B]: ...
        _flatmap2combiner__S = typing.TypeVar('_flatmap2combiner__S')  # <S>
        _flatmap2combiner__That = typing.TypeVar('_flatmap2combiner__That')  # <That>
        def flatmap2combiner(self, f: scala.Function1[_IterableSplitter__T, scala.collection.GenTraversableOnce[_flatmap2combiner__S]], cb: Combiner[_flatmap2combiner__S, _flatmap2combiner__That]) -> Combiner[_flatmap2combiner__S, _flatmap2combiner__That]: ...
        _fold__U = typing.TypeVar('_fold__U')  # <U>
        def fold(self, z: _fold__U, op: scala.Function2[_fold__U, _fold__U, _fold__U]) -> _fold__U: ...
        _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
        def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, _IterableSplitter__T, _foldLeft__B]) -> _foldLeft__B: ...
        _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
        def foldRight(self, z: _foldRight__B, op: scala.Function2[_IterableSplitter__T, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
        def forall(self, p: scala.Function1[_IterableSplitter__T, typing.Any]) -> bool: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[_IterableSplitter__T, _foreach__U]) -> None: ...
        _grouped__B = typing.TypeVar('_grouped__B')  # <B>
        def grouped(self, size: int) -> scala.collection.Iterator.GroupedIterator[_grouped__B]: ...
        def hasDefiniteSize(self) -> bool: ...
        def hasNext(self) -> bool: ...
        def indexFlag(self) -> int: ...
        _indexOf_0__B = typing.TypeVar('_indexOf_0__B')  # <B>
        _indexOf_1__B = typing.TypeVar('_indexOf_1__B')  # <B>
        @typing.overload
        def indexOf(self, elem: _indexOf_0__B) -> int: ...
        @typing.overload
        def indexOf(self, elem: _indexOf_1__B, from_: int) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[_IterableSplitter__T, typing.Any]) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[_IterableSplitter__T, typing.Any], from_: int) -> int: ...
        def isAborted(self) -> bool: ...
        def isEmpty(self) -> bool: ...
        def isRemainingCheap(self) -> bool: ...
        def isTraversableAgain(self) -> bool: ...
        def length(self) -> int: ...
        _map__S = typing.TypeVar('_map__S')  # <S>
        def map(self, f: scala.Function1[_IterableSplitter__T, _map__S]) -> 'IterableSplitter.Mapped'[_map__S]: ...
        _map2combiner__S = typing.TypeVar('_map2combiner__S')  # <S>
        _map2combiner__That = typing.TypeVar('_map2combiner__That')  # <That>
        def map2combiner(self, f: scala.Function1[_IterableSplitter__T, _map2combiner__S], cb: Combiner[_map2combiner__S, _map2combiner__That]) -> Combiner[_map2combiner__S, _map2combiner__That]: ...
        _max__U = typing.TypeVar('_max__U')  # <U>
        def max(self, ord: scala.math.Ordering[_max__U]) -> _IterableSplitter__T: ...
        _maxBy__B = typing.TypeVar('_maxBy__B')  # <B>
        def maxBy(self, f: scala.Function1[_IterableSplitter__T, _maxBy__B], cmp: scala.math.Ordering[_maxBy__B]) -> _IterableSplitter__T: ...
        _min__U = typing.TypeVar('_min__U')  # <U>
        def min(self, ord: scala.math.Ordering[_min__U]) -> _IterableSplitter__T: ...
        _minBy__B = typing.TypeVar('_minBy__B')  # <B>
        def minBy(self, f: scala.Function1[_IterableSplitter__T, _minBy__B], cmp: scala.math.Ordering[_minBy__B]) -> _IterableSplitter__T: ...
        @typing.overload
        def mkString(self) -> java.lang.String: ...
        @typing.overload
        def mkString(self, sep: typing.Union[java.lang.String, str]) -> java.lang.String: ...
        @typing.overload
        def mkString(self, start: typing.Union[java.lang.String, str], sep: typing.Union[java.lang.String, str], end: typing.Union[java.lang.String, str]) -> java.lang.String: ...
        _newSliceInternal__U = typing.TypeVar('_newSliceInternal__U', bound='IterableSplitter.Taken')  # <U>
        def newSliceInternal(self, it: _newSliceInternal__U, from1: int) -> _newSliceInternal__U: ...
        def newTaken(self, until: int) -> 'IterableSplitter.Taken': ...
        def next(self) -> _IterableSplitter__T: ...
        def nonEmpty(self) -> bool: ...
        _padTo__A1 = typing.TypeVar('_padTo__A1')  # <A1>
        def padTo(self, len: int, elem: _padTo__A1) -> scala.collection.Iterator[_padTo__A1]: ...
        def partition(self, p: scala.Function1[_IterableSplitter__T, typing.Any]) -> scala.Tuple2[scala.collection.Iterator[_IterableSplitter__T], scala.collection.Iterator[_IterableSplitter__T]]: ...
        _partition2combiners__U = typing.TypeVar('_partition2combiners__U')  # <U>
        _partition2combiners__This = typing.TypeVar('_partition2combiners__This')  # <This>
        def partition2combiners(self, pred: scala.Function1[_IterableSplitter__T, typing.Any], btrue: Combiner[_partition2combiners__U, _partition2combiners__This], bfalse: Combiner[_partition2combiners__U, _partition2combiners__This]) -> scala.Tuple2[Combiner[_partition2combiners__U, _partition2combiners__This], Combiner[_partition2combiners__U, _partition2combiners__This]]: ...
        _patch__B = typing.TypeVar('_patch__B')  # <B>
        def patch(self, from_: int, patchElems: scala.collection.Iterator[_patch__B], replaced: int) -> scala.collection.Iterator[_patch__B]: ...
        _product__U = typing.TypeVar('_product__U')  # <U>
        def product(self, num: scala.math.Numeric[_product__U]) -> _product__U: ...
        _reduce__U = typing.TypeVar('_reduce__U')  # <U>
        def reduce(self, op: scala.Function2[_reduce__U, _reduce__U, _reduce__U]) -> _reduce__U: ...
        _reduceLeft_0__U = typing.TypeVar('_reduceLeft_0__U')  # <U>
        _reduceLeft_1__B = typing.TypeVar('_reduceLeft_1__B')  # <B>
        @typing.overload
        def reduceLeft(self, howmany: int, op: scala.Function2[_reduceLeft_0__U, _reduceLeft_0__U, _reduceLeft_0__U]) -> _reduceLeft_0__U: ...
        @typing.overload
        def reduceLeft(self, op: scala.Function2[_reduceLeft_1__B, _IterableSplitter__T, _reduceLeft_1__B]) -> _reduceLeft_1__B: ...
        _reduceLeftOption__B = typing.TypeVar('_reduceLeftOption__B')  # <B>
        def reduceLeftOption(self, op: scala.Function2[_reduceLeftOption__B, _IterableSplitter__T, _reduceLeftOption__B]) -> scala.Option[_reduceLeftOption__B]: ...
        _reduceOption__A1 = typing.TypeVar('_reduceOption__A1')  # <A1>
        def reduceOption(self, op: scala.Function2[_reduceOption__A1, _reduceOption__A1, _reduceOption__A1]) -> scala.Option[_reduceOption__A1]: ...
        _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
        def reduceRight(self, op: scala.Function2[_IterableSplitter__T, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
        _reduceRightOption__B = typing.TypeVar('_reduceRightOption__B')  # <B>
        def reduceRightOption(self, op: scala.Function2[_IterableSplitter__T, _reduceRightOption__B, _reduceRightOption__B]) -> scala.Option[_reduceRightOption__B]: ...
        def remaining(self) -> int: ...
        def remaining_$eq(self, x$1: int) -> None: ...
        def reversed(self) -> scala.collection.immutable.List[_IterableSplitter__T]: ...
        def sameElements(self, that: scala.collection.Iterator[typing.Any]) -> bool: ...
        _scanLeft__B = typing.TypeVar('_scanLeft__B')  # <B>
        def scanLeft(self, z: _scanLeft__B, op: scala.Function2[_scanLeft__B, _IterableSplitter__T, _scanLeft__B]) -> scala.collection.Iterator[_scanLeft__B]: ...
        _scanRight__B = typing.TypeVar('_scanRight__B')  # <B>
        def scanRight(self, z: _scanRight__B, op: scala.Function2[_IterableSplitter__T, _scanRight__B, _scanRight__B]) -> scala.collection.Iterator[_scanRight__B]: ...
        _scanToArray__U = typing.TypeVar('_scanToArray__U')  # <U>
        _scanToArray__A = typing.TypeVar('_scanToArray__A')  # <A>
        def scanToArray(self, z: _scanToArray__U, op: scala.Function2[_scanToArray__U, _scanToArray__U, _scanToArray__U], array: typing.Any, from_: int) -> None: ...
        _scanToCombiner_0__U = typing.TypeVar('_scanToCombiner_0__U')  # <U>
        _scanToCombiner_0__That = typing.TypeVar('_scanToCombiner_0__That')  # <That>
        _scanToCombiner_1__U = typing.TypeVar('_scanToCombiner_1__U')  # <U>
        _scanToCombiner_1__That = typing.TypeVar('_scanToCombiner_1__That')  # <That>
        @typing.overload
        def scanToCombiner(self, howmany: int, startValue: _scanToCombiner_0__U, op: scala.Function2[_scanToCombiner_0__U, _scanToCombiner_0__U, _scanToCombiner_0__U], cb: Combiner[_scanToCombiner_0__U, _scanToCombiner_0__That]) -> Combiner[_scanToCombiner_0__U, _scanToCombiner_0__That]: ...
        @typing.overload
        def scanToCombiner(self, startValue: _scanToCombiner_1__U, op: scala.Function2[_scanToCombiner_1__U, _scanToCombiner_1__U, _scanToCombiner_1__U], cb: Combiner[_scanToCombiner_1__U, _scanToCombiner_1__That]) -> Combiner[_scanToCombiner_1__U, _scanToCombiner_1__That]: ...
        def seq(self) -> scala.collection.Iterator[_IterableSplitter__T]: ...
        def setIndexFlag(self, f: int) -> None: ...
        def setIndexFlagIfGreater(self, f: int) -> None: ...
        def setIndexFlagIfLesser(self, f: int) -> None: ...
        _shouldSplitFurther__S = typing.TypeVar('_shouldSplitFurther__S')  # <S>
        def shouldSplitFurther(self, coll: 'ParIterable'[_shouldSplitFurther__S], parallelismLevel: int) -> bool: ...
        def signalDelegate(self) -> scala.collection.generic.Signalling: ...
        def signalDelegate_$eq(self, x$1: scala.collection.generic.Signalling) -> None: ...
        def size(self) -> int: ...
        def sizeHintIfCheap(self) -> int: ...
        def slice(self, from1: int, until1: int) -> 'IterableSplitter'[_IterableSplitter__T]: ...
        _slice2combiner__U = typing.TypeVar('_slice2combiner__U')  # <U>
        _slice2combiner__This = typing.TypeVar('_slice2combiner__This')  # <This>
        def slice2combiner(self, from_: int, until: int, cb: Combiner[_slice2combiner__U, _slice2combiner__This]) -> Combiner[_slice2combiner__U, _slice2combiner__This]: ...
        def sliceIterator(self, from_: int, until: int) -> scala.collection.Iterator[_IterableSplitter__T]: ...
        _sliding__B = typing.TypeVar('_sliding__B')  # <B>
        def sliding(self, size: int, step: int) -> scala.collection.Iterator.GroupedIterator[_sliding__B]: ...
        _sliding$default$2__B = typing.TypeVar('_sliding$default$2__B')  # <B>
        def sliding$default$2(self) -> int: ...
        def span(self, p: scala.Function1[_IterableSplitter__T, typing.Any]) -> scala.Tuple2[scala.collection.Iterator[_IterableSplitter__T], scala.collection.Iterator[_IterableSplitter__T]]: ...
        _span2combiners__U = typing.TypeVar('_span2combiners__U')  # <U>
        _span2combiners__This = typing.TypeVar('_span2combiners__This')  # <This>
        def span2combiners(self, p: scala.Function1[_IterableSplitter__T, typing.Any], before: Combiner[_span2combiners__U, _span2combiners__This], after: Combiner[_span2combiners__U, _span2combiners__This]) -> scala.Tuple2[Combiner[_span2combiners__U, _span2combiners__This], Combiner[_span2combiners__U, _span2combiners__This]]: ...
        def split(self) -> scala.collection.Seq['IterableSplitter'[_IterableSplitter__T]]: ...
        _splitAt2combiners__U = typing.TypeVar('_splitAt2combiners__U')  # <U>
        _splitAt2combiners__This = typing.TypeVar('_splitAt2combiners__This')  # <This>
        def splitAt2combiners(self, at: int, before: Combiner[_splitAt2combiners__U, _splitAt2combiners__This], after: Combiner[_splitAt2combiners__U, _splitAt2combiners__This]) -> scala.Tuple2[Combiner[_splitAt2combiners__U, _splitAt2combiners__This], Combiner[_splitAt2combiners__U, _splitAt2combiners__This]]: ...
        def splitWithSignalling(self) -> scala.collection.Seq['IterableSplitter'[_IterableSplitter__T]]: ...
        _sum__U = typing.TypeVar('_sum__U')  # <U>
        def sum(self, num: scala.math.Numeric[_sum__U]) -> _sum__U: ...
        def tag(self) -> int: ...
        def take(self, n: int) -> 'IterableSplitter'[_IterableSplitter__T]: ...
        _take2combiner__U = typing.TypeVar('_take2combiner__U')  # <U>
        _take2combiner__This = typing.TypeVar('_take2combiner__This')  # <This>
        def take2combiner(self, n: int, cb: Combiner[_take2combiner__U, _take2combiner__This]) -> Combiner[_take2combiner__U, _take2combiner__This]: ...
        _takeSeq__PI = typing.TypeVar('_takeSeq__PI', bound='IterableSplitter')  # <PI>
        def takeSeq(self, sq: scala.collection.Seq[_takeSeq__PI], taker: scala.Function2[_takeSeq__PI, typing.Any, _takeSeq__PI]) -> scala.collection.Seq[_takeSeq__PI]: ...
        def takeWhile(self, p: scala.Function1[_IterableSplitter__T, typing.Any]) -> scala.collection.Iterator[_IterableSplitter__T]: ...
        _takeWhile2combiner__U = typing.TypeVar('_takeWhile2combiner__U')  # <U>
        _takeWhile2combiner__This = typing.TypeVar('_takeWhile2combiner__This')  # <This>
        def takeWhile2combiner(self, p: scala.Function1[_IterableSplitter__T, typing.Any], cb: Combiner[_takeWhile2combiner__U, _takeWhile2combiner__This]) -> scala.Tuple2[Combiner[_takeWhile2combiner__U, _takeWhile2combiner__This], typing.Any]: ...
        _to__Col = typing.TypeVar('_to__Col')  # <Col>
        def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., _IterableSplitter__T, _to__Col]) -> _to__Col: ...
        _toArray__B = typing.TypeVar('_toArray__B')  # <B>
        def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__B]) -> typing.Any: ...
        _toBuffer__B = typing.TypeVar('_toBuffer__B')  # <B>
        def toBuffer(self) -> scala.collection.mutable.Buffer[_toBuffer__B]: ...
        def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq[_IterableSplitter__T]: ...
        def toIterable(self) -> scala.collection.Iterable[_IterableSplitter__T]: ...
        def toIterator(self) -> scala.collection.Iterator[_IterableSplitter__T]: ...
        def toList(self) -> scala.collection.immutable.List[_IterableSplitter__T]: ...
        _toMap__T = typing.TypeVar('_toMap__T')  # <T>
        _toMap__U = typing.TypeVar('_toMap__U')  # <U>
        def toMap(self, ev: scala.Predef..less.colon.less[typing.Any, scala.Tuple2[typing.Any, _toMap__U]]) -> scala.collection.immutable.Map[typing.Any, _toMap__U]: ...
        def toSeq(self) -> scala.collection.Seq[_IterableSplitter__T]: ...
        _toSet__B = typing.TypeVar('_toSet__B')  # <B>
        def toSet(self) -> scala.collection.immutable.Set[_toSet__B]: ...
        def toStream(self) -> scala.collection.immutable.Stream[_IterableSplitter__T]: ...
        def toString(self) -> java.lang.String: ...
        def toTraversable(self) -> scala.collection.Traversable[_IterableSplitter__T]: ...
        def toVector(self) -> scala.collection.immutable.Vector[_IterableSplitter__T]: ...
        def withFilter(self, p: scala.Function1[_IterableSplitter__T, typing.Any]) -> scala.collection.Iterator[_IterableSplitter__T]: ...
        _zip__B = typing.TypeVar('_zip__B')  # <B>
        def zip(self, that: scala.collection.Iterator[_zip__B]) -> scala.collection.Iterator[scala.Tuple2[_IterableSplitter__T, _zip__B]]: ...
        _zip2combiner__U = typing.TypeVar('_zip2combiner__U')  # <U>
        _zip2combiner__S = typing.TypeVar('_zip2combiner__S')  # <S>
        _zip2combiner__That = typing.TypeVar('_zip2combiner__That')  # <That>
        def zip2combiner(self, otherpit: RemainsIterator[_zip2combiner__S], cb: Combiner[scala.Tuple2[_zip2combiner__U, _zip2combiner__S], _zip2combiner__That]) -> Combiner[scala.Tuple2[_zip2combiner__U, _zip2combiner__S], _zip2combiner__That]: ...
        _zipAll__B = typing.TypeVar('_zipAll__B')  # <B>
        _zipAll__A1 = typing.TypeVar('_zipAll__A1')  # <A1>
        _zipAll__B1 = typing.TypeVar('_zipAll__B1')  # <B1>
        def zipAll(self, that: scala.collection.Iterator[_zipAll__B], thisElem: _zipAll__A1, thatElem: _zipAll__B1) -> scala.collection.Iterator[scala.Tuple2[_zipAll__A1, _zipAll__B1]]: ...
        _zipAll2combiner__U = typing.TypeVar('_zipAll2combiner__U')  # <U>
        _zipAll2combiner__S = typing.TypeVar('_zipAll2combiner__S')  # <S>
        _zipAll2combiner__That = typing.TypeVar('_zipAll2combiner__That')  # <That>
        def zipAll2combiner(self, that: RemainsIterator[_zipAll2combiner__S], thiselem: _zipAll2combiner__U, thatelem: _zipAll2combiner__S, cb: Combiner[scala.Tuple2[_zipAll2combiner__U, _zipAll2combiner__S], _zipAll2combiner__That]) -> Combiner[scala.Tuple2[_zipAll2combiner__U, _zipAll2combiner__S], _zipAll2combiner__That]: ...
        _zipAllParSeq__S = typing.TypeVar('_zipAllParSeq__S')  # <S>
        _zipAllParSeq__U = typing.TypeVar('_zipAllParSeq__U')  # <U>
        _zipAllParSeq__R = typing.TypeVar('_zipAllParSeq__R')  # <R>
        def zipAllParSeq(self, that: 'SeqSplitter'[_zipAllParSeq__S], thisElem: _zipAllParSeq__U, thatElem: _zipAllParSeq__R) -> 'IterableSplitter.ZippedAll'[_zipAllParSeq__U, _zipAllParSeq__R]: ...
        _zipParSeq__S = typing.TypeVar('_zipParSeq__S')  # <S>
        def zipParSeq(self, that: 'SeqSplitter'[_zipParSeq__S]) -> 'IterableSplitter.Zipped'[_zipParSeq__S]: ...
        def zipWithIndex(self) -> scala.collection.Iterator[scala.Tuple2[_IterableSplitter__T, typing.Any]]: ...
    class Zipped(scala.collection.parallel.IterableSplitter[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S]], typing.Generic[_IterableSplitter__Zipped__S]):
        $outer: 'IterableSplitter' = ...
        def __init__(self, $outer: 'IterableSplitter', that: 'SeqSplitter'[_IterableSplitter__Zipped__S]): ...
        _$colon$bslash__B = typing.TypeVar('_$colon$bslash__B')  # <B>
        def $colon$bslash(self, z: _.colon.bslash__B, op: scala.Function2[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], _.colon.bslash__B, _.colon.bslash__B]) -> _.colon.bslash__B: ...
        _$div$colon__B = typing.TypeVar('_$div$colon__B')  # <B>
        def $div$colon(self, z: _.div.colon__B, op: scala.Function2[_.div.colon__B, scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], _.div.colon__B]) -> _.div.colon__B: ...
        _$plus$plus__B = typing.TypeVar('_$plus$plus__B')  # <B>
        def $plus$plus(self, that: scala.Function0[scala.collection.GenTraversableOnce[_.plus.plus__B]]) -> scala.collection.Iterator[_.plus.plus__B]: ...
        def abort(self) -> None: ...
        @typing.overload
        def addString(self, b: scala.collection.mutable.StringBuilder) -> scala.collection.mutable.StringBuilder: ...
        @typing.overload
        def addString(self, b: scala.collection.mutable.StringBuilder, sep: typing.Union[java.lang.String, str]) -> scala.collection.mutable.StringBuilder: ...
        @typing.overload
        def addString(self, b: scala.collection.mutable.StringBuilder, start: typing.Union[java.lang.String, str], sep: typing.Union[java.lang.String, str], end: typing.Union[java.lang.String, str]) -> scala.collection.mutable.StringBuilder: ...
        _aggregate__B = typing.TypeVar('_aggregate__B')  # <B>
        def aggregate(self, z: scala.Function0[_aggregate__B], seqop: scala.Function2[_aggregate__B, scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], _aggregate__B], combop: scala.Function2[_aggregate__B, _aggregate__B, _aggregate__B]) -> _aggregate__B: ...
        _appendParIterable__U = typing.TypeVar('_appendParIterable__U')  # <U>
        _appendParIterable__PI = typing.TypeVar('_appendParIterable__PI', bound='IterableSplitter')  # <PI>
        def appendParIterable(self, that: _appendParIterable__PI) -> 'IterableSplitter.Appended'[_appendParIterable__U, _appendParIterable__PI]: ...
        def buffered(self) -> scala.collection.BufferedIterator[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S]]: ...
        def buildString(self, closure: scala.Function1[scala.Function1[typing.Union[java.lang.String, str], scala.runtime.BoxedUnit], scala.runtime.BoxedUnit]) -> java.lang.String: ...
        _collect__B = typing.TypeVar('_collect__B')  # <B>
        def collect(self, pf: scala.PartialFunction[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], _collect__B]) -> scala.collection.Iterator[_collect__B]: ...
        _collect2combiner__S = typing.TypeVar('_collect2combiner__S')  # <S>
        _collect2combiner__That = typing.TypeVar('_collect2combiner__That')  # <That>
        def collect2combiner(self, pf: scala.PartialFunction[scala.Tuple2[_IterableSplitter__T, typing.Any], typing.Any], cb: Combiner[typing.Any, _collect2combiner__That]) -> Combiner[typing.Any, _collect2combiner__That]: ...
        _collectFirst__B = typing.TypeVar('_collectFirst__B')  # <B>
        def collectFirst(self, pf: scala.PartialFunction[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], _collectFirst__B]) -> scala.Option[_collectFirst__B]: ...
        def contains(self, elem: typing.Any) -> bool: ...
        _copy2builder__U = typing.TypeVar('_copy2builder__U')  # <U>
        _copy2builder__Coll = typing.TypeVar('_copy2builder__Coll')  # <Coll>
        _copy2builder__Bld = typing.TypeVar('_copy2builder__Bld', bound=scala.collection.mutable.Builder)  # <Bld>
        def copy2builder(self, b: _copy2builder__Bld) -> _copy2builder__Bld: ...
        _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
        _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
        _copyToArray_2__U = typing.TypeVar('_copyToArray_2__U')  # <U>
        @typing.overload
        def copyToArray(self, xs: typing.Any) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int) -> None: ...
        @typing.overload
        def copyToArray(self, array: typing.Any, from_: int, len: int) -> None: ...
        _copyToBuffer__B = typing.TypeVar('_copyToBuffer__B')  # <B>
        def copyToBuffer(self, dest: scala.collection.mutable.Buffer[_copyToBuffer__B]) -> None: ...
        _corresponds__B = typing.TypeVar('_corresponds__B')  # <B>
        def corresponds(self, that: scala.collection.GenTraversableOnce[_corresponds__B], p: scala.Function2[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], _corresponds__B, typing.Any]) -> bool: ...
        def count(self, p: scala.Function1[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], typing.Any]) -> int: ...
        def debugInformation(self) -> java.lang.String: ...
        def drop(self, n: int) -> 'IterableSplitter'[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S]]: ...
        _drop2combiner__U = typing.TypeVar('_drop2combiner__U')  # <U>
        _drop2combiner__This = typing.TypeVar('_drop2combiner__This')  # <This>
        def drop2combiner(self, n: int, cb: Combiner[_drop2combiner__U, _drop2combiner__This]) -> Combiner[_drop2combiner__U, _drop2combiner__This]: ...
        def dropWhile(self, p: scala.Function1[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], typing.Any]) -> scala.collection.Iterator[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S]]: ...
        def dup(self) -> 'IterableSplitter'[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S]]: ...
        def duplicate(self) -> scala.Tuple2[scala.collection.Iterator[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S]], scala.collection.Iterator[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S]]]: ...
        def exists(self, p: scala.Function1[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], typing.Any]) -> bool: ...
        def filter(self, p: scala.Function1[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], typing.Any]) -> scala.collection.Iterator[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S]]: ...
        _filter2combiner__U = typing.TypeVar('_filter2combiner__U')  # <U>
        _filter2combiner__This = typing.TypeVar('_filter2combiner__This')  # <This>
        def filter2combiner(self, pred: scala.Function1[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], typing.Any], cb: Combiner[_filter2combiner__U, _filter2combiner__This]) -> Combiner[_filter2combiner__U, _filter2combiner__This]: ...
        def filterNot(self, p: scala.Function1[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], typing.Any]) -> scala.collection.Iterator[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S]]: ...
        _filterNot2combiner__U = typing.TypeVar('_filterNot2combiner__U')  # <U>
        _filterNot2combiner__This = typing.TypeVar('_filterNot2combiner__This')  # <This>
        def filterNot2combiner(self, pred: scala.Function1[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], typing.Any], cb: Combiner[_filterNot2combiner__U, _filterNot2combiner__This]) -> Combiner[_filterNot2combiner__U, _filterNot2combiner__This]: ...
        def find(self, p: scala.Function1[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], typing.Any]) -> scala.Option[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S]]: ...
        _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
        def flatMap(self, f: scala.Function1[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], scala.collection.GenTraversableOnce[_flatMap__B]]) -> scala.collection.Iterator[_flatMap__B]: ...
        _flatmap2combiner__S = typing.TypeVar('_flatmap2combiner__S')  # <S>
        _flatmap2combiner__That = typing.TypeVar('_flatmap2combiner__That')  # <That>
        def flatmap2combiner(self, f: scala.Function1[scala.Tuple2[_IterableSplitter__T, typing.Any], scala.collection.GenTraversableOnce[typing.Any]], cb: Combiner[typing.Any, _flatmap2combiner__That]) -> Combiner[typing.Any, _flatmap2combiner__That]: ...
        _fold__U = typing.TypeVar('_fold__U')  # <U>
        def fold(self, z: _fold__U, op: scala.Function2[_fold__U, _fold__U, _fold__U]) -> _fold__U: ...
        _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
        def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], _foldLeft__B]) -> _foldLeft__B: ...
        _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
        def foldRight(self, z: _foldRight__B, op: scala.Function2[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
        def forall(self, p: scala.Function1[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], typing.Any]) -> bool: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], _foreach__U]) -> None: ...
        _grouped__B = typing.TypeVar('_grouped__B')  # <B>
        def grouped(self, size: int) -> scala.collection.Iterator.GroupedIterator[_grouped__B]: ...
        def hasDefiniteSize(self) -> bool: ...
        def hasNext(self) -> bool: ...
        def indexFlag(self) -> int: ...
        _indexOf_0__B = typing.TypeVar('_indexOf_0__B')  # <B>
        _indexOf_1__B = typing.TypeVar('_indexOf_1__B')  # <B>
        @typing.overload
        def indexOf(self, elem: _indexOf_0__B) -> int: ...
        @typing.overload
        def indexOf(self, elem: _indexOf_1__B, from_: int) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], typing.Any]) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], typing.Any], from_: int) -> int: ...
        def isAborted(self) -> bool: ...
        def isEmpty(self) -> bool: ...
        def isRemainingCheap(self) -> bool: ...
        def isTraversableAgain(self) -> bool: ...
        def length(self) -> int: ...
        _map__S = typing.TypeVar('_map__S')  # <S>
        def map(self, f: scala.Function1[scala.Tuple2[_IterableSplitter__T, typing.Any], typing.Any]) -> 'IterableSplitter.Mapped'[typing.Any]: ...
        _map2combiner__S = typing.TypeVar('_map2combiner__S')  # <S>
        _map2combiner__That = typing.TypeVar('_map2combiner__That')  # <That>
        def map2combiner(self, f: scala.Function1[scala.Tuple2[_IterableSplitter__T, typing.Any], typing.Any], cb: Combiner[typing.Any, _map2combiner__That]) -> Combiner[typing.Any, _map2combiner__That]: ...
        def max(self, ord: scala.math.Ordering) -> typing.Any: ...
        def maxBy(self, f: scala.Function1, cmp: scala.math.Ordering) -> typing.Any: ...
        def min(self, ord: scala.math.Ordering) -> typing.Any: ...
        def minBy(self, f: scala.Function1, cmp: scala.math.Ordering) -> typing.Any: ...
        @typing.overload
        def mkString(self) -> java.lang.String: ...
        @typing.overload
        def mkString(self, sep: typing.Union[java.lang.String, str]) -> java.lang.String: ...
        @typing.overload
        def mkString(self, start: typing.Union[java.lang.String, str], sep: typing.Union[java.lang.String, str], end: typing.Union[java.lang.String, str]) -> java.lang.String: ...
        _newSliceInternal__U = typing.TypeVar('_newSliceInternal__U', bound='IterableSplitter.Taken')  # <U>
        def newSliceInternal(self, it: _newSliceInternal__U, from1: int) -> _newSliceInternal__U: ...
        def newTaken(self, until: int) -> 'IterableSplitter.Taken': ...
        def next(self) -> scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S]: ...
        def nonEmpty(self) -> bool: ...
        _padTo__A1 = typing.TypeVar('_padTo__A1')  # <A1>
        def padTo(self, len: int, elem: _padTo__A1) -> scala.collection.Iterator[_padTo__A1]: ...
        def partition(self, p: scala.Function1[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], typing.Any]) -> scala.Tuple2[scala.collection.Iterator[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S]], scala.collection.Iterator[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S]]]: ...
        _partition2combiners__U = typing.TypeVar('_partition2combiners__U')  # <U>
        _partition2combiners__This = typing.TypeVar('_partition2combiners__This')  # <This>
        def partition2combiners(self, pred: scala.Function1[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], typing.Any], btrue: Combiner[_partition2combiners__U, _partition2combiners__This], bfalse: Combiner[_partition2combiners__U, _partition2combiners__This]) -> scala.Tuple2[Combiner[_partition2combiners__U, _partition2combiners__This], Combiner[_partition2combiners__U, _partition2combiners__This]]: ...
        _patch__B = typing.TypeVar('_patch__B')  # <B>
        def patch(self, from_: int, patchElems: scala.collection.Iterator[_patch__B], replaced: int) -> scala.collection.Iterator[_patch__B]: ...
        _product__U = typing.TypeVar('_product__U')  # <U>
        def product(self, num: scala.math.Numeric[_product__U]) -> _product__U: ...
        _reduce__U = typing.TypeVar('_reduce__U')  # <U>
        def reduce(self, op: scala.Function2[_reduce__U, _reduce__U, _reduce__U]) -> _reduce__U: ...
        _reduceLeft_0__U = typing.TypeVar('_reduceLeft_0__U')  # <U>
        _reduceLeft_1__B = typing.TypeVar('_reduceLeft_1__B')  # <B>
        @typing.overload
        def reduceLeft(self, howmany: int, op: scala.Function2[_reduceLeft_0__U, _reduceLeft_0__U, _reduceLeft_0__U]) -> _reduceLeft_0__U: ...
        @typing.overload
        def reduceLeft(self, op: scala.Function2[_reduceLeft_1__B, scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], _reduceLeft_1__B]) -> _reduceLeft_1__B: ...
        _reduceLeftOption__B = typing.TypeVar('_reduceLeftOption__B')  # <B>
        def reduceLeftOption(self, op: scala.Function2[_reduceLeftOption__B, scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], _reduceLeftOption__B]) -> scala.Option[_reduceLeftOption__B]: ...
        _reduceOption__A1 = typing.TypeVar('_reduceOption__A1')  # <A1>
        def reduceOption(self, op: scala.Function2[_reduceOption__A1, _reduceOption__A1, _reduceOption__A1]) -> scala.Option[_reduceOption__A1]: ...
        _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
        def reduceRight(self, op: scala.Function2[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
        _reduceRightOption__B = typing.TypeVar('_reduceRightOption__B')  # <B>
        def reduceRightOption(self, op: scala.Function2[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], _reduceRightOption__B, _reduceRightOption__B]) -> scala.Option[_reduceRightOption__B]: ...
        def remaining(self) -> int: ...
        def reversed(self) -> scala.collection.immutable.List[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S]]: ...
        def sameElements(self, that: scala.collection.Iterator[typing.Any]) -> bool: ...
        _scanLeft__B = typing.TypeVar('_scanLeft__B')  # <B>
        def scanLeft(self, z: _scanLeft__B, op: scala.Function2[_scanLeft__B, scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], _scanLeft__B]) -> scala.collection.Iterator[_scanLeft__B]: ...
        _scanRight__B = typing.TypeVar('_scanRight__B')  # <B>
        def scanRight(self, z: _scanRight__B, op: scala.Function2[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], _scanRight__B, _scanRight__B]) -> scala.collection.Iterator[_scanRight__B]: ...
        _scanToArray__U = typing.TypeVar('_scanToArray__U')  # <U>
        _scanToArray__A = typing.TypeVar('_scanToArray__A')  # <A>
        def scanToArray(self, z: _scanToArray__U, op: scala.Function2[_scanToArray__U, _scanToArray__U, _scanToArray__U], array: typing.Any, from_: int) -> None: ...
        _scanToCombiner_0__U = typing.TypeVar('_scanToCombiner_0__U')  # <U>
        _scanToCombiner_0__That = typing.TypeVar('_scanToCombiner_0__That')  # <That>
        _scanToCombiner_1__U = typing.TypeVar('_scanToCombiner_1__U')  # <U>
        _scanToCombiner_1__That = typing.TypeVar('_scanToCombiner_1__That')  # <That>
        @typing.overload
        def scanToCombiner(self, howmany: int, startValue: _scanToCombiner_0__U, op: scala.Function2[_scanToCombiner_0__U, _scanToCombiner_0__U, _scanToCombiner_0__U], cb: Combiner[_scanToCombiner_0__U, _scanToCombiner_0__That]) -> Combiner[_scanToCombiner_0__U, _scanToCombiner_0__That]: ...
        @typing.overload
        def scanToCombiner(self, startValue: _scanToCombiner_1__U, op: scala.Function2[_scanToCombiner_1__U, _scanToCombiner_1__U, _scanToCombiner_1__U], cb: Combiner[_scanToCombiner_1__U, _scanToCombiner_1__That]) -> Combiner[_scanToCombiner_1__U, _scanToCombiner_1__That]: ...
        def seq(self) -> scala.collection.Iterator[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S]]: ...
        def setIndexFlag(self, f: int) -> None: ...
        def setIndexFlagIfGreater(self, f: int) -> None: ...
        def setIndexFlagIfLesser(self, f: int) -> None: ...
        _shouldSplitFurther__S = typing.TypeVar('_shouldSplitFurther__S')  # <S>
        def shouldSplitFurther(self, coll: 'ParIterable'[typing.Any], parallelismLevel: int) -> bool: ...
        def signalDelegate(self) -> scala.collection.generic.Signalling: ...
        def signalDelegate_$eq(self, x$1: scala.collection.generic.Signalling) -> None: ...
        def size(self) -> int: ...
        def sizeHintIfCheap(self) -> int: ...
        def slice(self, from1: int, until1: int) -> 'IterableSplitter'[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S]]: ...
        _slice2combiner__U = typing.TypeVar('_slice2combiner__U')  # <U>
        _slice2combiner__This = typing.TypeVar('_slice2combiner__This')  # <This>
        def slice2combiner(self, from_: int, until: int, cb: Combiner[_slice2combiner__U, _slice2combiner__This]) -> Combiner[_slice2combiner__U, _slice2combiner__This]: ...
        def sliceIterator(self, from_: int, until: int) -> scala.collection.Iterator[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S]]: ...
        _sliding__B = typing.TypeVar('_sliding__B')  # <B>
        def sliding(self, size: int, step: int) -> scala.collection.Iterator.GroupedIterator[_sliding__B]: ...
        _sliding$default$2__B = typing.TypeVar('_sliding$default$2__B')  # <B>
        def sliding$default$2(self) -> int: ...
        def span(self, p: scala.Function1[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], typing.Any]) -> scala.Tuple2[scala.collection.Iterator[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S]], scala.collection.Iterator[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S]]]: ...
        _span2combiners__U = typing.TypeVar('_span2combiners__U')  # <U>
        _span2combiners__This = typing.TypeVar('_span2combiners__This')  # <This>
        def span2combiners(self, p: scala.Function1[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], typing.Any], before: Combiner[_span2combiners__U, _span2combiners__This], after: Combiner[_span2combiners__U, _span2combiners__This]) -> scala.Tuple2[Combiner[_span2combiners__U, _span2combiners__This], Combiner[_span2combiners__U, _span2combiners__This]]: ...
        def split(self) -> scala.collection.Seq['IterableSplitter'[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S]]]: ...
        _splitAt2combiners__U = typing.TypeVar('_splitAt2combiners__U')  # <U>
        _splitAt2combiners__This = typing.TypeVar('_splitAt2combiners__This')  # <This>
        def splitAt2combiners(self, at: int, before: Combiner[_splitAt2combiners__U, _splitAt2combiners__This], after: Combiner[_splitAt2combiners__U, _splitAt2combiners__This]) -> scala.Tuple2[Combiner[_splitAt2combiners__U, _splitAt2combiners__This], Combiner[_splitAt2combiners__U, _splitAt2combiners__This]]: ...
        def splitWithSignalling(self) -> scala.collection.Seq['IterableSplitter'[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S]]]: ...
        _sum__U = typing.TypeVar('_sum__U')  # <U>
        def sum(self, num: scala.math.Numeric[_sum__U]) -> _sum__U: ...
        def tag(self) -> int: ...
        def take(self, n: int) -> 'IterableSplitter'[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S]]: ...
        _take2combiner__U = typing.TypeVar('_take2combiner__U')  # <U>
        _take2combiner__This = typing.TypeVar('_take2combiner__This')  # <This>
        def take2combiner(self, n: int, cb: Combiner[_take2combiner__U, _take2combiner__This]) -> Combiner[_take2combiner__U, _take2combiner__This]: ...
        def takeWhile(self, p: scala.Function1[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], typing.Any]) -> scala.collection.Iterator[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S]]: ...
        _takeWhile2combiner__U = typing.TypeVar('_takeWhile2combiner__U')  # <U>
        _takeWhile2combiner__This = typing.TypeVar('_takeWhile2combiner__This')  # <This>
        def takeWhile2combiner(self, p: scala.Function1[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], typing.Any], cb: Combiner[_takeWhile2combiner__U, _takeWhile2combiner__This]) -> scala.Tuple2[Combiner[_takeWhile2combiner__U, _takeWhile2combiner__This], typing.Any]: ...
        def that(self) -> 'SeqSplitter'[_IterableSplitter__Zipped__S]: ...
        _to__Col = typing.TypeVar('_to__Col')  # <Col>
        def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], _to__Col]) -> _to__Col: ...
        _toArray__B = typing.TypeVar('_toArray__B')  # <B>
        def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__B]) -> typing.Any: ...
        _toBuffer__B = typing.TypeVar('_toBuffer__B')  # <B>
        def toBuffer(self) -> scala.collection.mutable.Buffer[_toBuffer__B]: ...
        def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S]]: ...
        def toIterable(self) -> scala.collection.Iterable[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S]]: ...
        def toIterator(self) -> scala.collection.Iterator[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S]]: ...
        def toList(self) -> scala.collection.immutable.List[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S]]: ...
        _toMap__T = typing.TypeVar('_toMap__T')  # <T>
        _toMap__U = typing.TypeVar('_toMap__U')  # <U>
        def toMap(self, ev: scala.Predef..less.colon.less[scala.Tuple2[typing.Any, _IterableSplitter__Zipped__S], scala.Tuple2[typing.Any, _toMap__U]]) -> scala.collection.immutable.Map[typing.Any, _toMap__U]: ...
        def toSeq(self) -> scala.collection.Seq[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S]]: ...
        _toSet__B = typing.TypeVar('_toSet__B')  # <B>
        def toSet(self) -> scala.collection.immutable.Set[_toSet__B]: ...
        def toStream(self) -> scala.collection.immutable.Stream[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S]]: ...
        def toString(self) -> java.lang.String: ...
        def toTraversable(self) -> scala.collection.Traversable[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S]]: ...
        def toVector(self) -> scala.collection.immutable.Vector[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S]]: ...
        def withFilter(self, p: scala.Function1[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], typing.Any]) -> scala.collection.Iterator[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S]]: ...
        _zip__B = typing.TypeVar('_zip__B')  # <B>
        def zip(self, that: scala.collection.Iterator[_zip__B]) -> scala.collection.Iterator[scala.Tuple2[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], _zip__B]]: ...
        _zip2combiner__U = typing.TypeVar('_zip2combiner__U')  # <U>
        _zip2combiner__S = typing.TypeVar('_zip2combiner__S')  # <S>
        _zip2combiner__That = typing.TypeVar('_zip2combiner__That')  # <That>
        def zip2combiner(self, otherpit: RemainsIterator[typing.Any], cb: Combiner[scala.Tuple2[_zip2combiner__U, typing.Any], _zip2combiner__That]) -> Combiner[scala.Tuple2[_zip2combiner__U, typing.Any], _zip2combiner__That]: ...
        _zipAll__B = typing.TypeVar('_zipAll__B')  # <B>
        _zipAll__A1 = typing.TypeVar('_zipAll__A1')  # <A1>
        _zipAll__B1 = typing.TypeVar('_zipAll__B1')  # <B1>
        def zipAll(self, that: scala.collection.Iterator[_zipAll__B], thisElem: _zipAll__A1, thatElem: _zipAll__B1) -> scala.collection.Iterator[scala.Tuple2[_zipAll__A1, _zipAll__B1]]: ...
        _zipAll2combiner__U = typing.TypeVar('_zipAll2combiner__U')  # <U>
        _zipAll2combiner__S = typing.TypeVar('_zipAll2combiner__S')  # <S>
        _zipAll2combiner__That = typing.TypeVar('_zipAll2combiner__That')  # <That>
        def zipAll2combiner(self, that: RemainsIterator[typing.Any], thiselem: _zipAll2combiner__U, thatelem: typing.Any, cb: Combiner[scala.Tuple2[_zipAll2combiner__U, typing.Any], _zipAll2combiner__That]) -> Combiner[scala.Tuple2[_zipAll2combiner__U, typing.Any], _zipAll2combiner__That]: ...
        _zipAllParSeq__S = typing.TypeVar('_zipAllParSeq__S')  # <S>
        _zipAllParSeq__U = typing.TypeVar('_zipAllParSeq__U')  # <U>
        _zipAllParSeq__R = typing.TypeVar('_zipAllParSeq__R')  # <R>
        def zipAllParSeq(self, that: 'SeqSplitter'[typing.Any], thisElem: _zipAllParSeq__U, thatElem: _zipAllParSeq__R) -> 'IterableSplitter.ZippedAll'[_zipAllParSeq__U, _zipAllParSeq__R]: ...
        _zipParSeq__S = typing.TypeVar('_zipParSeq__S')  # <S>
        def zipParSeq(self, that: 'SeqSplitter'[typing.Any]) -> 'IterableSplitter.Zipped'[typing.Any]: ...
        def zipWithIndex(self) -> scala.collection.Iterator[scala.Tuple2[scala.Tuple2[_IterableSplitter__T, _IterableSplitter__Zipped__S], typing.Any]]: ...
    class ZippedAll(scala.collection.parallel.IterableSplitter[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]], typing.Generic[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]):
        $outer: 'IterableSplitter' = ...
        def __init__(self, $outer: 'IterableSplitter', that: 'SeqSplitter'[_IterableSplitter__ZippedAll__S], thiselem: _IterableSplitter__ZippedAll__U, thatelem: _IterableSplitter__ZippedAll__S): ...
        _$colon$bslash__B = typing.TypeVar('_$colon$bslash__B')  # <B>
        def $colon$bslash(self, z: _.colon.bslash__B, op: scala.Function2[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S], _.colon.bslash__B, _.colon.bslash__B]) -> _.colon.bslash__B: ...
        _$div$colon__B = typing.TypeVar('_$div$colon__B')  # <B>
        def $div$colon(self, z: _.div.colon__B, op: scala.Function2[_.div.colon__B, scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S], _.div.colon__B]) -> _.div.colon__B: ...
        _$plus$plus__B = typing.TypeVar('_$plus$plus__B')  # <B>
        def $plus$plus(self, that: scala.Function0[scala.collection.GenTraversableOnce[_.plus.plus__B]]) -> scala.collection.Iterator[_.plus.plus__B]: ...
        def abort(self) -> None: ...
        @typing.overload
        def addString(self, b: scala.collection.mutable.StringBuilder) -> scala.collection.mutable.StringBuilder: ...
        @typing.overload
        def addString(self, b: scala.collection.mutable.StringBuilder, sep: typing.Union[java.lang.String, str]) -> scala.collection.mutable.StringBuilder: ...
        @typing.overload
        def addString(self, b: scala.collection.mutable.StringBuilder, start: typing.Union[java.lang.String, str], sep: typing.Union[java.lang.String, str], end: typing.Union[java.lang.String, str]) -> scala.collection.mutable.StringBuilder: ...
        _aggregate__B = typing.TypeVar('_aggregate__B')  # <B>
        def aggregate(self, z: scala.Function0[_aggregate__B], seqop: scala.Function2[_aggregate__B, scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S], _aggregate__B], combop: scala.Function2[_aggregate__B, _aggregate__B, _aggregate__B]) -> _aggregate__B: ...
        _appendParIterable__U = typing.TypeVar('_appendParIterable__U')  # <U>
        _appendParIterable__PI = typing.TypeVar('_appendParIterable__PI', bound='IterableSplitter')  # <PI>
        def appendParIterable(self, that: _appendParIterable__PI) -> 'IterableSplitter.Appended'[typing.Any, _appendParIterable__PI]: ...
        def buffered(self) -> scala.collection.BufferedIterator[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]]: ...
        def buildString(self, closure: scala.Function1[scala.Function1[typing.Union[java.lang.String, str], scala.runtime.BoxedUnit], scala.runtime.BoxedUnit]) -> java.lang.String: ...
        _collect__B = typing.TypeVar('_collect__B')  # <B>
        def collect(self, pf: scala.PartialFunction[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S], _collect__B]) -> scala.collection.Iterator[_collect__B]: ...
        _collect2combiner__S = typing.TypeVar('_collect2combiner__S')  # <S>
        _collect2combiner__That = typing.TypeVar('_collect2combiner__That')  # <That>
        def collect2combiner(self, pf: scala.PartialFunction[scala.Tuple2[_IterableSplitter__ZippedAll__U, typing.Any], typing.Any], cb: Combiner[typing.Any, _collect2combiner__That]) -> Combiner[typing.Any, _collect2combiner__That]: ...
        _collectFirst__B = typing.TypeVar('_collectFirst__B')  # <B>
        def collectFirst(self, pf: scala.PartialFunction[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S], _collectFirst__B]) -> scala.Option[_collectFirst__B]: ...
        def contains(self, elem: typing.Any) -> bool: ...
        _copy2builder__U = typing.TypeVar('_copy2builder__U')  # <U>
        _copy2builder__Coll = typing.TypeVar('_copy2builder__Coll')  # <Coll>
        _copy2builder__Bld = typing.TypeVar('_copy2builder__Bld', bound=scala.collection.mutable.Builder)  # <Bld>
        def copy2builder(self, b: _copy2builder__Bld) -> _copy2builder__Bld: ...
        _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
        _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
        _copyToArray_2__U = typing.TypeVar('_copyToArray_2__U')  # <U>
        @typing.overload
        def copyToArray(self, xs: typing.Any) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int) -> None: ...
        @typing.overload
        def copyToArray(self, array: typing.Any, from_: int, len: int) -> None: ...
        _copyToBuffer__B = typing.TypeVar('_copyToBuffer__B')  # <B>
        def copyToBuffer(self, dest: scala.collection.mutable.Buffer[_copyToBuffer__B]) -> None: ...
        _corresponds__B = typing.TypeVar('_corresponds__B')  # <B>
        def corresponds(self, that: scala.collection.GenTraversableOnce[_corresponds__B], p: scala.Function2[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S], _corresponds__B, typing.Any]) -> bool: ...
        def count(self, p: scala.Function1[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S], typing.Any]) -> int: ...
        def debugInformation(self) -> java.lang.String: ...
        def drop(self, n: int) -> 'IterableSplitter'[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]]: ...
        _drop2combiner__U = typing.TypeVar('_drop2combiner__U')  # <U>
        _drop2combiner__This = typing.TypeVar('_drop2combiner__This')  # <This>
        def drop2combiner(self, n: int, cb: Combiner[typing.Any, _drop2combiner__This]) -> Combiner[typing.Any, _drop2combiner__This]: ...
        def dropWhile(self, p: scala.Function1[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S], typing.Any]) -> scala.collection.Iterator[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]]: ...
        def dup(self) -> 'IterableSplitter'[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]]: ...
        def duplicate(self) -> scala.Tuple2[scala.collection.Iterator[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]], scala.collection.Iterator[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]]]: ...
        def exists(self, p: scala.Function1[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S], typing.Any]) -> bool: ...
        def filter(self, p: scala.Function1[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S], typing.Any]) -> scala.collection.Iterator[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]]: ...
        _filter2combiner__U = typing.TypeVar('_filter2combiner__U')  # <U>
        _filter2combiner__This = typing.TypeVar('_filter2combiner__This')  # <This>
        def filter2combiner(self, pred: scala.Function1[scala.Tuple2[typing.Any, _IterableSplitter__ZippedAll__S], typing.Any], cb: Combiner[typing.Any, _filter2combiner__This]) -> Combiner[typing.Any, _filter2combiner__This]: ...
        def filterNot(self, p: scala.Function1[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S], typing.Any]) -> scala.collection.Iterator[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]]: ...
        _filterNot2combiner__U = typing.TypeVar('_filterNot2combiner__U')  # <U>
        _filterNot2combiner__This = typing.TypeVar('_filterNot2combiner__This')  # <This>
        def filterNot2combiner(self, pred: scala.Function1[scala.Tuple2[typing.Any, _IterableSplitter__ZippedAll__S], typing.Any], cb: Combiner[typing.Any, _filterNot2combiner__This]) -> Combiner[typing.Any, _filterNot2combiner__This]: ...
        def find(self, p: scala.Function1[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S], typing.Any]) -> scala.Option[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]]: ...
        _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
        def flatMap(self, f: scala.Function1[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S], scala.collection.GenTraversableOnce[_flatMap__B]]) -> scala.collection.Iterator[_flatMap__B]: ...
        _flatmap2combiner__S = typing.TypeVar('_flatmap2combiner__S')  # <S>
        _flatmap2combiner__That = typing.TypeVar('_flatmap2combiner__That')  # <That>
        def flatmap2combiner(self, f: scala.Function1[scala.Tuple2[_IterableSplitter__ZippedAll__U, typing.Any], scala.collection.GenTraversableOnce[typing.Any]], cb: Combiner[typing.Any, _flatmap2combiner__That]) -> Combiner[typing.Any, _flatmap2combiner__That]: ...
        _fold__U = typing.TypeVar('_fold__U')  # <U>
        def fold(self, z: typing.Any, op: scala.Function2[typing.Any, typing.Any, typing.Any]) -> typing.Any: ...
        _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
        def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S], _foldLeft__B]) -> _foldLeft__B: ...
        _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
        def foldRight(self, z: _foldRight__B, op: scala.Function2[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S], _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
        def forall(self, p: scala.Function1[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S], typing.Any]) -> bool: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[scala.Tuple2[typing.Any, _IterableSplitter__ZippedAll__S], typing.Any]) -> None: ...
        _grouped__B = typing.TypeVar('_grouped__B')  # <B>
        def grouped(self, size: int) -> scala.collection.Iterator.GroupedIterator[_grouped__B]: ...
        def hasDefiniteSize(self) -> bool: ...
        def hasNext(self) -> bool: ...
        def indexFlag(self) -> int: ...
        _indexOf_0__B = typing.TypeVar('_indexOf_0__B')  # <B>
        _indexOf_1__B = typing.TypeVar('_indexOf_1__B')  # <B>
        @typing.overload
        def indexOf(self, elem: _indexOf_0__B) -> int: ...
        @typing.overload
        def indexOf(self, elem: _indexOf_1__B, from_: int) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S], typing.Any]) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S], typing.Any], from_: int) -> int: ...
        def isAborted(self) -> bool: ...
        def isEmpty(self) -> bool: ...
        def isRemainingCheap(self) -> bool: ...
        def isTraversableAgain(self) -> bool: ...
        def length(self) -> int: ...
        _map__S = typing.TypeVar('_map__S')  # <S>
        def map(self, f: scala.Function1[scala.Tuple2[_IterableSplitter__ZippedAll__U, typing.Any], typing.Any]) -> 'IterableSplitter.Mapped'[typing.Any]: ...
        _map2combiner__S = typing.TypeVar('_map2combiner__S')  # <S>
        _map2combiner__That = typing.TypeVar('_map2combiner__That')  # <That>
        def map2combiner(self, f: scala.Function1[scala.Tuple2[_IterableSplitter__ZippedAll__U, typing.Any], typing.Any], cb: Combiner[typing.Any, _map2combiner__That]) -> Combiner[typing.Any, _map2combiner__That]: ...
        def max(self, ord: scala.math.Ordering) -> typing.Any: ...
        def maxBy(self, f: scala.Function1, cmp: scala.math.Ordering) -> typing.Any: ...
        def min(self, ord: scala.math.Ordering) -> typing.Any: ...
        def minBy(self, f: scala.Function1, cmp: scala.math.Ordering) -> typing.Any: ...
        @typing.overload
        def mkString(self) -> java.lang.String: ...
        @typing.overload
        def mkString(self, sep: typing.Union[java.lang.String, str]) -> java.lang.String: ...
        @typing.overload
        def mkString(self, start: typing.Union[java.lang.String, str], sep: typing.Union[java.lang.String, str], end: typing.Union[java.lang.String, str]) -> java.lang.String: ...
        _newSliceInternal__U = typing.TypeVar('_newSliceInternal__U', bound='IterableSplitter.Taken')  # <U>
        def newSliceInternal(self, it: 'IterableSplitter.Taken', from1: int) -> 'IterableSplitter.Taken': ...
        def newTaken(self, until: int) -> 'IterableSplitter.Taken': ...
        def next(self) -> scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]: ...
        def nonEmpty(self) -> bool: ...
        _padTo__A1 = typing.TypeVar('_padTo__A1')  # <A1>
        def padTo(self, len: int, elem: _padTo__A1) -> scala.collection.Iterator[_padTo__A1]: ...
        def partition(self, p: scala.Function1[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S], typing.Any]) -> scala.Tuple2[scala.collection.Iterator[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]], scala.collection.Iterator[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]]]: ...
        _partition2combiners__U = typing.TypeVar('_partition2combiners__U')  # <U>
        _partition2combiners__This = typing.TypeVar('_partition2combiners__This')  # <This>
        def partition2combiners(self, pred: scala.Function1[scala.Tuple2[typing.Any, _IterableSplitter__ZippedAll__S], typing.Any], btrue: Combiner[typing.Any, _partition2combiners__This], bfalse: Combiner[typing.Any, _partition2combiners__This]) -> scala.Tuple2[Combiner[typing.Any, _partition2combiners__This], Combiner[typing.Any, _partition2combiners__This]]: ...
        _patch__B = typing.TypeVar('_patch__B')  # <B>
        def patch(self, from_: int, patchElems: scala.collection.Iterator[_patch__B], replaced: int) -> scala.collection.Iterator[_patch__B]: ...
        _product__U = typing.TypeVar('_product__U')  # <U>
        def product(self, num: scala.math.Numeric[typing.Any]) -> typing.Any: ...
        _reduce__U = typing.TypeVar('_reduce__U')  # <U>
        def reduce(self, op: scala.Function2[typing.Any, typing.Any, typing.Any]) -> typing.Any: ...
        _reduceLeft_0__U = typing.TypeVar('_reduceLeft_0__U')  # <U>
        _reduceLeft_1__B = typing.TypeVar('_reduceLeft_1__B')  # <B>
        @typing.overload
        def reduceLeft(self, howmany: int, op: scala.Function2[typing.Any, typing.Any, typing.Any]) -> typing.Any: ...
        @typing.overload
        def reduceLeft(self, op: scala.Function2[_reduceLeft_1__B, scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S], _reduceLeft_1__B]) -> _reduceLeft_1__B: ...
        _reduceLeftOption__B = typing.TypeVar('_reduceLeftOption__B')  # <B>
        def reduceLeftOption(self, op: scala.Function2[_reduceLeftOption__B, scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S], _reduceLeftOption__B]) -> scala.Option[_reduceLeftOption__B]: ...
        _reduceOption__A1 = typing.TypeVar('_reduceOption__A1')  # <A1>
        def reduceOption(self, op: scala.Function2[_reduceOption__A1, _reduceOption__A1, _reduceOption__A1]) -> scala.Option[_reduceOption__A1]: ...
        _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
        def reduceRight(self, op: scala.Function2[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S], _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
        _reduceRightOption__B = typing.TypeVar('_reduceRightOption__B')  # <B>
        def reduceRightOption(self, op: scala.Function2[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S], _reduceRightOption__B, _reduceRightOption__B]) -> scala.Option[_reduceRightOption__B]: ...
        def remaining(self) -> int: ...
        def reversed(self) -> scala.collection.immutable.List[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]]: ...
        def sameElements(self, that: scala.collection.Iterator[typing.Any]) -> bool: ...
        _scanLeft__B = typing.TypeVar('_scanLeft__B')  # <B>
        def scanLeft(self, z: _scanLeft__B, op: scala.Function2[_scanLeft__B, scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S], _scanLeft__B]) -> scala.collection.Iterator[_scanLeft__B]: ...
        _scanRight__B = typing.TypeVar('_scanRight__B')  # <B>
        def scanRight(self, z: _scanRight__B, op: scala.Function2[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S], _scanRight__B, _scanRight__B]) -> scala.collection.Iterator[_scanRight__B]: ...
        _scanToArray__U = typing.TypeVar('_scanToArray__U')  # <U>
        _scanToArray__A = typing.TypeVar('_scanToArray__A')  # <A>
        def scanToArray(self, z: typing.Any, op: scala.Function2[typing.Any, typing.Any, typing.Any], array: typing.Any, from_: int) -> None: ...
        _scanToCombiner_0__U = typing.TypeVar('_scanToCombiner_0__U')  # <U>
        _scanToCombiner_0__That = typing.TypeVar('_scanToCombiner_0__That')  # <That>
        _scanToCombiner_1__U = typing.TypeVar('_scanToCombiner_1__U')  # <U>
        _scanToCombiner_1__That = typing.TypeVar('_scanToCombiner_1__That')  # <That>
        @typing.overload
        def scanToCombiner(self, howmany: int, startValue: typing.Any, op: scala.Function2[typing.Any, typing.Any, typing.Any], cb: Combiner[typing.Any, _scanToCombiner_0__That]) -> Combiner[typing.Any, _scanToCombiner_0__That]: ...
        @typing.overload
        def scanToCombiner(self, startValue: typing.Any, op: scala.Function2[typing.Any, typing.Any, typing.Any], cb: Combiner[typing.Any, _scanToCombiner_1__That]) -> Combiner[typing.Any, _scanToCombiner_1__That]: ...
        def seq(self) -> scala.collection.Iterator[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]]: ...
        def setIndexFlag(self, f: int) -> None: ...
        def setIndexFlagIfGreater(self, f: int) -> None: ...
        def setIndexFlagIfLesser(self, f: int) -> None: ...
        _shouldSplitFurther__S = typing.TypeVar('_shouldSplitFurther__S')  # <S>
        def shouldSplitFurther(self, coll: 'ParIterable'[typing.Any], parallelismLevel: int) -> bool: ...
        def signalDelegate(self) -> scala.collection.generic.Signalling: ...
        def signalDelegate_$eq(self, x$1: scala.collection.generic.Signalling) -> None: ...
        def size(self) -> int: ...
        def sizeHintIfCheap(self) -> int: ...
        def slice(self, from1: int, until1: int) -> 'IterableSplitter'[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]]: ...
        _slice2combiner__U = typing.TypeVar('_slice2combiner__U')  # <U>
        _slice2combiner__This = typing.TypeVar('_slice2combiner__This')  # <This>
        def slice2combiner(self, from_: int, until: int, cb: Combiner[typing.Any, _slice2combiner__This]) -> Combiner[typing.Any, _slice2combiner__This]: ...
        def sliceIterator(self, from_: int, until: int) -> scala.collection.Iterator[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]]: ...
        _sliding__B = typing.TypeVar('_sliding__B')  # <B>
        def sliding(self, size: int, step: int) -> scala.collection.Iterator.GroupedIterator[_sliding__B]: ...
        _sliding$default$2__B = typing.TypeVar('_sliding$default$2__B')  # <B>
        def sliding$default$2(self) -> int: ...
        def span(self, p: scala.Function1[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S], typing.Any]) -> scala.Tuple2[scala.collection.Iterator[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]], scala.collection.Iterator[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]]]: ...
        _span2combiners__U = typing.TypeVar('_span2combiners__U')  # <U>
        _span2combiners__This = typing.TypeVar('_span2combiners__This')  # <This>
        def span2combiners(self, p: scala.Function1[scala.Tuple2[typing.Any, _IterableSplitter__ZippedAll__S], typing.Any], before: Combiner[typing.Any, _span2combiners__This], after: Combiner[typing.Any, _span2combiners__This]) -> scala.Tuple2[Combiner[typing.Any, _span2combiners__This], Combiner[typing.Any, _span2combiners__This]]: ...
        def split(self) -> scala.collection.Seq['IterableSplitter'[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]]]: ...
        _splitAt2combiners__U = typing.TypeVar('_splitAt2combiners__U')  # <U>
        _splitAt2combiners__This = typing.TypeVar('_splitAt2combiners__This')  # <This>
        def splitAt2combiners(self, at: int, before: Combiner[typing.Any, _splitAt2combiners__This], after: Combiner[typing.Any, _splitAt2combiners__This]) -> scala.Tuple2[Combiner[typing.Any, _splitAt2combiners__This], Combiner[typing.Any, _splitAt2combiners__This]]: ...
        def splitWithSignalling(self) -> scala.collection.Seq['IterableSplitter'[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]]]: ...
        _sum__U = typing.TypeVar('_sum__U')  # <U>
        def sum(self, num: scala.math.Numeric[typing.Any]) -> typing.Any: ...
        def tag(self) -> int: ...
        def take(self, n: int) -> 'IterableSplitter'[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]]: ...
        _take2combiner__U = typing.TypeVar('_take2combiner__U')  # <U>
        _take2combiner__This = typing.TypeVar('_take2combiner__This')  # <This>
        def take2combiner(self, n: int, cb: Combiner[typing.Any, _take2combiner__This]) -> Combiner[typing.Any, _take2combiner__This]: ...
        def takeWhile(self, p: scala.Function1[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S], typing.Any]) -> scala.collection.Iterator[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]]: ...
        _takeWhile2combiner__U = typing.TypeVar('_takeWhile2combiner__U')  # <U>
        _takeWhile2combiner__This = typing.TypeVar('_takeWhile2combiner__This')  # <This>
        def takeWhile2combiner(self, p: scala.Function1[scala.Tuple2[typing.Any, _IterableSplitter__ZippedAll__S], typing.Any], cb: Combiner[typing.Any, _takeWhile2combiner__This]) -> scala.Tuple2[Combiner[typing.Any, _takeWhile2combiner__This], typing.Any]: ...
        def that(self) -> 'SeqSplitter'[_IterableSplitter__ZippedAll__S]: ...
        def thatelem(self) -> _IterableSplitter__ZippedAll__S: ...
        def thiselem(self) -> _IterableSplitter__ZippedAll__U: ...
        _to__Col = typing.TypeVar('_to__Col')  # <Col>
        def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S], _to__Col]) -> _to__Col: ...
        _toArray__B = typing.TypeVar('_toArray__B')  # <B>
        def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__B]) -> typing.Any: ...
        _toBuffer__B = typing.TypeVar('_toBuffer__B')  # <B>
        def toBuffer(self) -> scala.collection.mutable.Buffer[_toBuffer__B]: ...
        def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]]: ...
        def toIterable(self) -> scala.collection.Iterable[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]]: ...
        def toIterator(self) -> scala.collection.Iterator[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]]: ...
        def toList(self) -> scala.collection.immutable.List[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]]: ...
        _toMap__T = typing.TypeVar('_toMap__T')  # <T>
        _toMap__U = typing.TypeVar('_toMap__U')  # <U>
        def toMap(self, ev: scala.Predef..less.colon.less[scala.Tuple2[typing.Any, _IterableSplitter__ZippedAll__S], scala.Tuple2[typing.Any, typing.Any]]) -> scala.collection.immutable.Map[typing.Any, typing.Any]: ...
        def toSeq(self) -> scala.collection.Seq[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]]: ...
        _toSet__B = typing.TypeVar('_toSet__B')  # <B>
        def toSet(self) -> scala.collection.immutable.Set[_toSet__B]: ...
        def toStream(self) -> scala.collection.immutable.Stream[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]]: ...
        def toString(self) -> java.lang.String: ...
        def toTraversable(self) -> scala.collection.Traversable[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]]: ...
        def toVector(self) -> scala.collection.immutable.Vector[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]]: ...
        def withFilter(self, p: scala.Function1[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S], typing.Any]) -> scala.collection.Iterator[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S]]: ...
        _zip__B = typing.TypeVar('_zip__B')  # <B>
        def zip(self, that: scala.collection.Iterator[_zip__B]) -> scala.collection.Iterator[scala.Tuple2[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S], _zip__B]]: ...
        _zip2combiner__U = typing.TypeVar('_zip2combiner__U')  # <U>
        _zip2combiner__S = typing.TypeVar('_zip2combiner__S')  # <S>
        _zip2combiner__That = typing.TypeVar('_zip2combiner__That')  # <That>
        def zip2combiner(self, otherpit: RemainsIterator[typing.Any], cb: Combiner[scala.Tuple2[typing.Any, typing.Any], _zip2combiner__That]) -> Combiner[scala.Tuple2[typing.Any, typing.Any], _zip2combiner__That]: ...
        _zipAll__B = typing.TypeVar('_zipAll__B')  # <B>
        _zipAll__A1 = typing.TypeVar('_zipAll__A1')  # <A1>
        _zipAll__B1 = typing.TypeVar('_zipAll__B1')  # <B1>
        def zipAll(self, that: scala.collection.Iterator[_zipAll__B], thisElem: _zipAll__A1, thatElem: _zipAll__B1) -> scala.collection.Iterator[scala.Tuple2[_zipAll__A1, _zipAll__B1]]: ...
        _zipAll2combiner__U = typing.TypeVar('_zipAll2combiner__U')  # <U>
        _zipAll2combiner__S = typing.TypeVar('_zipAll2combiner__S')  # <S>
        _zipAll2combiner__That = typing.TypeVar('_zipAll2combiner__That')  # <That>
        def zipAll2combiner(self, that: RemainsIterator[typing.Any], thiselem: typing.Any, thatelem: typing.Any, cb: Combiner[scala.Tuple2[typing.Any, typing.Any], _zipAll2combiner__That]) -> Combiner[scala.Tuple2[typing.Any, typing.Any], _zipAll2combiner__That]: ...
        _zipAllParSeq__S = typing.TypeVar('_zipAllParSeq__S')  # <S>
        _zipAllParSeq__U = typing.TypeVar('_zipAllParSeq__U')  # <U>
        _zipAllParSeq__R = typing.TypeVar('_zipAllParSeq__R')  # <R>
        def zipAllParSeq(self, that: 'SeqSplitter'[typing.Any], thisElem: typing.Any, thatElem: _zipAllParSeq__R) -> 'IterableSplitter.ZippedAll'[typing.Any, _zipAllParSeq__R]: ...
        _zipParSeq__S = typing.TypeVar('_zipParSeq__S')  # <S>
        def zipParSeq(self, that: 'SeqSplitter'[typing.Any]) -> 'IterableSplitter.Zipped'[typing.Any]: ...
        def zipWithIndex(self) -> scala.collection.Iterator[scala.Tuple2[scala.Tuple2[_IterableSplitter__ZippedAll__U, _IterableSplitter__ZippedAll__S], typing.Any]]: ...

_ParIterable__T = typing.TypeVar('_ParIterable__T')  # <T>
class ParIterable(scala.collection.GenIterable[_ParIterable__T], scala.collection.generic.GenericParTemplate[_ParIterable__T, 'ParIterable'], scala.collection.parallel.ParIterableLike[_ParIterable__T, 'ParIterable'[_ParIterable__T], scala.collection.Iterable[_ParIterable__T]], typing.Generic[_ParIterable__T]):
    @staticmethod
    def $init$($this: 'ParIterable') -> None: ...
    @staticmethod
    def ReusableCBF() -> scala.collection.generic.GenTraversableFactory.GenericCanBuildFrom[scala.runtime.Nothing.]: ...
    @staticmethod
    def apply(elems: scala.collection.Seq) -> scala.collection.GenTraversable: ...
    _canBuildFrom__T = typing.TypeVar('_canBuildFrom__T')  # <T>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanCombineFrom['ParIterable'[typing.Any], _canBuildFrom__T, 'ParIterable'[_canBuildFrom__T]]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['ParIterable']: ...
    @staticmethod
    def concat(xss: scala.collection.Seq) -> scala.collection.GenTraversable: ...
    @staticmethod
    def empty() -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, n5: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @staticmethod
    def iterate(start: typing.Any, len: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, step: typing.Any, evidence$2: scala.math.Integral) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, evidence$1: scala.math.Integral) -> scala.collection.GenTraversable: ...
    def stringPrefix(self) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, n5: int, f: scala.Function5) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, f: scala.Function4) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, f: scala.Function3) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, f: scala.Function2) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    def toString(self) -> java.lang.String: ...

_ParMap__WithDefault__A = typing.TypeVar('_ParMap__WithDefault__A')  # <A>
_ParMap__WithDefault__B = typing.TypeVar('_ParMap__WithDefault__B')  # <B>
_ParMap__K = typing.TypeVar('_ParMap__K')  # <K>
_ParMap__V = typing.TypeVar('_ParMap__V')  # <V>
class ParMap(scala.collection.GenMap[_ParMap__K, _ParMap__V], scala.collection.generic.GenericParMapTemplate[_ParMap__K, _ParMap__V, 'ParMap'], ParIterable[scala.Tuple2[_ParMap__K, _ParMap__V]], scala.collection.parallel.ParMapLike[_ParMap__K, _ParMap__V, 'ParMap'[_ParMap__K, _ParMap__V], scala.collection.Map[_ParMap__K, _ParMap__V]], typing.Generic[_ParMap__K, _ParMap__V]):
    @staticmethod
    def $init$($this: 'ParMap') -> None: ...
    _$plus_0__V1 = typing.TypeVar('_$plus_0__V1')  # <V1>
    _$plus_1__U = typing.TypeVar('_$plus_1__U')  # <U>
    @typing.overload
    def $plus(self, kv: scala.Tuple2[_ParMap__K, _.plus_0__V1]) -> scala.collection.GenMap[_ParMap__K, _.plus_0__V1]: ...
    @typing.overload
    def $plus(self, kv: scala.Tuple2[_ParMap__K, _.plus_1__U]) -> 'ParMap'[_ParMap__K, _.plus_1__U]: ...
    _canBuildFrom__K = typing.TypeVar('_canBuildFrom__K')  # <K>
    _canBuildFrom__V = typing.TypeVar('_canBuildFrom__V')  # <V>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanCombineFrom['ParMap'[typing.Any, typing.Any], scala.Tuple2[_canBuildFrom__K, _canBuildFrom__V], 'ParMap'[_canBuildFrom__K, _canBuildFrom__V]]: ...
    def empty(self) -> 'ParMap'[_ParMap__K, _ParMap__V]: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def mapCompanion(self) -> scala.collection.generic.GenericParMapCompanion['ParMap']: ...
    def stringPrefix(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...
    _updated_0__V1 = typing.TypeVar('_updated_0__V1')  # <V1>
    _updated_1__U = typing.TypeVar('_updated_1__U')  # <U>
    @typing.overload
    def updated(self, key: _ParMap__K, value: _updated_0__V1) -> scala.collection.GenMap[_ParMap__K, _updated_0__V1]: ...
    @typing.overload
    def updated(self, key: _ParMap__K, value: _updated_1__U) -> 'ParMap'[_ParMap__K, _updated_1__U]: ...
    class WithDefault(scala.collection.parallel.ParMap[_ParMap__WithDefault__A, _ParMap__WithDefault__B], typing.Generic[_ParMap__WithDefault__A, _ParMap__WithDefault__B]):
        def __init__(self, underlying: 'ParMap'[_ParMap__WithDefault__A, _ParMap__WithDefault__B], d: scala.Function1[_ParMap__WithDefault__A, _ParMap__WithDefault__B]): ...
        _$colon$bslash__S = typing.TypeVar('_$colon$bslash__S')  # <S>
        def $colon$bslash(self, z: _.colon.bslash__S, op: scala.Function2[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B], _.colon.bslash__S, _.colon.bslash__S]) -> _.colon.bslash__S: ...
        _$div$colon__S = typing.TypeVar('_$div$colon__S')  # <S>
        def $div$colon(self, z: _.div.colon__S, op: scala.Function2[_.div.colon__S, scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B], _.div.colon__S]) -> _.div.colon__S: ...
        _$plus$plus__U = typing.TypeVar('_$plus$plus__U')  # <U>
        _$plus$plus__That = typing.TypeVar('_$plus$plus__That')  # <That>
        def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus__U], bf: scala.collection.generic.CanBuildFrom['ParMap'[_ParMap__WithDefault__A, _ParMap__WithDefault__B], _.plus.plus__U, _.plus.plus__That]) -> _.plus.plus__That: ...
        def ScanLeaf(self) -> 'ParIterableLike.ScanLeaf.': ...
        def ScanNode(self) -> 'ParIterableLike.ScanNode.': ...
        _aggregate__S = typing.TypeVar('_aggregate__S')  # <S>
        def aggregate(self, z: scala.Function0[_aggregate__S], seqop: scala.Function2[_aggregate__S, scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B], _aggregate__S], combop: scala.Function2[_aggregate__S, _aggregate__S, _aggregate__S]) -> _aggregate__S: ...
        def apply(self, key: _ParMap__WithDefault__A) -> _ParMap__WithDefault__B: ...
        _bf2seq__S = typing.TypeVar('_bf2seq__S')  # <S>
        _bf2seq__That = typing.TypeVar('_bf2seq__That')  # <That>
        def bf2seq(self, bf: scala.collection.generic.CanBuildFrom['ParMap'[_ParMap__WithDefault__A, _ParMap__WithDefault__B], _bf2seq__S, _bf2seq__That]) -> scala.collection.generic.CanBuildFrom[scala.collection.Map[_ParMap__WithDefault__A, _ParMap__WithDefault__B], _bf2seq__S, _bf2seq__That]: ...
        def brokenInvariants(self) -> scala.collection.Seq[java.lang.String]: ...
        _builder2ops__Elem = typing.TypeVar('_builder2ops__Elem')  # <Elem>
        _builder2ops__To = typing.TypeVar('_builder2ops__To')  # <To>
        def builder2ops(self, cb: scala.collection.mutable.Builder[_builder2ops__Elem, _builder2ops__To]) -> 'ParIterableLike.BuilderOps'[_builder2ops__Elem, _builder2ops__To]: ...
        def canEqual(self, other: typing.Any) -> bool: ...
        _collect__S = typing.TypeVar('_collect__S')  # <S>
        _collect__That = typing.TypeVar('_collect__That')  # <That>
        def collect(self, pf: scala.PartialFunction[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B], _collect__S], bf: scala.collection.generic.CanBuildFrom['ParMap'[_ParMap__WithDefault__A, _ParMap__WithDefault__B], _collect__S, _collect__That]) -> _collect__That: ...
        _combinerFactory_1__S = typing.TypeVar('_combinerFactory_1__S')  # <S>
        _combinerFactory_1__That = typing.TypeVar('_combinerFactory_1__That')  # <That>
        @typing.overload
        def combinerFactory(self) -> CombinerFactory[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B], 'ParMap'[_ParMap__WithDefault__A, _ParMap__WithDefault__B]]: ...
        @typing.overload
        def combinerFactory(self, cbf: scala.Function0[Combiner[_combinerFactory_1__S, _combinerFactory_1__That]]) -> CombinerFactory[_combinerFactory_1__S, _combinerFactory_1__That]: ...
        def companion(self) -> scala.collection.generic.GenericCompanion[ParIterable]: ...
        def contains(self, key: _ParMap__WithDefault__A) -> bool: ...
        _copyToArray_0__U = typing.TypeVar('_copyToArray_0__U')  # <U>
        _copyToArray_1__U = typing.TypeVar('_copyToArray_1__U')  # <U>
        _copyToArray_2__U = typing.TypeVar('_copyToArray_2__U')  # <U>
        @typing.overload
        def copyToArray(self, xs: typing.Any) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
        def count(self, p: scala.Function1[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B], typing.Any]) -> int: ...
        def debugBuffer(self) -> scala.collection.mutable.ArrayBuffer[java.lang.String]: ...
        def debugInformation(self) -> java.lang.String: ...
        def debugclear(self) -> None: ...
        def debuglog(self, s: typing.Union[java.lang.String, str]) -> scala.collection.mutable.ArrayBuffer[java.lang.String]: ...
        def default(self, key: _ParMap__WithDefault__A) -> _ParMap__WithDefault__B: ...
        _delegatedSignalling2ops__PI = typing.TypeVar('_delegatedSignalling2ops__PI', bound=scala.collection.generic.DelegatedSignalling)  # <PI>
        def delegatedSignalling2ops(self, it: _delegatedSignalling2ops__PI) -> 'ParIterableLike.SignallingOps'[_delegatedSignalling2ops__PI]: ...
        def drop(self, n: int) -> ParIterable: ...
        def dropWhile(self, pred: scala.Function1) -> ParIterable: ...
        def empty(self) -> 'ParMap'[_ParMap__WithDefault__A, _ParMap__WithDefault__B]: ...
        def equals(self, that: typing.Any) -> bool: ...
        def exists(self, p: scala.Function1[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B], typing.Any]) -> bool: ...
        def filter(self, pred: scala.Function1) -> ParIterable: ...
        def filterKeys(self, p: scala.Function1[_ParMap__WithDefault__A, typing.Any]) -> 'ParMap'[_ParMap__WithDefault__A, _ParMap__WithDefault__B]: ...
        def filterNot(self, pred: scala.Function1) -> ParIterable: ...
        def find(self, p: scala.Function1[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B], typing.Any]) -> scala.Option[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B]]: ...
        _flatMap__S = typing.TypeVar('_flatMap__S')  # <S>
        _flatMap__That = typing.TypeVar('_flatMap__That')  # <That>
        def flatMap(self, f: scala.Function1[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B], scala.collection.GenTraversableOnce[_flatMap__S]], bf: scala.collection.generic.CanBuildFrom['ParMap'[_ParMap__WithDefault__A, _ParMap__WithDefault__B], _flatMap__S, _flatMap__That]) -> _flatMap__That: ...
        def flatten(self, asTraversable: scala.Function1) -> scala.collection.GenTraversable: ...
        _fold__U = typing.TypeVar('_fold__U')  # <U>
        def fold(self, z: _fold__U, op: scala.Function2[_fold__U, _fold__U, _fold__U]) -> _fold__U: ...
        _foldLeft__S = typing.TypeVar('_foldLeft__S')  # <S>
        def foldLeft(self, z: _foldLeft__S, op: scala.Function2[_foldLeft__S, scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B], _foldLeft__S]) -> _foldLeft__S: ...
        _foldRight__S = typing.TypeVar('_foldRight__S')  # <S>
        def foldRight(self, z: _foldRight__S, op: scala.Function2[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B], _foldRight__S, _foldRight__S]) -> _foldRight__S: ...
        def forall(self, p: scala.Function1[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B], typing.Any]) -> bool: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B], _foreach__U]) -> None: ...
        _genericBuilder__B = typing.TypeVar('_genericBuilder__B')  # <B>
        def genericBuilder(self) -> Combiner[typing.Any, ParIterable[typing.Any]]: ...
        _genericCombiner__B = typing.TypeVar('_genericCombiner__B')  # <B>
        def genericCombiner(self) -> Combiner[typing.Any, ParIterable[typing.Any]]: ...
        _genericMapCombiner__P = typing.TypeVar('_genericMapCombiner__P')  # <P>
        _genericMapCombiner__Q = typing.TypeVar('_genericMapCombiner__Q')  # <Q>
        def genericMapCombiner(self) -> Combiner[scala.Tuple2[_genericMapCombiner__P, _genericMapCombiner__Q], 'ParMap'[_genericMapCombiner__P, _genericMapCombiner__Q]]: ...
        def get(self, key: _ParMap__WithDefault__A) -> scala.Option[_ParMap__WithDefault__B]: ...
        _getOrElse__U = typing.TypeVar('_getOrElse__U')  # <U>
        def getOrElse(self, key: _ParMap__WithDefault__A, default: scala.Function0[_getOrElse__U]) -> _getOrElse__U: ...
        _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
        def groupBy(self, f: scala.Function1[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B], _groupBy__K]) -> scala.collection.parallel.immutable.ParMap[_groupBy__K, 'ParMap'[_ParMap__WithDefault__A, _ParMap__WithDefault__B]]: ...
        def hasDefiniteSize(self) -> bool: ...
        def hashCode(self) -> int: ...
        def head(self) -> typing.Any: ...
        def headOption(self) -> scala.Option[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B]]: ...
        def init(self) -> ParIterable: ...
        def initTaskSupport(self) -> None: ...
        def isDefinedAt(self, key: _ParMap__WithDefault__A) -> bool: ...
        def isEmpty(self) -> bool: ...
        def isStrictSplitterCollection(self) -> bool: ...
        def isTraversableAgain(self) -> bool: ...
        def iterator(self) -> Splitter[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B]]: ...
        def keySet(self) -> 'ParSet'[_ParMap__WithDefault__A]: ...
        def keys(self) -> ParIterable[_ParMap__WithDefault__A]: ...
        def keysIterator(self) -> IterableSplitter[_ParMap__WithDefault__A]: ...
        def last(self) -> typing.Any: ...
        def lastOption(self) -> scala.Option[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B]]: ...
        _map__S = typing.TypeVar('_map__S')  # <S>
        _map__That = typing.TypeVar('_map__That')  # <That>
        def map(self, f: scala.Function1[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B], _map__S], bf: scala.collection.generic.CanBuildFrom['ParMap'[_ParMap__WithDefault__A, _ParMap__WithDefault__B], _map__S, _map__That]) -> _map__That: ...
        def mapCompanion(self) -> scala.collection.generic.GenericParMapCompanion['ParMap']: ...
        _mapValues__S = typing.TypeVar('_mapValues__S')  # <S>
        def mapValues(self, f: scala.Function1[_ParMap__WithDefault__B, _mapValues__S]) -> 'ParMap'[_ParMap__WithDefault__A, _mapValues__S]: ...
        def max(self, ord: scala.math.Ordering) -> typing.Any: ...
        def maxBy(self, f: scala.Function1, cmp: scala.math.Ordering) -> typing.Any: ...
        def min(self, ord: scala.math.Ordering) -> typing.Any: ...
        def minBy(self, f: scala.Function1, cmp: scala.math.Ordering) -> typing.Any: ...
        @typing.overload
        def mkString(self) -> java.lang.String: ...
        @typing.overload
        def mkString(self, sep: typing.Union[java.lang.String, str]) -> java.lang.String: ...
        @typing.overload
        def mkString(self, start: typing.Union[java.lang.String, str], sep: typing.Union[java.lang.String, str], end: typing.Union[java.lang.String, str]) -> java.lang.String: ...
        def newBuilder(self) -> scala.collection.mutable.Builder[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B], ParIterable[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B]]]: ...
        def newCombiner(self) -> Combiner[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B], 'ParMap'[_ParMap__WithDefault__A, _ParMap__WithDefault__B]]: ...
        def nonEmpty(self) -> bool: ...
        def par(self) -> ParIterable: ...
        def parCombiner(self) -> Combiner[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B], 'ParMap'[_ParMap__WithDefault__A, _ParMap__WithDefault__B]]: ...
        def partition(self, pred: scala.Function1[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B], typing.Any]) -> scala.Tuple2['ParMap'[_ParMap__WithDefault__A, _ParMap__WithDefault__B], 'ParMap'[_ParMap__WithDefault__A, _ParMap__WithDefault__B]]: ...
        def printDebugBuffer(self) -> None: ...
        _product__U = typing.TypeVar('_product__U')  # <U>
        def product(self, num: scala.math.Numeric[_product__U]) -> _product__U: ...
        _reduce__U = typing.TypeVar('_reduce__U')  # <U>
        def reduce(self, op: scala.Function2[_reduce__U, _reduce__U, _reduce__U]) -> _reduce__U: ...
        _reduceLeft__U = typing.TypeVar('_reduceLeft__U')  # <U>
        def reduceLeft(self, op: scala.Function2[_reduceLeft__U, scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B], _reduceLeft__U]) -> _reduceLeft__U: ...
        _reduceLeftOption__U = typing.TypeVar('_reduceLeftOption__U')  # <U>
        def reduceLeftOption(self, op: scala.Function2[_reduceLeftOption__U, scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B], _reduceLeftOption__U]) -> scala.Option[_reduceLeftOption__U]: ...
        _reduceOption__U = typing.TypeVar('_reduceOption__U')  # <U>
        def reduceOption(self, op: scala.Function2[_reduceOption__U, _reduceOption__U, _reduceOption__U]) -> scala.Option[_reduceOption__U]: ...
        _reduceRight__U = typing.TypeVar('_reduceRight__U')  # <U>
        def reduceRight(self, op: scala.Function2[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B], _reduceRight__U, _reduceRight__U]) -> _reduceRight__U: ...
        _reduceRightOption__U = typing.TypeVar('_reduceRightOption__U')  # <U>
        def reduceRightOption(self, op: scala.Function2[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B], _reduceRightOption__U, _reduceRightOption__U]) -> scala.Option[_reduceRightOption__U]: ...
        def repr(self) -> ParIterable: ...
        _reuse__S = typing.TypeVar('_reuse__S')  # <S>
        _reuse__That = typing.TypeVar('_reuse__That')  # <That>
        def reuse(self, oldc: scala.Option[Combiner[_reuse__S, _reuse__That]], newc: Combiner[_reuse__S, _reuse__That]) -> Combiner[_reuse__S, _reuse__That]: ...
        _sameElements__U = typing.TypeVar('_sameElements__U')  # <U>
        def sameElements(self, that: scala.collection.GenIterable[_sameElements__U]) -> bool: ...
        def scala$collection$parallel$ParIterableLike$$_tasksupport(self) -> TaskSupport: ...
        def scala$collection$parallel$ParIterableLike$$_tasksupport_$eq(self, x$1: TaskSupport) -> None: ...
        _scan__U = typing.TypeVar('_scan__U')  # <U>
        _scan__That = typing.TypeVar('_scan__That')  # <That>
        def scan(self, z: _scan__U, op: scala.Function2[_scan__U, _scan__U, _scan__U], bf: scala.collection.generic.CanBuildFrom['ParMap'[_ParMap__WithDefault__A, _ParMap__WithDefault__B], _scan__U, _scan__That]) -> _scan__That: ...
        def scanBlockSize(self) -> int: ...
        _scanLeft__S = typing.TypeVar('_scanLeft__S')  # <S>
        _scanLeft__That = typing.TypeVar('_scanLeft__That')  # <That>
        def scanLeft(self, z: _scanLeft__S, op: scala.Function2[_scanLeft__S, scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B], _scanLeft__S], bf: scala.collection.generic.CanBuildFrom['ParMap'[_ParMap__WithDefault__A, _ParMap__WithDefault__B], _scanLeft__S, _scanLeft__That]) -> _scanLeft__That: ...
        _scanRight__S = typing.TypeVar('_scanRight__S')  # <S>
        _scanRight__That = typing.TypeVar('_scanRight__That')  # <That>
        def scanRight(self, z: _scanRight__S, op: scala.Function2[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B], _scanRight__S, _scanRight__S], bf: scala.collection.generic.CanBuildFrom['ParMap'[_ParMap__WithDefault__A, _ParMap__WithDefault__B], _scanRight__S, _scanRight__That]) -> _scanRight__That: ...
        def sequentially(self, b: scala.Function1) -> ParIterable: ...
        def size(self) -> int: ...
        def sizeHintIfCheap(self) -> int: ...
        def slice(self, unc_from: int, unc_until: int) -> ParIterable: ...
        def span(self, pred: scala.Function1[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B], typing.Any]) -> scala.Tuple2['ParMap'[_ParMap__WithDefault__A, _ParMap__WithDefault__B], 'ParMap'[_ParMap__WithDefault__A, _ParMap__WithDefault__B]]: ...
        def splitAt(self, n: int) -> scala.Tuple2['ParMap'[_ParMap__WithDefault__A, _ParMap__WithDefault__B], 'ParMap'[_ParMap__WithDefault__A, _ParMap__WithDefault__B]]: ...
        def splitter(self) -> IterableSplitter[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B]]: ...
        def stringPrefix(self) -> java.lang.String: ...
        _sum__U = typing.TypeVar('_sum__U')  # <U>
        def sum(self, num: scala.math.Numeric[_sum__U]) -> _sum__U: ...
        def tail(self) -> ParIterable: ...
        def take(self, n: int) -> ParIterable: ...
        def takeWhile(self, pred: scala.Function1) -> ParIterable: ...
        _task2ops__R = typing.TypeVar('_task2ops__R')  # <R>
        _task2ops__Tp = typing.TypeVar('_task2ops__Tp')  # <Tp>
        def task2ops(self, tsk: 'ParIterableLike.StrictSplitterCheckTask'[_task2ops__R, _task2ops__Tp]) -> 'ParIterableLike.TaskOps'[_task2ops__R, _task2ops__Tp]: ...
        def tasksupport(self) -> TaskSupport: ...
        def tasksupport_$eq(self, ts: TaskSupport) -> None: ...
        _to__Col = typing.TypeVar('_to__Col')  # <Col>
        def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B], _to__Col]) -> _to__Col: ...
        _toArray__U = typing.TypeVar('_toArray__U')  # <U>
        def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__U]) -> typing.Any: ...
        _toBuffer__U = typing.TypeVar('_toBuffer__U')  # <U>
        def toBuffer(self) -> scala.collection.mutable.Buffer[_toBuffer__U]: ...
        def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B]]: ...
        def toIterable(self) -> ParIterable[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B]]: ...
        def toIterator(self) -> scala.collection.Iterator[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B]]: ...
        def toList(self) -> scala.collection.immutable.List[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B]]: ...
        _toMap__K = typing.TypeVar('_toMap__K')  # <K>
        _toMap__V = typing.TypeVar('_toMap__V')  # <V>
        def toMap(self, ev: scala.Predef..less.colon.less[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B], scala.Tuple2[_toMap__K, _toMap__V]]) -> scala.collection.parallel.immutable.ParMap[_toMap__K, _toMap__V]: ...
        _toParCollection__U = typing.TypeVar('_toParCollection__U')  # <U>
        _toParCollection__That = typing.TypeVar('_toParCollection__That')  # <That>
        def toParCollection(self, cbf: scala.Function0[Combiner[_toParCollection__U, _toParCollection__That]]) -> _toParCollection__That: ...
        _toParMap__K = typing.TypeVar('_toParMap__K')  # <K>
        _toParMap__V = typing.TypeVar('_toParMap__V')  # <V>
        _toParMap__That = typing.TypeVar('_toParMap__That')  # <That>
        def toParMap(self, cbf: scala.Function0[Combiner[scala.Tuple2[_toParMap__K, _toParMap__V], _toParMap__That]], ev: scala.Predef..less.colon.less[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B], scala.Tuple2[_toParMap__K, _toParMap__V]]) -> _toParMap__That: ...
        def toSeq(self) -> 'ParSeq'[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B]]: ...
        _toSet__U = typing.TypeVar('_toSet__U')  # <U>
        def toSet(self) -> scala.collection.parallel.immutable.ParSet[_toSet__U]: ...
        def toStream(self) -> scala.collection.immutable.Stream[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B]]: ...
        def toString(self) -> java.lang.String: ...
        def toTraversable(self) -> scala.collection.GenTraversable[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B]]: ...
        def toVector(self) -> scala.collection.immutable.Vector[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B]]: ...
        def transpose(self, asTraversable: scala.Function1) -> scala.collection.GenTraversable: ...
        _unzip__A1 = typing.TypeVar('_unzip__A1')  # <A1>
        _unzip__A2 = typing.TypeVar('_unzip__A2')  # <A2>
        def unzip(self, asPair: scala.Function1[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B], scala.Tuple2[_unzip__A1, _unzip__A2]]) -> scala.Tuple2[ParIterable[_unzip__A1], ParIterable[_unzip__A2]]: ...
        _unzip3__A1 = typing.TypeVar('_unzip3__A1')  # <A1>
        _unzip3__A2 = typing.TypeVar('_unzip3__A2')  # <A2>
        _unzip3__A3 = typing.TypeVar('_unzip3__A3')  # <A3>
        def unzip3(self, asTriple: scala.Function1[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B], scala.Tuple3[_unzip3__A1, _unzip3__A2, _unzip3__A3]]) -> scala.Tuple3[ParIterable[_unzip3__A1], ParIterable[_unzip3__A2], ParIterable[_unzip3__A3]]: ...
        _updated__U = typing.TypeVar('_updated__U')  # <U>
        def updated(self, key: _ParMap__WithDefault__A, value: _updated__U) -> 'ParMap'[_ParMap__WithDefault__A, _updated__U]: ...
        def values(self) -> ParIterable[_ParMap__WithDefault__B]: ...
        def valuesIterator(self) -> IterableSplitter[_ParMap__WithDefault__B]: ...
        def view(self) -> scala.collection.IterableView[scala.Tuple2[_ParMap__WithDefault__A, _ParMap__WithDefault__B], scala.collection.Map[_ParMap__WithDefault__A, _ParMap__WithDefault__B]]: ...
        def withFilter(self, pred: scala.Function1) -> ParIterable: ...
        _wrap__R = typing.TypeVar('_wrap__R')  # <R>
        def wrap(self, body: scala.Function0[_wrap__R]) -> 'ParIterableLike.NonDivisible'[_wrap__R]: ...
        _zip__U = typing.TypeVar('_zip__U')  # <U>
        _zip__S = typing.TypeVar('_zip__S')  # <S>
        _zip__That = typing.TypeVar('_zip__That')  # <That>
        def zip(self, that: scala.collection.GenIterable[_zip__S], bf: scala.collection.generic.CanBuildFrom['ParMap'[_ParMap__WithDefault__A, _ParMap__WithDefault__B], scala.Tuple2[_zip__U, _zip__S], _zip__That]) -> _zip__That: ...
        _zipAll__S = typing.TypeVar('_zipAll__S')  # <S>
        _zipAll__U = typing.TypeVar('_zipAll__U')  # <U>
        _zipAll__That = typing.TypeVar('_zipAll__That')  # <That>
        def zipAll(self, that: scala.collection.GenIterable[_zipAll__S], thisElem: _zipAll__U, thatElem: _zipAll__S, bf: scala.collection.generic.CanBuildFrom['ParMap'[_ParMap__WithDefault__A, _ParMap__WithDefault__B], scala.Tuple2[_zipAll__U, _zipAll__S], _zipAll__That]) -> _zipAll__That: ...
        _zipWithIndex__U = typing.TypeVar('_zipWithIndex__U')  # <U>
        _zipWithIndex__That = typing.TypeVar('_zipWithIndex__That')  # <That>
        def zipWithIndex(self, bf: scala.collection.generic.CanBuildFrom['ParMap'[_ParMap__WithDefault__A, _ParMap__WithDefault__B], scala.Tuple2[_zipWithIndex__U, typing.Any], _zipWithIndex__That]) -> _zipWithIndex__That: ...

_ParMapLike__K = typing.TypeVar('_ParMapLike__K')  # <K>
_ParMapLike__V = typing.TypeVar('_ParMapLike__V')  # <V>
_ParMapLike__Repr = typing.TypeVar('_ParMapLike__Repr', bound='ParMapLike')  # <Repr>
_ParMapLike__Sequential = typing.TypeVar('_ParMapLike__Sequential', bound=scala.collection.Map)  # <Sequential>
class ParMapLike(scala.collection.GenMapLike[_ParMapLike__K, _ParMapLike__V, _ParMapLike__Repr], scala.collection.parallel.ParIterableLike[scala.Tuple2[_ParMapLike__K, _ParMapLike__V], _ParMapLike__Repr, _ParMapLike__Sequential], typing.Generic[_ParMapLike__K, _ParMapLike__V, _ParMapLike__Repr, _ParMapLike__Sequential]):
    @staticmethod
    def $init$($this: 'ParMapLike') -> None: ...
    def apply(self, key: _ParMapLike__K) -> _ParMapLike__V: ...
    def contains(self, key: _ParMapLike__K) -> bool: ...
    def default(self, key: _ParMapLike__K) -> _ParMapLike__V: ...
    def empty(self) -> _ParMapLike__Repr: ...
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    def filterKeys(self, p: scala.Function1[_ParMapLike__K, typing.Any]) -> scala.collection.GenMap[_ParMapLike__K, _ParMapLike__V]: ...
    @typing.overload
    def filterKeys(self, p: scala.Function1[_ParMapLike__K, typing.Any]) -> ParMap[_ParMapLike__K, _ParMapLike__V]: ...
    _getOrElse__U = typing.TypeVar('_getOrElse__U')  # <U>
    def getOrElse(self, key: _ParMapLike__K, default: scala.Function0[_getOrElse__U]) -> _getOrElse__U: ...
    def hashCode(self) -> int: ...
    def isDefinedAt(self, key: _ParMapLike__K) -> bool: ...
    @typing.overload
    def keySet(self) -> scala.collection.GenSet[_ParMapLike__K]: ...
    @typing.overload
    def keySet(self) -> 'ParSet'[_ParMapLike__K]: ...
    @typing.overload
    def keys(self) -> scala.collection.GenIterable[_ParMapLike__K]: ...
    @typing.overload
    def keys(self) -> ParIterable[_ParMapLike__K]: ...
    @typing.overload
    def keysIterator(self) -> scala.collection.Iterator[_ParMapLike__K]: ...
    @typing.overload
    def keysIterator(self) -> IterableSplitter[_ParMapLike__K]: ...
    _mapValues_0__W = typing.TypeVar('_mapValues_0__W')  # <W>
    _mapValues_1__S = typing.TypeVar('_mapValues_1__S')  # <S>
    @typing.overload
    def mapValues(self, f: scala.Function1[_ParMapLike__V, _mapValues_0__W]) -> scala.collection.GenMap[_ParMapLike__K, _mapValues_0__W]: ...
    @typing.overload
    def mapValues(self, f: scala.Function1[_ParMapLike__V, _mapValues_1__S]) -> ParMap[_ParMapLike__K, _mapValues_1__S]: ...
    def scala$collection$parallel$ParMapLike$$keysIterator(self, s: IterableSplitter[scala.Tuple2[_ParMapLike__K, _ParMapLike__V]]) -> IterableSplitter[_ParMapLike__K]: ...
    def scala$collection$parallel$ParMapLike$$valuesIterator(self, s: IterableSplitter[scala.Tuple2[_ParMapLike__K, _ParMapLike__V]]) -> IterableSplitter[_ParMapLike__V]: ...
    def toString(self) -> java.lang.String: ...
    @typing.overload
    def values(self) -> scala.collection.GenIterable[_ParMapLike__V]: ...
    @typing.overload
    def values(self) -> ParIterable[_ParMapLike__V]: ...
    @typing.overload
    def valuesIterator(self) -> scala.collection.Iterator[_ParMapLike__V]: ...
    @typing.overload
    def valuesIterator(self) -> IterableSplitter[_ParMapLike__V]: ...
    class DefaultKeySet(scala.collection.parallel.ParSet[_ParMapLike__K]):
        $outer: 'ParMapLike' = ...
        def __init__(self, $outer: 'ParMapLike'): ...
        def $amp(self, that: scala.collection.GenSet) -> typing.Any: ...
        def $amp$tilde(self, that: scala.collection.GenSet) -> typing.Any: ...
        def $bar(self, that: scala.collection.GenSet) -> typing.Any: ...
        _$colon$bslash__S = typing.TypeVar('_$colon$bslash__S')  # <S>
        def $colon$bslash(self, z: _.colon.bslash__S, op: scala.Function2[_ParMapLike__K, _.colon.bslash__S, _.colon.bslash__S]) -> _.colon.bslash__S: ...
        _$div$colon__S = typing.TypeVar('_$div$colon__S')  # <S>
        def $div$colon(self, z: _.div.colon__S, op: scala.Function2[_.div.colon__S, _ParMapLike__K, _.div.colon__S]) -> _.div.colon__S: ...
        def $minus(self, elem: _ParMapLike__K) -> 'ParSet'[_ParMapLike__K]: ...
        def $plus(self, elem: _ParMapLike__K) -> 'ParSet'[_ParMapLike__K]: ...
        _$plus$plus__U = typing.TypeVar('_$plus$plus__U')  # <U>
        _$plus$plus__That = typing.TypeVar('_$plus$plus__That')  # <That>
        def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus__U], bf: scala.collection.generic.CanBuildFrom['ParSet'[_ParMapLike__K], _.plus.plus__U, _.plus.plus__That]) -> _.plus.plus__That: ...
        def ScanLeaf(self) -> 'ParIterableLike.ScanLeaf.': ...
        def ScanNode(self) -> 'ParIterableLike.ScanNode.': ...
        _aggregate__S = typing.TypeVar('_aggregate__S')  # <S>
        def aggregate(self, z: scala.Function0[_aggregate__S], seqop: scala.Function2[_aggregate__S, _ParMapLike__K, _aggregate__S], combop: scala.Function2[_aggregate__S, _aggregate__S, _aggregate__S]) -> _aggregate__S: ...
        _andThen__A = typing.TypeVar('_andThen__A')  # <A>
        def andThen(self, g: scala.Function1[typing.Any, _andThen__A]) -> scala.Function1[_ParMapLike__K, _andThen__A]: ...
        def apply(self, elem: _ParMapLike__K) -> bool: ...
        def apply$mcDD$sp(self, v1: float) -> float: ...
        def apply$mcDF$sp(self, v1: float) -> float: ...
        def apply$mcDI$sp(self, v1: int) -> float: ...
        def apply$mcDJ$sp(self, v1: int) -> float: ...
        def apply$mcFD$sp(self, v1: float) -> float: ...
        def apply$mcFF$sp(self, v1: float) -> float: ...
        def apply$mcFI$sp(self, v1: int) -> float: ...
        def apply$mcFJ$sp(self, v1: int) -> float: ...
        def apply$mcID$sp(self, v1: float) -> int: ...
        def apply$mcIF$sp(self, v1: float) -> int: ...
        def apply$mcII$sp(self, v1: int) -> int: ...
        def apply$mcIJ$sp(self, v1: int) -> int: ...
        def apply$mcJD$sp(self, v1: float) -> int: ...
        def apply$mcJF$sp(self, v1: float) -> int: ...
        def apply$mcJI$sp(self, v1: int) -> int: ...
        def apply$mcJJ$sp(self, v1: int) -> int: ...
        def apply$mcVD$sp(self, v1: float) -> None: ...
        def apply$mcVF$sp(self, v1: float) -> None: ...
        def apply$mcVI$sp(self, v1: int) -> None: ...
        def apply$mcVJ$sp(self, v1: int) -> None: ...
        def apply$mcZD$sp(self, v1: float) -> bool: ...
        def apply$mcZF$sp(self, v1: float) -> bool: ...
        def apply$mcZI$sp(self, v1: int) -> bool: ...
        def apply$mcZJ$sp(self, v1: int) -> bool: ...
        _bf2seq__S = typing.TypeVar('_bf2seq__S')  # <S>
        _bf2seq__That = typing.TypeVar('_bf2seq__That')  # <That>
        def bf2seq(self, bf: scala.collection.generic.CanBuildFrom['ParSet'[_ParMapLike__K], _bf2seq__S, _bf2seq__That]) -> scala.collection.generic.CanBuildFrom[scala.collection.Set[_ParMapLike__K], _bf2seq__S, _bf2seq__That]: ...
        def brokenInvariants(self) -> scala.collection.Seq[java.lang.String]: ...
        _builder2ops__Elem = typing.TypeVar('_builder2ops__Elem')  # <Elem>
        _builder2ops__To = typing.TypeVar('_builder2ops__To')  # <To>
        def builder2ops(self, cb: scala.collection.mutable.Builder[_builder2ops__Elem, _builder2ops__To]) -> 'ParIterableLike.BuilderOps'[_builder2ops__Elem, _builder2ops__To]: ...
        def canEqual(self, other: typing.Any) -> bool: ...
        _collect__S = typing.TypeVar('_collect__S')  # <S>
        _collect__That = typing.TypeVar('_collect__That')  # <That>
        def collect(self, pf: scala.PartialFunction[_ParMapLike__K, _collect__S], bf: scala.collection.generic.CanBuildFrom['ParSet'[_ParMapLike__K], _collect__S, _collect__That]) -> _collect__That: ...
        _combinerFactory_1__S = typing.TypeVar('_combinerFactory_1__S')  # <S>
        _combinerFactory_1__That = typing.TypeVar('_combinerFactory_1__That')  # <That>
        @typing.overload
        def combinerFactory(self) -> CombinerFactory[_ParMapLike__K, 'ParSet'[_ParMapLike__K]]: ...
        @typing.overload
        def combinerFactory(self, cbf: scala.Function0[Combiner[_combinerFactory_1__S, _combinerFactory_1__That]]) -> CombinerFactory[_combinerFactory_1__S, _combinerFactory_1__That]: ...
        def companion(self) -> scala.collection.generic.GenericCompanion['ParSet']: ...
        _compose__A = typing.TypeVar('_compose__A')  # <A>
        def compose(self, g: scala.Function1[_compose__A, _ParMapLike__K]) -> scala.Function1[_compose__A, typing.Any]: ...
        def contains(self, key: _ParMapLike__K) -> bool: ...
        _copyToArray_0__U = typing.TypeVar('_copyToArray_0__U')  # <U>
        _copyToArray_1__U = typing.TypeVar('_copyToArray_1__U')  # <U>
        _copyToArray_2__U = typing.TypeVar('_copyToArray_2__U')  # <U>
        @typing.overload
        def copyToArray(self, xs: typing.Any) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
        def count(self, p: scala.Function1[_ParMapLike__K, typing.Any]) -> int: ...
        def debugBuffer(self) -> scala.collection.mutable.ArrayBuffer[java.lang.String]: ...
        def debugInformation(self) -> java.lang.String: ...
        def debugclear(self) -> None: ...
        def debuglog(self, s: typing.Union[java.lang.String, str]) -> scala.collection.mutable.ArrayBuffer[java.lang.String]: ...
        _delegatedSignalling2ops__PI = typing.TypeVar('_delegatedSignalling2ops__PI', bound=scala.collection.generic.DelegatedSignalling)  # <PI>
        def delegatedSignalling2ops(self, it: _delegatedSignalling2ops__PI) -> 'ParIterableLike.SignallingOps'[_delegatedSignalling2ops__PI]: ...
        def diff(self, that: scala.collection.GenSet[_ParMapLike__K]) -> 'ParSet'[_ParMapLike__K]: ...
        def drop(self, n: int) -> ParIterable: ...
        def dropWhile(self, pred: scala.Function1) -> ParIterable: ...
        def empty(self) -> 'ParSet'[_ParMapLike__K]: ...
        def equals(self, that: typing.Any) -> bool: ...
        def exists(self, p: scala.Function1[_ParMapLike__K, typing.Any]) -> bool: ...
        def filter(self, pred: scala.Function1) -> ParIterable: ...
        def filterNot(self, pred: scala.Function1) -> ParIterable: ...
        def find(self, p: scala.Function1[_ParMapLike__K, typing.Any]) -> scala.Option[_ParMapLike__K]: ...
        _flatMap__S = typing.TypeVar('_flatMap__S')  # <S>
        _flatMap__That = typing.TypeVar('_flatMap__That')  # <That>
        def flatMap(self, f: scala.Function1[_ParMapLike__K, scala.collection.GenTraversableOnce[_flatMap__S]], bf: scala.collection.generic.CanBuildFrom['ParSet'[_ParMapLike__K], _flatMap__S, _flatMap__That]) -> _flatMap__That: ...
        def flatten(self, asTraversable: scala.Function1) -> scala.collection.GenTraversable: ...
        _fold__U = typing.TypeVar('_fold__U')  # <U>
        def fold(self, z: _fold__U, op: scala.Function2[_fold__U, _fold__U, _fold__U]) -> _fold__U: ...
        _foldLeft__S = typing.TypeVar('_foldLeft__S')  # <S>
        def foldLeft(self, z: _foldLeft__S, op: scala.Function2[_foldLeft__S, _ParMapLike__K, _foldLeft__S]) -> _foldLeft__S: ...
        _foldRight__S = typing.TypeVar('_foldRight__S')  # <S>
        def foldRight(self, z: _foldRight__S, op: scala.Function2[_ParMapLike__K, _foldRight__S, _foldRight__S]) -> _foldRight__S: ...
        def forall(self, p: scala.Function1[_ParMapLike__K, typing.Any]) -> bool: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[_ParMapLike__K, _foreach__U]) -> None: ...
        _genericBuilder__B = typing.TypeVar('_genericBuilder__B')  # <B>
        def genericBuilder(self) -> Combiner[_genericBuilder__B, 'ParSet'[_genericBuilder__B]]: ...
        _genericCombiner__B = typing.TypeVar('_genericCombiner__B')  # <B>
        def genericCombiner(self) -> Combiner[_genericCombiner__B, 'ParSet'[_genericCombiner__B]]: ...
        _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
        def groupBy(self, f: scala.Function1[typing.Any, typing.Any]) -> scala.collection.parallel.immutable.ParMap[typing.Any, 'ParSet'[typing.Any]]: ...
        def hasDefiniteSize(self) -> bool: ...
        def hashCode(self) -> int: ...
        def head(self) -> _ParMapLike__K: ...
        def headOption(self) -> scala.Option[_ParMapLike__K]: ...
        def init(self) -> ParIterable: ...
        def initTaskSupport(self) -> None: ...
        def intersect(self, that: scala.collection.GenSet) -> typing.Any: ...
        def isEmpty(self) -> bool: ...
        def isStrictSplitterCollection(self) -> bool: ...
        def isTraversableAgain(self) -> bool: ...
        def iterator(self) -> Splitter[_ParMapLike__K]: ...
        def last(self) -> _ParMapLike__K: ...
        def lastOption(self) -> scala.Option[_ParMapLike__K]: ...
        _map__S = typing.TypeVar('_map__S')  # <S>
        _map__That = typing.TypeVar('_map__That')  # <That>
        def map(self, f: scala.Function1[_ParMapLike__K, _map__S], bf: scala.collection.generic.CanBuildFrom['ParSet'[_ParMapLike__K], _map__S, _map__That]) -> _map__That: ...
        _max__U = typing.TypeVar('_max__U')  # <U>
        def max(self, ord: scala.math.Ordering[_max__U]) -> _ParMapLike__K: ...
        _maxBy__S = typing.TypeVar('_maxBy__S')  # <S>
        def maxBy(self, f: scala.Function1[_ParMapLike__K, _maxBy__S], cmp: scala.math.Ordering[_maxBy__S]) -> _ParMapLike__K: ...
        _min__U = typing.TypeVar('_min__U')  # <U>
        def min(self, ord: scala.math.Ordering[_min__U]) -> _ParMapLike__K: ...
        _minBy__S = typing.TypeVar('_minBy__S')  # <S>
        def minBy(self, f: scala.Function1[_ParMapLike__K, _minBy__S], cmp: scala.math.Ordering[_minBy__S]) -> _ParMapLike__K: ...
        @typing.overload
        def mkString(self) -> java.lang.String: ...
        @typing.overload
        def mkString(self, sep: typing.Union[java.lang.String, str]) -> java.lang.String: ...
        @typing.overload
        def mkString(self, start: typing.Union[java.lang.String, str], sep: typing.Union[java.lang.String, str], end: typing.Union[java.lang.String, str]) -> java.lang.String: ...
        def newBuilder(self) -> scala.collection.mutable.Builder[_ParMapLike__K, 'ParSet'[_ParMapLike__K]]: ...
        def newCombiner(self) -> Combiner[_ParMapLike__K, 'ParSet'[_ParMapLike__K]]: ...
        def nonEmpty(self) -> bool: ...
        def par(self) -> ParIterable: ...
        def parCombiner(self) -> Combiner[_ParMapLike__K, 'ParSet'[_ParMapLike__K]]: ...
        def partition(self, pred: scala.Function1[_ParMapLike__K, typing.Any]) -> scala.Tuple2['ParSet'[_ParMapLike__K], 'ParSet'[_ParMapLike__K]]: ...
        def printDebugBuffer(self) -> None: ...
        _product__U = typing.TypeVar('_product__U')  # <U>
        def product(self, num: scala.math.Numeric[_product__U]) -> _product__U: ...
        _reduce__U = typing.TypeVar('_reduce__U')  # <U>
        def reduce(self, op: scala.Function2[_reduce__U, _reduce__U, _reduce__U]) -> _reduce__U: ...
        _reduceLeft__U = typing.TypeVar('_reduceLeft__U')  # <U>
        def reduceLeft(self, op: scala.Function2[_reduceLeft__U, _ParMapLike__K, _reduceLeft__U]) -> _reduceLeft__U: ...
        _reduceLeftOption__U = typing.TypeVar('_reduceLeftOption__U')  # <U>
        def reduceLeftOption(self, op: scala.Function2[_reduceLeftOption__U, _ParMapLike__K, _reduceLeftOption__U]) -> scala.Option[_reduceLeftOption__U]: ...
        _reduceOption__U = typing.TypeVar('_reduceOption__U')  # <U>
        def reduceOption(self, op: scala.Function2[_reduceOption__U, _reduceOption__U, _reduceOption__U]) -> scala.Option[_reduceOption__U]: ...
        _reduceRight__U = typing.TypeVar('_reduceRight__U')  # <U>
        def reduceRight(self, op: scala.Function2[_ParMapLike__K, _reduceRight__U, _reduceRight__U]) -> _reduceRight__U: ...
        _reduceRightOption__U = typing.TypeVar('_reduceRightOption__U')  # <U>
        def reduceRightOption(self, op: scala.Function2[_ParMapLike__K, _reduceRightOption__U, _reduceRightOption__U]) -> scala.Option[_reduceRightOption__U]: ...
        def repr(self) -> ParIterable: ...
        _reuse__S = typing.TypeVar('_reuse__S')  # <S>
        _reuse__That = typing.TypeVar('_reuse__That')  # <That>
        def reuse(self, oldc: scala.Option[Combiner[_reuse__S, _reuse__That]], newc: Combiner[_reuse__S, _reuse__That]) -> Combiner[_reuse__S, _reuse__That]: ...
        _sameElements__U = typing.TypeVar('_sameElements__U')  # <U>
        def sameElements(self, that: scala.collection.GenIterable[_sameElements__U]) -> bool: ...
        def scala$collection$parallel$ParIterableLike$$_tasksupport(self) -> TaskSupport: ...
        def scala$collection$parallel$ParIterableLike$$_tasksupport_$eq(self, x$1: TaskSupport) -> None: ...
        _scan__U = typing.TypeVar('_scan__U')  # <U>
        _scan__That = typing.TypeVar('_scan__That')  # <That>
        def scan(self, z: _scan__U, op: scala.Function2[_scan__U, _scan__U, _scan__U], bf: scala.collection.generic.CanBuildFrom['ParSet'[_ParMapLike__K], _scan__U, _scan__That]) -> _scan__That: ...
        def scanBlockSize(self) -> int: ...
        _scanLeft__S = typing.TypeVar('_scanLeft__S')  # <S>
        _scanLeft__That = typing.TypeVar('_scanLeft__That')  # <That>
        def scanLeft(self, z: _scanLeft__S, op: scala.Function2[_scanLeft__S, _ParMapLike__K, _scanLeft__S], bf: scala.collection.generic.CanBuildFrom['ParSet'[_ParMapLike__K], _scanLeft__S, _scanLeft__That]) -> _scanLeft__That: ...
        _scanRight__S = typing.TypeVar('_scanRight__S')  # <S>
        _scanRight__That = typing.TypeVar('_scanRight__That')  # <That>
        def scanRight(self, z: _scanRight__S, op: scala.Function2[_ParMapLike__K, _scanRight__S, _scanRight__S], bf: scala.collection.generic.CanBuildFrom['ParSet'[_ParMapLike__K], _scanRight__S, _scanRight__That]) -> _scanRight__That: ...
        def seq(self) -> scala.collection.Set[_ParMapLike__K]: ...
        def sequentially(self, b: scala.Function1) -> ParIterable: ...
        def size(self) -> int: ...
        def sizeHintIfCheap(self) -> int: ...
        def slice(self, unc_from: int, unc_until: int) -> ParIterable: ...
        def span(self, pred: scala.Function1[_ParMapLike__K, typing.Any]) -> scala.Tuple2['ParSet'[_ParMapLike__K], 'ParSet'[_ParMapLike__K]]: ...
        def splitAt(self, n: int) -> scala.Tuple2['ParSet'[_ParMapLike__K], 'ParSet'[_ParMapLike__K]]: ...
        def splitter(self) -> IterableSplitter[_ParMapLike__K]: ...
        def stringPrefix(self) -> java.lang.String: ...
        def subsetOf(self, that: scala.collection.GenSet[_ParMapLike__K]) -> bool: ...
        _sum__U = typing.TypeVar('_sum__U')  # <U>
        def sum(self, num: scala.math.Numeric[_sum__U]) -> _sum__U: ...
        def tail(self) -> ParIterable: ...
        def take(self, n: int) -> ParIterable: ...
        def takeWhile(self, pred: scala.Function1) -> ParIterable: ...
        _task2ops__R = typing.TypeVar('_task2ops__R')  # <R>
        _task2ops__Tp = typing.TypeVar('_task2ops__Tp')  # <Tp>
        def task2ops(self, tsk: 'ParIterableLike.StrictSplitterCheckTask'[_task2ops__R, _task2ops__Tp]) -> 'ParIterableLike.TaskOps'[_task2ops__R, _task2ops__Tp]: ...
        def tasksupport(self) -> TaskSupport: ...
        def tasksupport_$eq(self, ts: TaskSupport) -> None: ...
        _to__Col = typing.TypeVar('_to__Col')  # <Col>
        def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., _ParMapLike__K, _to__Col]) -> _to__Col: ...
        _toArray__U = typing.TypeVar('_toArray__U')  # <U>
        def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__U]) -> typing.Any: ...
        _toBuffer__U = typing.TypeVar('_toBuffer__U')  # <U>
        def toBuffer(self) -> scala.collection.mutable.Buffer[_toBuffer__U]: ...
        def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq[_ParMapLike__K]: ...
        def toIterable(self) -> ParIterable[_ParMapLike__K]: ...
        def toIterator(self) -> scala.collection.Iterator[_ParMapLike__K]: ...
        def toList(self) -> scala.collection.immutable.List[_ParMapLike__K]: ...
        _toMap__K = typing.TypeVar('_toMap__K')  # <K>
        _toMap__V = typing.TypeVar('_toMap__V')  # <V>
        def toMap(self, ev: scala.Predef..less.colon.less[typing.Any, scala.Tuple2[typing.Any, typing.Any]]) -> scala.collection.parallel.immutable.ParMap[typing.Any, typing.Any]: ...
        _toParCollection__U = typing.TypeVar('_toParCollection__U')  # <U>
        _toParCollection__That = typing.TypeVar('_toParCollection__That')  # <That>
        def toParCollection(self, cbf: scala.Function0[Combiner[_toParCollection__U, _toParCollection__That]]) -> _toParCollection__That: ...
        _toParMap__K = typing.TypeVar('_toParMap__K')  # <K>
        _toParMap__V = typing.TypeVar('_toParMap__V')  # <V>
        _toParMap__That = typing.TypeVar('_toParMap__That')  # <That>
        def toParMap(self, cbf: scala.Function0[Combiner[scala.Tuple2[typing.Any, typing.Any], _toParMap__That]], ev: scala.Predef..less.colon.less[typing.Any, scala.Tuple2[typing.Any, typing.Any]]) -> _toParMap__That: ...
        def toSeq(self) -> 'ParSeq'[_ParMapLike__K]: ...
        _toSet__U = typing.TypeVar('_toSet__U')  # <U>
        def toSet(self) -> scala.collection.parallel.immutable.ParSet[_toSet__U]: ...
        def toStream(self) -> scala.collection.immutable.Stream[_ParMapLike__K]: ...
        def toString(self) -> java.lang.String: ...
        def toTraversable(self) -> scala.collection.GenTraversable[_ParMapLike__K]: ...
        def toVector(self) -> scala.collection.immutable.Vector[_ParMapLike__K]: ...
        def transpose(self, asTraversable: scala.Function1) -> scala.collection.GenTraversable: ...
        def union(self, that: scala.collection.GenSet[_ParMapLike__K]) -> 'ParSet'[_ParMapLike__K]: ...
        _unzip__A1 = typing.TypeVar('_unzip__A1')  # <A1>
        _unzip__A2 = typing.TypeVar('_unzip__A2')  # <A2>
        def unzip(self, asPair: scala.Function1[_ParMapLike__K, scala.Tuple2[_unzip__A1, _unzip__A2]]) -> scala.Tuple2['ParSet'[_unzip__A1], 'ParSet'[_unzip__A2]]: ...
        _unzip3__A1 = typing.TypeVar('_unzip3__A1')  # <A1>
        _unzip3__A2 = typing.TypeVar('_unzip3__A2')  # <A2>
        _unzip3__A3 = typing.TypeVar('_unzip3__A3')  # <A3>
        def unzip3(self, asTriple: scala.Function1[_ParMapLike__K, scala.Tuple3[_unzip3__A1, _unzip3__A2, _unzip3__A3]]) -> scala.Tuple3['ParSet'[_unzip3__A1], 'ParSet'[_unzip3__A2], 'ParSet'[_unzip3__A3]]: ...
        def view(self) -> scala.collection.IterableView[_ParMapLike__K, scala.collection.Set[_ParMapLike__K]]: ...
        def withFilter(self, pred: scala.Function1) -> ParIterable: ...
        _wrap__R = typing.TypeVar('_wrap__R')  # <R>
        def wrap(self, body: scala.Function0[_wrap__R]) -> 'ParIterableLike.NonDivisible'[_wrap__R]: ...
        _zip__U = typing.TypeVar('_zip__U')  # <U>
        _zip__S = typing.TypeVar('_zip__S')  # <S>
        _zip__That = typing.TypeVar('_zip__That')  # <That>
        def zip(self, that: scala.collection.GenIterable[_zip__S], bf: scala.collection.generic.CanBuildFrom['ParSet'[_ParMapLike__K], scala.Tuple2[_zip__U, _zip__S], _zip__That]) -> _zip__That: ...
        _zipAll__S = typing.TypeVar('_zipAll__S')  # <S>
        _zipAll__U = typing.TypeVar('_zipAll__U')  # <U>
        _zipAll__That = typing.TypeVar('_zipAll__That')  # <That>
        def zipAll(self, that: scala.collection.GenIterable[_zipAll__S], thisElem: _zipAll__U, thatElem: _zipAll__S, bf: scala.collection.generic.CanBuildFrom['ParSet'[_ParMapLike__K], scala.Tuple2[_zipAll__U, _zipAll__S], _zipAll__That]) -> _zipAll__That: ...
        _zipWithIndex__U = typing.TypeVar('_zipWithIndex__U')  # <U>
        _zipWithIndex__That = typing.TypeVar('_zipWithIndex__That')  # <That>
        def zipWithIndex(self, bf: scala.collection.generic.CanBuildFrom['ParSet'[_ParMapLike__K], scala.Tuple2[_zipWithIndex__U, typing.Any], _zipWithIndex__That]) -> _zipWithIndex__That: ...
    class DefaultValuesIterable(ParIterable[_ParMapLike__V]):
        $outer: 'ParMapLike' = ...
        def __init__(self, $outer: 'ParMapLike'): ...
        _$colon$bslash__S = typing.TypeVar('_$colon$bslash__S')  # <S>
        def $colon$bslash(self, z: _.colon.bslash__S, op: scala.Function2[_ParMapLike__V, _.colon.bslash__S, _.colon.bslash__S]) -> _.colon.bslash__S: ...
        _$div$colon__S = typing.TypeVar('_$div$colon__S')  # <S>
        def $div$colon(self, z: _.div.colon__S, op: scala.Function2[_.div.colon__S, _ParMapLike__V, _.div.colon__S]) -> _.div.colon__S: ...
        _$plus$plus__U = typing.TypeVar('_$plus$plus__U')  # <U>
        _$plus$plus__That = typing.TypeVar('_$plus$plus__That')  # <That>
        def $plus$plus(self, that: scala.collection.GenTraversableOnce[_.plus.plus__U], bf: scala.collection.generic.CanBuildFrom[ParIterable[_ParMapLike__V], _.plus.plus__U, _.plus.plus__That]) -> _.plus.plus__That: ...
        def ScanLeaf(self) -> 'ParIterableLike.ScanLeaf.': ...
        def ScanNode(self) -> 'ParIterableLike.ScanNode.': ...
        _aggregate__S = typing.TypeVar('_aggregate__S')  # <S>
        def aggregate(self, z: scala.Function0[_aggregate__S], seqop: scala.Function2[_aggregate__S, _ParMapLike__V, _aggregate__S], combop: scala.Function2[_aggregate__S, _aggregate__S, _aggregate__S]) -> _aggregate__S: ...
        _bf2seq__S = typing.TypeVar('_bf2seq__S')  # <S>
        _bf2seq__That = typing.TypeVar('_bf2seq__That')  # <That>
        def bf2seq(self, bf: scala.collection.generic.CanBuildFrom[ParIterable[_ParMapLike__V], _bf2seq__S, _bf2seq__That]) -> scala.collection.generic.CanBuildFrom[scala.collection.Iterable[_ParMapLike__V], _bf2seq__S, _bf2seq__That]: ...
        def brokenInvariants(self) -> scala.collection.Seq[java.lang.String]: ...
        _builder2ops__Elem = typing.TypeVar('_builder2ops__Elem')  # <Elem>
        _builder2ops__To = typing.TypeVar('_builder2ops__To')  # <To>
        def builder2ops(self, cb: scala.collection.mutable.Builder[_builder2ops__Elem, _builder2ops__To]) -> 'ParIterableLike.BuilderOps'[_builder2ops__Elem, _builder2ops__To]: ...
        def canEqual(self, other: typing.Any) -> bool: ...
        _collect__S = typing.TypeVar('_collect__S')  # <S>
        _collect__That = typing.TypeVar('_collect__That')  # <That>
        def collect(self, pf: scala.PartialFunction[_ParMapLike__V, _collect__S], bf: scala.collection.generic.CanBuildFrom[ParIterable[_ParMapLike__V], _collect__S, _collect__That]) -> _collect__That: ...
        _combinerFactory_1__S = typing.TypeVar('_combinerFactory_1__S')  # <S>
        _combinerFactory_1__That = typing.TypeVar('_combinerFactory_1__That')  # <That>
        @typing.overload
        def combinerFactory(self) -> CombinerFactory[_ParMapLike__V, ParIterable[_ParMapLike__V]]: ...
        @typing.overload
        def combinerFactory(self, cbf: scala.Function0[Combiner[_combinerFactory_1__S, _combinerFactory_1__That]]) -> CombinerFactory[_combinerFactory_1__S, _combinerFactory_1__That]: ...
        def companion(self) -> scala.collection.generic.GenericCompanion[ParIterable]: ...
        _copyToArray_0__U = typing.TypeVar('_copyToArray_0__U')  # <U>
        _copyToArray_1__U = typing.TypeVar('_copyToArray_1__U')  # <U>
        _copyToArray_2__U = typing.TypeVar('_copyToArray_2__U')  # <U>
        @typing.overload
        def copyToArray(self, xs: typing.Any) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
        def count(self, p: scala.Function1[_ParMapLike__V, typing.Any]) -> int: ...
        def debugBuffer(self) -> scala.collection.mutable.ArrayBuffer[java.lang.String]: ...
        def debugInformation(self) -> java.lang.String: ...
        def debugclear(self) -> None: ...
        def debuglog(self, s: typing.Union[java.lang.String, str]) -> scala.collection.mutable.ArrayBuffer[java.lang.String]: ...
        _delegatedSignalling2ops__PI = typing.TypeVar('_delegatedSignalling2ops__PI', bound=scala.collection.generic.DelegatedSignalling)  # <PI>
        def delegatedSignalling2ops(self, it: _delegatedSignalling2ops__PI) -> 'ParIterableLike.SignallingOps'[_delegatedSignalling2ops__PI]: ...
        def drop(self, n: int) -> ParIterable[_ParMapLike__V]: ...
        def dropWhile(self, pred: scala.Function1[_ParMapLike__V, typing.Any]) -> ParIterable[_ParMapLike__V]: ...
        def exists(self, p: scala.Function1[_ParMapLike__V, typing.Any]) -> bool: ...
        def filter(self, pred: scala.Function1[_ParMapLike__V, typing.Any]) -> ParIterable[_ParMapLike__V]: ...
        def filterNot(self, pred: scala.Function1[_ParMapLike__V, typing.Any]) -> ParIterable[_ParMapLike__V]: ...
        def find(self, p: scala.Function1[_ParMapLike__V, typing.Any]) -> scala.Option[_ParMapLike__V]: ...
        _flatMap__S = typing.TypeVar('_flatMap__S')  # <S>
        _flatMap__That = typing.TypeVar('_flatMap__That')  # <That>
        def flatMap(self, f: scala.Function1[_ParMapLike__V, scala.collection.GenTraversableOnce[_flatMap__S]], bf: scala.collection.generic.CanBuildFrom[ParIterable[_ParMapLike__V], _flatMap__S, _flatMap__That]) -> _flatMap__That: ...
        def flatten(self, asTraversable: scala.Function1) -> scala.collection.GenTraversable: ...
        _fold__U = typing.TypeVar('_fold__U')  # <U>
        def fold(self, z: _fold__U, op: scala.Function2[_fold__U, _fold__U, _fold__U]) -> _fold__U: ...
        _foldLeft__S = typing.TypeVar('_foldLeft__S')  # <S>
        def foldLeft(self, z: _foldLeft__S, op: scala.Function2[_foldLeft__S, _ParMapLike__V, _foldLeft__S]) -> _foldLeft__S: ...
        _foldRight__S = typing.TypeVar('_foldRight__S')  # <S>
        def foldRight(self, z: _foldRight__S, op: scala.Function2[_ParMapLike__V, _foldRight__S, _foldRight__S]) -> _foldRight__S: ...
        def forall(self, p: scala.Function1[_ParMapLike__V, typing.Any]) -> bool: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[_ParMapLike__V, _foreach__U]) -> None: ...
        _genericBuilder__B = typing.TypeVar('_genericBuilder__B')  # <B>
        def genericBuilder(self) -> Combiner[_genericBuilder__B, ParIterable[_genericBuilder__B]]: ...
        _genericCombiner__B = typing.TypeVar('_genericCombiner__B')  # <B>
        def genericCombiner(self) -> Combiner[_genericCombiner__B, ParIterable[_genericCombiner__B]]: ...
        _groupBy__K = typing.TypeVar('_groupBy__K')  # <K>
        def groupBy(self, f: scala.Function1[_ParMapLike__V, typing.Any]) -> scala.collection.parallel.immutable.ParMap[typing.Any, ParIterable[_ParMapLike__V]]: ...
        def hasDefiniteSize(self) -> bool: ...
        def head(self) -> _ParMapLike__V: ...
        def headOption(self) -> scala.Option[_ParMapLike__V]: ...
        def init(self) -> ParIterable[_ParMapLike__V]: ...
        def initTaskSupport(self) -> None: ...
        def isEmpty(self) -> bool: ...
        def isStrictSplitterCollection(self) -> bool: ...
        def isTraversableAgain(self) -> bool: ...
        def iterator(self) -> Splitter[_ParMapLike__V]: ...
        def last(self) -> _ParMapLike__V: ...
        def lastOption(self) -> scala.Option[_ParMapLike__V]: ...
        _map__S = typing.TypeVar('_map__S')  # <S>
        _map__That = typing.TypeVar('_map__That')  # <That>
        def map(self, f: scala.Function1[_ParMapLike__V, _map__S], bf: scala.collection.generic.CanBuildFrom[ParIterable[_ParMapLike__V], _map__S, _map__That]) -> _map__That: ...
        _max__U = typing.TypeVar('_max__U')  # <U>
        def max(self, ord: scala.math.Ordering[_max__U]) -> _ParMapLike__V: ...
        _maxBy__S = typing.TypeVar('_maxBy__S')  # <S>
        def maxBy(self, f: scala.Function1[_ParMapLike__V, _maxBy__S], cmp: scala.math.Ordering[_maxBy__S]) -> _ParMapLike__V: ...
        _min__U = typing.TypeVar('_min__U')  # <U>
        def min(self, ord: scala.math.Ordering[_min__U]) -> _ParMapLike__V: ...
        _minBy__S = typing.TypeVar('_minBy__S')  # <S>
        def minBy(self, f: scala.Function1[_ParMapLike__V, _minBy__S], cmp: scala.math.Ordering[_minBy__S]) -> _ParMapLike__V: ...
        @typing.overload
        def mkString(self) -> java.lang.String: ...
        @typing.overload
        def mkString(self, sep: typing.Union[java.lang.String, str]) -> java.lang.String: ...
        @typing.overload
        def mkString(self, start: typing.Union[java.lang.String, str], sep: typing.Union[java.lang.String, str], end: typing.Union[java.lang.String, str]) -> java.lang.String: ...
        def newBuilder(self) -> scala.collection.mutable.Builder[_ParMapLike__V, ParIterable[_ParMapLike__V]]: ...
        def newCombiner(self) -> Combiner[_ParMapLike__V, ParIterable[_ParMapLike__V]]: ...
        def nonEmpty(self) -> bool: ...
        def par(self) -> ParIterable[_ParMapLike__V]: ...
        def parCombiner(self) -> Combiner[_ParMapLike__V, ParIterable[_ParMapLike__V]]: ...
        def partition(self, pred: scala.Function1[_ParMapLike__V, typing.Any]) -> scala.Tuple2[ParIterable[_ParMapLike__V], ParIterable[_ParMapLike__V]]: ...
        def printDebugBuffer(self) -> None: ...
        _product__U = typing.TypeVar('_product__U')  # <U>
        def product(self, num: scala.math.Numeric[_product__U]) -> _product__U: ...
        _reduce__U = typing.TypeVar('_reduce__U')  # <U>
        def reduce(self, op: scala.Function2[_reduce__U, _reduce__U, _reduce__U]) -> _reduce__U: ...
        _reduceLeft__U = typing.TypeVar('_reduceLeft__U')  # <U>
        def reduceLeft(self, op: scala.Function2[_reduceLeft__U, _ParMapLike__V, _reduceLeft__U]) -> _reduceLeft__U: ...
        _reduceLeftOption__U = typing.TypeVar('_reduceLeftOption__U')  # <U>
        def reduceLeftOption(self, op: scala.Function2[_reduceLeftOption__U, _ParMapLike__V, _reduceLeftOption__U]) -> scala.Option[_reduceLeftOption__U]: ...
        _reduceOption__U = typing.TypeVar('_reduceOption__U')  # <U>
        def reduceOption(self, op: scala.Function2[_reduceOption__U, _reduceOption__U, _reduceOption__U]) -> scala.Option[_reduceOption__U]: ...
        _reduceRight__U = typing.TypeVar('_reduceRight__U')  # <U>
        def reduceRight(self, op: scala.Function2[_ParMapLike__V, _reduceRight__U, _reduceRight__U]) -> _reduceRight__U: ...
        _reduceRightOption__U = typing.TypeVar('_reduceRightOption__U')  # <U>
        def reduceRightOption(self, op: scala.Function2[_ParMapLike__V, _reduceRightOption__U, _reduceRightOption__U]) -> scala.Option[_reduceRightOption__U]: ...
        def repr(self) -> ParIterable[_ParMapLike__V]: ...
        _reuse__S = typing.TypeVar('_reuse__S')  # <S>
        _reuse__That = typing.TypeVar('_reuse__That')  # <That>
        def reuse(self, oldc: scala.Option[Combiner[_reuse__S, _reuse__That]], newc: Combiner[_reuse__S, _reuse__That]) -> Combiner[_reuse__S, _reuse__That]: ...
        _sameElements__U = typing.TypeVar('_sameElements__U')  # <U>
        def sameElements(self, that: scala.collection.GenIterable[_sameElements__U]) -> bool: ...
        def scala$collection$parallel$ParIterableLike$$_tasksupport(self) -> TaskSupport: ...
        def scala$collection$parallel$ParIterableLike$$_tasksupport_$eq(self, x$1: TaskSupport) -> None: ...
        _scan__U = typing.TypeVar('_scan__U')  # <U>
        _scan__That = typing.TypeVar('_scan__That')  # <That>
        def scan(self, z: _scan__U, op: scala.Function2[_scan__U, _scan__U, _scan__U], bf: scala.collection.generic.CanBuildFrom[ParIterable[_ParMapLike__V], _scan__U, _scan__That]) -> _scan__That: ...
        def scanBlockSize(self) -> int: ...
        _scanLeft__S = typing.TypeVar('_scanLeft__S')  # <S>
        _scanLeft__That = typing.TypeVar('_scanLeft__That')  # <That>
        def scanLeft(self, z: _scanLeft__S, op: scala.Function2[_scanLeft__S, _ParMapLike__V, _scanLeft__S], bf: scala.collection.generic.CanBuildFrom[ParIterable[_ParMapLike__V], _scanLeft__S, _scanLeft__That]) -> _scanLeft__That: ...
        _scanRight__S = typing.TypeVar('_scanRight__S')  # <S>
        _scanRight__That = typing.TypeVar('_scanRight__That')  # <That>
        def scanRight(self, z: _scanRight__S, op: scala.Function2[_ParMapLike__V, _scanRight__S, _scanRight__S], bf: scala.collection.generic.CanBuildFrom[ParIterable[_ParMapLike__V], _scanRight__S, _scanRight__That]) -> _scanRight__That: ...
        def seq(self) -> scala.collection.Iterable[_ParMapLike__V]: ...
        _sequentially__S = typing.TypeVar('_sequentially__S')  # <S>
        _sequentially__That = typing.TypeVar('_sequentially__That', bound=scala.collection.Parallel)  # <That>
        def sequentially(self, b: scala.Function1[scala.collection.Iterable[_ParMapLike__V], scala.collection.Parallelizable[_sequentially__S, _sequentially__That]]) -> ParIterable[_ParMapLike__V]: ...
        def size(self) -> int: ...
        def sizeHintIfCheap(self) -> int: ...
        def slice(self, unc_from: int, unc_until: int) -> ParIterable[_ParMapLike__V]: ...
        def span(self, pred: scala.Function1[_ParMapLike__V, typing.Any]) -> scala.Tuple2[ParIterable[_ParMapLike__V], ParIterable[_ParMapLike__V]]: ...
        def splitAt(self, n: int) -> scala.Tuple2[ParIterable[_ParMapLike__V], ParIterable[_ParMapLike__V]]: ...
        def splitter(self) -> IterableSplitter[_ParMapLike__V]: ...
        def stringPrefix(self) -> java.lang.String: ...
        _sum__U = typing.TypeVar('_sum__U')  # <U>
        def sum(self, num: scala.math.Numeric[_sum__U]) -> _sum__U: ...
        def tail(self) -> ParIterable[_ParMapLike__V]: ...
        def take(self, n: int) -> ParIterable[_ParMapLike__V]: ...
        def takeWhile(self, pred: scala.Function1[_ParMapLike__V, typing.Any]) -> ParIterable[_ParMapLike__V]: ...
        _task2ops__R = typing.TypeVar('_task2ops__R')  # <R>
        _task2ops__Tp = typing.TypeVar('_task2ops__Tp')  # <Tp>
        def task2ops(self, tsk: 'ParIterableLike.StrictSplitterCheckTask'[_task2ops__R, _task2ops__Tp]) -> 'ParIterableLike.TaskOps'[_task2ops__R, _task2ops__Tp]: ...
        def tasksupport(self) -> TaskSupport: ...
        def tasksupport_$eq(self, ts: TaskSupport) -> None: ...
        _to__Col = typing.TypeVar('_to__Col')  # <Col>
        def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., _ParMapLike__V, _to__Col]) -> _to__Col: ...
        _toArray__U = typing.TypeVar('_toArray__U')  # <U>
        def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__U]) -> typing.Any: ...
        _toBuffer__U = typing.TypeVar('_toBuffer__U')  # <U>
        def toBuffer(self) -> scala.collection.mutable.Buffer[_toBuffer__U]: ...
        def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq[_ParMapLike__V]: ...
        def toIterable(self) -> ParIterable[_ParMapLike__V]: ...
        def toIterator(self) -> scala.collection.Iterator[_ParMapLike__V]: ...
        def toList(self) -> scala.collection.immutable.List[_ParMapLike__V]: ...
        _toMap__K = typing.TypeVar('_toMap__K')  # <K>
        _toMap__V = typing.TypeVar('_toMap__V')  # <V>
        def toMap(self, ev: scala.Predef..less.colon.less[typing.Any, scala.Tuple2[typing.Any, typing.Any]]) -> scala.collection.parallel.immutable.ParMap[typing.Any, typing.Any]: ...
        _toParCollection__U = typing.TypeVar('_toParCollection__U')  # <U>
        _toParCollection__That = typing.TypeVar('_toParCollection__That')  # <That>
        def toParCollection(self, cbf: scala.Function0[Combiner[_toParCollection__U, _toParCollection__That]]) -> _toParCollection__That: ...
        _toParMap__K = typing.TypeVar('_toParMap__K')  # <K>
        _toParMap__V = typing.TypeVar('_toParMap__V')  # <V>
        _toParMap__That = typing.TypeVar('_toParMap__That')  # <That>
        def toParMap(self, cbf: scala.Function0[Combiner[scala.Tuple2[typing.Any, typing.Any], _toParMap__That]], ev: scala.Predef..less.colon.less[typing.Any, scala.Tuple2[typing.Any, typing.Any]]) -> _toParMap__That: ...
        def toSeq(self) -> 'ParSeq'[_ParMapLike__V]: ...
        _toSet__U = typing.TypeVar('_toSet__U')  # <U>
        def toSet(self) -> scala.collection.parallel.immutable.ParSet[_toSet__U]: ...
        def toStream(self) -> scala.collection.immutable.Stream[_ParMapLike__V]: ...
        def toString(self) -> java.lang.String: ...
        def toTraversable(self) -> scala.collection.GenTraversable[_ParMapLike__V]: ...
        def toVector(self) -> scala.collection.immutable.Vector[_ParMapLike__V]: ...
        def transpose(self, asTraversable: scala.Function1) -> scala.collection.GenTraversable: ...
        _unzip__A1 = typing.TypeVar('_unzip__A1')  # <A1>
        _unzip__A2 = typing.TypeVar('_unzip__A2')  # <A2>
        def unzip(self, asPair: scala.Function1[_ParMapLike__V, scala.Tuple2[_unzip__A1, _unzip__A2]]) -> scala.Tuple2[ParIterable[_unzip__A1], ParIterable[_unzip__A2]]: ...
        _unzip3__A1 = typing.TypeVar('_unzip3__A1')  # <A1>
        _unzip3__A2 = typing.TypeVar('_unzip3__A2')  # <A2>
        _unzip3__A3 = typing.TypeVar('_unzip3__A3')  # <A3>
        def unzip3(self, asTriple: scala.Function1[_ParMapLike__V, scala.Tuple3[_unzip3__A1, _unzip3__A2, _unzip3__A3]]) -> scala.Tuple3[ParIterable[_unzip3__A1], ParIterable[_unzip3__A2], ParIterable[_unzip3__A3]]: ...
        def view(self) -> scala.collection.IterableView[_ParMapLike__V, scala.collection.Iterable[_ParMapLike__V]]: ...
        def withFilter(self, pred: scala.Function1[_ParMapLike__V, typing.Any]) -> ParIterable[_ParMapLike__V]: ...
        _wrap__R = typing.TypeVar('_wrap__R')  # <R>
        def wrap(self, body: scala.Function0[_wrap__R]) -> 'ParIterableLike.NonDivisible'[_wrap__R]: ...
        _zip__U = typing.TypeVar('_zip__U')  # <U>
        _zip__S = typing.TypeVar('_zip__S')  # <S>
        _zip__That = typing.TypeVar('_zip__That')  # <That>
        def zip(self, that: scala.collection.GenIterable[_zip__S], bf: scala.collection.generic.CanBuildFrom[ParIterable[_ParMapLike__V], scala.Tuple2[_zip__U, _zip__S], _zip__That]) -> _zip__That: ...
        _zipAll__S = typing.TypeVar('_zipAll__S')  # <S>
        _zipAll__U = typing.TypeVar('_zipAll__U')  # <U>
        _zipAll__That = typing.TypeVar('_zipAll__That')  # <That>
        def zipAll(self, that: scala.collection.GenIterable[_zipAll__S], thisElem: _zipAll__U, thatElem: _zipAll__S, bf: scala.collection.generic.CanBuildFrom[ParIterable[_ParMapLike__V], scala.Tuple2[_zipAll__U, _zipAll__S], _zipAll__That]) -> _zipAll__That: ...
        _zipWithIndex__U = typing.TypeVar('_zipWithIndex__U')  # <U>
        _zipWithIndex__That = typing.TypeVar('_zipWithIndex__That')  # <That>
        def zipWithIndex(self, bf: scala.collection.generic.CanBuildFrom[ParIterable[_ParMapLike__V], scala.Tuple2[_zipWithIndex__U, typing.Any], _zipWithIndex__That]) -> _zipWithIndex__That: ...

_ParSeq__T = typing.TypeVar('_ParSeq__T')  # <T>
class ParSeq(scala.collection.GenSeq[_ParSeq__T], ParIterable[_ParSeq__T], scala.collection.parallel.ParSeqLike[_ParSeq__T, 'ParSeq'[_ParSeq__T], scala.collection.Seq[_ParSeq__T]], typing.Generic[_ParSeq__T]):
    @staticmethod
    def $init$($this: 'ParSeq') -> None: ...
    @staticmethod
    def ReusableCBF() -> scala.collection.generic.GenTraversableFactory.GenericCanBuildFrom[scala.runtime.Nothing.]: ...
    def apply(self, i: int) -> _ParSeq__T: ...
    _canBuildFrom__T = typing.TypeVar('_canBuildFrom__T')  # <T>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanCombineFrom['ParSeq'[typing.Any], _canBuildFrom__T, 'ParSeq'[_canBuildFrom__T]]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['ParSeq']: ...
    @staticmethod
    def concat(xss: scala.collection.Seq) -> scala.collection.GenTraversable: ...
    @staticmethod
    def empty() -> scala.collection.GenTraversable: ...
    def equals(self, that: typing.Any) -> bool: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, n5: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, n4: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, n3: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n1: int, n2: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def fill(n: int, elem: scala.Function0) -> scala.collection.GenTraversable: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def iterate(start: typing.Any, len: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, step: typing.Any, evidence$2: scala.math.Integral) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def range(start: typing.Any, end: typing.Any, evidence$1: scala.math.Integral) -> scala.collection.GenTraversable: ...
    def stringPrefix(self) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, n5: int, f: scala.Function5) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, n4: int, f: scala.Function4) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, n3: int, f: scala.Function3) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n1: int, n2: int, f: scala.Function2) -> scala.collection.GenTraversable: ...
    @typing.overload
    @staticmethod
    def tabulate(n: int, f: scala.Function1) -> scala.collection.GenTraversable: ...
    def toString(self) -> java.lang.String: ...

_ParSeqLike__Accessor__R = typing.TypeVar('_ParSeqLike__Accessor__R')  # <R>
_ParSeqLike__Accessor__Tp = typing.TypeVar('_ParSeqLike__Accessor__Tp')  # <Tp>
_ParSeqLike__Corresponds__S = typing.TypeVar('_ParSeqLike__Corresponds__S')  # <S>
_ParSeqLike__Reverse__U = typing.TypeVar('_ParSeqLike__Reverse__U')  # <U>
_ParSeqLike__Reverse__This = typing.TypeVar('_ParSeqLike__Reverse__This')  # <This>
_ParSeqLike__ReverseMap__S = typing.TypeVar('_ParSeqLike__ReverseMap__S')  # <S>
_ParSeqLike__ReverseMap__That = typing.TypeVar('_ParSeqLike__ReverseMap__That')  # <That>
_ParSeqLike__SameElements__U = typing.TypeVar('_ParSeqLike__SameElements__U')  # <U>
_ParSeqLike__Transformer__R = typing.TypeVar('_ParSeqLike__Transformer__R')  # <R>
_ParSeqLike__Transformer__Tp = typing.TypeVar('_ParSeqLike__Transformer__Tp')  # <Tp>
_ParSeqLike__Updated__U = typing.TypeVar('_ParSeqLike__Updated__U')  # <U>
_ParSeqLike__Updated__That = typing.TypeVar('_ParSeqLike__Updated__That')  # <That>
_ParSeqLike__Zip__U = typing.TypeVar('_ParSeqLike__Zip__U')  # <U>
_ParSeqLike__Zip__S = typing.TypeVar('_ParSeqLike__Zip__S')  # <S>
_ParSeqLike__Zip__That = typing.TypeVar('_ParSeqLike__Zip__That')  # <That>
_ParSeqLike__T = typing.TypeVar('_ParSeqLike__T')  # <T>
_ParSeqLike__Repr = typing.TypeVar('_ParSeqLike__Repr', bound=ParSeq)  # <Repr>
_ParSeqLike__Sequential = typing.TypeVar('_ParSeqLike__Sequential', bound=scala.collection.Seq)  # <Sequential>
class ParSeqLike(scala.collection.GenSeqLike[_ParSeqLike__T, _ParSeqLike__Repr], scala.collection.parallel.ParIterableLike[_ParSeqLike__T, _ParSeqLike__Repr, _ParSeqLike__Sequential], typing.Generic[_ParSeqLike__T, _ParSeqLike__Repr, _ParSeqLike__Sequential]):
    _$colon$plus__U = typing.TypeVar('_$colon$plus__U')  # <U>
    _$colon$plus__That = typing.TypeVar('_$colon$plus__That')  # <That>
    def $colon$plus(self, elem: _.colon.plus__U, bf: scala.collection.generic.CanBuildFrom[_ParSeqLike__Repr, _.colon.plus__U, _.colon.plus__That]) -> _.colon.plus__That: ...
    @staticmethod
    def $init$($this: 'ParSeqLike') -> None: ...
    _$plus$colon__U = typing.TypeVar('_$plus$colon__U')  # <U>
    _$plus$colon__That = typing.TypeVar('_$plus$colon__That')  # <That>
    def $plus$colon(self, elem: _.plus.colon__U, bf: scala.collection.generic.CanBuildFrom[_ParSeqLike__Repr, _.plus.colon__U, _.plus.colon__That]) -> _.plus.colon__That: ...
    _corresponds__S = typing.TypeVar('_corresponds__S')  # <S>
    def corresponds(self, that: scala.collection.GenSeq[_corresponds__S], p: scala.Function2[_ParSeqLike__T, _corresponds__S, typing.Any]) -> bool: ...
    _diff_0__B = typing.TypeVar('_diff_0__B')  # <B>
    _diff_1__U = typing.TypeVar('_diff_1__U')  # <U>
    @typing.overload
    def diff(self, that: scala.collection.GenSeq[_diff_0__B]) -> _ParSeqLike__Repr: ...
    @typing.overload
    def diff(self, that: scala.collection.GenSeq[_diff_1__U]) -> _ParSeqLike__Repr: ...
    @typing.overload
    def distinct(self) -> _ParSeqLike__Repr: ...
    @typing.overload
    def distinct(self) -> _ParSeqLike__Repr: ...
    def down(self, p: IterableSplitter[typing.Any]) -> 'SeqSplitter'[_ParSeqLike__T]: ...
    _endsWith__S = typing.TypeVar('_endsWith__S')  # <S>
    def endsWith(self, that: scala.collection.GenSeq[_endsWith__S]) -> bool: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[_ParSeqLike__T, typing.Any], from_: int) -> int: ...
    _intersect_0__B = typing.TypeVar('_intersect_0__B')  # <B>
    _intersect_1__U = typing.TypeVar('_intersect_1__U')  # <U>
    @typing.overload
    def intersect(self, that: scala.collection.GenSeq[_intersect_0__B]) -> _ParSeqLike__Repr: ...
    @typing.overload
    def intersect(self, that: scala.collection.GenSeq[_intersect_1__U]) -> _ParSeqLike__Repr: ...
    @typing.overload
    def iterator(self) -> scala.collection.Iterator[typing.Any]: ...
    @typing.overload
    def iterator(self) -> PreciseSplitter[_ParSeqLike__T]: ...
    @typing.overload
    def iterator(self) -> Splitter[_ParSeqLike__T]: ...
    @typing.overload
    def lastIndexWhere(self, p: scala.Function1[typing.Any, typing.Any]) -> int: ...
    @typing.overload
    def lastIndexWhere(self, p: scala.Function1[_ParSeqLike__T, typing.Any], end: int) -> int: ...
    _padTo__U = typing.TypeVar('_padTo__U')  # <U>
    _padTo__That = typing.TypeVar('_padTo__That')  # <That>
    def padTo(self, len: int, elem: _padTo__U, bf: scala.collection.generic.CanBuildFrom[_ParSeqLike__Repr, _padTo__U, _padTo__That]) -> _padTo__That: ...
    _patch__U = typing.TypeVar('_patch__U')  # <U>
    _patch__That = typing.TypeVar('_patch__That')  # <That>
    def patch(self, from_: int, patch: scala.collection.GenSeq[_patch__U], replaced: int, bf: scala.collection.generic.CanBuildFrom[_ParSeqLike__Repr, _patch__U, _patch__That]) -> _patch__That: ...
    @typing.overload
    def reverse(self) -> _ParSeqLike__Repr: ...
    @typing.overload
    def reverse(self) -> _ParSeqLike__Repr: ...
    _reverseMap__S = typing.TypeVar('_reverseMap__S')  # <S>
    _reverseMap__That = typing.TypeVar('_reverseMap__That')  # <That>
    def reverseMap(self, f: scala.Function1[_ParSeqLike__T, _reverseMap__S], bf: scala.collection.generic.CanBuildFrom[_ParSeqLike__Repr, _reverseMap__S, _reverseMap__That]) -> _reverseMap__That: ...
    _sameElements__U = typing.TypeVar('_sameElements__U')  # <U>
    def sameElements(self, that: scala.collection.GenIterable[_sameElements__U]) -> bool: ...
    def segmentLength(self, p: scala.Function1[_ParSeqLike__T, typing.Any], from_: int) -> int: ...
    def size(self) -> int: ...
    @typing.overload
    def splitter(self) -> IterableSplitter[_ParSeqLike__T]: ...
    @typing.overload
    def splitter(self) -> 'SeqSplitter'[_ParSeqLike__T]: ...
    _startsWith_0__B = typing.TypeVar('_startsWith_0__B')  # <B>
    _startsWith_1__S = typing.TypeVar('_startsWith_1__S')  # <S>
    @typing.overload
    def startsWith(self, that: scala.collection.GenSeq[_startsWith_0__B]) -> bool: ...
    @typing.overload
    def startsWith(self, that: scala.collection.GenSeq[_startsWith_1__S], offset: int) -> bool: ...
    @typing.overload
    def toSeq(self) -> scala.collection.GenSeq[typing.Any]: ...
    @typing.overload
    def toSeq(self) -> ParSeq[_ParSeqLike__T]: ...
    def toString(self) -> java.lang.String: ...
    _updated__U = typing.TypeVar('_updated__U')  # <U>
    _updated__That = typing.TypeVar('_updated__That')  # <That>
    def updated(self, index: int, elem: _updated__U, bf: scala.collection.generic.CanBuildFrom[_ParSeqLike__Repr, _updated__U, _updated__That]) -> _updated__That: ...
    @typing.overload
    def view(self) -> scala.collection.IterableView[_ParSeqLike__T, _ParSeqLike__Sequential]: ...
    @typing.overload
    def view(self) -> scala.collection.SeqView[_ParSeqLike__T, _ParSeqLike__Sequential]: ...
    _zip__U = typing.TypeVar('_zip__U')  # <U>
    _zip__S = typing.TypeVar('_zip__S')  # <S>
    _zip__That = typing.TypeVar('_zip__That')  # <That>
    def zip(self, that: scala.collection.GenIterable[_zip__S], bf: scala.collection.generic.CanBuildFrom[_ParSeqLike__Repr, scala.Tuple2[_zip__U, _zip__S], _zip__That]) -> _zip__That: ...
    class Accessor(scala.collection.parallel.ParIterableLike.Accessor[_ParSeqLike__Accessor__R, _ParSeqLike__Accessor__Tp], typing.Generic[_ParSeqLike__Accessor__R, _ParSeqLike__Accessor__Tp]):
        @typing.overload
        def pit(self) -> IterableSplitter[_ParSeqLike__T]: ...
        @typing.overload
        def pit(self) -> 'SeqSplitter'[_ParSeqLike__T]: ...
        def toString(self) -> java.lang.String: ...
    class Corresponds(scala.collection.parallel.ParSeqLike.Accessor[typing.Any, 'ParSeqLike.Corresponds'[_ParSeqLike__Corresponds__S]], typing.Generic[_ParSeqLike__Corresponds__S]):
        $outer: 'ParSeqLike' = ...
        def __init__(self, $outer: 'ParSeqLike', corr: scala.Function2[_ParSeqLike__T, _ParSeqLike__Corresponds__S, typing.Any], pit: 'SeqSplitter'[_ParSeqLike__T], otherpit: 'SeqSplitter'[_ParSeqLike__Corresponds__S]): ...
        def forwardThrowable(self) -> None: ...
        def leaf(self, prev: scala.Option[typing.Any]) -> None: ...
        def merge(self, that: 'ParSeqLike.Corresponds'[_ParSeqLike__Corresponds__S]) -> None: ...
        def mergeThrowables(self, that: Task[typing.Any, typing.Any]) -> None: ...
        def newSubtask(self, p: IterableSplitter[_ParSeqLike__T]) -> scala.runtime.Nothing.: ...
        def otherpit(self) -> 'SeqSplitter'[_ParSeqLike__Corresponds__S]: ...
        def pit(self) -> 'SeqSplitter'[_ParSeqLike__T]: ...
        def repr(self) -> typing.Any: ...
        def requiresStrictSplitters(self) -> bool: ...
        def result(self) -> bool: ...
        def result_$eq(self, x$1: bool) -> None: ...
        def shouldSplitFurther(self) -> bool: ...
        def signalAbort(self) -> None: ...
        def split(self) -> scala.collection.Seq[Task[typing.Any, 'ParSeqLike.Corresponds'[_ParSeqLike__Corresponds__S]]]: ...
        def throwable(self) -> java.lang.Throwable: ...
        def throwable_$eq(self, x$1: java.lang.Throwable) -> None: ...
        def toString(self) -> java.lang.String: ...
        def tryLeaf(self, lastres: scala.Option[typing.Any]) -> None: ...
        def tryMerge(self, t: typing.Any) -> None: ...
    class Elements(scala.collection.parallel.SeqSplitter[_ParSeqLike__T], scala.collection.BufferedIterator[_ParSeqLike__T]):
        scala$collection$parallel$ParSeqLike$Elements$$start: int = ...
        $outer: 'ParSeqLike' = ...
        def __init__(self, $outer: 'ParSeqLike', start: int, end: int): ...
        _$colon$bslash__B = typing.TypeVar('_$colon$bslash__B')  # <B>
        def $colon$bslash(self, z: _.colon.bslash__B, op: scala.Function2[_ParSeqLike__T, _.colon.bslash__B, _.colon.bslash__B]) -> _.colon.bslash__B: ...
        _$div$colon__B = typing.TypeVar('_$div$colon__B')  # <B>
        def $div$colon(self, z: _.div.colon__B, op: scala.Function2[_.div.colon__B, _ParSeqLike__T, _.div.colon__B]) -> _.div.colon__B: ...
        _$plus$plus__B = typing.TypeVar('_$plus$plus__B')  # <B>
        def $plus$plus(self, that: scala.Function0[scala.collection.GenTraversableOnce[_.plus.plus__B]]) -> scala.collection.Iterator[_.plus.plus__B]: ...
        def abort(self) -> None: ...
        @typing.overload
        def addString(self, b: scala.collection.mutable.StringBuilder) -> scala.collection.mutable.StringBuilder: ...
        @typing.overload
        def addString(self, b: scala.collection.mutable.StringBuilder, sep: typing.Union[java.lang.String, str]) -> scala.collection.mutable.StringBuilder: ...
        @typing.overload
        def addString(self, b: scala.collection.mutable.StringBuilder, start: typing.Union[java.lang.String, str], sep: typing.Union[java.lang.String, str], end: typing.Union[java.lang.String, str]) -> scala.collection.mutable.StringBuilder: ...
        _aggregate__B = typing.TypeVar('_aggregate__B')  # <B>
        def aggregate(self, z: scala.Function0[_aggregate__B], seqop: scala.Function2[_aggregate__B, _ParSeqLike__T, _aggregate__B], combop: scala.Function2[_aggregate__B, _aggregate__B, _aggregate__B]) -> _aggregate__B: ...
        _appendParIterable__U = typing.TypeVar('_appendParIterable__U')  # <U>
        _appendParIterable__PI = typing.TypeVar('_appendParIterable__PI', bound=IterableSplitter)  # <PI>
        def appendParIterable(self, that: _appendParIterable__PI) -> IterableSplitter.Appended[_appendParIterable__U, _appendParIterable__PI]: ...
        _appendParSeq__U = typing.TypeVar('_appendParSeq__U')  # <U>
        _appendParSeq__PI = typing.TypeVar('_appendParSeq__PI', bound='SeqSplitter')  # <PI>
        def appendParSeq(self, that: _appendParSeq__PI) -> 'SeqSplitter.Appended'[_appendParSeq__U, _appendParSeq__PI]: ...
        def buffered(self) -> scala.collection.BufferedIterator[_ParSeqLike__T]: ...
        def buildString(self, closure: scala.Function1[scala.Function1[typing.Union[java.lang.String, str], scala.runtime.BoxedUnit], scala.runtime.BoxedUnit]) -> java.lang.String: ...
        _collect__B = typing.TypeVar('_collect__B')  # <B>
        def collect(self, pf: scala.PartialFunction[_ParSeqLike__T, _collect__B]) -> scala.collection.Iterator[_collect__B]: ...
        _collect2combiner__S = typing.TypeVar('_collect2combiner__S')  # <S>
        _collect2combiner__That = typing.TypeVar('_collect2combiner__That')  # <That>
        def collect2combiner(self, pf: scala.PartialFunction[_ParSeqLike__T, _collect2combiner__S], cb: Combiner[_collect2combiner__S, _collect2combiner__That]) -> Combiner[_collect2combiner__S, _collect2combiner__That]: ...
        _collectFirst__B = typing.TypeVar('_collectFirst__B')  # <B>
        def collectFirst(self, pf: scala.PartialFunction[_ParSeqLike__T, _collectFirst__B]) -> scala.Option[_collectFirst__B]: ...
        def contains(self, elem: typing.Any) -> bool: ...
        _copy2builder__U = typing.TypeVar('_copy2builder__U')  # <U>
        _copy2builder__Coll = typing.TypeVar('_copy2builder__Coll')  # <Coll>
        _copy2builder__Bld = typing.TypeVar('_copy2builder__Bld', bound=scala.collection.mutable.Builder)  # <Bld>
        def copy2builder(self, b: _copy2builder__Bld) -> _copy2builder__Bld: ...
        _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
        _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
        _copyToArray_2__U = typing.TypeVar('_copyToArray_2__U')  # <U>
        @typing.overload
        def copyToArray(self, xs: typing.Any) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int) -> None: ...
        @typing.overload
        def copyToArray(self, array: typing.Any, from_: int, len: int) -> None: ...
        _copyToBuffer__B = typing.TypeVar('_copyToBuffer__B')  # <B>
        def copyToBuffer(self, dest: scala.collection.mutable.Buffer[_copyToBuffer__B]) -> None: ...
        _corresponds_0__S = typing.TypeVar('_corresponds_0__S')  # <S>
        _corresponds_1__B = typing.TypeVar('_corresponds_1__B')  # <B>
        @typing.overload
        def corresponds(self, corr: scala.Function2[_ParSeqLike__T, _corresponds_0__S, typing.Any], that: scala.collection.Iterator[_corresponds_0__S]) -> bool: ...
        @typing.overload
        def corresponds(self, that: scala.collection.GenTraversableOnce[_corresponds_1__B], p: scala.Function2[_ParSeqLike__T, _corresponds_1__B, typing.Any]) -> bool: ...
        def count(self, p: scala.Function1[_ParSeqLike__T, typing.Any]) -> int: ...
        def debugInformation(self) -> java.lang.String: ...
        def drop(self, n: int) -> IterableSplitter[_ParSeqLike__T]: ...
        _drop2combiner__U = typing.TypeVar('_drop2combiner__U')  # <U>
        _drop2combiner__This = typing.TypeVar('_drop2combiner__This')  # <This>
        def drop2combiner(self, n: int, cb: Combiner[_drop2combiner__U, _drop2combiner__This]) -> Combiner[_drop2combiner__U, _drop2combiner__This]: ...
        def dropWhile(self, p: scala.Function1[_ParSeqLike__T, typing.Any]) -> scala.collection.Iterator[_ParSeqLike__T]: ...
        def dup(self) -> 'ParSeqLike.Elements': ...
        def duplicate(self) -> scala.Tuple2[scala.collection.Iterator[_ParSeqLike__T], scala.collection.Iterator[_ParSeqLike__T]]: ...
        def end(self) -> int: ...
        def exists(self, p: scala.Function1[_ParSeqLike__T, typing.Any]) -> bool: ...
        def filter(self, p: scala.Function1[_ParSeqLike__T, typing.Any]) -> scala.collection.Iterator[_ParSeqLike__T]: ...
        _filter2combiner__U = typing.TypeVar('_filter2combiner__U')  # <U>
        _filter2combiner__This = typing.TypeVar('_filter2combiner__This')  # <This>
        def filter2combiner(self, pred: scala.Function1[_ParSeqLike__T, typing.Any], cb: Combiner[_filter2combiner__U, _filter2combiner__This]) -> Combiner[_filter2combiner__U, _filter2combiner__This]: ...
        def filterNot(self, p: scala.Function1[_ParSeqLike__T, typing.Any]) -> scala.collection.Iterator[_ParSeqLike__T]: ...
        _filterNot2combiner__U = typing.TypeVar('_filterNot2combiner__U')  # <U>
        _filterNot2combiner__This = typing.TypeVar('_filterNot2combiner__This')  # <This>
        def filterNot2combiner(self, pred: scala.Function1[_ParSeqLike__T, typing.Any], cb: Combiner[_filterNot2combiner__U, _filterNot2combiner__This]) -> Combiner[_filterNot2combiner__U, _filterNot2combiner__This]: ...
        def find(self, p: scala.Function1[_ParSeqLike__T, typing.Any]) -> scala.Option[_ParSeqLike__T]: ...
        _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
        def flatMap(self, f: scala.Function1[_ParSeqLike__T, scala.collection.GenTraversableOnce[_flatMap__B]]) -> scala.collection.Iterator[_flatMap__B]: ...
        _flatmap2combiner__S = typing.TypeVar('_flatmap2combiner__S')  # <S>
        _flatmap2combiner__That = typing.TypeVar('_flatmap2combiner__That')  # <That>
        def flatmap2combiner(self, f: scala.Function1[_ParSeqLike__T, scala.collection.GenTraversableOnce[_flatmap2combiner__S]], cb: Combiner[_flatmap2combiner__S, _flatmap2combiner__That]) -> Combiner[_flatmap2combiner__S, _flatmap2combiner__That]: ...
        _fold__U = typing.TypeVar('_fold__U')  # <U>
        def fold(self, z: _fold__U, op: scala.Function2[_fold__U, _fold__U, _fold__U]) -> _fold__U: ...
        _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
        def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, _ParSeqLike__T, _foldLeft__B]) -> _foldLeft__B: ...
        _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
        def foldRight(self, z: _foldRight__B, op: scala.Function2[_ParSeqLike__T, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
        def forall(self, p: scala.Function1[_ParSeqLike__T, typing.Any]) -> bool: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[_ParSeqLike__T, _foreach__U]) -> None: ...
        _grouped__B = typing.TypeVar('_grouped__B')  # <B>
        def grouped(self, size: int) -> scala.collection.Iterator.GroupedIterator[_grouped__B]: ...
        def hasDefiniteSize(self) -> bool: ...
        def hasNext(self) -> bool: ...
        def head(self) -> _ParSeqLike__T: ...
        def headOption(self) -> scala.Option[_ParSeqLike__T]: ...
        def indexFlag(self) -> int: ...
        _indexOf_0__B = typing.TypeVar('_indexOf_0__B')  # <B>
        _indexOf_1__B = typing.TypeVar('_indexOf_1__B')  # <B>
        @typing.overload
        def indexOf(self, elem: _indexOf_0__B) -> int: ...
        @typing.overload
        def indexOf(self, elem: _indexOf_1__B, from_: int) -> int: ...
        @typing.overload
        def indexWhere(self, pred: scala.Function1[_ParSeqLike__T, typing.Any]) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[_ParSeqLike__T, typing.Any], from_: int) -> int: ...
        def isAborted(self) -> bool: ...
        def isEmpty(self) -> bool: ...
        def isRemainingCheap(self) -> bool: ...
        def isTraversableAgain(self) -> bool: ...
        def lastIndexWhere(self, pred: scala.Function1[_ParSeqLike__T, typing.Any]) -> int: ...
        def length(self) -> int: ...
        _map__S = typing.TypeVar('_map__S')  # <S>
        def map(self, f: scala.Function1[_ParSeqLike__T, _map__S]) -> 'SeqSplitter.Mapped'[_map__S]: ...
        _map2combiner__S = typing.TypeVar('_map2combiner__S')  # <S>
        _map2combiner__That = typing.TypeVar('_map2combiner__That')  # <That>
        def map2combiner(self, f: scala.Function1[_ParSeqLike__T, _map2combiner__S], cb: Combiner[_map2combiner__S, _map2combiner__That]) -> Combiner[_map2combiner__S, _map2combiner__That]: ...
        _max__U = typing.TypeVar('_max__U')  # <U>
        def max(self, ord: scala.math.Ordering[_max__U]) -> _ParSeqLike__T: ...
        _maxBy__B = typing.TypeVar('_maxBy__B')  # <B>
        def maxBy(self, f: scala.Function1[_ParSeqLike__T, _maxBy__B], cmp: scala.math.Ordering[_maxBy__B]) -> _ParSeqLike__T: ...
        _min__U = typing.TypeVar('_min__U')  # <U>
        def min(self, ord: scala.math.Ordering[_min__U]) -> _ParSeqLike__T: ...
        _minBy__B = typing.TypeVar('_minBy__B')  # <B>
        def minBy(self, f: scala.Function1[_ParSeqLike__T, _minBy__B], cmp: scala.math.Ordering[_minBy__B]) -> _ParSeqLike__T: ...
        @typing.overload
        def mkString(self) -> java.lang.String: ...
        @typing.overload
        def mkString(self, sep: typing.Union[java.lang.String, str]) -> java.lang.String: ...
        @typing.overload
        def mkString(self, start: typing.Union[java.lang.String, str], sep: typing.Union[java.lang.String, str], end: typing.Union[java.lang.String, str]) -> java.lang.String: ...
        _newSliceInternal__U = typing.TypeVar('_newSliceInternal__U', bound=IterableSplitter.Taken)  # <U>
        def newSliceInternal(self, it: _newSliceInternal__U, from1: int) -> _newSliceInternal__U: ...
        def newTaken(self, until: int) -> 'SeqSplitter.Taken': ...
        def next(self) -> _ParSeqLike__T: ...
        def nonEmpty(self) -> bool: ...
        _padTo__A1 = typing.TypeVar('_padTo__A1')  # <A1>
        def padTo(self, len: int, elem: _padTo__A1) -> scala.collection.Iterator[_padTo__A1]: ...
        def partition(self, p: scala.Function1[_ParSeqLike__T, typing.Any]) -> scala.Tuple2[scala.collection.Iterator[_ParSeqLike__T], scala.collection.Iterator[_ParSeqLike__T]]: ...
        _partition2combiners__U = typing.TypeVar('_partition2combiners__U')  # <U>
        _partition2combiners__This = typing.TypeVar('_partition2combiners__This')  # <This>
        def partition2combiners(self, pred: scala.Function1[_ParSeqLike__T, typing.Any], btrue: Combiner[_partition2combiners__U, _partition2combiners__This], bfalse: Combiner[_partition2combiners__U, _partition2combiners__This]) -> scala.Tuple2[Combiner[_partition2combiners__U, _partition2combiners__This], Combiner[_partition2combiners__U, _partition2combiners__This]]: ...
        _patch__B = typing.TypeVar('_patch__B')  # <B>
        def patch(self, from_: int, patchElems: scala.collection.Iterator[_patch__B], replaced: int) -> scala.collection.Iterator[_patch__B]: ...
        _patchParSeq__U = typing.TypeVar('_patchParSeq__U')  # <U>
        def patchParSeq(self, from_: int, patchElems: 'SeqSplitter'[_patchParSeq__U], replaced: int) -> 'SeqSplitter.Patched'[_patchParSeq__U]: ...
        def prefixLength(self, pred: scala.Function1[_ParSeqLike__T, typing.Any]) -> int: ...
        _product__U = typing.TypeVar('_product__U')  # <U>
        def product(self, num: scala.math.Numeric[_product__U]) -> _product__U: ...
        def psplit(self, sizes: scala.collection.Seq[typing.Any]) -> scala.collection.Seq['SeqSplitter'[_ParSeqLike__T]]: ...
        def psplitWithSignalling(self, sizes: scala.collection.Seq[typing.Any]) -> scala.collection.Seq['SeqSplitter'[_ParSeqLike__T]]: ...
        _reduce__U = typing.TypeVar('_reduce__U')  # <U>
        def reduce(self, op: scala.Function2[_reduce__U, _reduce__U, _reduce__U]) -> _reduce__U: ...
        _reduceLeft_0__U = typing.TypeVar('_reduceLeft_0__U')  # <U>
        _reduceLeft_1__B = typing.TypeVar('_reduceLeft_1__B')  # <B>
        @typing.overload
        def reduceLeft(self, howmany: int, op: scala.Function2[_reduceLeft_0__U, _reduceLeft_0__U, _reduceLeft_0__U]) -> _reduceLeft_0__U: ...
        @typing.overload
        def reduceLeft(self, op: scala.Function2[_reduceLeft_1__B, _ParSeqLike__T, _reduceLeft_1__B]) -> _reduceLeft_1__B: ...
        _reduceLeftOption__B = typing.TypeVar('_reduceLeftOption__B')  # <B>
        def reduceLeftOption(self, op: scala.Function2[_reduceLeftOption__B, _ParSeqLike__T, _reduceLeftOption__B]) -> scala.Option[_reduceLeftOption__B]: ...
        _reduceOption__A1 = typing.TypeVar('_reduceOption__A1')  # <A1>
        def reduceOption(self, op: scala.Function2[_reduceOption__A1, _reduceOption__A1, _reduceOption__A1]) -> scala.Option[_reduceOption__A1]: ...
        _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
        def reduceRight(self, op: scala.Function2[_ParSeqLike__T, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
        _reduceRightOption__B = typing.TypeVar('_reduceRightOption__B')  # <B>
        def reduceRightOption(self, op: scala.Function2[_ParSeqLike__T, _reduceRightOption__B, _reduceRightOption__B]) -> scala.Option[_reduceRightOption__B]: ...
        def remaining(self) -> int: ...
        def reverse(self) -> 'SeqSplitter'[_ParSeqLike__T]: ...
        _reverse2combiner__U = typing.TypeVar('_reverse2combiner__U')  # <U>
        _reverse2combiner__This = typing.TypeVar('_reverse2combiner__This')  # <This>
        def reverse2combiner(self, cb: Combiner[_reverse2combiner__U, _reverse2combiner__This]) -> Combiner[_reverse2combiner__U, _reverse2combiner__This]: ...
        _reverseMap2combiner__S = typing.TypeVar('_reverseMap2combiner__S')  # <S>
        _reverseMap2combiner__That = typing.TypeVar('_reverseMap2combiner__That')  # <That>
        def reverseMap2combiner(self, f: scala.Function1[_ParSeqLike__T, _reverseMap2combiner__S], cb: Combiner[_reverseMap2combiner__S, _reverseMap2combiner__That]) -> Combiner[_reverseMap2combiner__S, _reverseMap2combiner__That]: ...
        def reversed(self) -> scala.collection.immutable.List[_ParSeqLike__T]: ...
        def sameElements(self, that: scala.collection.Iterator[typing.Any]) -> bool: ...
        def scala$collection$parallel$ParSeqLike$Elements$$i(self) -> int: ...
        _scanLeft__B = typing.TypeVar('_scanLeft__B')  # <B>
        def scanLeft(self, z: _scanLeft__B, op: scala.Function2[_scanLeft__B, _ParSeqLike__T, _scanLeft__B]) -> scala.collection.Iterator[_scanLeft__B]: ...
        _scanRight__B = typing.TypeVar('_scanRight__B')  # <B>
        def scanRight(self, z: _scanRight__B, op: scala.Function2[_ParSeqLike__T, _scanRight__B, _scanRight__B]) -> scala.collection.Iterator[_scanRight__B]: ...
        _scanToArray__U = typing.TypeVar('_scanToArray__U')  # <U>
        _scanToArray__A = typing.TypeVar('_scanToArray__A')  # <A>
        def scanToArray(self, z: _scanToArray__U, op: scala.Function2[_scanToArray__U, _scanToArray__U, _scanToArray__U], array: typing.Any, from_: int) -> None: ...
        _scanToCombiner_0__U = typing.TypeVar('_scanToCombiner_0__U')  # <U>
        _scanToCombiner_0__That = typing.TypeVar('_scanToCombiner_0__That')  # <That>
        _scanToCombiner_1__U = typing.TypeVar('_scanToCombiner_1__U')  # <U>
        _scanToCombiner_1__That = typing.TypeVar('_scanToCombiner_1__That')  # <That>
        @typing.overload
        def scanToCombiner(self, howmany: int, startValue: _scanToCombiner_0__U, op: scala.Function2[_scanToCombiner_0__U, _scanToCombiner_0__U, _scanToCombiner_0__U], cb: Combiner[_scanToCombiner_0__U, _scanToCombiner_0__That]) -> Combiner[_scanToCombiner_0__U, _scanToCombiner_0__That]: ...
        @typing.overload
        def scanToCombiner(self, startValue: _scanToCombiner_1__U, op: scala.Function2[_scanToCombiner_1__U, _scanToCombiner_1__U, _scanToCombiner_1__U], cb: Combiner[_scanToCombiner_1__U, _scanToCombiner_1__That]) -> Combiner[_scanToCombiner_1__U, _scanToCombiner_1__That]: ...
        def seq(self) -> scala.collection.Iterator[_ParSeqLike__T]: ...
        def setIndexFlag(self, f: int) -> None: ...
        def setIndexFlagIfGreater(self, f: int) -> None: ...
        def setIndexFlagIfLesser(self, f: int) -> None: ...
        _shouldSplitFurther__S = typing.TypeVar('_shouldSplitFurther__S')  # <S>
        def shouldSplitFurther(self, coll: ParIterable[_shouldSplitFurther__S], parallelismLevel: int) -> bool: ...
        def signalDelegate(self) -> scala.collection.generic.Signalling: ...
        def signalDelegate_$eq(self, x$1: scala.collection.generic.Signalling) -> None: ...
        def size(self) -> int: ...
        def sizeHintIfCheap(self) -> int: ...
        def slice(self, from1: int, until1: int) -> 'SeqSplitter'[_ParSeqLike__T]: ...
        _slice2combiner__U = typing.TypeVar('_slice2combiner__U')  # <U>
        _slice2combiner__This = typing.TypeVar('_slice2combiner__This')  # <This>
        def slice2combiner(self, from_: int, until: int, cb: Combiner[_slice2combiner__U, _slice2combiner__This]) -> Combiner[_slice2combiner__U, _slice2combiner__This]: ...
        def sliceIterator(self, from_: int, until: int) -> scala.collection.Iterator[_ParSeqLike__T]: ...
        _sliding__B = typing.TypeVar('_sliding__B')  # <B>
        def sliding(self, size: int, step: int) -> scala.collection.Iterator.GroupedIterator[_sliding__B]: ...
        _sliding$default$2__B = typing.TypeVar('_sliding$default$2__B')  # <B>
        def sliding$default$2(self) -> int: ...
        def span(self, p: scala.Function1[_ParSeqLike__T, typing.Any]) -> scala.Tuple2[scala.collection.Iterator[_ParSeqLike__T], scala.collection.Iterator[_ParSeqLike__T]]: ...
        _span2combiners__U = typing.TypeVar('_span2combiners__U')  # <U>
        _span2combiners__This = typing.TypeVar('_span2combiners__This')  # <This>
        def span2combiners(self, p: scala.Function1[_ParSeqLike__T, typing.Any], before: Combiner[_span2combiners__U, _span2combiners__This], after: Combiner[_span2combiners__U, _span2combiners__This]) -> scala.Tuple2[Combiner[_span2combiners__U, _span2combiners__This], Combiner[_span2combiners__U, _span2combiners__This]]: ...
        def split(self) -> scala.collection.Seq['SeqSplitter'[_ParSeqLike__T]]: ...
        _splitAt2combiners__U = typing.TypeVar('_splitAt2combiners__U')  # <U>
        _splitAt2combiners__This = typing.TypeVar('_splitAt2combiners__This')  # <This>
        def splitAt2combiners(self, at: int, before: Combiner[_splitAt2combiners__U, _splitAt2combiners__This], after: Combiner[_splitAt2combiners__U, _splitAt2combiners__This]) -> scala.Tuple2[Combiner[_splitAt2combiners__U, _splitAt2combiners__This], Combiner[_splitAt2combiners__U, _splitAt2combiners__This]]: ...
        def splitWithSignalling(self) -> scala.collection.Seq['SeqSplitter'[_ParSeqLike__T]]: ...
        _sum__U = typing.TypeVar('_sum__U')  # <U>
        def sum(self, num: scala.math.Numeric[_sum__U]) -> _sum__U: ...
        def tag(self) -> int: ...
        def take(self, n: int) -> 'SeqSplitter'[_ParSeqLike__T]: ...
        _take2combiner__U = typing.TypeVar('_take2combiner__U')  # <U>
        _take2combiner__This = typing.TypeVar('_take2combiner__This')  # <This>
        def take2combiner(self, n: int, cb: Combiner[_take2combiner__U, _take2combiner__This]) -> Combiner[_take2combiner__U, _take2combiner__This]: ...
        def takeWhile(self, p: scala.Function1[_ParSeqLike__T, typing.Any]) -> scala.collection.Iterator[_ParSeqLike__T]: ...
        _takeWhile2combiner__U = typing.TypeVar('_takeWhile2combiner__U')  # <U>
        _takeWhile2combiner__This = typing.TypeVar('_takeWhile2combiner__This')  # <This>
        def takeWhile2combiner(self, p: scala.Function1[_ParSeqLike__T, typing.Any], cb: Combiner[_takeWhile2combiner__U, _takeWhile2combiner__This]) -> scala.Tuple2[Combiner[_takeWhile2combiner__U, _takeWhile2combiner__This], typing.Any]: ...
        _to__Col = typing.TypeVar('_to__Col')  # <Col>
        def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., _ParSeqLike__T, _to__Col]) -> _to__Col: ...
        _toArray__B = typing.TypeVar('_toArray__B')  # <B>
        def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__B]) -> typing.Any: ...
        _toBuffer__B = typing.TypeVar('_toBuffer__B')  # <B>
        def toBuffer(self) -> scala.collection.mutable.Buffer[_toBuffer__B]: ...
        def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq[_ParSeqLike__T]: ...
        def toIterable(self) -> scala.collection.Iterable[_ParSeqLike__T]: ...
        def toIterator(self) -> scala.collection.Iterator[_ParSeqLike__T]: ...
        def toList(self) -> scala.collection.immutable.List[_ParSeqLike__T]: ...
        _toMap__T = typing.TypeVar('_toMap__T')  # <T>
        _toMap__U = typing.TypeVar('_toMap__U')  # <U>
        def toMap(self, ev: scala.Predef..less.colon.less[typing.Any, scala.Tuple2[typing.Any, _toMap__U]]) -> scala.collection.immutable.Map[typing.Any, _toMap__U]: ...
        def toSeq(self) -> scala.collection.Seq[_ParSeqLike__T]: ...
        _toSet__B = typing.TypeVar('_toSet__B')  # <B>
        def toSet(self) -> scala.collection.immutable.Set[_toSet__B]: ...
        def toStream(self) -> scala.collection.immutable.Stream[_ParSeqLike__T]: ...
        def toString(self) -> java.lang.String: ...
        def toTraversable(self) -> scala.collection.Traversable[_ParSeqLike__T]: ...
        def toVector(self) -> scala.collection.immutable.Vector[_ParSeqLike__T]: ...
        _updated2combiner__U = typing.TypeVar('_updated2combiner__U')  # <U>
        _updated2combiner__That = typing.TypeVar('_updated2combiner__That')  # <That>
        def updated2combiner(self, index: int, elem: _updated2combiner__U, cb: Combiner[_updated2combiner__U, _updated2combiner__That]) -> Combiner[_updated2combiner__U, _updated2combiner__That]: ...
        def withFilter(self, p: scala.Function1[_ParSeqLike__T, typing.Any]) -> scala.collection.Iterator[_ParSeqLike__T]: ...
        _zip__B = typing.TypeVar('_zip__B')  # <B>
        def zip(self, that: scala.collection.Iterator[_zip__B]) -> scala.collection.Iterator[scala.Tuple2[_ParSeqLike__T, _zip__B]]: ...
        _zip2combiner__U = typing.TypeVar('_zip2combiner__U')  # <U>
        _zip2combiner__S = typing.TypeVar('_zip2combiner__S')  # <S>
        _zip2combiner__That = typing.TypeVar('_zip2combiner__That')  # <That>
        def zip2combiner(self, otherpit: RemainsIterator[_zip2combiner__S], cb: Combiner[scala.Tuple2[_zip2combiner__U, _zip2combiner__S], _zip2combiner__That]) -> Combiner[scala.Tuple2[_zip2combiner__U, _zip2combiner__S], _zip2combiner__That]: ...
        _zipAll__B = typing.TypeVar('_zipAll__B')  # <B>
        _zipAll__A1 = typing.TypeVar('_zipAll__A1')  # <A1>
        _zipAll__B1 = typing.TypeVar('_zipAll__B1')  # <B1>
        def zipAll(self, that: scala.collection.Iterator[_zipAll__B], thisElem: _zipAll__A1, thatElem: _zipAll__B1) -> scala.collection.Iterator[scala.Tuple2[_zipAll__A1, _zipAll__B1]]: ...
        _zipAll2combiner__U = typing.TypeVar('_zipAll2combiner__U')  # <U>
        _zipAll2combiner__S = typing.TypeVar('_zipAll2combiner__S')  # <S>
        _zipAll2combiner__That = typing.TypeVar('_zipAll2combiner__That')  # <That>
        def zipAll2combiner(self, that: RemainsIterator[_zipAll2combiner__S], thiselem: _zipAll2combiner__U, thatelem: _zipAll2combiner__S, cb: Combiner[scala.Tuple2[_zipAll2combiner__U, _zipAll2combiner__S], _zipAll2combiner__That]) -> Combiner[scala.Tuple2[_zipAll2combiner__U, _zipAll2combiner__S], _zipAll2combiner__That]: ...
        _zipAllParSeq__S = typing.TypeVar('_zipAllParSeq__S')  # <S>
        _zipAllParSeq__U = typing.TypeVar('_zipAllParSeq__U')  # <U>
        _zipAllParSeq__R = typing.TypeVar('_zipAllParSeq__R')  # <R>
        def zipAllParSeq(self, that: 'SeqSplitter'[_zipAllParSeq__S], thisElem: _zipAllParSeq__U, thatElem: _zipAllParSeq__R) -> 'SeqSplitter.ZippedAll'[_zipAllParSeq__U, _zipAllParSeq__R]: ...
        _zipParSeq__S = typing.TypeVar('_zipParSeq__S')  # <S>
        def zipParSeq(self, that: 'SeqSplitter'[_zipParSeq__S]) -> 'SeqSplitter.Zipped'[_zipParSeq__S]: ...
        def zipWithIndex(self) -> scala.collection.Iterator[scala.Tuple2[_ParSeqLike__T, typing.Any]]: ...
    class IndexWhere(scala.collection.parallel.ParSeqLike.Accessor[typing.Any, 'ParSeqLike.IndexWhere']):
        $outer: 'ParSeqLike' = ...
        def __init__(self, $outer: 'ParSeqLike', pred: scala.Function1[_ParSeqLike__T, typing.Any], from_: int, pit: 'SeqSplitter'[_ParSeqLike__T]): ...
        def forwardThrowable(self) -> None: ...
        def leaf(self, prev: scala.Option[typing.Any]) -> None: ...
        def merge(self, that: 'ParSeqLike.IndexWhere') -> None: ...
        def mergeThrowables(self, that: Task[typing.Any, typing.Any]) -> None: ...
        def newSubtask(self, p: IterableSplitter[_ParSeqLike__T]) -> scala.runtime.Nothing.: ...
        def pit(self) -> 'SeqSplitter'[_ParSeqLike__T]: ...
        def repr(self) -> typing.Any: ...
        def requiresStrictSplitters(self) -> bool: ...
        def result(self) -> int: ...
        def result_$eq(self, x$1: int) -> None: ...
        def shouldSplitFurther(self) -> bool: ...
        def signalAbort(self) -> None: ...
        def split(self) -> scala.collection.Seq[Task[typing.Any, 'ParSeqLike.IndexWhere']]: ...
        def throwable(self) -> java.lang.Throwable: ...
        def throwable_$eq(self, x$1: java.lang.Throwable) -> None: ...
        def toString(self) -> java.lang.String: ...
        def tryLeaf(self, lastres: scala.Option[typing.Any]) -> None: ...
        def tryMerge(self, t: typing.Any) -> None: ...
    class LastIndexWhere(scala.collection.parallel.ParSeqLike.Accessor[typing.Any, 'ParSeqLike.LastIndexWhere']):
        $outer: 'ParSeqLike' = ...
        def __init__(self, $outer: 'ParSeqLike', pred: scala.Function1[_ParSeqLike__T, typing.Any], pos: int, pit: 'SeqSplitter'[_ParSeqLike__T]): ...
        def forwardThrowable(self) -> None: ...
        def leaf(self, prev: scala.Option[typing.Any]) -> None: ...
        def merge(self, that: 'ParSeqLike.LastIndexWhere') -> None: ...
        def mergeThrowables(self, that: Task[typing.Any, typing.Any]) -> None: ...
        def newSubtask(self, p: IterableSplitter[_ParSeqLike__T]) -> scala.runtime.Nothing.: ...
        def pit(self) -> 'SeqSplitter'[_ParSeqLike__T]: ...
        def repr(self) -> typing.Any: ...
        def requiresStrictSplitters(self) -> bool: ...
        def result(self) -> int: ...
        def result_$eq(self, x$1: int) -> None: ...
        def shouldSplitFurther(self) -> bool: ...
        def signalAbort(self) -> None: ...
        def split(self) -> scala.collection.Seq[Task[typing.Any, 'ParSeqLike.LastIndexWhere']]: ...
        def throwable(self) -> java.lang.Throwable: ...
        def throwable_$eq(self, x$1: java.lang.Throwable) -> None: ...
        def toString(self) -> java.lang.String: ...
        def tryLeaf(self, lastres: scala.Option[typing.Any]) -> None: ...
        def tryMerge(self, t: typing.Any) -> None: ...
    class Reverse(scala.collection.parallel.ParSeqLike.Transformer[Combiner[_ParSeqLike__Reverse__U, _ParSeqLike__Reverse__This], 'ParSeqLike.Reverse'[_ParSeqLike__Reverse__U, _ParSeqLike__Reverse__This]], typing.Generic[_ParSeqLike__Reverse__U, _ParSeqLike__Reverse__This]):
        $outer: 'ParSeqLike' = ...
        def __init__(self, $outer: 'ParSeqLike', cbf: scala.Function0[Combiner[_ParSeqLike__Reverse__U, _ParSeqLike__Reverse__This]], pit: 'SeqSplitter'[_ParSeqLike__T]): ...
        def forwardThrowable(self) -> None: ...
        def leaf(self, prev: scala.Option[Combiner[_ParSeqLike__Reverse__U, _ParSeqLike__Reverse__This]]) -> None: ...
        def merge(self, that: 'ParSeqLike.Reverse'[_ParSeqLike__Reverse__U, _ParSeqLike__Reverse__This]) -> None: ...
        def mergeThrowables(self, that: Task[typing.Any, typing.Any]) -> None: ...
        def newSubtask(self, p: IterableSplitter[_ParSeqLike__T]) -> 'ParSeqLike.Reverse'[_ParSeqLike__Reverse__U, _ParSeqLike__Reverse__This]: ...
        def pit(self) -> 'SeqSplitter'[_ParSeqLike__T]: ...
        def repr(self) -> typing.Any: ...
        def requiresStrictSplitters(self) -> bool: ...
        def result(self) -> Combiner[_ParSeqLike__Reverse__U, _ParSeqLike__Reverse__This]: ...
        def result_$eq(self, x$1: Combiner[_ParSeqLike__Reverse__U, _ParSeqLike__Reverse__This]) -> None: ...
        def shouldSplitFurther(self) -> bool: ...
        def signalAbort(self) -> None: ...
        def split(self) -> scala.collection.Seq[Task[Combiner[_ParSeqLike__Reverse__U, _ParSeqLike__Reverse__This], 'ParSeqLike.Reverse'[_ParSeqLike__Reverse__U, _ParSeqLike__Reverse__This]]]: ...
        def throwable(self) -> java.lang.Throwable: ...
        def throwable_$eq(self, x$1: java.lang.Throwable) -> None: ...
        def toString(self) -> java.lang.String: ...
        def tryLeaf(self, lastres: scala.Option[Combiner[_ParSeqLike__Reverse__U, _ParSeqLike__Reverse__This]]) -> None: ...
        def tryMerge(self, t: typing.Any) -> None: ...
    class ReverseMap(scala.collection.parallel.ParSeqLike.Transformer[Combiner[_ParSeqLike__ReverseMap__S, _ParSeqLike__ReverseMap__That], 'ParSeqLike.ReverseMap'[_ParSeqLike__ReverseMap__S, _ParSeqLike__ReverseMap__That]], typing.Generic[_ParSeqLike__ReverseMap__S, _ParSeqLike__ReverseMap__That]):
        $outer: 'ParSeqLike' = ...
        def __init__(self, $outer: 'ParSeqLike', f: scala.Function1[_ParSeqLike__T, _ParSeqLike__ReverseMap__S], pbf: scala.Function0[Combiner[_ParSeqLike__ReverseMap__S, _ParSeqLike__ReverseMap__That]], pit: 'SeqSplitter'[_ParSeqLike__T]): ...
        def forwardThrowable(self) -> None: ...
        def leaf(self, prev: scala.Option[Combiner[_ParSeqLike__ReverseMap__S, _ParSeqLike__ReverseMap__That]]) -> None: ...
        def merge(self, that: 'ParSeqLike.ReverseMap'[_ParSeqLike__ReverseMap__S, _ParSeqLike__ReverseMap__That]) -> None: ...
        def mergeThrowables(self, that: Task[typing.Any, typing.Any]) -> None: ...
        def newSubtask(self, p: IterableSplitter[_ParSeqLike__T]) -> 'ParSeqLike.ReverseMap'[_ParSeqLike__ReverseMap__S, _ParSeqLike__ReverseMap__That]: ...
        def pit(self) -> 'SeqSplitter'[_ParSeqLike__T]: ...
        def repr(self) -> typing.Any: ...
        def requiresStrictSplitters(self) -> bool: ...
        def result(self) -> Combiner[_ParSeqLike__ReverseMap__S, _ParSeqLike__ReverseMap__That]: ...
        def result_$eq(self, x$1: Combiner[_ParSeqLike__ReverseMap__S, _ParSeqLike__ReverseMap__That]) -> None: ...
        def shouldSplitFurther(self) -> bool: ...
        def signalAbort(self) -> None: ...
        def split(self) -> scala.collection.Seq[Task[Combiner[_ParSeqLike__ReverseMap__S, _ParSeqLike__ReverseMap__That], 'ParSeqLike.ReverseMap'[_ParSeqLike__ReverseMap__S, _ParSeqLike__ReverseMap__That]]]: ...
        def throwable(self) -> java.lang.Throwable: ...
        def throwable_$eq(self, x$1: java.lang.Throwable) -> None: ...
        def toString(self) -> java.lang.String: ...
        def tryLeaf(self, lastres: scala.Option[Combiner[_ParSeqLike__ReverseMap__S, _ParSeqLike__ReverseMap__That]]) -> None: ...
        def tryMerge(self, t: typing.Any) -> None: ...
    class SameElements(scala.collection.parallel.ParSeqLike.Accessor[typing.Any, 'ParSeqLike.SameElements'[_ParSeqLike__SameElements__U]], typing.Generic[_ParSeqLike__SameElements__U]):
        $outer: 'ParSeqLike' = ...
        def __init__(self, $outer: 'ParSeqLike', pit: 'SeqSplitter'[_ParSeqLike__T], otherpit: 'SeqSplitter'[_ParSeqLike__SameElements__U]): ...
        def forwardThrowable(self) -> None: ...
        def leaf(self, prev: scala.Option[typing.Any]) -> None: ...
        def merge(self, that: 'ParSeqLike.SameElements'[_ParSeqLike__SameElements__U]) -> None: ...
        def mergeThrowables(self, that: Task[typing.Any, typing.Any]) -> None: ...
        def newSubtask(self, p: IterableSplitter[_ParSeqLike__T]) -> scala.runtime.Nothing.: ...
        def otherpit(self) -> 'SeqSplitter'[_ParSeqLike__SameElements__U]: ...
        def pit(self) -> 'SeqSplitter'[_ParSeqLike__T]: ...
        def repr(self) -> typing.Any: ...
        def requiresStrictSplitters(self) -> bool: ...
        def result(self) -> bool: ...
        def result_$eq(self, x$1: bool) -> None: ...
        def shouldSplitFurther(self) -> bool: ...
        def signalAbort(self) -> None: ...
        def split(self) -> scala.collection.Seq[Task[typing.Any, 'ParSeqLike.SameElements'[_ParSeqLike__SameElements__U]]]: ...
        def throwable(self) -> java.lang.Throwable: ...
        def throwable_$eq(self, x$1: java.lang.Throwable) -> None: ...
        def toString(self) -> java.lang.String: ...
        def tryLeaf(self, lastres: scala.Option[typing.Any]) -> None: ...
        def tryMerge(self, t: typing.Any) -> None: ...
    class SegmentLength(scala.collection.parallel.ParSeqLike.Accessor[scala.Tuple2[typing.Any, typing.Any], 'ParSeqLike.SegmentLength']):
        $outer: 'ParSeqLike' = ...
        def __init__(self, $outer: 'ParSeqLike', pred: scala.Function1[_ParSeqLike__T, typing.Any], from_: int, pit: 'SeqSplitter'[_ParSeqLike__T]): ...
        def forwardThrowable(self) -> None: ...
        def leaf(self, prev: scala.Option[scala.Tuple2[typing.Any, typing.Any]]) -> None: ...
        def merge(self, that: 'ParSeqLike.SegmentLength') -> None: ...
        def mergeThrowables(self, that: Task[typing.Any, typing.Any]) -> None: ...
        def newSubtask(self, p: IterableSplitter[_ParSeqLike__T]) -> scala.runtime.Nothing.: ...
        def pit(self) -> 'SeqSplitter'[_ParSeqLike__T]: ...
        def repr(self) -> typing.Any: ...
        def requiresStrictSplitters(self) -> bool: ...
        def result(self) -> scala.Tuple2[typing.Any, typing.Any]: ...
        def result_$eq(self, x$1: scala.Tuple2[typing.Any, typing.Any]) -> None: ...
        def shouldSplitFurther(self) -> bool: ...
        def signalAbort(self) -> None: ...
        def split(self) -> scala.collection.Seq[Task[scala.Tuple2[typing.Any, typing.Any], 'ParSeqLike.SegmentLength']]: ...
        def throwable(self) -> java.lang.Throwable: ...
        def throwable_$eq(self, x$1: java.lang.Throwable) -> None: ...
        def toString(self) -> java.lang.String: ...
        def tryLeaf(self, lastres: scala.Option[scala.Tuple2[typing.Any, typing.Any]]) -> None: ...
        def tryMerge(self, t: typing.Any) -> None: ...
    class Transformer(scala.collection.parallel.ParSeqLike.Accessor[_ParSeqLike__Transformer__R, _ParSeqLike__Transformer__Tp], scala.collection.parallel.ParIterableLike.Transformer[_ParSeqLike__Transformer__R, _ParSeqLike__Transformer__Tp], typing.Generic[_ParSeqLike__Transformer__R, _ParSeqLike__Transformer__Tp]):
        def toString(self) -> java.lang.String: ...
    class Updated(scala.collection.parallel.ParSeqLike.Transformer[Combiner[_ParSeqLike__Updated__U, _ParSeqLike__Updated__That], 'ParSeqLike.Updated'[_ParSeqLike__Updated__U, _ParSeqLike__Updated__That]], typing.Generic[_ParSeqLike__Updated__U, _ParSeqLike__Updated__That]):
        $outer: 'ParSeqLike' = ...
        def __init__(self, $outer: 'ParSeqLike', pos: int, elem: _ParSeqLike__Updated__U, pbf: CombinerFactory[_ParSeqLike__Updated__U, _ParSeqLike__Updated__That], pit: 'SeqSplitter'[_ParSeqLike__T]): ...
        def forwardThrowable(self) -> None: ...
        def leaf(self, prev: scala.Option[Combiner[_ParSeqLike__Updated__U, _ParSeqLike__Updated__That]]) -> None: ...
        def merge(self, that: 'ParSeqLike.Updated'[_ParSeqLike__Updated__U, _ParSeqLike__Updated__That]) -> None: ...
        def mergeThrowables(self, that: Task[typing.Any, typing.Any]) -> None: ...
        def newSubtask(self, p: IterableSplitter[_ParSeqLike__T]) -> scala.runtime.Nothing.: ...
        def pit(self) -> 'SeqSplitter'[_ParSeqLike__T]: ...
        def repr(self) -> typing.Any: ...
        def requiresStrictSplitters(self) -> bool: ...
        def result(self) -> Combiner[_ParSeqLike__Updated__U, _ParSeqLike__Updated__That]: ...
        def result_$eq(self, x$1: Combiner[_ParSeqLike__Updated__U, _ParSeqLike__Updated__That]) -> None: ...
        def shouldSplitFurther(self) -> bool: ...
        def signalAbort(self) -> None: ...
        def split(self) -> scala.collection.Seq[Task[Combiner[_ParSeqLike__Updated__U, _ParSeqLike__Updated__That], 'ParSeqLike.Updated'[_ParSeqLike__Updated__U, _ParSeqLike__Updated__That]]]: ...
        def throwable(self) -> java.lang.Throwable: ...
        def throwable_$eq(self, x$1: java.lang.Throwable) -> None: ...
        def toString(self) -> java.lang.String: ...
        def tryLeaf(self, lastres: scala.Option[Combiner[_ParSeqLike__Updated__U, _ParSeqLike__Updated__That]]) -> None: ...
        def tryMerge(self, t: typing.Any) -> None: ...
    class Zip(scala.collection.parallel.ParSeqLike.Transformer[Combiner[scala.Tuple2[_ParSeqLike__Zip__U, _ParSeqLike__Zip__S], _ParSeqLike__Zip__That], 'ParSeqLike.Zip'[_ParSeqLike__Zip__U, _ParSeqLike__Zip__S, _ParSeqLike__Zip__That]], typing.Generic[_ParSeqLike__Zip__U, _ParSeqLike__Zip__S, _ParSeqLike__Zip__That]):
        $outer: 'ParSeqLike' = ...
        def __init__(self, $outer: 'ParSeqLike', len: int, cf: CombinerFactory[scala.Tuple2[_ParSeqLike__Zip__U, _ParSeqLike__Zip__S], _ParSeqLike__Zip__That], pit: 'SeqSplitter'[_ParSeqLike__T], otherpit: 'SeqSplitter'[_ParSeqLike__Zip__S]): ...
        def forwardThrowable(self) -> None: ...
        def leaf(self, prev: scala.Option[Combiner[scala.Tuple2[_ParSeqLike__Zip__U, _ParSeqLike__Zip__S], _ParSeqLike__Zip__That]]) -> None: ...
        def merge(self, that: 'ParSeqLike.Zip'[_ParSeqLike__Zip__U, _ParSeqLike__Zip__S, _ParSeqLike__Zip__That]) -> None: ...
        def mergeThrowables(self, that: Task[typing.Any, typing.Any]) -> None: ...
        def newSubtask(self, p: IterableSplitter[_ParSeqLike__T]) -> scala.runtime.Nothing.: ...
        def otherpit(self) -> 'SeqSplitter'[_ParSeqLike__Zip__S]: ...
        def pit(self) -> 'SeqSplitter'[_ParSeqLike__T]: ...
        def repr(self) -> typing.Any: ...
        def requiresStrictSplitters(self) -> bool: ...
        def result(self) -> Combiner[scala.Tuple2[_ParSeqLike__Zip__U, _ParSeqLike__Zip__S], _ParSeqLike__Zip__That]: ...
        def result_$eq(self, x$1: Combiner[scala.Tuple2[_ParSeqLike__Zip__U, _ParSeqLike__Zip__S], _ParSeqLike__Zip__That]) -> None: ...
        def shouldSplitFurther(self) -> bool: ...
        def signalAbort(self) -> None: ...
        def split(self) -> scala.collection.Seq['ParSeqLike.Zip'[_ParSeqLike__Zip__U, _ParSeqLike__Zip__S, _ParSeqLike__Zip__That]]: ...
        def throwable(self) -> java.lang.Throwable: ...
        def throwable_$eq(self, x$1: java.lang.Throwable) -> None: ...
        def toString(self) -> java.lang.String: ...
        def tryLeaf(self, lastres: scala.Option[Combiner[scala.Tuple2[_ParSeqLike__Zip__U, _ParSeqLike__Zip__S], _ParSeqLike__Zip__That]]) -> None: ...
        def tryMerge(self, t: typing.Any) -> None: ...

_ParSet__T = typing.TypeVar('_ParSet__T')  # <T>
class ParSet(scala.collection.GenSet[_ParSet__T], ParIterable[_ParSet__T], scala.collection.parallel.ParSetLike[_ParSet__T, 'ParSet'[_ParSet__T], scala.collection.Set[_ParSet__T]], typing.Generic[_ParSet__T]):
    @staticmethod
    def $init$($this: 'ParSet') -> None: ...
    _canBuildFrom__T = typing.TypeVar('_canBuildFrom__T')  # <T>
    @staticmethod
    def canBuildFrom() -> scala.collection.generic.CanCombineFrom['ParSet'[typing.Any], _canBuildFrom__T, 'ParSet'[_canBuildFrom__T]]: ...
    def companion(self) -> scala.collection.generic.GenericCompanion['ParSet']: ...
    @typing.overload
    def empty(self) -> scala.collection.GenSet: ...
    @typing.overload
    def empty(self) -> 'ParSet'[_ParSet__T]: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    _setCanBuildFrom__A = typing.TypeVar('_setCanBuildFrom__A')  # <A>
    @staticmethod
    def setCanBuildFrom() -> scala.collection.generic.CanBuildFrom['ParSet'[typing.Any], _setCanBuildFrom__A, 'ParSet'[_setCanBuildFrom__A]]: ...
    def stringPrefix(self) -> java.lang.String: ...
    @typing.overload
    def toString(self) -> java.lang.String: ...
    @typing.overload
    def toString(self) -> java.lang.String: ...

_ParSetLike__T = typing.TypeVar('_ParSetLike__T')  # <T>
_ParSetLike__Repr = typing.TypeVar('_ParSetLike__Repr', bound='ParSetLike')  # <Repr>
_ParSetLike__Sequential = typing.TypeVar('_ParSetLike__Sequential', bound=scala.collection.Set)  # <Sequential>
class ParSetLike(scala.collection.GenSetLike[_ParSetLike__T, _ParSetLike__Repr], scala.collection.parallel.ParIterableLike[_ParSetLike__T, _ParSetLike__Repr, _ParSetLike__Sequential], typing.Generic[_ParSetLike__T, _ParSetLike__Repr, _ParSetLike__Sequential]):
    @staticmethod
    def $init$($this: 'ParSetLike') -> None: ...
    @typing.overload
    def diff(self, that: scala.collection.GenSet[typing.Any]) -> _ParSetLike__Repr: ...
    @typing.overload
    def diff(self, that: scala.collection.GenSet[_ParSetLike__T]) -> _ParSetLike__Repr: ...
    def empty(self) -> _ParSetLike__Repr: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def toString(self) -> java.lang.String: ...
    @typing.overload
    def toString(self) -> java.lang.String: ...
    @typing.overload
    def union(self, that: scala.collection.GenSet[typing.Any]) -> _ParSetLike__Repr: ...
    @typing.overload
    def union(self, that: scala.collection.GenSet[_ParSetLike__T]) -> _ParSetLike__Repr: ...

_SeqSplitter__Appended__U = typing.TypeVar('_SeqSplitter__Appended__U')  # <U>
_SeqSplitter__Appended__PI = typing.TypeVar('_SeqSplitter__Appended__PI', bound='SeqSplitter')  # <PI>
_SeqSplitter__Mapped__S = typing.TypeVar('_SeqSplitter__Mapped__S')  # <S>
_SeqSplitter__Patched__U = typing.TypeVar('_SeqSplitter__Patched__U')  # <U>
_SeqSplitter__Zipped__S = typing.TypeVar('_SeqSplitter__Zipped__S')  # <S>
_SeqSplitter__ZippedAll__U = typing.TypeVar('_SeqSplitter__ZippedAll__U')  # <U>
_SeqSplitter__ZippedAll__S = typing.TypeVar('_SeqSplitter__ZippedAll__S')  # <S>
_SeqSplitter__T = typing.TypeVar('_SeqSplitter__T')  # <T>
class SeqSplitter(IterableSplitter[_SeqSplitter__T], AugmentedSeqIterator[_SeqSplitter__T], PreciseSplitter[_SeqSplitter__T], typing.Generic[_SeqSplitter__T]):
    @staticmethod
    def $init$($this: 'SeqSplitter') -> None: ...
    _appendParSeq__U = typing.TypeVar('_appendParSeq__U')  # <U>
    _appendParSeq__PI = typing.TypeVar('_appendParSeq__PI', bound='SeqSplitter')  # <PI>
    def appendParSeq(self, that: _appendParSeq__PI) -> 'SeqSplitter.Appended'[_appendParSeq__U, _appendParSeq__PI]: ...
    @typing.overload
    def dup(self) -> IterableSplitter[_SeqSplitter__T]: ...
    @typing.overload
    def dup(self) -> 'SeqSplitter'[_SeqSplitter__T]: ...
    _map_0__B = typing.TypeVar('_map_0__B')  # <B>
    _map_1__S = typing.TypeVar('_map_1__S')  # <S>
    _map_2__S = typing.TypeVar('_map_2__S')  # <S>
    @typing.overload
    def map(self, f: scala.Function1[typing.Any, _map_0__B]) -> scala.collection.Iterator[_map_0__B]: ...
    @typing.overload
    def map(self, f: scala.Function1[_SeqSplitter__T, _map_1__S]) -> IterableSplitter.Mapped[_map_1__S]: ...
    @typing.overload
    def map(self, f: scala.Function1[_SeqSplitter__T, _map_2__S]) -> 'SeqSplitter.Mapped'[_map_2__S]: ...
    @typing.overload
    def newTaken(self, until: int) -> IterableSplitter.Taken: ...
    @typing.overload
    def newTaken(self, until: int) -> 'SeqSplitter.Taken': ...
    _patchParSeq__U = typing.TypeVar('_patchParSeq__U')  # <U>
    def patchParSeq(self, from_: int, patchElems: 'SeqSplitter'[_patchParSeq__U], replaced: int) -> 'SeqSplitter.Patched'[_patchParSeq__U]: ...
    def psplit(self, sizes: scala.collection.Seq[typing.Any]) -> scala.collection.Seq['SeqSplitter'[_SeqSplitter__T]]: ...
    def psplitWithSignalling(self, sizes: scala.collection.Seq[typing.Any]) -> scala.collection.Seq['SeqSplitter'[_SeqSplitter__T]]: ...
    def remaining(self) -> int: ...
    def reverse(self) -> 'SeqSplitter'[_SeqSplitter__T]: ...
    @typing.overload
    def slice(self, from_: int, until: int) -> scala.collection.Iterator[typing.Any]: ...
    @typing.overload
    def slice(self, from1: int, until1: int) -> IterableSplitter[_SeqSplitter__T]: ...
    @typing.overload
    def slice(self, from1: int, until1: int) -> 'SeqSplitter'[_SeqSplitter__T]: ...
    def split(self) -> scala.collection.Seq['SeqSplitter'[_SeqSplitter__T]]: ...
    def splitWithSignalling(self) -> scala.collection.Seq['SeqSplitter'[_SeqSplitter__T]]: ...
    @typing.overload
    def take(self, n: int) -> scala.collection.Iterator[typing.Any]: ...
    @typing.overload
    def take(self, n: int) -> IterableSplitter[_SeqSplitter__T]: ...
    @typing.overload
    def take(self, n: int) -> 'SeqSplitter'[_SeqSplitter__T]: ...
    def toString(self) -> java.lang.String: ...
    _zipAllParSeq_0__S = typing.TypeVar('_zipAllParSeq_0__S')  # <S>
    _zipAllParSeq_0__U = typing.TypeVar('_zipAllParSeq_0__U')  # <U>
    _zipAllParSeq_0__R = typing.TypeVar('_zipAllParSeq_0__R')  # <R>
    _zipAllParSeq_1__S = typing.TypeVar('_zipAllParSeq_1__S')  # <S>
    _zipAllParSeq_1__U = typing.TypeVar('_zipAllParSeq_1__U')  # <U>
    _zipAllParSeq_1__R = typing.TypeVar('_zipAllParSeq_1__R')  # <R>
    @typing.overload
    def zipAllParSeq(self, that: 'SeqSplitter'[_zipAllParSeq_0__S], thisElem: _zipAllParSeq_0__U, thatElem: _zipAllParSeq_0__R) -> IterableSplitter.ZippedAll[_zipAllParSeq_0__U, _zipAllParSeq_0__R]: ...
    @typing.overload
    def zipAllParSeq(self, that: 'SeqSplitter'[_zipAllParSeq_1__S], thisElem: _zipAllParSeq_1__U, thatElem: _zipAllParSeq_1__R) -> 'SeqSplitter.ZippedAll'[_zipAllParSeq_1__U, _zipAllParSeq_1__R]: ...
    _zipParSeq_0__S = typing.TypeVar('_zipParSeq_0__S')  # <S>
    _zipParSeq_1__S = typing.TypeVar('_zipParSeq_1__S')  # <S>
    @typing.overload
    def zipParSeq(self, that: 'SeqSplitter'[_zipParSeq_0__S]) -> IterableSplitter.Zipped[_zipParSeq_0__S]: ...
    @typing.overload
    def zipParSeq(self, that: 'SeqSplitter'[_zipParSeq_1__S]) -> 'SeqSplitter.Zipped'[_zipParSeq_1__S]: ...
    class Appended(IterableSplitter.Appended[_SeqSplitter__Appended__U, _SeqSplitter__Appended__PI], scala.collection.parallel.SeqSplitter[_SeqSplitter__Appended__U], typing.Generic[_SeqSplitter__Appended__U, _SeqSplitter__Appended__PI]):
        def __init__(self, $outer: 'SeqSplitter', it: _SeqSplitter__Appended__PI): ...
        _appendParSeq__U = typing.TypeVar('_appendParSeq__U')  # <U>
        _appendParSeq__PI = typing.TypeVar('_appendParSeq__PI', bound='SeqSplitter')  # <PI>
        def appendParSeq(self, that: 'SeqSplitter') -> 'SeqSplitter.Appended'[typing.Any, 'SeqSplitter']: ...
        _corresponds_0__B = typing.TypeVar('_corresponds_0__B')  # <B>
        _corresponds_1__S = typing.TypeVar('_corresponds_1__S')  # <S>
        @typing.overload
        def corresponds(self, that: scala.collection.GenTraversableOnce[_corresponds_0__B], p: scala.Function2[_SeqSplitter__Appended__U, _corresponds_0__B, typing.Any]) -> bool: ...
        @typing.overload
        def corresponds(self, corr: scala.Function2[_SeqSplitter__Appended__U, _corresponds_1__S, typing.Any], that: scala.collection.Iterator[_corresponds_1__S]) -> bool: ...
        def dup(self) -> 'SeqSplitter'[_SeqSplitter__Appended__U]: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[_SeqSplitter__Appended__U, typing.Any], from_: int) -> int: ...
        @typing.overload
        def indexWhere(self, pred: scala.Function1[_SeqSplitter__Appended__U, typing.Any]) -> int: ...
        def lastIndexWhere(self, pred: scala.Function1[_SeqSplitter__Appended__U, typing.Any]) -> int: ...
        _map__S = typing.TypeVar('_map__S')  # <S>
        def map(self, f: scala.Function1[_SeqSplitter__Appended__U, _map__S]) -> 'SeqSplitter.Mapped'[_map__S]: ...
        def newTaken(self, until: int) -> 'SeqSplitter.Taken': ...
        _patchParSeq__U = typing.TypeVar('_patchParSeq__U')  # <U>
        def patchParSeq(self, from_: int, patchElems: 'SeqSplitter'[typing.Any], replaced: int) -> 'SeqSplitter.Patched'[typing.Any]: ...
        def prefixLength(self, pred: scala.Function1[_SeqSplitter__Appended__U, typing.Any]) -> int: ...
        def psplit(self, sizes: scala.collection.Seq[typing.Any]) -> scala.collection.Seq['SeqSplitter'[_SeqSplitter__Appended__U]]: ...
        def psplitWithSignalling(self, sizes: scala.collection.Seq[typing.Any]) -> scala.collection.Seq['SeqSplitter'[_SeqSplitter__Appended__U]]: ...
        def reverse(self) -> 'SeqSplitter'[_SeqSplitter__Appended__U]: ...
        _reverse2combiner__U = typing.TypeVar('_reverse2combiner__U')  # <U>
        _reverse2combiner__This = typing.TypeVar('_reverse2combiner__This')  # <This>
        def reverse2combiner(self, cb: Combiner[typing.Any, _reverse2combiner__This]) -> Combiner[typing.Any, _reverse2combiner__This]: ...
        _reverseMap2combiner__S = typing.TypeVar('_reverseMap2combiner__S')  # <S>
        _reverseMap2combiner__That = typing.TypeVar('_reverseMap2combiner__That')  # <That>
        def reverseMap2combiner(self, f: scala.Function1[_SeqSplitter__Appended__U, _reverseMap2combiner__S], cb: Combiner[_reverseMap2combiner__S, _reverseMap2combiner__That]) -> Combiner[_reverseMap2combiner__S, _reverseMap2combiner__That]: ...
        def slice(self, from1: int, until1: int) -> 'SeqSplitter'[_SeqSplitter__Appended__U]: ...
        def split(self) -> scala.collection.Seq['SeqSplitter'[_SeqSplitter__Appended__U]]: ...
        def splitWithSignalling(self) -> scala.collection.Seq['SeqSplitter'[_SeqSplitter__Appended__U]]: ...
        def take(self, n: int) -> 'SeqSplitter'[_SeqSplitter__Appended__U]: ...
        _updated2combiner__U = typing.TypeVar('_updated2combiner__U')  # <U>
        _updated2combiner__That = typing.TypeVar('_updated2combiner__That')  # <That>
        def updated2combiner(self, index: int, elem: typing.Any, cb: Combiner[typing.Any, _updated2combiner__That]) -> Combiner[typing.Any, _updated2combiner__That]: ...
        _zipAllParSeq__S = typing.TypeVar('_zipAllParSeq__S')  # <S>
        _zipAllParSeq__U = typing.TypeVar('_zipAllParSeq__U')  # <U>
        _zipAllParSeq__R = typing.TypeVar('_zipAllParSeq__R')  # <R>
        def zipAllParSeq(self, that: 'SeqSplitter'[_zipAllParSeq__S], thisElem: typing.Any, thatElem: _zipAllParSeq__R) -> 'SeqSplitter.ZippedAll'[typing.Any, _zipAllParSeq__R]: ...
        _zipParSeq__S = typing.TypeVar('_zipParSeq__S')  # <S>
        def zipParSeq(self, that: 'SeqSplitter'[_zipParSeq__S]) -> 'SeqSplitter.Zipped'[_zipParSeq__S]: ...
    class Mapped(IterableSplitter.Mapped[_SeqSplitter__Mapped__S], scala.collection.parallel.SeqSplitter[_SeqSplitter__Mapped__S], typing.Generic[_SeqSplitter__Mapped__S]):
        def __init__(self, $outer: 'SeqSplitter', f: scala.Function1[_SeqSplitter__T, _SeqSplitter__Mapped__S]): ...
        _appendParSeq__U = typing.TypeVar('_appendParSeq__U')  # <U>
        _appendParSeq__PI = typing.TypeVar('_appendParSeq__PI', bound='SeqSplitter')  # <PI>
        def appendParSeq(self, that: _appendParSeq__PI) -> 'SeqSplitter.Appended'[_appendParSeq__U, _appendParSeq__PI]: ...
        _corresponds_0__B = typing.TypeVar('_corresponds_0__B')  # <B>
        _corresponds_1__S = typing.TypeVar('_corresponds_1__S')  # <S>
        @typing.overload
        def corresponds(self, that: scala.collection.GenTraversableOnce[_corresponds_0__B], p: scala.Function2[_SeqSplitter__Mapped__S, _corresponds_0__B, typing.Any]) -> bool: ...
        @typing.overload
        def corresponds(self, corr: scala.Function2[typing.Any, typing.Any, typing.Any], that: scala.collection.Iterator[typing.Any]) -> bool: ...
        def dup(self) -> 'SeqSplitter'[_SeqSplitter__Mapped__S]: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[_SeqSplitter__Mapped__S, typing.Any], from_: int) -> int: ...
        @typing.overload
        def indexWhere(self, pred: scala.Function1[_SeqSplitter__Mapped__S, typing.Any]) -> int: ...
        def lastIndexWhere(self, pred: scala.Function1[_SeqSplitter__Mapped__S, typing.Any]) -> int: ...
        _map__S = typing.TypeVar('_map__S')  # <S>
        def map(self, f: scala.Function1[typing.Any, typing.Any]) -> 'SeqSplitter.Mapped'[typing.Any]: ...
        def newTaken(self, until: int) -> 'SeqSplitter.Taken': ...
        _patchParSeq__U = typing.TypeVar('_patchParSeq__U')  # <U>
        def patchParSeq(self, from_: int, patchElems: 'SeqSplitter'[_patchParSeq__U], replaced: int) -> 'SeqSplitter.Patched'[_patchParSeq__U]: ...
        def prefixLength(self, pred: scala.Function1[_SeqSplitter__Mapped__S, typing.Any]) -> int: ...
        def psplit(self, sizes: scala.collection.Seq[typing.Any]) -> scala.collection.Seq['SeqSplitter'[_SeqSplitter__Mapped__S]]: ...
        def psplitWithSignalling(self, sizes: scala.collection.Seq[typing.Any]) -> scala.collection.Seq['SeqSplitter'[_SeqSplitter__Mapped__S]]: ...
        def reverse(self) -> 'SeqSplitter'[_SeqSplitter__Mapped__S]: ...
        _reverse2combiner__U = typing.TypeVar('_reverse2combiner__U')  # <U>
        _reverse2combiner__This = typing.TypeVar('_reverse2combiner__This')  # <This>
        def reverse2combiner(self, cb: Combiner[_reverse2combiner__U, _reverse2combiner__This]) -> Combiner[_reverse2combiner__U, _reverse2combiner__This]: ...
        _reverseMap2combiner__S = typing.TypeVar('_reverseMap2combiner__S')  # <S>
        _reverseMap2combiner__That = typing.TypeVar('_reverseMap2combiner__That')  # <That>
        def reverseMap2combiner(self, f: scala.Function1[typing.Any, typing.Any], cb: Combiner[typing.Any, _reverseMap2combiner__That]) -> Combiner[typing.Any, _reverseMap2combiner__That]: ...
        def slice(self, from1: int, until1: int) -> 'SeqSplitter'[_SeqSplitter__Mapped__S]: ...
        def split(self) -> scala.collection.Seq['SeqSplitter'[_SeqSplitter__Mapped__S]]: ...
        def splitWithSignalling(self) -> scala.collection.Seq['SeqSplitter'[_SeqSplitter__Mapped__S]]: ...
        def take(self, n: int) -> 'SeqSplitter'[_SeqSplitter__Mapped__S]: ...
        _updated2combiner__U = typing.TypeVar('_updated2combiner__U')  # <U>
        _updated2combiner__That = typing.TypeVar('_updated2combiner__That')  # <That>
        def updated2combiner(self, index: int, elem: _updated2combiner__U, cb: Combiner[_updated2combiner__U, _updated2combiner__That]) -> Combiner[_updated2combiner__U, _updated2combiner__That]: ...
        _zipAllParSeq__S = typing.TypeVar('_zipAllParSeq__S')  # <S>
        _zipAllParSeq__U = typing.TypeVar('_zipAllParSeq__U')  # <U>
        _zipAllParSeq__R = typing.TypeVar('_zipAllParSeq__R')  # <R>
        def zipAllParSeq(self, that: 'SeqSplitter'[typing.Any], thisElem: _zipAllParSeq__U, thatElem: _zipAllParSeq__R) -> 'SeqSplitter.ZippedAll'[_zipAllParSeq__U, _zipAllParSeq__R]: ...
        _zipParSeq__S = typing.TypeVar('_zipParSeq__S')  # <S>
        def zipParSeq(self, that: 'SeqSplitter'[typing.Any]) -> 'SeqSplitter.Zipped'[typing.Any]: ...
    class Patched(scala.collection.parallel.SeqSplitter[_SeqSplitter__Patched__U], typing.Generic[_SeqSplitter__Patched__U]):
        $outer: 'SeqSplitter' = ...
        def __init__(self, $outer: 'SeqSplitter', from_: int, patch: 'SeqSplitter'[_SeqSplitter__Patched__U], replaced: int): ...
        _$colon$bslash__B = typing.TypeVar('_$colon$bslash__B')  # <B>
        def $colon$bslash(self, z: _.colon.bslash__B, op: scala.Function2[_SeqSplitter__Patched__U, _.colon.bslash__B, _.colon.bslash__B]) -> _.colon.bslash__B: ...
        _$div$colon__B = typing.TypeVar('_$div$colon__B')  # <B>
        def $div$colon(self, z: _.div.colon__B, op: scala.Function2[_.div.colon__B, _SeqSplitter__Patched__U, _.div.colon__B]) -> _.div.colon__B: ...
        _$plus$plus__B = typing.TypeVar('_$plus$plus__B')  # <B>
        def $plus$plus(self, that: scala.Function0[scala.collection.GenTraversableOnce[_.plus.plus__B]]) -> scala.collection.Iterator[_.plus.plus__B]: ...
        def abort(self) -> None: ...
        @typing.overload
        def addString(self, b: scala.collection.mutable.StringBuilder) -> scala.collection.mutable.StringBuilder: ...
        @typing.overload
        def addString(self, b: scala.collection.mutable.StringBuilder, sep: typing.Union[java.lang.String, str]) -> scala.collection.mutable.StringBuilder: ...
        @typing.overload
        def addString(self, b: scala.collection.mutable.StringBuilder, start: typing.Union[java.lang.String, str], sep: typing.Union[java.lang.String, str], end: typing.Union[java.lang.String, str]) -> scala.collection.mutable.StringBuilder: ...
        _aggregate__B = typing.TypeVar('_aggregate__B')  # <B>
        def aggregate(self, z: scala.Function0[_aggregate__B], seqop: scala.Function2[_aggregate__B, _SeqSplitter__Patched__U, _aggregate__B], combop: scala.Function2[_aggregate__B, _aggregate__B, _aggregate__B]) -> _aggregate__B: ...
        _appendParIterable__U = typing.TypeVar('_appendParIterable__U')  # <U>
        _appendParIterable__PI = typing.TypeVar('_appendParIterable__PI', bound=IterableSplitter)  # <PI>
        def appendParIterable(self, that: _appendParIterable__PI) -> IterableSplitter.Appended[typing.Any, _appendParIterable__PI]: ...
        _appendParSeq__U = typing.TypeVar('_appendParSeq__U')  # <U>
        _appendParSeq__PI = typing.TypeVar('_appendParSeq__PI', bound='SeqSplitter')  # <PI>
        def appendParSeq(self, that: _appendParSeq__PI) -> 'SeqSplitter.Appended'[typing.Any, _appendParSeq__PI]: ...
        def buffered(self) -> scala.collection.BufferedIterator[_SeqSplitter__Patched__U]: ...
        def buildString(self, closure: scala.Function1[scala.Function1[typing.Union[java.lang.String, str], scala.runtime.BoxedUnit], scala.runtime.BoxedUnit]) -> java.lang.String: ...
        _collect__B = typing.TypeVar('_collect__B')  # <B>
        def collect(self, pf: scala.PartialFunction[_SeqSplitter__Patched__U, _collect__B]) -> scala.collection.Iterator[_collect__B]: ...
        _collect2combiner__S = typing.TypeVar('_collect2combiner__S')  # <S>
        _collect2combiner__That = typing.TypeVar('_collect2combiner__That')  # <That>
        def collect2combiner(self, pf: scala.PartialFunction[_SeqSplitter__Patched__U, _collect2combiner__S], cb: Combiner[_collect2combiner__S, _collect2combiner__That]) -> Combiner[_collect2combiner__S, _collect2combiner__That]: ...
        _collectFirst__B = typing.TypeVar('_collectFirst__B')  # <B>
        def collectFirst(self, pf: scala.PartialFunction[_SeqSplitter__Patched__U, _collectFirst__B]) -> scala.Option[_collectFirst__B]: ...
        def contains(self, elem: typing.Any) -> bool: ...
        _copy2builder__U = typing.TypeVar('_copy2builder__U')  # <U>
        _copy2builder__Coll = typing.TypeVar('_copy2builder__Coll')  # <Coll>
        _copy2builder__Bld = typing.TypeVar('_copy2builder__Bld', bound=scala.collection.mutable.Builder)  # <Bld>
        def copy2builder(self, b: _copy2builder__Bld) -> _copy2builder__Bld: ...
        _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
        _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
        _copyToArray_2__U = typing.TypeVar('_copyToArray_2__U')  # <U>
        @typing.overload
        def copyToArray(self, xs: typing.Any) -> None: ...
        @typing.overload
        def copyToArray(self, xs: typing.Any, start: int) -> None: ...
        @typing.overload
        def copyToArray(self, array: typing.Any, from_: int, len: int) -> None: ...
        _copyToBuffer__B = typing.TypeVar('_copyToBuffer__B')  # <B>
        def copyToBuffer(self, dest: scala.collection.mutable.Buffer[_copyToBuffer__B]) -> None: ...
        _corresponds_0__S = typing.TypeVar('_corresponds_0__S')  # <S>
        _corresponds_1__B = typing.TypeVar('_corresponds_1__B')  # <B>
        @typing.overload
        def corresponds(self, corr: scala.Function2[_SeqSplitter__Patched__U, _corresponds_0__S, typing.Any], that: scala.collection.Iterator[_corresponds_0__S]) -> bool: ...
        @typing.overload
        def corresponds(self, that: scala.collection.GenTraversableOnce[_corresponds_1__B], p: scala.Function2[_SeqSplitter__Patched__U, _corresponds_1__B, typing.Any]) -> bool: ...
        def count(self, p: scala.Function1[_SeqSplitter__Patched__U, typing.Any]) -> int: ...
        def debugInformation(self) -> java.lang.String: ...
        def drop(self, n: int) -> IterableSplitter[_SeqSplitter__Patched__U]: ...
        _drop2combiner__U = typing.TypeVar('_drop2combiner__U')  # <U>
        _drop2combiner__This = typing.TypeVar('_drop2combiner__This')  # <This>
        def drop2combiner(self, n: int, cb: Combiner[typing.Any, _drop2combiner__This]) -> Combiner[typing.Any, _drop2combiner__This]: ...
        def dropWhile(self, p: scala.Function1[_SeqSplitter__Patched__U, typing.Any]) -> scala.collection.Iterator[_SeqSplitter__Patched__U]: ...
        def dup(self) -> 'SeqSplitter.Patched'[_SeqSplitter__Patched__U]: ...
        def duplicate(self) -> scala.Tuple2[scala.collection.Iterator[_SeqSplitter__Patched__U], scala.collection.Iterator[_SeqSplitter__Patched__U]]: ...
        def exists(self, p: scala.Function1[_SeqSplitter__Patched__U, typing.Any]) -> bool: ...
        def filter(self, p: scala.Function1[_SeqSplitter__Patched__U, typing.Any]) -> scala.collection.Iterator[_SeqSplitter__Patched__U]: ...
        _filter2combiner__U = typing.TypeVar('_filter2combiner__U')  # <U>
        _filter2combiner__This = typing.TypeVar('_filter2combiner__This')  # <This>
        def filter2combiner(self, pred: scala.Function1[typing.Any, typing.Any], cb: Combiner[typing.Any, _filter2combiner__This]) -> Combiner[typing.Any, _filter2combiner__This]: ...
        def filterNot(self, p: scala.Function1[_SeqSplitter__Patched__U, typing.Any]) -> scala.collection.Iterator[_SeqSplitter__Patched__U]: ...
        _filterNot2combiner__U = typing.TypeVar('_filterNot2combiner__U')  # <U>
        _filterNot2combiner__This = typing.TypeVar('_filterNot2combiner__This')  # <This>
        def filterNot2combiner(self, pred: scala.Function1[typing.Any, typing.Any], cb: Combiner[typing.Any, _filterNot2combiner__This]) -> Combiner[typing.Any, _filterNot2combiner__This]: ...
        def find(self, p: scala.Function1[_SeqSplitter__Patched__U, typing.Any]) -> scala.Option[_SeqSplitter__Patched__U]: ...
        _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
        def flatMap(self, f: scala.Function1[_SeqSplitter__Patched__U, scala.collection.GenTraversableOnce[_flatMap__B]]) -> scala.collection.Iterator[_flatMap__B]: ...
        _flatmap2combiner__S = typing.TypeVar('_flatmap2combiner__S')  # <S>
        _flatmap2combiner__That = typing.TypeVar('_flatmap2combiner__That')  # <That>
        def flatmap2combiner(self, f: scala.Function1[_SeqSplitter__Patched__U, scala.collection.GenTraversableOnce[_flatmap2combiner__S]], cb: Combiner[_flatmap2combiner__S, _flatmap2combiner__That]) -> Combiner[_flatmap2combiner__S, _flatmap2combiner__That]: ...
        _fold__U = typing.TypeVar('_fold__U')  # <U>
        def fold(self, z: typing.Any, op: scala.Function2[typing.Any, typing.Any, typing.Any]) -> typing.Any: ...
        _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
        def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, _SeqSplitter__Patched__U, _foldLeft__B]) -> _foldLeft__B: ...
        _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
        def foldRight(self, z: _foldRight__B, op: scala.Function2[_SeqSplitter__Patched__U, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
        def forall(self, p: scala.Function1[_SeqSplitter__Patched__U, typing.Any]) -> bool: ...
        _foreach__U = typing.TypeVar('_foreach__U')  # <U>
        def foreach(self, f: scala.Function1[typing.Any, typing.Any]) -> None: ...
        _grouped__B = typing.TypeVar('_grouped__B')  # <B>
        def grouped(self, size: int) -> scala.collection.Iterator.GroupedIterator[_grouped__B]: ...
        def hasDefiniteSize(self) -> bool: ...
        def hasNext(self) -> bool: ...
        def indexFlag(self) -> int: ...
        _indexOf_0__B = typing.TypeVar('_indexOf_0__B')  # <B>
        _indexOf_1__B = typing.TypeVar('_indexOf_1__B')  # <B>
        @typing.overload
        def indexOf(self, elem: _indexOf_0__B) -> int: ...
        @typing.overload
        def indexOf(self, elem: _indexOf_1__B, from_: int) -> int: ...
        @typing.overload
        def indexWhere(self, pred: scala.Function1[_SeqSplitter__Patched__U, typing.Any]) -> int: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[_SeqSplitter__Patched__U, typing.Any], from_: int) -> int: ...
        def isAborted(self) -> bool: ...
        def isEmpty(self) -> bool: ...
        def isRemainingCheap(self) -> bool: ...
        def isTraversableAgain(self) -> bool: ...
        def lastIndexWhere(self, pred: scala.Function1[_SeqSplitter__Patched__U, typing.Any]) -> int: ...
        def length(self) -> int: ...
        _map__S = typing.TypeVar('_map__S')  # <S>
        def map(self, f: scala.Function1[_SeqSplitter__Patched__U, _map__S]) -> 'SeqSplitter.Mapped'[_map__S]: ...
        _map2combiner__S = typing.TypeVar('_map2combiner__S')  # <S>
        _map2combiner__That = typing.TypeVar('_map2combiner__That')  # <That>
        def map2combiner(self, f: scala.Function1[_SeqSplitter__Patched__U, _map2combiner__S], cb: Combiner[_map2combiner__S, _map2combiner__That]) -> Combiner[_map2combiner__S, _map2combiner__That]: ...
        _max__U = typing.TypeVar('_max__U')  # <U>
        def max(self, ord: scala.math.Ordering[typing.Any]) -> typing.Any: ...
        _maxBy__B = typing.TypeVar('_maxBy__B')  # <B>
        def maxBy(self, f: scala.Function1[_SeqSplitter__Patched__U, _maxBy__B], cmp: scala.math.Ordering[_maxBy__B]) -> _SeqSplitter__Patched__U: ...
        _min__U = typing.TypeVar('_min__U')  # <U>
        def min(self, ord: scala.math.Ordering[typing.Any]) -> typing.Any: ...
        _minBy__B = typing.TypeVar('_minBy__B')  # <B>
        def minBy(self, f: scala.Function1[_SeqSplitter__Patched__U, _minBy__B], cmp: scala.math.Ordering[_minBy__B]) -> _SeqSplitter__Patched__U: ...
        @typing.overload
        def mkString(self) -> java.lang.String: ...
        @typing.overload
        def mkString(self, sep: typing.Union[java.lang.String, str]) -> java.lang.String: ...
        @typing.overload
        def mkString(self, start: typing.Union[java.lang.String, str], sep: typing.Union[java.lang.String, str], end: typing.Union[java.lang.String, str]) -> java.lang.String: ...
        _newSliceInternal__U = typing.TypeVar('_newSliceInternal__U', bound=IterableSplitter.Taken)  # <U>
        def newSliceInternal(self, it: IterableSplitter.Taken, from1: int) -> IterableSplitter.Taken: ...
        def newTaken(self, until: int) -> 'SeqSplitter.Taken': ...
        def next(self) -> _SeqSplitter__Patched__U: ...
        def nonEmpty(self) -> bool: ...
        _padTo__A1 = typing.TypeVar('_padTo__A1')  # <A1>
        def padTo(self, len: int, elem: _padTo__A1) -> scala.collection.Iterator[_padTo__A1]: ...
        def partition(self, p: scala.Function1[_SeqSplitter__Patched__U, typing.Any]) -> scala.Tuple2[scala.collection.Iterator[_SeqSplitter__Patched__U], scala.collection.Iterator[_SeqSplitter__Patched__U]]: ...
        _partition2combiners__U = typing.TypeVar('_partition2combiners__U')  # <U>
        _partition2combiners__This = typing.TypeVar('_partition2combiners__This')  # <This>
        def partition2combiners(self, pred: scala.Function1[typing.Any, typing.Any], btrue: Combiner[typing.Any, _partition2combiners__This], bfalse: Combiner[typing.Any, _partition2combiners__This]) -> scala.Tuple2[Combiner[typing.Any, _partition2combiners__This], Combiner[typing.Any, _partition2combiners__This]]: ...
        _patch__B = typing.TypeVar('_patch__B')  # <B>
        def patch(self, from_: int, patchElems: scala.collection.Iterator[_patch__B], replaced: int) -> scala.collection.Iterator[_patch__B]: ...
        _patchParSeq__U = typing.TypeVar('_patchParSeq__U')  # <U>
        def patchParSeq(self, from_: int, patchElems: 'SeqSplitter'[typing.Any], replaced: int) -> 'SeqSplitter.Patched'[typing.Any]: ...
        def prefixLength(self, pred: scala.Function1[_SeqSplitter__Patched__U, typing.Any]) -> int: ...
        _product__U = typing.TypeVar('_product__U')  # <U>
        def product(self, num: scala.math.Numeric[typing.Any]) -> typing.Any: ...
        def psplit(self, sizes: scala.collection.Seq[typing.Any]) -> scala.collection.Seq['SeqSplitter'[_SeqSplitter__Patched__U]]: ...
        def psplitWithSignalling(self, sizes: scala.collection.Seq[typing.Any]) -> scala.collection.Seq['SeqSplitter'[_SeqSplitter__Patched__U]]: ...
        _reduce__U = typing.TypeVar('_reduce__U')  # <U>
        def reduce(self, op: scala.Function2[typing.Any, typing.Any, typing.Any]) -> typing.Any: ...
        _reduceLeft_0__U = typing.TypeVar('_reduceLeft_0__U')  # <U>
        _reduceLeft_1__B = typing.TypeVar('_reduceLeft_1__B')  # <B>
        @typing.overload
        def reduceLeft(self, howmany: int, op: scala.Function2[typing.Any, typing.Any, typing.Any]) -> typing.Any: ...
        @typing.overload
        def reduceLeft(self, op: scala.Function2[_reduceLeft_1__B, _SeqSplitter__Patched__U, _reduceLeft_1__B]) -> _reduceLeft_1__B: ...
        _reduceLeftOption__B = typing.TypeVar('_reduceLeftOption__B')  # <B>
        def reduceLeftOption(self, op: scala.Function2[_reduceLeftOption__B, _SeqSplitter__Patched__U, _reduceLeftOption__B]) -> scala.Option[_reduceLeftOption__B]: ...
        _reduceOption__A1 = typing.TypeVar('_reduceOption__A1')  # <A1>
        def reduceOption(self, op: scala.Function2[_reduceOption__A1, _reduceOption__A1, _reduceOption__A1]) -> scala.Option[_reduceOption__A1]: ...
        _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
        def reduceRight(self, op: scala.Function2[_SeqSplitter__Patched__U, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
        _reduceRightOption__B = typing.TypeVar('_reduceRightOption__B')  # <B>
        def reduceRightOption(self, op: scala.Function2[_SeqSplitter__Patched__U, _reduceRightOption__B, _reduceRightOption__B]) -> scala.Option[_reduceRightOption__B]: ...
        def remaining(self) -> int: ...
        def reverse(self) -> 'SeqSplitter'[_SeqSplitter__Patched__U]: ...
        _reverse2combiner__U = typing.TypeVar('_reverse2combiner__U')  # <U>
        _reverse2combiner__This = typing.TypeVar('_reverse2combiner__This')  # <This>
        def reverse2combiner(self, cb: Combiner[typing.Any, _reverse2combiner__This]) -> Combiner[typing.Any, _reverse2combiner__This]: ...
        _reverseMap2combiner__S = typing.TypeVar('_reverseMap2combiner__S')  # <S>
        _reverseMap2combiner__That = typing.TypeVar('_reverseMap2combiner__That')  # <That>
        def reverseMap2combiner(self, f: scala.Function1[_SeqSplitter__Patched__U, _reverseMap2combiner__S], cb: Combiner[_reverseMap2combiner__S, _reverseMap2combiner__That]) -> Combiner[_reverseMap2combiner__S, _reverseMap2combiner__That]: ...
        def reversed(self) -> scala.collection.immutable.List[_SeqSplitter__Patched__U]: ...
        def sameElements(self, that: scala.collection.Iterator[typing.Any]) -> bool: ...
        _scanLeft__B = typing.TypeVar('_scanLeft__B')  # <B>
        def scanLeft(self, z: _scanLeft__B, op: scala.Function2[_scanLeft__B, _SeqSplitter__Patched__U, _scanLeft__B]) -> scala.collection.Iterator[_scanLeft__B]: ...
        _scanRight__B = typing.TypeVar('_scanRight__B')  # <B>
        def scanRight(self, z: _scanRight__B, op: scala.Function2[_SeqSplitter__Patched__U, _scanRight__B, _scanRight__B]) -> scala.collection.Iterator[_scanRight__B]: ...
        _scanToArray__U = typing.TypeVar('_scanToArray__U')  # <U>
        _scanToArray__A = typing.TypeVar('_scanToArray__A')  # <A>
        def scanToArray(self, z: typing.Any, op: scala.Function2[typing.Any, typing.Any, typing.Any], array: typing.Any, from_: int) -> None: ...
        _scanToCombiner_0__U = typing.TypeVar('_scanToCombiner_0__U')  # <U>
        _scanToCombiner_0__That = typing.TypeVar('_scanToCombiner_0__That')  # <That>
        _scanToCombiner_1__U = typing.TypeVar('_scanToCombiner_1__U')  # <U>
        _scanToCombiner_1__That = typing.TypeVar('_scanToCombiner_1__That')  # <That>
        @typing.overload
        def scanToCombiner(self, howmany: int, startValue: typing.Any, op: scala.Function2[typing.Any, typing.Any, typing.Any], cb: Combiner[typing.Any, _scanToCombiner_0__That]) -> Combiner[typing.Any, _scanToCombiner_0__That]: ...
        @typing.overload
        def scanToCombiner(self, startValue: typing.Any, op: scala.Function2[typing.Any, typing.Any, typing.Any], cb: Combiner[typing.Any, _scanToCombiner_1__That]) -> Combiner[typing.Any, _scanToCombiner_1__That]: ...
        def seq(self) -> scala.collection.Iterator[_SeqSplitter__Patched__U]: ...
        def setIndexFlag(self, f: int) -> None: ...
        def setIndexFlagIfGreater(self, f: int) -> None: ...
        def setIndexFlagIfLesser(self, f: int) -> None: ...
        _shouldSplitFurther__S = typing.TypeVar('_shouldSplitFurther__S')  # <S>
        def shouldSplitFurther(self, coll: ParIterable[_shouldSplitFurther__S], parallelismLevel: int) -> bool: ...
        def signalDelegate(self) -> scala.collection.generic.Signalling: ...
        def signalDelegate_$eq(self, x$1: scala.collection.generic.Signalling) -> None: ...
        def size(self) -> int: ...
        def sizeHintIfCheap(self) -> int: ...
        def slice(self, from1: int, until1: int) -> 'SeqSplitter'[_SeqSplitter__Patched__U]: ...
        _slice2combiner__U = typing.TypeVar('_slice2combiner__U')  # <U>
        _slice2combiner__This = typing.TypeVar('_slice2combiner__This')  # <This>
        def slice2combiner(self, from_: int, until: int, cb: Combiner[typing.Any, _slice2combiner__This]) -> Combiner[typing.Any, _slice2combiner__This]: ...
        def sliceIterator(self, from_: int, until: int) -> scala.collection.Iterator[_SeqSplitter__Patched__U]: ...
        _sliding__B = typing.TypeVar('_sliding__B')  # <B>
        def sliding(self, size: int, step: int) -> scala.collection.Iterator.GroupedIterator[_sliding__B]: ...
        _sliding$default$2__B = typing.TypeVar('_sliding$default$2__B')  # <B>
        def sliding$default$2(self) -> int: ...
        def span(self, p: scala.Function1[_SeqSplitter__Patched__U, typing.Any]) -> scala.Tuple2[scala.collection.Iterator[_SeqSplitter__Patched__U], scala.collection.Iterator[_SeqSplitter__Patched__U]]: ...
        _span2combiners__U = typing.TypeVar('_span2combiners__U')  # <U>
        _span2combiners__This = typing.TypeVar('_span2combiners__This')  # <This>
        def span2combiners(self, p: scala.Function1[typing.Any, typing.Any], before: Combiner[typing.Any, _span2combiners__This], after: Combiner[typing.Any, _span2combiners__This]) -> scala.Tuple2[Combiner[typing.Any, _span2combiners__This], Combiner[typing.Any, _span2combiners__This]]: ...
        def split(self) -> scala.collection.Seq['SeqSplitter'[_SeqSplitter__Patched__U]]: ...
        _splitAt2combiners__U = typing.TypeVar('_splitAt2combiners__U')  # <U>
        _splitAt2combiners__This = typing.TypeVar('_splitAt2combiners__This')  # <This>
        def splitAt2combiners(self, at: int, before: Combiner[typing.Any, _splitAt2combiners__This], after: Combiner[typing.Any, _splitAt2combiners__This]) -> scala.Tuple2[Combiner[typing.Any, _splitAt2combiners__This], Combiner[typing.Any, _splitAt2combiners__This]]: ...
        def splitWithSignalling(self) -> scala.collection.Seq['SeqSplitter'[_SeqSplitter__Patched__U]]: ...
        _sum__U = typing.TypeVar('_sum__U')  # <U>
        def sum(self, num: scala.math.Numeric[typing.Any]) -> typing.Any: ...
        def tag(self) -> int: ...
        def take(self, n: int) -> 'SeqSplitter'[_SeqSplitter__Patched__U]: ...
        _take2combiner__U = typing.TypeVar('_take2combiner__U')  # <U>
        _take2combiner__This = typing.TypeVar('_take2combiner__This')  # <This>
        def take2combiner(self, n: int, cb: Combiner[typing.Any, _take2combiner__This]) -> Combiner[typing.Any, _take2combiner__This]: ...
        def takeWhile(self, p: scala.Function1[_SeqSplitter__Patched__U, typing.Any]) -> scala.collection.Iterator[_SeqSplitter__Patched__U]: ...
        _takeWhile2combiner__U = typing.TypeVar('_takeWhile2combiner__U')  # <U>
        _takeWhile2combiner__This = typing.TypeVar('_takeWhile2combiner__This')  # <This>
        def takeWhile2combiner(self, p: scala.Function1[typing.Any, typing.Any], cb: Combiner[typing.Any, _takeWhile2combiner__This]) -> scala.Tuple2[Combiner[typing.Any, _takeWhile2combiner__This], typing.Any]: ...
        _to__Col = typing.TypeVar('_to__Col')  # <Col>
        def to(self, cbf: scala.collection.generic.CanBuildFrom[scala.runtime.Nothing., _SeqSplitter__Patched__U, _to__Col]) -> _to__Col: ...
        _toArray__B = typing.TypeVar('_toArray__B')  # <B>
        def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__B]) -> typing.Any: ...
        _toBuffer__B = typing.TypeVar('_toBuffer__B')  # <B>
        def toBuffer(self) -> scala.collection.mutable.Buffer[_toBuffer__B]: ...
        def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq[_SeqSplitter__Patched__U]: ...
        def toIterable(self) -> scala.collection.Iterable[_SeqSplitter__Patched__U]: ...
        def toIterator(self) -> scala.collection.Iterator[_SeqSplitter__Patched__U]: ...
        def toList(self) -> scala.collection.immutable.List[_SeqSplitter__Patched__U]: ...
        _toMap__T = typing.TypeVar('_toMap__T')  # <T>
        _toMap__U = typing.TypeVar('_toMap__U')  # <U>
        def toMap(self, ev: scala.Predef..less.colon.less[typing.Any, scala.Tuple2[typing.Any, typing.Any]]) -> scala.collection.immutable.Map[typing.Any, typing.Any]: ...
        def toSeq(self) -> scala.collection.Seq[_SeqSplitter__Patched__U]: ...
        _toSet__B = typing.TypeVar('_toSet__B')  # <B>
        def toSet(self) -> scala.collection.immutable.Set[_toSet__B]: ...
        def toStream(self) -> scala.collection.immutable.Stream[_SeqSplitter__Patched__U]: ...
        def toString(self) -> java.lang.String: ...
        def toTraversable(self) -> scala.collection.Traversable[_SeqSplitter__Patched__U]: ...
        def toVector(self) -> scala.collection.immutable.Vector[_SeqSplitter__Patched__U]: ...
        _updated2combiner__U = typing.TypeVar('_updated2combiner__U')  # <U>
        _updated2combiner__That = typing.TypeVar('_updated2combiner__That')  # <That>
        def updated2combiner(self, index: int, elem: typing.Any, cb: Combiner[typing.Any, _updated2combiner__That]) -> Combiner[typing.Any, _updated2combiner__That]: ...
        def withFilter(self, p: scala.Function1[_SeqSplitter__Patched__U, typing.Any]) -> scala.collection.Iterator[_SeqSplitter__Patched__U]: ...
        _zip__B = typing.TypeVar('_zip__B')  # <B>
        def zip(self, that: scala.collection.Iterator[_zip__B]) -> scala.collection.Iterator[scala.Tuple2[_SeqSplitter__Patched__U, _zip__B]]: ...
        _zip2combiner__U = typing.TypeVar('_zip2combiner__U')  # <U>
        _zip2combiner__S = typing.TypeVar('_zip2combiner__S')  # <S>
        _zip2combiner__That = typing.TypeVar('_zip2combiner__That')  # <That>
        def zip2combiner(self, otherpit: RemainsIterator[_zip2combiner__S], cb: Combiner[scala.Tuple2[typing.Any, _zip2combiner__S], _zip2combiner__That]) -> Combiner[scala.Tuple2[typing.Any, _zip2combiner__S], _zip2combiner__That]: ...
        _zipAll__B = typing.TypeVar('_zipAll__B')  # <B>
        _zipAll__A1 = typing.TypeVar('_zipAll__A1')  # <A1>
        _zipAll__B1 = typing.TypeVar('_zipAll__B1')  # <B1>
        def zipAll(self, that: scala.collection.Iterator[_zipAll__B], thisElem: _zipAll__A1, thatElem: _zipAll__B1) -> scala.collection.Iterator[scala.Tuple2[_zipAll__A1, _zipAll__B1]]: ...
        _zipAll2combiner__U = typing.TypeVar('_zipAll2combiner__U')  # <U>
        _zipAll2combiner__S = typing.TypeVar('_zipAll2combiner__S')  # <S>
        _zipAll2combiner__That = typing.TypeVar('_zipAll2combiner__That')  # <That>
        def zipAll2combiner(self, that: RemainsIterator[_zipAll2combiner__S], thiselem: typing.Any, thatelem: _zipAll2combiner__S, cb: Combiner[scala.Tuple2[typing.Any, _zipAll2combiner__S], _zipAll2combiner__That]) -> Combiner[scala.Tuple2[typing.Any, _zipAll2combiner__S], _zipAll2combiner__That]: ...
        _zipAllParSeq__S = typing.TypeVar('_zipAllParSeq__S')  # <S>
        _zipAllParSeq__U = typing.TypeVar('_zipAllParSeq__U')  # <U>
        _zipAllParSeq__R = typing.TypeVar('_zipAllParSeq__R')  # <R>
        def zipAllParSeq(self, that: 'SeqSplitter'[_zipAllParSeq__S], thisElem: typing.Any, thatElem: _zipAllParSeq__R) -> 'SeqSplitter.ZippedAll'[typing.Any, _zipAllParSeq__R]: ...
        _zipParSeq__S = typing.TypeVar('_zipParSeq__S')  # <S>
        def zipParSeq(self, that: 'SeqSplitter'[_zipParSeq__S]) -> 'SeqSplitter.Zipped'[_zipParSeq__S]: ...
        def zipWithIndex(self) -> scala.collection.Iterator[scala.Tuple2[_SeqSplitter__Patched__U, typing.Any]]: ...
    class Taken(IterableSplitter.Taken, scala.collection.parallel.SeqSplitter[_SeqSplitter__T]):
        def __init__(self, $outer: 'SeqSplitter', tk: int): ...
        _appendParSeq__U = typing.TypeVar('_appendParSeq__U')  # <U>
        _appendParSeq__PI = typing.TypeVar('_appendParSeq__PI', bound='SeqSplitter')  # <PI>
        def appendParSeq(self, that: _appendParSeq__PI) -> 'SeqSplitter.Appended'[_appendParSeq__U, _appendParSeq__PI]: ...
        _corresponds_0__B = typing.TypeVar('_corresponds_0__B')  # <B>
        _corresponds_1__S = typing.TypeVar('_corresponds_1__S')  # <S>
        @typing.overload
        def corresponds(self, that: scala.collection.GenTraversableOnce[_corresponds_0__B], p: scala.Function2[_SeqSplitter__T, _corresponds_0__B, typing.Any]) -> bool: ...
        @typing.overload
        def corresponds(self, corr: scala.Function2[_SeqSplitter__T, _corresponds_1__S, typing.Any], that: scala.collection.Iterator[_corresponds_1__S]) -> bool: ...
        def dup(self) -> 'SeqSplitter'[_SeqSplitter__T]: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[_SeqSplitter__T, typing.Any], from_: int) -> int: ...
        @typing.overload
        def indexWhere(self, pred: scala.Function1[_SeqSplitter__T, typing.Any]) -> int: ...
        def lastIndexWhere(self, pred: scala.Function1[_SeqSplitter__T, typing.Any]) -> int: ...
        _map__S = typing.TypeVar('_map__S')  # <S>
        def map(self, f: scala.Function1[_SeqSplitter__T, _map__S]) -> 'SeqSplitter.Mapped'[_map__S]: ...
        def newTaken(self, until: int) -> 'SeqSplitter.Taken': ...
        _patchParSeq__U = typing.TypeVar('_patchParSeq__U')  # <U>
        def patchParSeq(self, from_: int, patchElems: 'SeqSplitter'[_patchParSeq__U], replaced: int) -> 'SeqSplitter.Patched'[_patchParSeq__U]: ...
        def prefixLength(self, pred: scala.Function1[_SeqSplitter__T, typing.Any]) -> int: ...
        def psplit(self, sizes: scala.collection.Seq[typing.Any]) -> scala.collection.Seq['SeqSplitter'[_SeqSplitter__T]]: ...
        def psplitWithSignalling(self, sizes: scala.collection.Seq[typing.Any]) -> scala.collection.Seq['SeqSplitter'[_SeqSplitter__T]]: ...
        def reverse(self) -> 'SeqSplitter'[_SeqSplitter__T]: ...
        _reverse2combiner__U = typing.TypeVar('_reverse2combiner__U')  # <U>
        _reverse2combiner__This = typing.TypeVar('_reverse2combiner__This')  # <This>
        def reverse2combiner(self, cb: Combiner[_reverse2combiner__U, _reverse2combiner__This]) -> Combiner[_reverse2combiner__U, _reverse2combiner__This]: ...
        _reverseMap2combiner__S = typing.TypeVar('_reverseMap2combiner__S')  # <S>
        _reverseMap2combiner__That = typing.TypeVar('_reverseMap2combiner__That')  # <That>
        def reverseMap2combiner(self, f: scala.Function1[_SeqSplitter__T, _reverseMap2combiner__S], cb: Combiner[_reverseMap2combiner__S, _reverseMap2combiner__That]) -> Combiner[_reverseMap2combiner__S, _reverseMap2combiner__That]: ...
        def slice(self, from1: int, until1: int) -> 'SeqSplitter'[_SeqSplitter__T]: ...
        def split(self) -> scala.collection.Seq['SeqSplitter'[_SeqSplitter__T]]: ...
        def splitWithSignalling(self) -> scala.collection.Seq['SeqSplitter'[_SeqSplitter__T]]: ...
        def take(self, n: int) -> 'SeqSplitter'[_SeqSplitter__T]: ...
        _updated2combiner__U = typing.TypeVar('_updated2combiner__U')  # <U>
        _updated2combiner__That = typing.TypeVar('_updated2combiner__That')  # <That>
        def updated2combiner(self, index: int, elem: _updated2combiner__U, cb: Combiner[_updated2combiner__U, _updated2combiner__That]) -> Combiner[_updated2combiner__U, _updated2combiner__That]: ...
        _zipAllParSeq__S = typing.TypeVar('_zipAllParSeq__S')  # <S>
        _zipAllParSeq__U = typing.TypeVar('_zipAllParSeq__U')  # <U>
        _zipAllParSeq__R = typing.TypeVar('_zipAllParSeq__R')  # <R>
        def zipAllParSeq(self, that: 'SeqSplitter'[_zipAllParSeq__S], thisElem: _zipAllParSeq__U, thatElem: _zipAllParSeq__R) -> 'SeqSplitter.ZippedAll'[_zipAllParSeq__U, _zipAllParSeq__R]: ...
        _zipParSeq__S = typing.TypeVar('_zipParSeq__S')  # <S>
        def zipParSeq(self, that: 'SeqSplitter'[_zipParSeq__S]) -> 'SeqSplitter.Zipped'[_zipParSeq__S]: ...
    class Zipped(IterableSplitter.Zipped[_SeqSplitter__Zipped__S], scala.collection.parallel.SeqSplitter[scala.Tuple2[_SeqSplitter__T, _SeqSplitter__Zipped__S]], typing.Generic[_SeqSplitter__Zipped__S]):
        def __init__(self, $outer: 'SeqSplitter', ti: 'SeqSplitter'[_SeqSplitter__Zipped__S]): ...
        _appendParSeq__U = typing.TypeVar('_appendParSeq__U')  # <U>
        _appendParSeq__PI = typing.TypeVar('_appendParSeq__PI', bound='SeqSplitter')  # <PI>
        def appendParSeq(self, that: _appendParSeq__PI) -> 'SeqSplitter.Appended'[_appendParSeq__U, _appendParSeq__PI]: ...
        _corresponds_0__B = typing.TypeVar('_corresponds_0__B')  # <B>
        _corresponds_1__S = typing.TypeVar('_corresponds_1__S')  # <S>
        @typing.overload
        def corresponds(self, that: scala.collection.GenTraversableOnce[_corresponds_0__B], p: scala.Function2[scala.Tuple2[_SeqSplitter__T, _SeqSplitter__Zipped__S], _corresponds_0__B, typing.Any]) -> bool: ...
        @typing.overload
        def corresponds(self, corr: scala.Function2[scala.Tuple2[_SeqSplitter__T, typing.Any], typing.Any, typing.Any], that: scala.collection.Iterator[typing.Any]) -> bool: ...
        def dup(self) -> 'SeqSplitter'[scala.Tuple2[_SeqSplitter__T, _SeqSplitter__Zipped__S]]: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[scala.Tuple2[_SeqSplitter__T, _SeqSplitter__Zipped__S], typing.Any], from_: int) -> int: ...
        @typing.overload
        def indexWhere(self, pred: scala.Function1[scala.Tuple2[_SeqSplitter__T, _SeqSplitter__Zipped__S], typing.Any]) -> int: ...
        def lastIndexWhere(self, pred: scala.Function1[scala.Tuple2[_SeqSplitter__T, _SeqSplitter__Zipped__S], typing.Any]) -> int: ...
        _map__S = typing.TypeVar('_map__S')  # <S>
        def map(self, f: scala.Function1[scala.Tuple2[_SeqSplitter__T, typing.Any], typing.Any]) -> 'SeqSplitter.Mapped'[typing.Any]: ...
        def newTaken(self, until: int) -> 'SeqSplitter.Taken': ...
        _patchParSeq__U = typing.TypeVar('_patchParSeq__U')  # <U>
        def patchParSeq(self, from_: int, patchElems: 'SeqSplitter'[_patchParSeq__U], replaced: int) -> 'SeqSplitter.Patched'[_patchParSeq__U]: ...
        def prefixLength(self, pred: scala.Function1[scala.Tuple2[_SeqSplitter__T, _SeqSplitter__Zipped__S], typing.Any]) -> int: ...
        def psplit(self, szs: scala.collection.Seq[typing.Any]) -> scala.collection.Seq['SeqSplitter'[scala.Tuple2[_SeqSplitter__T, _SeqSplitter__Zipped__S]]]: ...
        def psplitWithSignalling(self, sizes: scala.collection.Seq[typing.Any]) -> scala.collection.Seq['SeqSplitter'[scala.Tuple2[_SeqSplitter__T, _SeqSplitter__Zipped__S]]]: ...
        def reverse(self) -> 'SeqSplitter'[scala.Tuple2[_SeqSplitter__T, _SeqSplitter__Zipped__S]]: ...
        _reverse2combiner__U = typing.TypeVar('_reverse2combiner__U')  # <U>
        _reverse2combiner__This = typing.TypeVar('_reverse2combiner__This')  # <This>
        def reverse2combiner(self, cb: Combiner[_reverse2combiner__U, _reverse2combiner__This]) -> Combiner[_reverse2combiner__U, _reverse2combiner__This]: ...
        _reverseMap2combiner__S = typing.TypeVar('_reverseMap2combiner__S')  # <S>
        _reverseMap2combiner__That = typing.TypeVar('_reverseMap2combiner__That')  # <That>
        def reverseMap2combiner(self, f: scala.Function1[scala.Tuple2[_SeqSplitter__T, typing.Any], typing.Any], cb: Combiner[typing.Any, _reverseMap2combiner__That]) -> Combiner[typing.Any, _reverseMap2combiner__That]: ...
        def slice(self, from1: int, until1: int) -> 'SeqSplitter'[scala.Tuple2[_SeqSplitter__T, _SeqSplitter__Zipped__S]]: ...
        def split(self) -> scala.collection.Seq['SeqSplitter'[scala.Tuple2[_SeqSplitter__T, _SeqSplitter__Zipped__S]]]: ...
        def splitWithSignalling(self) -> scala.collection.Seq['SeqSplitter'[scala.Tuple2[_SeqSplitter__T, _SeqSplitter__Zipped__S]]]: ...
        def take(self, n: int) -> 'SeqSplitter'[scala.Tuple2[_SeqSplitter__T, _SeqSplitter__Zipped__S]]: ...
        _updated2combiner__U = typing.TypeVar('_updated2combiner__U')  # <U>
        _updated2combiner__That = typing.TypeVar('_updated2combiner__That')  # <That>
        def updated2combiner(self, index: int, elem: _updated2combiner__U, cb: Combiner[_updated2combiner__U, _updated2combiner__That]) -> Combiner[_updated2combiner__U, _updated2combiner__That]: ...
        _zipAllParSeq__S = typing.TypeVar('_zipAllParSeq__S')  # <S>
        _zipAllParSeq__U = typing.TypeVar('_zipAllParSeq__U')  # <U>
        _zipAllParSeq__R = typing.TypeVar('_zipAllParSeq__R')  # <R>
        def zipAllParSeq(self, that: 'SeqSplitter'[typing.Any], thisElem: _zipAllParSeq__U, thatElem: _zipAllParSeq__R) -> 'SeqSplitter.ZippedAll'[_zipAllParSeq__U, _zipAllParSeq__R]: ...
        _zipParSeq__S = typing.TypeVar('_zipParSeq__S')  # <S>
        def zipParSeq(self, that: 'SeqSplitter'[typing.Any]) -> 'SeqSplitter.Zipped'[typing.Any]: ...
    class ZippedAll(IterableSplitter.ZippedAll[_SeqSplitter__ZippedAll__U, _SeqSplitter__ZippedAll__S], scala.collection.parallel.SeqSplitter[scala.Tuple2[_SeqSplitter__ZippedAll__U, _SeqSplitter__ZippedAll__S]], typing.Generic[_SeqSplitter__ZippedAll__U, _SeqSplitter__ZippedAll__S]):
        def __init__(self, $outer: 'SeqSplitter', ti: 'SeqSplitter'[_SeqSplitter__ZippedAll__S], thise: _SeqSplitter__ZippedAll__U, thate: _SeqSplitter__ZippedAll__S): ...
        _appendParSeq__U = typing.TypeVar('_appendParSeq__U')  # <U>
        _appendParSeq__PI = typing.TypeVar('_appendParSeq__PI', bound='SeqSplitter')  # <PI>
        def appendParSeq(self, that: _appendParSeq__PI) -> 'SeqSplitter.Appended'[typing.Any, _appendParSeq__PI]: ...
        _corresponds_0__B = typing.TypeVar('_corresponds_0__B')  # <B>
        _corresponds_1__S = typing.TypeVar('_corresponds_1__S')  # <S>
        @typing.overload
        def corresponds(self, that: scala.collection.GenTraversableOnce[_corresponds_0__B], p: scala.Function2[scala.Tuple2[_SeqSplitter__ZippedAll__U, _SeqSplitter__ZippedAll__S], _corresponds_0__B, typing.Any]) -> bool: ...
        @typing.overload
        def corresponds(self, corr: scala.Function2[scala.Tuple2[_SeqSplitter__ZippedAll__U, typing.Any], typing.Any, typing.Any], that: scala.collection.Iterator[typing.Any]) -> bool: ...
        def dup(self) -> 'SeqSplitter'[scala.Tuple2[_SeqSplitter__ZippedAll__U, _SeqSplitter__ZippedAll__S]]: ...
        @typing.overload
        def indexWhere(self, p: scala.Function1[scala.Tuple2[_SeqSplitter__ZippedAll__U, _SeqSplitter__ZippedAll__S], typing.Any], from_: int) -> int: ...
        @typing.overload
        def indexWhere(self, pred: scala.Function1[scala.Tuple2[_SeqSplitter__ZippedAll__U, _SeqSplitter__ZippedAll__S], typing.Any]) -> int: ...
        def lastIndexWhere(self, pred: scala.Function1[scala.Tuple2[_SeqSplitter__ZippedAll__U, _SeqSplitter__ZippedAll__S], typing.Any]) -> int: ...
        _map__S = typing.TypeVar('_map__S')  # <S>
        def map(self, f: scala.Function1[scala.Tuple2[_SeqSplitter__ZippedAll__U, typing.Any], typing.Any]) -> 'SeqSplitter.Mapped'[typing.Any]: ...
        def newTaken(self, until: int) -> 'SeqSplitter.Taken': ...
        _patchParSeq__U = typing.TypeVar('_patchParSeq__U')  # <U>
        def patchParSeq(self, from_: int, patchElems: 'SeqSplitter'[typing.Any], replaced: int) -> 'SeqSplitter.Patched'[typing.Any]: ...
        def prefixLength(self, pred: scala.Function1[scala.Tuple2[_SeqSplitter__ZippedAll__U, _SeqSplitter__ZippedAll__S], typing.Any]) -> int: ...
        def psplit(self, sizes: scala.collection.Seq[typing.Any]) -> scala.collection.Seq['SeqSplitter'[scala.Tuple2[_SeqSplitter__ZippedAll__U, _SeqSplitter__ZippedAll__S]]]: ...
        def psplitWithSignalling(self, sizes: scala.collection.Seq[typing.Any]) -> scala.collection.Seq['SeqSplitter'[scala.Tuple2[_SeqSplitter__ZippedAll__U, _SeqSplitter__ZippedAll__S]]]: ...
        def reverse(self) -> 'SeqSplitter'[scala.Tuple2[_SeqSplitter__ZippedAll__U, _SeqSplitter__ZippedAll__S]]: ...
        _reverse2combiner__U = typing.TypeVar('_reverse2combiner__U')  # <U>
        _reverse2combiner__This = typing.TypeVar('_reverse2combiner__This')  # <This>
        def reverse2combiner(self, cb: Combiner[typing.Any, _reverse2combiner__This]) -> Combiner[typing.Any, _reverse2combiner__This]: ...
        _reverseMap2combiner__S = typing.TypeVar('_reverseMap2combiner__S')  # <S>
        _reverseMap2combiner__That = typing.TypeVar('_reverseMap2combiner__That')  # <That>
        def reverseMap2combiner(self, f: scala.Function1[scala.Tuple2[_SeqSplitter__ZippedAll__U, typing.Any], typing.Any], cb: Combiner[typing.Any, _reverseMap2combiner__That]) -> Combiner[typing.Any, _reverseMap2combiner__That]: ...
        def slice(self, from1: int, until1: int) -> 'SeqSplitter'[scala.Tuple2[_SeqSplitter__ZippedAll__U, _SeqSplitter__ZippedAll__S]]: ...
        def split(self) -> scala.collection.Seq['SeqSplitter'[scala.Tuple2[_SeqSplitter__ZippedAll__U, _SeqSplitter__ZippedAll__S]]]: ...
        def splitWithSignalling(self) -> scala.collection.Seq['SeqSplitter'[scala.Tuple2[_SeqSplitter__ZippedAll__U, _SeqSplitter__ZippedAll__S]]]: ...
        def take(self, n: int) -> 'SeqSplitter'[scala.Tuple2[_SeqSplitter__ZippedAll__U, _SeqSplitter__ZippedAll__S]]: ...
        _updated2combiner__U = typing.TypeVar('_updated2combiner__U')  # <U>
        _updated2combiner__That = typing.TypeVar('_updated2combiner__That')  # <That>
        def updated2combiner(self, index: int, elem: typing.Any, cb: Combiner[typing.Any, _updated2combiner__That]) -> Combiner[typing.Any, _updated2combiner__That]: ...
        _zipAllParSeq__S = typing.TypeVar('_zipAllParSeq__S')  # <S>
        _zipAllParSeq__U = typing.TypeVar('_zipAllParSeq__U')  # <U>
        _zipAllParSeq__R = typing.TypeVar('_zipAllParSeq__R')  # <R>
        def zipAllParSeq(self, that: 'SeqSplitter'[typing.Any], thisElem: typing.Any, thatElem: _zipAllParSeq__R) -> 'SeqSplitter.ZippedAll'[typing.Any, _zipAllParSeq__R]: ...
        _zipParSeq__S = typing.TypeVar('_zipParSeq__S')  # <S>
        def zipParSeq(self, that: 'SeqSplitter'[typing.Any]) -> 'SeqSplitter.Zipped'[typing.Any]: ...

class ParIterableLike: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("scala.collection.parallel")``.

    AdaptiveWorkStealingForkJoinTasks: typing.Type[AdaptiveWorkStealingForkJoinTasks]
    AdaptiveWorkStealingTasks: typing.Type[AdaptiveWorkStealingTasks]
    AdaptiveWorkStealingThreadPoolTasks: typing.Type[AdaptiveWorkStealingThreadPoolTasks]
    AugmentedIterableIterator: typing.Type[AugmentedIterableIterator]
    AugmentedSeqIterator: typing.Type[AugmentedSeqIterator]
    BucketCombiner: typing.Type[BucketCombiner]
    BufferSplitter: typing.Type[BufferSplitter]
    Combiner: typing.Type[Combiner]
    CombinerFactory: typing.Type[CombinerFactory]
    CompositeThrowable: typing.Type[CompositeThrowable]
    ExecutionContextTaskSupport: typing.Type[ExecutionContextTaskSupport]
    ExecutionContextTasks: typing.Type[ExecutionContextTasks]
    FactoryOps: typing.Type[FactoryOps]
    ForkJoinTaskSupport: typing.Type[ForkJoinTaskSupport]
    ForkJoinTasks: typing.Type[ForkJoinTasks]
    FutureTasks: typing.Type[FutureTasks]
    FutureThreadPoolTasks: typing.Type[FutureThreadPoolTasks]
    HavingForkJoinPool: typing.Type[HavingForkJoinPool]
    IterableSplitter: typing.Type[IterableSplitter]
    ParIterable: typing.Type[ParIterable]
    ParIterableLike: typing.Type[ParIterableLike]
    ParMap: typing.Type[ParMap]
    ParMapLike: typing.Type[ParMapLike]
    ParSeq: typing.Type[ParSeq]
    ParSeqLike: typing.Type[ParSeqLike]
    ParSet: typing.Type[ParSet]
    ParSetLike: typing.Type[ParSetLike]
    ParallelCollectionImplicits: typing.Type[ParallelCollectionImplicits]
    PreciseSplitter: typing.Type[PreciseSplitter]
    RemainsIterator: typing.Type[RemainsIterator]
    SeqSplitter: typing.Type[SeqSplitter]
    Splitter: typing.Type[Splitter]
    Task: typing.Type[Task]
    TaskSupport: typing.Type[TaskSupport]
    Tasks: typing.Type[Tasks]
    ThreadPoolTaskSupport: typing.Type[ThreadPoolTaskSupport]
    ThreadPoolTasks: typing.Type[ThreadPoolTasks]
    ThrowableOps: typing.Type[ThrowableOps]
    TraversableOps: typing.Type[TraversableOps]
    package: typing.Type[package]
    immutable: scala.collection.parallel.immutable.__module_protocol__
    mutable: scala.collection.parallel.mutable.__module_protocol__
