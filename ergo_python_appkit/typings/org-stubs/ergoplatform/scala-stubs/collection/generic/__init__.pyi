import java.lang
import java.util.concurrent.atomic
import scala
import scala.collection
import scala.collection.immutable
import scala.collection.mutable
import scala.collection.parallel
import scala.math
import scala.reflect
import scala.runtime
import typing



_BitSetFactory__Coll = typing.TypeVar('_BitSetFactory__Coll', bound=scala.collection.BitSet)  # <Coll>
class BitSetFactory(typing.Generic[_BitSetFactory__Coll]):
    @staticmethod
    def $init$($this: 'BitSetFactory') -> None: ...
    def apply(self, elems: scala.collection.Seq[typing.Any]) -> _BitSetFactory__Coll: ...
    def bitsetCanBuildFrom(self) -> 'CanBuildFrom'[_BitSetFactory__Coll, typing.Any, _BitSetFactory__Coll]: ...
    def empty(self) -> _BitSetFactory__Coll: ...
    def newBuilder(self) -> scala.collection.mutable.Builder[typing.Any, _BitSetFactory__Coll]: ...

_CanBuildFrom__From = typing.TypeVar('_CanBuildFrom__From')  # <From>
_CanBuildFrom__Elem = typing.TypeVar('_CanBuildFrom__Elem')  # <Elem>
_CanBuildFrom__To = typing.TypeVar('_CanBuildFrom__To')  # <To>
class CanBuildFrom(typing.Generic[_CanBuildFrom__From, _CanBuildFrom__Elem, _CanBuildFrom__To]):
    @typing.overload
    def apply(self) -> scala.collection.mutable.Builder[_CanBuildFrom__Elem, _CanBuildFrom__To]: ...
    @typing.overload
    def apply(self, from_: _CanBuildFrom__From) -> scala.collection.mutable.Builder[_CanBuildFrom__Elem, _CanBuildFrom__To]: ...

class Clearable:
    def clear(self) -> None: ...

_FilterMonadic__A = typing.TypeVar('_FilterMonadic__A')  # <A>
_FilterMonadic__Repr = typing.TypeVar('_FilterMonadic__Repr')  # <Repr>
class FilterMonadic(typing.Generic[_FilterMonadic__A, _FilterMonadic__Repr]):
    _flatMap__B = typing.TypeVar('_flatMap__B')  # <B>
    _flatMap__That = typing.TypeVar('_flatMap__That')  # <That>
    def flatMap(self, f: scala.Function1[_FilterMonadic__A, scala.collection.GenTraversableOnce[_flatMap__B]], bf: CanBuildFrom[_FilterMonadic__Repr, _flatMap__B, _flatMap__That]) -> _flatMap__That: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_FilterMonadic__A, _foreach__U]) -> None: ...
    _map__B = typing.TypeVar('_map__B')  # <B>
    _map__That = typing.TypeVar('_map__That')  # <That>
    def map(self, f: scala.Function1[_FilterMonadic__A, _map__B], bf: CanBuildFrom[_FilterMonadic__Repr, _map__B, _map__That]) -> _map__That: ...
    def withFilter(self, p: scala.Function1[_FilterMonadic__A, typing.Any]) -> 'FilterMonadic'[_FilterMonadic__A, _FilterMonadic__Repr]: ...

_GenericClassTagCompanion__CC = typing.TypeVar('_GenericClassTagCompanion__CC', bound=scala.collection.Traversable)  # <CC>
class GenericClassTagCompanion(typing.Generic[_GenericClassTagCompanion__CC]):
    def __init__(self): ...
    _apply__A = typing.TypeVar('_apply__A')  # <A>
    def apply(self, elems: scala.collection.Seq[_apply__A], ord: scala.reflect.ClassTag[_apply__A]) -> _GenericClassTagCompanion__CC: ...
    _empty__A = typing.TypeVar('_empty__A')  # <A>
    def empty(self, evidence$1: scala.reflect.ClassTag[_empty__A]) -> _GenericClassTagCompanion__CC: ...
    _newBuilder__A = typing.TypeVar('_newBuilder__A')  # <A>
    def newBuilder(self, ord: scala.reflect.ClassTag[_newBuilder__A]) -> scala.collection.mutable.Builder[_newBuilder__A, _GenericClassTagCompanion__CC]: ...

_GenericCompanion__CC = typing.TypeVar('_GenericCompanion__CC', bound=scala.collection.GenTraversable)  # <CC>
class GenericCompanion(typing.Generic[_GenericCompanion__CC]):
    def __init__(self): ...
    _apply__A = typing.TypeVar('_apply__A')  # <A>
    def apply(self, elems: scala.collection.Seq[_apply__A]) -> _GenericCompanion__CC: ...
    _empty__A = typing.TypeVar('_empty__A')  # <A>
    def empty(self) -> _GenericCompanion__CC: ...
    _newBuilder__A = typing.TypeVar('_newBuilder__A')  # <A>
    def newBuilder(self) -> scala.collection.mutable.Builder[_newBuilder__A, _GenericCompanion__CC]: ...

_GenericOrderedCompanion__CC = typing.TypeVar('_GenericOrderedCompanion__CC', bound=scala.collection.Traversable)  # <CC>
class GenericOrderedCompanion(typing.Generic[_GenericOrderedCompanion__CC]):
    def __init__(self): ...
    _apply__A = typing.TypeVar('_apply__A')  # <A>
    def apply(self, elems: scala.collection.Seq[_apply__A], ord: scala.math.Ordering[_apply__A]) -> _GenericOrderedCompanion__CC: ...
    _empty__A = typing.TypeVar('_empty__A')  # <A>
    def empty(self, evidence$1: scala.math.Ordering[_empty__A]) -> _GenericOrderedCompanion__CC: ...
    _newBuilder__A = typing.TypeVar('_newBuilder__A')  # <A>
    def newBuilder(self, ord: scala.math.Ordering[_newBuilder__A]) -> scala.collection.mutable.Builder[_newBuilder__A, _GenericOrderedCompanion__CC]: ...

_GenericParCompanion__CC = typing.TypeVar('_GenericParCompanion__CC', bound=scala.collection.parallel.ParIterable)  # <CC>
class GenericParCompanion(typing.Generic[_GenericParCompanion__CC]):
    _newBuilder__A = typing.TypeVar('_newBuilder__A')  # <A>
    def newBuilder(self) -> scala.collection.parallel.Combiner[_newBuilder__A, _GenericParCompanion__CC]: ...
    _newCombiner__A = typing.TypeVar('_newCombiner__A')  # <A>
    def newCombiner(self) -> scala.collection.parallel.Combiner[_newCombiner__A, _GenericParCompanion__CC]: ...

_GenericParMapCompanion__CC = typing.TypeVar('_GenericParMapCompanion__CC', bound=scala.collection.parallel.ParMap)  # <CC>
class GenericParMapCompanion(typing.Generic[_GenericParMapCompanion__CC]):
    _newCombiner__P = typing.TypeVar('_newCombiner__P')  # <P>
    _newCombiner__Q = typing.TypeVar('_newCombiner__Q')  # <Q>
    def newCombiner(self) -> scala.collection.parallel.Combiner[scala.Tuple2[_newCombiner__P, _newCombiner__Q], _GenericParMapCompanion__CC]: ...

_GenericSeqCompanion__CC = typing.TypeVar('_GenericSeqCompanion__CC', bound=scala.collection.Traversable)  # <CC>
class GenericSeqCompanion(typing.Generic[_GenericSeqCompanion__CC]): ...

_HasNewBuilder__A = typing.TypeVar('_HasNewBuilder__A')  # <A>
_HasNewBuilder__Repr = typing.TypeVar('_HasNewBuilder__Repr')  # <Repr>
class HasNewBuilder(typing.Generic[_HasNewBuilder__A, _HasNewBuilder__Repr]):
    def newBuilder(self) -> scala.collection.mutable.Builder[_HasNewBuilder__A, _HasNewBuilder__Repr]: ...

_HasNewCombiner__T = typing.TypeVar('_HasNewCombiner__T')  # <T>
_HasNewCombiner__Repr = typing.TypeVar('_HasNewCombiner__Repr')  # <Repr>
class HasNewCombiner(typing.Generic[_HasNewCombiner__T, _HasNewCombiner__Repr]):
    def newCombiner(self) -> scala.collection.parallel.Combiner[_HasNewCombiner__T, _HasNewCombiner__Repr]: ...

class IdleSignalling:
    @staticmethod
    def abort() -> None: ...
    @staticmethod
    def indexFlag() -> int: ...
    @staticmethod
    def isAborted() -> bool: ...
    @staticmethod
    def setIndexFlag(f: int) -> None: ...
    @staticmethod
    def setIndexFlagIfGreater(f: int) -> None: ...
    @staticmethod
    def setIndexFlagIfLesser(f: int) -> None: ...
    @staticmethod
    def tag() -> int: ...

_IsSeqLike__Repr = typing.TypeVar('_IsSeqLike__Repr')  # <Repr>
class IsSeqLike(typing.Generic[_IsSeqLike__Repr]):
    def conversion(self) -> scala.Function1[_IsSeqLike__Repr, scala.collection.SeqLike[typing.Any, _IsSeqLike__Repr]]: ...
    _seqLikeRepr__C = typing.TypeVar('_seqLikeRepr__C')  # <C>
    _seqLikeRepr__A0 = typing.TypeVar('_seqLikeRepr__A0')  # <A0>
    @staticmethod
    def seqLikeRepr(conv: scala.Function1[_seqLikeRepr__C, scala.collection.SeqLike[_seqLikeRepr__A0, _seqLikeRepr__C]]) -> 'IsSeqLike'[_seqLikeRepr__C]: ...
    @staticmethod
    def stringRepr() -> 'IsSeqLike'[java.lang.String]: ...

_IsTraversableLike__Repr = typing.TypeVar('_IsTraversableLike__Repr')  # <Repr>
class IsTraversableLike(typing.Generic[_IsTraversableLike__Repr]):
    def conversion(self) -> scala.Function1[_IsTraversableLike__Repr, scala.collection.GenTraversableLike[typing.Any, _IsTraversableLike__Repr]]: ...
    _genTraversableLikeRepr__C = typing.TypeVar('_genTraversableLikeRepr__C')  # <C>
    _genTraversableLikeRepr__A0 = typing.TypeVar('_genTraversableLikeRepr__A0')  # <A0>
    @staticmethod
    def genTraversableLikeRepr(conv: scala.Function1[_genTraversableLikeRepr__C, scala.collection.GenTraversableLike[_genTraversableLikeRepr__A0, _genTraversableLikeRepr__C]]) -> 'IsTraversableLike'[_genTraversableLikeRepr__C]: ...
    @staticmethod
    def stringRepr() -> 'IsTraversableLike'[java.lang.String]: ...

_IsTraversableOnce__Repr = typing.TypeVar('_IsTraversableOnce__Repr')  # <Repr>
class IsTraversableOnce(typing.Generic[_IsTraversableOnce__Repr]):
    def conversion(self) -> scala.Function1[_IsTraversableOnce__Repr, scala.collection.GenTraversableOnce[typing.Any]]: ...
    _genTraversableLikeRepr__C = typing.TypeVar('_genTraversableLikeRepr__C')  # <C>
    _genTraversableLikeRepr__A0 = typing.TypeVar('_genTraversableLikeRepr__A0')  # <A0>
    @staticmethod
    def genTraversableLikeRepr(conv: scala.Function1[_genTraversableLikeRepr__C, scala.collection.GenTraversableOnce[_genTraversableLikeRepr__A0]]) -> 'IsTraversableOnce'[_genTraversableLikeRepr__C]: ...
    @staticmethod
    def stringRepr() -> 'IsTraversableOnce'[java.lang.String]: ...

_Shrinkable__A = typing.TypeVar('_Shrinkable__A')  # <A>
class Shrinkable(typing.Generic[_Shrinkable__A]):
    @staticmethod
    def $init$($this: 'Shrinkable') -> None: ...
    @typing.overload
    def $minus$eq(self, elem: _Shrinkable__A) -> 'Shrinkable'[_Shrinkable__A]: ...
    @typing.overload
    def $minus$eq(self, elem1: _Shrinkable__A, elem2: _Shrinkable__A, elems: scala.collection.Seq[_Shrinkable__A]) -> 'Shrinkable'[_Shrinkable__A]: ...
    def $minus$minus$eq(self, xs: scala.collection.TraversableOnce[_Shrinkable__A]) -> 'Shrinkable'[_Shrinkable__A]: ...

class Signalling:
    def abort(self) -> None: ...
    def indexFlag(self) -> int: ...
    def isAborted(self) -> bool: ...
    def setIndexFlag(self, f: int) -> None: ...
    def setIndexFlagIfGreater(self, f: int) -> None: ...
    def setIndexFlagIfLesser(self, f: int) -> None: ...
    def tag(self) -> int: ...

class Sizing:
    def size(self) -> int: ...

class SliceInterval:
    def __init__(self, from_: int, until: int): ...
    @staticmethod
    def apply(from_: int, until: int) -> 'SliceInterval': ...
    @typing.overload
    def recalculate(self, _from: int, _until: int) -> 'SliceInterval': ...
    @typing.overload
    def recalculate(self, interval: 'SliceInterval') -> 'SliceInterval': ...
    def until(self) -> int: ...
    def width(self) -> int: ...

_Sorted__K = typing.TypeVar('_Sorted__K')  # <K>
_Sorted__This = typing.TypeVar('_Sorted__This', bound='Sorted')  # <This>
class Sorted(typing.Generic[_Sorted__K, _Sorted__This]):
    @staticmethod
    def $init$($this: 'Sorted') -> None: ...
    def compare(self, k0: _Sorted__K, k1: _Sorted__K) -> int: ...
    def firstKey(self) -> _Sorted__K: ...
    def hasAll(self, j: scala.collection.Iterator[_Sorted__K]) -> bool: ...
    def keySet(self) -> scala.collection.SortedSet[_Sorted__K]: ...
    def keysIteratorFrom(self, start: _Sorted__K) -> scala.collection.Iterator[_Sorted__K]: ...
    def lastKey(self) -> _Sorted__K: ...
    def ordering(self) -> scala.math.Ordering[_Sorted__K]: ...
    def range(self, from_: _Sorted__K, until: _Sorted__K) -> _Sorted__This: ...
    def rangeImpl(self, from_: scala.Option[_Sorted__K], until: scala.Option[_Sorted__K]) -> _Sorted__This: ...
    def repr(self) -> _Sorted__This: ...
    def to(self, to: _Sorted__K) -> _Sorted__This: ...
    def until(self, until: _Sorted__K) -> _Sorted__This: ...

_Subtractable__A = typing.TypeVar('_Subtractable__A')  # <A>
_Subtractable__Repr = typing.TypeVar('_Subtractable__Repr', bound='Subtractable')  # <Repr>
class Subtractable(typing.Generic[_Subtractable__A, _Subtractable__Repr]):
    @staticmethod
    def $init$($this: 'Subtractable') -> None: ...
    @typing.overload
    def $minus(self, elem: _Subtractable__A) -> _Subtractable__Repr: ...
    @typing.overload
    def $minus(self, elem1: _Subtractable__A, elem2: _Subtractable__A, elems: scala.collection.Seq[_Subtractable__A]) -> _Subtractable__Repr: ...
    def $minus$minus(self, xs: scala.collection.GenTraversableOnce[_Subtractable__A]) -> _Subtractable__Repr: ...
    def repr(self) -> _Subtractable__Repr: ...

_TraversableForwarder__A = typing.TypeVar('_TraversableForwarder__A')  # <A>
class TraversableForwarder(scala.collection.Traversable[_TraversableForwarder__A], typing.Generic[_TraversableForwarder__A]):
    _$colon$bslash__B = typing.TypeVar('_$colon$bslash__B')  # <B>
    def $colon$bslash(self, z: _.colon.bslash__B, op: scala.Function2[_TraversableForwarder__A, _.colon.bslash__B, _.colon.bslash__B]) -> _.colon.bslash__B: ...
    _$div$colon__B = typing.TypeVar('_$div$colon__B')  # <B>
    def $div$colon(self, z: _.div.colon__B, op: scala.Function2[_.div.colon__B, _TraversableForwarder__A, _.div.colon__B]) -> _.div.colon__B: ...
    @staticmethod
    def $init$($this: 'TraversableForwarder') -> None: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder) -> scala.collection.mutable.StringBuilder: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder, sep: typing.Union[java.lang.String, str]) -> scala.collection.mutable.StringBuilder: ...
    @typing.overload
    def addString(self, b: scala.collection.mutable.StringBuilder, start: typing.Union[java.lang.String, str], sep: typing.Union[java.lang.String, str], end: typing.Union[java.lang.String, str]) -> scala.collection.mutable.StringBuilder: ...
    _copyToArray_0__B = typing.TypeVar('_copyToArray_0__B')  # <B>
    _copyToArray_1__B = typing.TypeVar('_copyToArray_1__B')  # <B>
    _copyToArray_2__B = typing.TypeVar('_copyToArray_2__B')  # <B>
    @typing.overload
    def copyToArray(self, xs: typing.Any) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int) -> None: ...
    @typing.overload
    def copyToArray(self, xs: typing.Any, start: int, len: int) -> None: ...
    _copyToBuffer__B = typing.TypeVar('_copyToBuffer__B')  # <B>
    def copyToBuffer(self, dest: scala.collection.mutable.Buffer[_copyToBuffer__B]) -> None: ...
    def count(self, p: scala.Function1[_TraversableForwarder__A, typing.Any]) -> int: ...
    def exists(self, p: scala.Function1[_TraversableForwarder__A, typing.Any]) -> bool: ...
    def find(self, p: scala.Function1[_TraversableForwarder__A, typing.Any]) -> scala.Option[_TraversableForwarder__A]: ...
    _foldLeft__B = typing.TypeVar('_foldLeft__B')  # <B>
    def foldLeft(self, z: _foldLeft__B, op: scala.Function2[_foldLeft__B, _TraversableForwarder__A, _foldLeft__B]) -> _foldLeft__B: ...
    _foldRight__B = typing.TypeVar('_foldRight__B')  # <B>
    def foldRight(self, z: _foldRight__B, op: scala.Function2[_TraversableForwarder__A, _foldRight__B, _foldRight__B]) -> _foldRight__B: ...
    def forall(self, p: scala.Function1[_TraversableForwarder__A, typing.Any]) -> bool: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_TraversableForwarder__A, _foreach__U]) -> None: ...
    def hasDefiniteSize(self) -> bool: ...
    def head(self) -> _TraversableForwarder__A: ...
    def headOption(self) -> scala.Option[_TraversableForwarder__A]: ...
    def isEmpty(self) -> bool: ...
    def last(self) -> _TraversableForwarder__A: ...
    def lastOption(self) -> scala.Option[_TraversableForwarder__A]: ...
    _max__B = typing.TypeVar('_max__B')  # <B>
    def max(self, cmp: scala.math.Ordering[_max__B]) -> _TraversableForwarder__A: ...
    _min__B = typing.TypeVar('_min__B')  # <B>
    def min(self, cmp: scala.math.Ordering[_min__B]) -> _TraversableForwarder__A: ...
    @typing.overload
    def mkString(self) -> java.lang.String: ...
    @typing.overload
    def mkString(self, sep: typing.Union[java.lang.String, str]) -> java.lang.String: ...
    @typing.overload
    def mkString(self, start: typing.Union[java.lang.String, str], sep: typing.Union[java.lang.String, str], end: typing.Union[java.lang.String, str]) -> java.lang.String: ...
    def nonEmpty(self) -> bool: ...
    _product__B = typing.TypeVar('_product__B')  # <B>
    def product(self, num: scala.math.Numeric[_product__B]) -> _product__B: ...
    _reduceLeft__B = typing.TypeVar('_reduceLeft__B')  # <B>
    def reduceLeft(self, op: scala.Function2[_reduceLeft__B, _TraversableForwarder__A, _reduceLeft__B]) -> _reduceLeft__B: ...
    _reduceLeftOption__B = typing.TypeVar('_reduceLeftOption__B')  # <B>
    def reduceLeftOption(self, op: scala.Function2[_reduceLeftOption__B, _TraversableForwarder__A, _reduceLeftOption__B]) -> scala.Option[_reduceLeftOption__B]: ...
    _reduceRight__B = typing.TypeVar('_reduceRight__B')  # <B>
    def reduceRight(self, op: scala.Function2[_TraversableForwarder__A, _reduceRight__B, _reduceRight__B]) -> _reduceRight__B: ...
    _reduceRightOption__B = typing.TypeVar('_reduceRightOption__B')  # <B>
    def reduceRightOption(self, op: scala.Function2[_TraversableForwarder__A, _reduceRightOption__B, _reduceRightOption__B]) -> scala.Option[_reduceRightOption__B]: ...
    def size(self) -> int: ...
    _sum__B = typing.TypeVar('_sum__B')  # <B>
    def sum(self, num: scala.math.Numeric[_sum__B]) -> _sum__B: ...
    _toArray__B = typing.TypeVar('_toArray__B')  # <B>
    def toArray(self, evidence$1: scala.reflect.ClassTag[_toArray__B]) -> typing.Any: ...
    _toBuffer__B = typing.TypeVar('_toBuffer__B')  # <B>
    def toBuffer(self) -> scala.collection.mutable.Buffer[_toBuffer__B]: ...
    def toIndexedSeq(self) -> scala.collection.immutable.IndexedSeq[_TraversableForwarder__A]: ...
    @typing.overload
    def toIterable(self) -> scala.collection.GenIterable[_TraversableForwarder__A]: ...
    @typing.overload
    def toIterable(self) -> scala.collection.Iterable[_TraversableForwarder__A]: ...
    def toList(self) -> scala.collection.immutable.List[_TraversableForwarder__A]: ...
    _toMap_0__K = typing.TypeVar('_toMap_0__K')  # <K>
    _toMap_0__V = typing.TypeVar('_toMap_0__V')  # <V>
    _toMap_1__T = typing.TypeVar('_toMap_1__T')  # <T>
    _toMap_1__U = typing.TypeVar('_toMap_1__U')  # <U>
    @typing.overload
    def toMap(self, ev: scala.Predef..less.colon.less[_TraversableForwarder__A, scala.Tuple2[_toMap_0__K, _toMap_0__V]]) -> scala.collection.GenMap[_toMap_0__K, _toMap_0__V]: ...
    @typing.overload
    def toMap(self, ev: scala.Predef..less.colon.less[_TraversableForwarder__A, scala.Tuple2[_toMap_1__T, _toMap_1__U]]) -> scala.collection.immutable.Map[_toMap_1__T, _toMap_1__U]: ...
    @typing.overload
    def toSeq(self) -> scala.collection.GenSeq[_TraversableForwarder__A]: ...
    @typing.overload
    def toSeq(self) -> scala.collection.Seq[_TraversableForwarder__A]: ...
    _toSet_0__A1 = typing.TypeVar('_toSet_0__A1')  # <A1>
    _toSet_1__B = typing.TypeVar('_toSet_1__B')  # <B>
    @typing.overload
    def toSet(self) -> scala.collection.GenSet[_toSet_0__A1]: ...
    @typing.overload
    def toSet(self) -> scala.collection.immutable.Set[_toSet_1__B]: ...
    def toStream(self) -> scala.collection.immutable.Stream[_TraversableForwarder__A]: ...
    def toString(self) -> java.lang.String: ...
    def underlying(self) -> scala.collection.Traversable[_TraversableForwarder__A]: ...

class package: ...

class AtomicIndexFlag(Signalling):
    @staticmethod
    def $init$($this: 'AtomicIndexFlag') -> None: ...
    def indexFlag(self) -> int: ...
    def scala$collection$generic$AtomicIndexFlag$$intflag(self) -> java.util.concurrent.atomic.AtomicInteger: ...
    def scala$collection$generic$AtomicIndexFlag$_setter_$scala$collection$generic$AtomicIndexFlag$$intflag_$eq(self, x$1: java.util.concurrent.atomic.AtomicInteger) -> None: ...
    def setIndexFlag(self, f: int) -> None: ...
    def setIndexFlagIfGreater(self, f: int) -> None: ...
    def setIndexFlagIfLesser(self, f: int) -> None: ...

_CanCombineFrom__From = typing.TypeVar('_CanCombineFrom__From')  # <From>
_CanCombineFrom__Elem = typing.TypeVar('_CanCombineFrom__Elem')  # <Elem>
_CanCombineFrom__To = typing.TypeVar('_CanCombineFrom__To')  # <To>
class CanCombineFrom(CanBuildFrom[_CanCombineFrom__From, _CanCombineFrom__Elem, _CanCombineFrom__To], scala.collection.Parallel, typing.Generic[_CanCombineFrom__From, _CanCombineFrom__Elem, _CanCombineFrom__To]):
    @typing.overload
    def apply(self) -> scala.collection.mutable.Builder[_CanCombineFrom__Elem, _CanCombineFrom__To]: ...
    @typing.overload
    def apply(self, from_: _CanCombineFrom__From) -> scala.collection.mutable.Builder[_CanCombineFrom__Elem, _CanCombineFrom__To]: ...
    @typing.overload
    def apply(self) -> scala.collection.parallel.Combiner[_CanCombineFrom__Elem, _CanCombineFrom__To]: ...
    @typing.overload
    def apply(self, from_: _CanCombineFrom__From) -> scala.collection.parallel.Combiner[_CanCombineFrom__Elem, _CanCombineFrom__To]: ...

_ClassTagTraversableFactory__GenericCanBuildFrom__A = typing.TypeVar('_ClassTagTraversableFactory__GenericCanBuildFrom__A')  # <A>
_ClassTagTraversableFactory__CC = typing.TypeVar('_ClassTagTraversableFactory__CC', bound=scala.collection.Traversable)  # <CC>
class ClassTagTraversableFactory(GenericClassTagCompanion[_ClassTagTraversableFactory__CC], typing.Generic[_ClassTagTraversableFactory__CC]):
    def __init__(self): ...
    class GenericCanBuildFrom(CanBuildFrom[_ClassTagTraversableFactory__CC, _ClassTagTraversableFactory__GenericCanBuildFrom__A, _ClassTagTraversableFactory__CC], typing.Generic[_ClassTagTraversableFactory__GenericCanBuildFrom__A]):
        $outer: 'ClassTagTraversableFactory' = ...
        def __init__(self, $outer: 'ClassTagTraversableFactory', tag: scala.reflect.ClassTag[_ClassTagTraversableFactory__GenericCanBuildFrom__A]): ...
        @typing.overload
        def apply(self) -> scala.collection.mutable.Builder[_ClassTagTraversableFactory__GenericCanBuildFrom__A, _ClassTagTraversableFactory__CC]: ...
        @typing.overload
        def apply(self, from_: _ClassTagTraversableFactory__CC) -> scala.collection.mutable.Builder[_ClassTagTraversableFactory__GenericCanBuildFrom__A, _ClassTagTraversableFactory__CC]: ...

class DelegatedSignalling(Signalling):
    @staticmethod
    def $init$($this: 'DelegatedSignalling') -> None: ...
    def abort(self) -> None: ...
    def indexFlag(self) -> int: ...
    def isAborted(self) -> bool: ...
    def setIndexFlag(self, f: int) -> None: ...
    def setIndexFlagIfGreater(self, f: int) -> None: ...
    def setIndexFlagIfLesser(self, f: int) -> None: ...
    def signalDelegate(self) -> Signalling: ...
    def signalDelegate_$eq(self, x$1: Signalling) -> None: ...
    def tag(self) -> int: ...

_GenMapFactory__MapCanBuildFrom__A = typing.TypeVar('_GenMapFactory__MapCanBuildFrom__A')  # <A>
_GenMapFactory__MapCanBuildFrom__B = typing.TypeVar('_GenMapFactory__MapCanBuildFrom__B')  # <B>
_GenMapFactory__CC = typing.TypeVar('_GenMapFactory__CC', bound=scala.collection.GenMap)  # <CC>
class GenMapFactory(typing.Generic[_GenMapFactory__CC]):
    def __init__(self): ...
    _apply__A = typing.TypeVar('_apply__A')  # <A>
    _apply__B = typing.TypeVar('_apply__B')  # <B>
    def apply(self, elems: scala.collection.Seq[scala.Tuple2[_apply__A, _apply__B]]) -> _GenMapFactory__CC: ...
    _empty__A = typing.TypeVar('_empty__A')  # <A>
    _empty__B = typing.TypeVar('_empty__B')  # <B>
    def empty(self) -> _GenMapFactory__CC: ...
    _newBuilder__A = typing.TypeVar('_newBuilder__A')  # <A>
    _newBuilder__B = typing.TypeVar('_newBuilder__B')  # <B>
    def newBuilder(self) -> scala.collection.mutable.Builder[scala.Tuple2[_newBuilder__A, _newBuilder__B], _GenMapFactory__CC]: ...
    class MapCanBuildFrom(CanBuildFrom[_GenMapFactory__CC, scala.Tuple2[_GenMapFactory__MapCanBuildFrom__A, _GenMapFactory__MapCanBuildFrom__B], _GenMapFactory__CC], typing.Generic[_GenMapFactory__MapCanBuildFrom__A, _GenMapFactory__MapCanBuildFrom__B]):
        $outer: 'GenMapFactory' = ...
        def __init__(self, $outer: 'GenMapFactory'): ...
        @typing.overload
        def apply(self) -> scala.collection.mutable.Builder[scala.Tuple2[_GenMapFactory__MapCanBuildFrom__A, _GenMapFactory__MapCanBuildFrom__B], _GenMapFactory__CC]: ...
        @typing.overload
        def apply(self, from_: _GenMapFactory__CC) -> scala.collection.mutable.Builder[scala.Tuple2[_GenMapFactory__MapCanBuildFrom__A, _GenMapFactory__MapCanBuildFrom__B], _GenMapFactory__CC]: ...

_GenSetFactory__CC = typing.TypeVar('_GenSetFactory__CC', bound=scala.collection.GenSet)  # <CC>
class GenSetFactory(GenericCompanion[_GenSetFactory__CC], typing.Generic[_GenSetFactory__CC]):
    def __init__(self): ...
    _newBuilder__A = typing.TypeVar('_newBuilder__A')  # <A>
    def newBuilder(self) -> scala.collection.mutable.Builder[_newBuilder__A, _GenSetFactory__CC]: ...
    _setCanBuildFrom__A = typing.TypeVar('_setCanBuildFrom__A')  # <A>
    def setCanBuildFrom(self) -> CanBuildFrom[_GenSetFactory__CC, _setCanBuildFrom__A, _GenSetFactory__CC]: ...

_GenTraversableFactory__GenericCanBuildFrom__A = typing.TypeVar('_GenTraversableFactory__GenericCanBuildFrom__A')  # <A>
_GenTraversableFactory__CC = typing.TypeVar('_GenTraversableFactory__CC', bound=scala.collection.GenTraversable)  # <CC>
class GenTraversableFactory(GenericCompanion[_GenTraversableFactory__CC], typing.Generic[_GenTraversableFactory__CC]):
    def __init__(self): ...
    def ReusableCBF(self) -> 'GenTraversableFactory.GenericCanBuildFrom'[scala.runtime.Nothing.]: ...
    _concat__A = typing.TypeVar('_concat__A')  # <A>
    def concat(self, xss: scala.collection.Seq[scala.collection.Traversable[_concat__A]]) -> _GenTraversableFactory__CC: ...
    _fill_0__A = typing.TypeVar('_fill_0__A')  # <A>
    _fill_1__A = typing.TypeVar('_fill_1__A')  # <A>
    _fill_2__A = typing.TypeVar('_fill_2__A')  # <A>
    _fill_3__A = typing.TypeVar('_fill_3__A')  # <A>
    _fill_4__A = typing.TypeVar('_fill_4__A')  # <A>
    @typing.overload
    def fill(self, n1: int, n2: int, n3: int, n4: int, n5: int, elem: scala.Function0[_fill_0__A]) -> _GenTraversableFactory__CC: ...
    @typing.overload
    def fill(self, n1: int, n2: int, n3: int, n4: int, elem: scala.Function0[_fill_1__A]) -> _GenTraversableFactory__CC: ...
    @typing.overload
    def fill(self, n1: int, n2: int, n3: int, elem: scala.Function0[_fill_2__A]) -> _GenTraversableFactory__CC: ...
    @typing.overload
    def fill(self, n1: int, n2: int, elem: scala.Function0[_fill_3__A]) -> _GenTraversableFactory__CC: ...
    @typing.overload
    def fill(self, n: int, elem: scala.Function0[_fill_4__A]) -> _GenTraversableFactory__CC: ...
    _iterate__A = typing.TypeVar('_iterate__A')  # <A>
    def iterate(self, start: _iterate__A, len: int, f: scala.Function1[_iterate__A, _iterate__A]) -> _GenTraversableFactory__CC: ...
    _range_0__T = typing.TypeVar('_range_0__T')  # <T>
    _range_1__T = typing.TypeVar('_range_1__T')  # <T>
    @typing.overload
    def range(self, start: _range_0__T, end: _range_0__T, step: _range_0__T, evidence$2: scala.math.Integral[_range_0__T]) -> _GenTraversableFactory__CC: ...
    @typing.overload
    def range(self, start: _range_1__T, end: _range_1__T, evidence$1: scala.math.Integral[_range_1__T]) -> _GenTraversableFactory__CC: ...
    _tabulate_0__A = typing.TypeVar('_tabulate_0__A')  # <A>
    _tabulate_1__A = typing.TypeVar('_tabulate_1__A')  # <A>
    _tabulate_2__A = typing.TypeVar('_tabulate_2__A')  # <A>
    _tabulate_3__A = typing.TypeVar('_tabulate_3__A')  # <A>
    _tabulate_4__A = typing.TypeVar('_tabulate_4__A')  # <A>
    @typing.overload
    def tabulate(self, n1: int, n2: int, n3: int, n4: int, n5: int, f: scala.Function5[typing.Any, typing.Any, typing.Any, typing.Any, typing.Any, _tabulate_0__A]) -> _GenTraversableFactory__CC: ...
    @typing.overload
    def tabulate(self, n1: int, n2: int, n3: int, n4: int, f: scala.Function4[typing.Any, typing.Any, typing.Any, typing.Any, _tabulate_1__A]) -> _GenTraversableFactory__CC: ...
    @typing.overload
    def tabulate(self, n1: int, n2: int, n3: int, f: scala.Function3[typing.Any, typing.Any, typing.Any, _tabulate_2__A]) -> _GenTraversableFactory__CC: ...
    @typing.overload
    def tabulate(self, n1: int, n2: int, f: scala.Function2[typing.Any, typing.Any, _tabulate_3__A]) -> _GenTraversableFactory__CC: ...
    @typing.overload
    def tabulate(self, n: int, f: scala.Function1[typing.Any, _tabulate_4__A]) -> _GenTraversableFactory__CC: ...
    class GenericCanBuildFrom(CanBuildFrom[_GenTraversableFactory__CC, _GenTraversableFactory__GenericCanBuildFrom__A, _GenTraversableFactory__CC], typing.Generic[_GenTraversableFactory__GenericCanBuildFrom__A]):
        $outer: 'GenTraversableFactory' = ...
        def __init__(self, $outer: 'GenTraversableFactory'): ...
        @typing.overload
        def apply(self) -> scala.collection.mutable.Builder[_GenTraversableFactory__GenericCanBuildFrom__A, _GenTraversableFactory__CC]: ...
        @typing.overload
        def apply(self, from_: _GenTraversableFactory__CC) -> scala.collection.mutable.Builder[_GenTraversableFactory__GenericCanBuildFrom__A, _GenTraversableFactory__CC]: ...

_GenericClassTagTraversableTemplate__A = typing.TypeVar('_GenericClassTagTraversableTemplate__A')  # <A>
_GenericClassTagTraversableTemplate__CC = typing.TypeVar('_GenericClassTagTraversableTemplate__CC', bound=scala.collection.Traversable)  # <CC>
class GenericClassTagTraversableTemplate(HasNewBuilder[_GenericClassTagTraversableTemplate__A, _GenericClassTagTraversableTemplate__CC], typing.Generic[_GenericClassTagTraversableTemplate__A, _GenericClassTagTraversableTemplate__CC]):
    @staticmethod
    def $init$($this: 'GenericClassTagTraversableTemplate') -> None: ...
    def classManifestCompanion(self) -> GenericClassTagCompanion[_GenericClassTagTraversableTemplate__CC]: ...
    def classTagCompanion(self) -> GenericClassTagCompanion[_GenericClassTagTraversableTemplate__CC]: ...
    _genericClassManifestBuilder__B = typing.TypeVar('_genericClassManifestBuilder__B')  # <B>
    def genericClassManifestBuilder(self, manifest: scala.reflect.ClassTag[_genericClassManifestBuilder__B]) -> scala.collection.mutable.Builder[_genericClassManifestBuilder__B, _GenericClassTagTraversableTemplate__CC]: ...
    _genericClassTagBuilder__B = typing.TypeVar('_genericClassTagBuilder__B')  # <B>
    def genericClassTagBuilder(self, tag: scala.reflect.ClassTag[_genericClassTagBuilder__B]) -> scala.collection.mutable.Builder[_genericClassTagBuilder__B, _GenericClassTagTraversableTemplate__CC]: ...
    def tag(self) -> scala.reflect.ClassTag[_GenericClassTagTraversableTemplate__A]: ...

_GenericOrderedTraversableTemplate__A = typing.TypeVar('_GenericOrderedTraversableTemplate__A')  # <A>
_GenericOrderedTraversableTemplate__CC = typing.TypeVar('_GenericOrderedTraversableTemplate__CC', bound=scala.collection.Traversable)  # <CC>
class GenericOrderedTraversableTemplate(HasNewBuilder[_GenericOrderedTraversableTemplate__A, _GenericOrderedTraversableTemplate__CC], typing.Generic[_GenericOrderedTraversableTemplate__A, _GenericOrderedTraversableTemplate__CC]):
    @staticmethod
    def $init$($this: 'GenericOrderedTraversableTemplate') -> None: ...
    _genericOrderedBuilder__B = typing.TypeVar('_genericOrderedBuilder__B')  # <B>
    def genericOrderedBuilder(self, ord: scala.math.Ordering[_genericOrderedBuilder__B]) -> scala.collection.mutable.Builder[_genericOrderedBuilder__B, _GenericOrderedTraversableTemplate__CC]: ...
    def ord(self) -> scala.math.Ordering[_GenericOrderedTraversableTemplate__A]: ...
    def orderedCompanion(self) -> GenericOrderedCompanion[_GenericOrderedTraversableTemplate__CC]: ...

_GenericTraversableTemplate__A = typing.TypeVar('_GenericTraversableTemplate__A')  # <A>
_GenericTraversableTemplate__CC = typing.TypeVar('_GenericTraversableTemplate__CC', bound=scala.collection.GenTraversable)  # <CC>
class GenericTraversableTemplate(HasNewBuilder[_GenericTraversableTemplate__A, _GenericTraversableTemplate__CC], typing.Generic[_GenericTraversableTemplate__A, _GenericTraversableTemplate__CC]):
    @staticmethod
    def $init$($this: 'GenericTraversableTemplate') -> None: ...
    def companion(self) -> GenericCompanion[_GenericTraversableTemplate__CC]: ...
    _flatten__B = typing.TypeVar('_flatten__B')  # <B>
    def flatten(self, asTraversable: scala.Function1[_GenericTraversableTemplate__A, scala.collection.GenTraversableOnce[_flatten__B]]) -> _GenericTraversableTemplate__CC: ...
    _foreach__U = typing.TypeVar('_foreach__U')  # <U>
    def foreach(self, f: scala.Function1[_GenericTraversableTemplate__A, _foreach__U]) -> None: ...
    _genericBuilder__B = typing.TypeVar('_genericBuilder__B')  # <B>
    def genericBuilder(self) -> scala.collection.mutable.Builder[_genericBuilder__B, _GenericTraversableTemplate__CC]: ...
    def head(self) -> _GenericTraversableTemplate__A: ...
    def isEmpty(self) -> bool: ...
    def newBuilder(self) -> scala.collection.mutable.Builder[_GenericTraversableTemplate__A, _GenericTraversableTemplate__CC]: ...
    _transpose__B = typing.TypeVar('_transpose__B')  # <B>
    def transpose(self, asTraversable: scala.Function1[_GenericTraversableTemplate__A, scala.collection.GenTraversableOnce[_transpose__B]]) -> _GenericTraversableTemplate__CC: ...
    _unzip__A1 = typing.TypeVar('_unzip__A1')  # <A1>
    _unzip__A2 = typing.TypeVar('_unzip__A2')  # <A2>
    def unzip(self, asPair: scala.Function1[_GenericTraversableTemplate__A, scala.Tuple2[_unzip__A1, _unzip__A2]]) -> scala.Tuple2[_GenericTraversableTemplate__CC, _GenericTraversableTemplate__CC]: ...
    _unzip3__A1 = typing.TypeVar('_unzip3__A1')  # <A1>
    _unzip3__A2 = typing.TypeVar('_unzip3__A2')  # <A2>
    _unzip3__A3 = typing.TypeVar('_unzip3__A3')  # <A3>
    def unzip3(self, asTriple: scala.Function1[_GenericTraversableTemplate__A, scala.Tuple3[_unzip3__A1, _unzip3__A2, _unzip3__A3]]) -> scala.Tuple3[_GenericTraversableTemplate__CC, _GenericTraversableTemplate__CC, _GenericTraversableTemplate__CC]: ...

_Growable__A = typing.TypeVar('_Growable__A')  # <A>
class Growable(Clearable, typing.Generic[_Growable__A]):
    @staticmethod
    def $init$($this: 'Growable') -> None: ...
    @typing.overload
    def $plus$eq(self, elem: _Growable__A) -> 'Growable'[_Growable__A]: ...
    @typing.overload
    def $plus$eq(self, elem1: _Growable__A, elem2: _Growable__A, elems: scala.collection.Seq[_Growable__A]) -> 'Growable'[_Growable__A]: ...
    def $plus$plus$eq(self, xs: scala.collection.TraversableOnce[_Growable__A]) -> 'Growable'[_Growable__A]: ...
    def clear(self) -> None: ...

_IterableForwarder__A = typing.TypeVar('_IterableForwarder__A')  # <A>
class IterableForwarder(scala.collection.Iterable[_IterableForwarder__A], TraversableForwarder[_IterableForwarder__A], typing.Generic[_IterableForwarder__A]):
    @staticmethod
    def $init$($this: 'IterableForwarder') -> None: ...
    def equals(self, that: typing.Any) -> bool: ...
    def iterator(self) -> scala.collection.Iterator[_IterableForwarder__A]: ...
    _sameElements__B = typing.TypeVar('_sameElements__B')  # <B>
    def sameElements(self, that: scala.collection.GenIterable[_sameElements__B]) -> bool: ...
    def toString(self) -> java.lang.String: ...
    @typing.overload
    def underlying(self) -> scala.collection.Iterable[_IterableForwarder__A]: ...
    @typing.overload
    def underlying(self) -> scala.collection.Traversable[_IterableForwarder__A]: ...

_OrderedTraversableFactory__GenericCanBuildFrom__A = typing.TypeVar('_OrderedTraversableFactory__GenericCanBuildFrom__A')  # <A>
_OrderedTraversableFactory__CC = typing.TypeVar('_OrderedTraversableFactory__CC', bound=scala.collection.Traversable)  # <CC>
class OrderedTraversableFactory(GenericOrderedCompanion[_OrderedTraversableFactory__CC], typing.Generic[_OrderedTraversableFactory__CC]):
    def __init__(self): ...
    class GenericCanBuildFrom(CanBuildFrom[_OrderedTraversableFactory__CC, _OrderedTraversableFactory__GenericCanBuildFrom__A, _OrderedTraversableFactory__CC], typing.Generic[_OrderedTraversableFactory__GenericCanBuildFrom__A]):
        $outer: 'OrderedTraversableFactory' = ...
        def __init__(self, $outer: 'OrderedTraversableFactory', ord: scala.math.Ordering[_OrderedTraversableFactory__GenericCanBuildFrom__A]): ...
        @typing.overload
        def apply(self) -> scala.collection.mutable.Builder[_OrderedTraversableFactory__GenericCanBuildFrom__A, _OrderedTraversableFactory__CC]: ...
        @typing.overload
        def apply(self, from_: _OrderedTraversableFactory__CC) -> scala.collection.mutable.Builder[_OrderedTraversableFactory__GenericCanBuildFrom__A, _OrderedTraversableFactory__CC]: ...

_SortedMapFactory__SortedMapCanBuildFrom__A = typing.TypeVar('_SortedMapFactory__SortedMapCanBuildFrom__A')  # <A>
_SortedMapFactory__SortedMapCanBuildFrom__B = typing.TypeVar('_SortedMapFactory__SortedMapCanBuildFrom__B')  # <B>
_SortedMapFactory__CC = typing.TypeVar('_SortedMapFactory__CC', bound=scala.collection.SortedMap)  # <CC>
class SortedMapFactory(typing.Generic[_SortedMapFactory__CC]):
    def __init__(self): ...
    _apply__A = typing.TypeVar('_apply__A')  # <A>
    _apply__B = typing.TypeVar('_apply__B')  # <B>
    def apply(self, elems: scala.collection.Seq[scala.Tuple2[_apply__A, _apply__B]], ord: scala.math.Ordering[_apply__A]) -> _SortedMapFactory__CC: ...
    _empty__A = typing.TypeVar('_empty__A')  # <A>
    _empty__B = typing.TypeVar('_empty__B')  # <B>
    def empty(self, ord: scala.math.Ordering[_empty__A]) -> _SortedMapFactory__CC: ...
    _newBuilder__A = typing.TypeVar('_newBuilder__A')  # <A>
    _newBuilder__B = typing.TypeVar('_newBuilder__B')  # <B>
    def newBuilder(self, ord: scala.math.Ordering[_newBuilder__A]) -> scala.collection.mutable.Builder[scala.Tuple2[_newBuilder__A, _newBuilder__B], _SortedMapFactory__CC]: ...
    class SortedMapCanBuildFrom(CanBuildFrom[_SortedMapFactory__CC, scala.Tuple2[_SortedMapFactory__SortedMapCanBuildFrom__A, _SortedMapFactory__SortedMapCanBuildFrom__B], _SortedMapFactory__CC], typing.Generic[_SortedMapFactory__SortedMapCanBuildFrom__A, _SortedMapFactory__SortedMapCanBuildFrom__B]):
        $outer: 'SortedMapFactory' = ...
        def __init__(self, $outer: 'SortedMapFactory', ord: scala.math.Ordering[_SortedMapFactory__SortedMapCanBuildFrom__A]): ...
        @typing.overload
        def apply(self) -> scala.collection.mutable.Builder[scala.Tuple2[_SortedMapFactory__SortedMapCanBuildFrom__A, _SortedMapFactory__SortedMapCanBuildFrom__B], _SortedMapFactory__CC]: ...
        @typing.overload
        def apply(self, from_: _SortedMapFactory__CC) -> scala.collection.mutable.Builder[scala.Tuple2[_SortedMapFactory__SortedMapCanBuildFrom__A, _SortedMapFactory__SortedMapCanBuildFrom__B], _SortedMapFactory__CC]: ...

_SortedSetFactory__SortedSetCanBuildFrom__A = typing.TypeVar('_SortedSetFactory__SortedSetCanBuildFrom__A')  # <A>
_SortedSetFactory__CC = typing.TypeVar('_SortedSetFactory__CC', bound=scala.collection.SortedSet)  # <CC>
class SortedSetFactory(typing.Generic[_SortedSetFactory__CC]):
    def __init__(self): ...
    _apply__A = typing.TypeVar('_apply__A')  # <A>
    def apply(self, elems: scala.collection.Seq[_apply__A], ord: scala.math.Ordering[_apply__A]) -> _SortedSetFactory__CC: ...
    _empty__A = typing.TypeVar('_empty__A')  # <A>
    def empty(self, ord: scala.math.Ordering[_empty__A]) -> _SortedSetFactory__CC: ...
    _newBuilder__A = typing.TypeVar('_newBuilder__A')  # <A>
    def newBuilder(self, ord: scala.math.Ordering[_newBuilder__A]) -> scala.collection.mutable.Builder[_newBuilder__A, _SortedSetFactory__CC]: ...
    _newCanBuildFrom__A = typing.TypeVar('_newCanBuildFrom__A')  # <A>
    def newCanBuildFrom(self, ord: scala.math.Ordering[_newCanBuildFrom__A]) -> CanBuildFrom[_SortedSetFactory__CC, _newCanBuildFrom__A, _SortedSetFactory__CC]: ...
    class SortedSetCanBuildFrom(CanBuildFrom[_SortedSetFactory__CC, _SortedSetFactory__SortedSetCanBuildFrom__A, _SortedSetFactory__CC], typing.Generic[_SortedSetFactory__SortedSetCanBuildFrom__A]):
        $outer: 'SortedSetFactory' = ...
        def __init__(self, $outer: 'SortedSetFactory', ord: scala.math.Ordering[_SortedSetFactory__SortedSetCanBuildFrom__A]): ...
        @typing.overload
        def apply(self) -> scala.collection.mutable.Builder[_SortedSetFactory__SortedSetCanBuildFrom__A, _SortedSetFactory__CC]: ...
        @typing.overload
        def apply(self, from_: _SortedSetFactory__CC) -> scala.collection.mutable.Builder[_SortedSetFactory__SortedSetCanBuildFrom__A, _SortedSetFactory__CC]: ...

_TraversableFactory__CC = typing.TypeVar('_TraversableFactory__CC', bound=scala.collection.Traversable)  # <CC>
class TraversableFactory(GenericSeqCompanion[_TraversableFactory__CC], typing.Generic[_TraversableFactory__CC]): ...

class VolatileAbort(Signalling):
    @staticmethod
    def $init$($this: 'VolatileAbort') -> None: ...
    def abort(self) -> None: ...
    def isAborted(self) -> bool: ...
    def scala$collection$generic$VolatileAbort$$abortflag(self) -> bool: ...
    def scala$collection$generic$VolatileAbort$$abortflag_$eq(self, x$1: bool) -> None: ...

class DefaultSignalling(VolatileAbort):
    def __init__(self): ...
    def abort(self) -> None: ...
    def indexFlag(self) -> int: ...
    def isAborted(self) -> bool: ...
    def scala$collection$generic$VolatileAbort$$abortflag(self) -> bool: ...
    def scala$collection$generic$VolatileAbort$$abortflag_$eq(self, x$1: bool) -> None: ...
    def setIndexFlag(self, f: int) -> None: ...
    def setIndexFlagIfGreater(self, f: int) -> None: ...
    def setIndexFlagIfLesser(self, f: int) -> None: ...
    def tag(self) -> int: ...

class DelegatedContext(DelegatedSignalling):
    def __init__(self, signalDelegate: Signalling): ...
    def abort(self) -> None: ...
    def indexFlag(self) -> int: ...
    def isAborted(self) -> bool: ...
    def setIndexFlag(self, f: int) -> None: ...
    def setIndexFlagIfGreater(self, f: int) -> None: ...
    def setIndexFlagIfLesser(self, f: int) -> None: ...
    def signalDelegate(self) -> Signalling: ...
    def signalDelegate_$eq(self, x$1: Signalling) -> None: ...
    def tag(self) -> int: ...

_GenSeqFactory__CC = typing.TypeVar('_GenSeqFactory__CC', bound=scala.collection.GenSeq)  # <CC>
class GenSeqFactory(GenTraversableFactory[_GenSeqFactory__CC], typing.Generic[_GenSeqFactory__CC]):
    def __init__(self): ...

_GenericParTemplate__A = typing.TypeVar('_GenericParTemplate__A')  # <A>
_GenericParTemplate__CC = typing.TypeVar('_GenericParTemplate__CC', bound=scala.collection.parallel.ParIterable)  # <CC>
class GenericParTemplate(GenericTraversableTemplate[_GenericParTemplate__A, _GenericParTemplate__CC], HasNewCombiner[_GenericParTemplate__A, _GenericParTemplate__CC], typing.Generic[_GenericParTemplate__A, _GenericParTemplate__CC]):
    @staticmethod
    def $init$($this: 'GenericParTemplate') -> None: ...
    def companion(self) -> GenericCompanion[_GenericParTemplate__CC]: ...
    _genericBuilder_0__B = typing.TypeVar('_genericBuilder_0__B')  # <B>
    _genericBuilder_1__B = typing.TypeVar('_genericBuilder_1__B')  # <B>
    @typing.overload
    def genericBuilder(self) -> scala.collection.mutable.Builder[_genericBuilder_0__B, _GenericParTemplate__CC]: ...
    @typing.overload
    def genericBuilder(self) -> scala.collection.parallel.Combiner[_genericBuilder_1__B, _GenericParTemplate__CC]: ...
    _genericCombiner__B = typing.TypeVar('_genericCombiner__B')  # <B>
    def genericCombiner(self) -> scala.collection.parallel.Combiner[_genericCombiner__B, _GenericParTemplate__CC]: ...
    def newBuilder(self) -> scala.collection.mutable.Builder[_GenericParTemplate__A, _GenericParTemplate__CC]: ...
    def newCombiner(self) -> scala.collection.parallel.Combiner[_GenericParTemplate__A, _GenericParTemplate__CC]: ...

_GenericSetTemplate__A = typing.TypeVar('_GenericSetTemplate__A')  # <A>
_GenericSetTemplate__CC = typing.TypeVar('_GenericSetTemplate__CC', bound=scala.collection.GenSet)  # <CC>
class GenericSetTemplate(GenericTraversableTemplate[_GenericSetTemplate__A, _GenericSetTemplate__CC], typing.Generic[_GenericSetTemplate__A, _GenericSetTemplate__CC]):
    @staticmethod
    def $init$($this: 'GenericSetTemplate') -> None: ...
    def empty(self) -> _GenericSetTemplate__CC: ...

_ImmutableSortedMapFactory__CC = typing.TypeVar('_ImmutableSortedMapFactory__CC', bound=scala.collection.immutable.SortedMap)  # <CC>
class ImmutableSortedMapFactory(SortedMapFactory[_ImmutableSortedMapFactory__CC], typing.Generic[_ImmutableSortedMapFactory__CC]):
    def __init__(self): ...

_ImmutableSortedSetFactory__CC = typing.TypeVar('_ImmutableSortedSetFactory__CC', bound=scala.collection.immutable.SortedSet)  # <CC>
class ImmutableSortedSetFactory(SortedSetFactory[_ImmutableSortedSetFactory__CC], typing.Generic[_ImmutableSortedSetFactory__CC]):
    def __init__(self): ...

_MapFactory__CC = typing.TypeVar('_MapFactory__CC', bound=scala.collection.Map)  # <CC>
class MapFactory(GenMapFactory[_MapFactory__CC], typing.Generic[_MapFactory__CC]):
    def __init__(self): ...
    _empty_0__A = typing.TypeVar('_empty_0__A')  # <A>
    _empty_0__B = typing.TypeVar('_empty_0__B')  # <B>
    _empty_1__A = typing.TypeVar('_empty_1__A')  # <A>
    _empty_1__B = typing.TypeVar('_empty_1__B')  # <B>
    @typing.overload
    def empty(self) -> _MapFactory__CC: ...
    @typing.overload
    def empty(self) -> _MapFactory__CC: ...

_MutableSortedMapFactory__CC = typing.TypeVar('_MutableSortedMapFactory__CC', bound=scala.collection.mutable.SortedMap)  # <CC>
class MutableSortedMapFactory(SortedMapFactory[_MutableSortedMapFactory__CC], typing.Generic[_MutableSortedMapFactory__CC]):
    def __init__(self): ...

_MutableSortedSetFactory__CC = typing.TypeVar('_MutableSortedSetFactory__CC', bound=scala.collection.mutable.SortedSet)  # <CC>
class MutableSortedSetFactory(SortedSetFactory[_MutableSortedSetFactory__CC], typing.Generic[_MutableSortedSetFactory__CC]):
    def __init__(self): ...
    _newBuilder__A = typing.TypeVar('_newBuilder__A')  # <A>
    def newBuilder(self, ord: scala.math.Ordering[_newBuilder__A]) -> scala.collection.mutable.Builder[_newBuilder__A, _MutableSortedSetFactory__CC]: ...

_ParFactory__GenericCanCombineFrom__A = typing.TypeVar('_ParFactory__GenericCanCombineFrom__A')  # <A>
_ParFactory__CC = typing.TypeVar('_ParFactory__CC', bound=scala.collection.parallel.ParIterable)  # <CC>
class ParFactory(GenTraversableFactory[_ParFactory__CC], GenericParCompanion[_ParFactory__CC], typing.Generic[_ParFactory__CC]):
    def __init__(self): ...
    class GenericCanCombineFrom(GenTraversableFactory.GenericCanBuildFrom[_ParFactory__GenericCanCombineFrom__A], CanCombineFrom[_ParFactory__CC, _ParFactory__GenericCanCombineFrom__A, _ParFactory__CC], typing.Generic[_ParFactory__GenericCanCombineFrom__A]):
        def __init__(self, $outer: 'ParFactory'): ...
        @typing.overload
        def apply(self) -> scala.collection.parallel.Combiner[_ParFactory__GenericCanCombineFrom__A, _ParFactory__CC]: ...
        @typing.overload
        def apply(self, from_: _ParFactory__CC) -> scala.collection.parallel.Combiner[_ParFactory__GenericCanCombineFrom__A, _ParFactory__CC]: ...

_ParMapFactory__CanCombineFromMap__K = typing.TypeVar('_ParMapFactory__CanCombineFromMap__K')  # <K>
_ParMapFactory__CanCombineFromMap__V = typing.TypeVar('_ParMapFactory__CanCombineFromMap__V')  # <V>
_ParMapFactory__CC = typing.TypeVar('_ParMapFactory__CC', bound=scala.collection.parallel.ParMap)  # <CC>
class ParMapFactory(GenMapFactory[_ParMapFactory__CC], GenericParMapCompanion[_ParMapFactory__CC], typing.Generic[_ParMapFactory__CC]):
    def __init__(self): ...
    _newBuilder__K = typing.TypeVar('_newBuilder__K')  # <K>
    _newBuilder__V = typing.TypeVar('_newBuilder__V')  # <V>
    def newBuilder(self) -> scala.collection.mutable.Builder[scala.Tuple2[_newBuilder__K, _newBuilder__V], _ParMapFactory__CC]: ...
    _newCombiner__K = typing.TypeVar('_newCombiner__K')  # <K>
    _newCombiner__V = typing.TypeVar('_newCombiner__V')  # <V>
    def newCombiner(self) -> scala.collection.parallel.Combiner[scala.Tuple2[_newCombiner__K, _newCombiner__V], _ParMapFactory__CC]: ...
    class CanCombineFromMap(CanCombineFrom[_ParMapFactory__CC, scala.Tuple2[_ParMapFactory__CanCombineFromMap__K, _ParMapFactory__CanCombineFromMap__V], _ParMapFactory__CC], typing.Generic[_ParMapFactory__CanCombineFromMap__K, _ParMapFactory__CanCombineFromMap__V]):
        $outer: 'ParMapFactory' = ...
        def __init__(self, $outer: 'ParMapFactory'): ...
        @typing.overload
        def apply(self) -> scala.collection.parallel.Combiner[scala.Tuple2[_ParMapFactory__CanCombineFromMap__K, _ParMapFactory__CanCombineFromMap__V], _ParMapFactory__CC]: ...
        @typing.overload
        def apply(self, from_: _ParMapFactory__CC) -> scala.collection.parallel.Combiner[scala.Tuple2[_ParMapFactory__CanCombineFromMap__K, _ParMapFactory__CanCombineFromMap__V], _ParMapFactory__CC]: ...

_ParSetFactory__GenericCanCombineFrom__A = typing.TypeVar('_ParSetFactory__GenericCanCombineFrom__A')  # <A>
_ParSetFactory__CC = typing.TypeVar('_ParSetFactory__CC', bound=scala.collection.parallel.ParSet)  # <CC>
class ParSetFactory(GenSetFactory[_ParSetFactory__CC], GenericParCompanion[_ParSetFactory__CC], typing.Generic[_ParSetFactory__CC]):
    def __init__(self): ...
    _newBuilder__A = typing.TypeVar('_newBuilder__A')  # <A>
    def newBuilder(self) -> scala.collection.parallel.Combiner[_newBuilder__A, _ParSetFactory__CC]: ...
    _newCombiner__A = typing.TypeVar('_newCombiner__A')  # <A>
    def newCombiner(self) -> scala.collection.parallel.Combiner[_newCombiner__A, _ParSetFactory__CC]: ...
    class GenericCanCombineFrom(CanCombineFrom[_ParSetFactory__CC, _ParSetFactory__GenericCanCombineFrom__A, _ParSetFactory__CC], typing.Generic[_ParSetFactory__GenericCanCombineFrom__A]):
        $outer: 'ParSetFactory' = ...
        def __init__(self, $outer: 'ParSetFactory'): ...
        @typing.overload
        def apply(self) -> scala.collection.parallel.Combiner[_ParSetFactory__GenericCanCombineFrom__A, _ParSetFactory__CC]: ...
        @typing.overload
        def apply(self, from_: _ParSetFactory__CC) -> scala.collection.parallel.Combiner[_ParSetFactory__GenericCanCombineFrom__A, _ParSetFactory__CC]: ...

_SeqForwarder__A = typing.TypeVar('_SeqForwarder__A')  # <A>
class SeqForwarder(scala.collection.Seq[_SeqForwarder__A], IterableForwarder[_SeqForwarder__A], typing.Generic[_SeqForwarder__A]):
    @staticmethod
    def $init$($this: 'SeqForwarder') -> None: ...
    @typing.overload
    def apply(self, v1: typing.Any) -> typing.Any: ...
    @typing.overload
    def apply(self, idx: int) -> _SeqForwarder__A: ...
    _contains__A1 = typing.TypeVar('_contains__A1')  # <A1>
    def contains(self, elem: _contains__A1) -> bool: ...
    _containsSlice__B = typing.TypeVar('_containsSlice__B')  # <B>
    def containsSlice(self, that: scala.collection.GenSeq[_containsSlice__B]) -> bool: ...
    _corresponds__B = typing.TypeVar('_corresponds__B')  # <B>
    def corresponds(self, that: scala.collection.GenSeq[_corresponds__B], p: scala.Function2[_SeqForwarder__A, _corresponds__B, typing.Any]) -> bool: ...
    _endsWith__B = typing.TypeVar('_endsWith__B')  # <B>
    def endsWith(self, that: scala.collection.GenSeq[_endsWith__B]) -> bool: ...
    def equals(self, that: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    _indexOf_0__B = typing.TypeVar('_indexOf_0__B')  # <B>
    _indexOf_1__B = typing.TypeVar('_indexOf_1__B')  # <B>
    @typing.overload
    def indexOf(self, elem: _indexOf_0__B) -> int: ...
    @typing.overload
    def indexOf(self, elem: _indexOf_1__B, from_: int) -> int: ...
    _indexOfSlice_0__B = typing.TypeVar('_indexOfSlice_0__B')  # <B>
    _indexOfSlice_1__B = typing.TypeVar('_indexOfSlice_1__B')  # <B>
    @typing.overload
    def indexOfSlice(self, that: scala.collection.GenSeq[_indexOfSlice_0__B]) -> int: ...
    @typing.overload
    def indexOfSlice(self, that: scala.collection.GenSeq[_indexOfSlice_1__B], from_: int) -> int: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[_SeqForwarder__A, typing.Any]) -> int: ...
    @typing.overload
    def indexWhere(self, p: scala.Function1[_SeqForwarder__A, typing.Any], from_: int) -> int: ...
    def indices(self) -> scala.collection.immutable.Range: ...
    @typing.overload
    def isDefinedAt(self, x: _SeqForwarder__A) -> bool: ...
    @typing.overload
    def isDefinedAt(self, x: int) -> bool: ...
    _lastIndexOf_0__B = typing.TypeVar('_lastIndexOf_0__B')  # <B>
    _lastIndexOf_1__B = typing.TypeVar('_lastIndexOf_1__B')  # <B>
    @typing.overload
    def lastIndexOf(self, elem: _lastIndexOf_0__B) -> int: ...
    @typing.overload
    def lastIndexOf(self, elem: _lastIndexOf_1__B, end: int) -> int: ...
    _lastIndexOfSlice_0__B = typing.TypeVar('_lastIndexOfSlice_0__B')  # <B>
    _lastIndexOfSlice_1__B = typing.TypeVar('_lastIndexOfSlice_1__B')  # <B>
    @typing.overload
    def lastIndexOfSlice(self, that: scala.collection.GenSeq[_lastIndexOfSlice_0__B]) -> int: ...
    @typing.overload
    def lastIndexOfSlice(self, that: scala.collection.GenSeq[_lastIndexOfSlice_1__B], end: int) -> int: ...
    @typing.overload
    def lastIndexWhere(self, p: scala.Function1[_SeqForwarder__A, typing.Any]) -> int: ...
    @typing.overload
    def lastIndexWhere(self, p: scala.Function1[_SeqForwarder__A, typing.Any], end: int) -> int: ...
    def length(self) -> int: ...
    def lengthCompare(self, len: int) -> int: ...
    def prefixLength(self, p: scala.Function1[_SeqForwarder__A, typing.Any]) -> int: ...
    def reverseIterator(self) -> scala.collection.Iterator[_SeqForwarder__A]: ...
    def segmentLength(self, p: scala.Function1[_SeqForwarder__A, typing.Any], from_: int) -> int: ...
    _startsWith_0__B = typing.TypeVar('_startsWith_0__B')  # <B>
    _startsWith_1__B = typing.TypeVar('_startsWith_1__B')  # <B>
    @typing.overload
    def startsWith(self, that: scala.collection.GenSeq[_startsWith_0__B]) -> bool: ...
    @typing.overload
    def startsWith(self, that: scala.collection.GenSeq[_startsWith_1__B], offset: int) -> bool: ...
    @typing.overload
    def toString(self) -> java.lang.String: ...
    @typing.overload
    def toString(self) -> java.lang.String: ...
    @typing.overload
    def underlying(self) -> scala.collection.Iterable[_SeqForwarder__A]: ...
    @typing.overload
    def underlying(self) -> scala.collection.Seq[_SeqForwarder__A]: ...
    @typing.overload
    def underlying(self) -> scala.collection.Traversable[_SeqForwarder__A]: ...

_SetFactory__CC = typing.TypeVar('_SetFactory__CC', bound=scala.collection.Set)  # <CC>
class SetFactory(GenSetFactory[_SetFactory__CC], GenericSeqCompanion[_SetFactory__CC], typing.Generic[_SetFactory__CC]):
    def __init__(self): ...

_GenericParMapTemplate__K = typing.TypeVar('_GenericParMapTemplate__K')  # <K>
_GenericParMapTemplate__V = typing.TypeVar('_GenericParMapTemplate__V')  # <V>
_GenericParMapTemplate__CC = typing.TypeVar('_GenericParMapTemplate__CC', bound=scala.collection.parallel.ParMap)  # <CC>
class GenericParMapTemplate(GenericParTemplate[scala.Tuple2[_GenericParMapTemplate__K, _GenericParMapTemplate__V], scala.collection.parallel.ParIterable], typing.Generic[_GenericParMapTemplate__K, _GenericParMapTemplate__V, _GenericParMapTemplate__CC]):
    @staticmethod
    def $init$($this: 'GenericParMapTemplate') -> None: ...
    _genericMapCombiner__P = typing.TypeVar('_genericMapCombiner__P')  # <P>
    _genericMapCombiner__Q = typing.TypeVar('_genericMapCombiner__Q')  # <Q>
    def genericMapCombiner(self) -> scala.collection.parallel.Combiner[scala.Tuple2[_genericMapCombiner__P, _genericMapCombiner__Q], _GenericParMapTemplate__CC]: ...
    def mapCompanion(self) -> GenericParMapCompanion[_GenericParMapTemplate__CC]: ...
    def newCombiner(self) -> scala.collection.parallel.Combiner[scala.Tuple2[_GenericParMapTemplate__K, _GenericParMapTemplate__V], _GenericParMapTemplate__CC]: ...

_ImmutableMapFactory__CC = typing.TypeVar('_ImmutableMapFactory__CC', bound=scala.collection.immutable.Map)  # <CC>
class ImmutableMapFactory(MapFactory[_ImmutableMapFactory__CC], typing.Generic[_ImmutableMapFactory__CC]):
    def __init__(self): ...

_ImmutableSetFactory__CC = typing.TypeVar('_ImmutableSetFactory__CC', bound=scala.collection.immutable.Set)  # <CC>
class ImmutableSetFactory(SetFactory[_ImmutableSetFactory__CC], typing.Generic[_ImmutableSetFactory__CC]):
    def __init__(self): ...
    _empty__A = typing.TypeVar('_empty__A')  # <A>
    def empty(self) -> _ImmutableSetFactory__CC: ...
    def emptyInstance(self) -> _ImmutableSetFactory__CC: ...
    _newBuilder__A = typing.TypeVar('_newBuilder__A')  # <A>
    def newBuilder(self) -> scala.collection.mutable.Builder[_newBuilder__A, _ImmutableSetFactory__CC]: ...

_MutableMapFactory__CC = typing.TypeVar('_MutableMapFactory__CC', bound=scala.collection.mutable.Map)  # <CC>
class MutableMapFactory(MapFactory[_MutableMapFactory__CC], typing.Generic[_MutableMapFactory__CC]):
    def __init__(self): ...
    _newBuilder__A = typing.TypeVar('_newBuilder__A')  # <A>
    _newBuilder__B = typing.TypeVar('_newBuilder__B')  # <B>
    def newBuilder(self) -> scala.collection.mutable.Builder[scala.Tuple2[_newBuilder__A, _newBuilder__B], _MutableMapFactory__CC]: ...

_MutableSetFactory__CC = typing.TypeVar('_MutableSetFactory__CC', bound=scala.collection.mutable.Set)  # <CC>
class MutableSetFactory(SetFactory[_MutableSetFactory__CC], typing.Generic[_MutableSetFactory__CC]):
    def __init__(self): ...
    _newBuilder__A = typing.TypeVar('_newBuilder__A')  # <A>
    def newBuilder(self) -> scala.collection.mutable.Builder[_newBuilder__A, _MutableSetFactory__CC]: ...

_SeqFactory__CC = typing.TypeVar('_SeqFactory__CC', bound=scala.collection.Seq)  # <CC>
class SeqFactory(GenSeqFactory[_SeqFactory__CC], TraversableFactory[_SeqFactory__CC], typing.Generic[_SeqFactory__CC]):
    def __init__(self): ...
    _unapplySeq__A = typing.TypeVar('_unapplySeq__A')  # <A>
    def unapplySeq(self, x: _SeqFactory__CC) -> scala.Some[_SeqFactory__CC]: ...

class TaggedDelegatedContext(DelegatedContext):
    def __init__(self, deleg: Signalling, tag: int): ...
    def tag(self) -> int: ...

_IndexedSeqFactory__CC = typing.TypeVar('_IndexedSeqFactory__CC', bound=scala.collection.IndexedSeq)  # <CC>
class IndexedSeqFactory(SeqFactory[_IndexedSeqFactory__CC], typing.Generic[_IndexedSeqFactory__CC]):
    def __init__(self): ...
    def ReusableCBF(self) -> GenTraversableFactory.GenericCanBuildFrom[scala.runtime.Nothing.]: ...

class BitOperations:
    class Int:
        @staticmethod
        def $init$($this: 'BitOperations.Int') -> None: ...
        def bitString(self, num: int, sep: typing.Union[java.lang.String, str]) -> java.lang.String: ...
        def bitString$default$2(self) -> java.lang.String: ...
        def bits(self, num: int) -> scala.collection.immutable.IndexedSeq[typing.Any]: ...
        def complement(self, i: int) -> int: ...
        def hasMatch(self, key: int, prefix: int, m: int) -> bool: ...
        def highestOneBit(self, j: int) -> int: ...
        def mask(self, i: int, mask: int) -> int: ...
        def shorter(self, m1: int, m2: int) -> bool: ...
        def unsignedCompare(self, i: int, j: int) -> bool: ...
        def zero(self, i: int, mask: int) -> bool: ...
    class Int$(scala.collection.generic.BitOperations.Int):
        MODULE$: typing.ClassVar['BitOperations.Int.'] = ...
        def __init__(self): ...
        def bitString(self, num: int, sep: typing.Union[java.lang.String, str]) -> java.lang.String: ...
        def bitString$default$2(self) -> java.lang.String: ...
        def bits(self, num: int) -> scala.collection.immutable.IndexedSeq[typing.Any]: ...
        def complement(self, i: int) -> int: ...
        def hasMatch(self, key: int, prefix: int, m: int) -> bool: ...
        def highestOneBit(self, j: int) -> int: ...
        def mask(self, i: int, mask: int) -> int: ...
        def shorter(self, m1: int, m2: int) -> bool: ...
        def unsignedCompare(self, i: int, j: int) -> bool: ...
        def zero(self, i: int, mask: int) -> bool: ...
    class Long:
        @staticmethod
        def $init$($this: 'BitOperations.Long') -> None: ...
        def bitString(self, num: int, sep: typing.Union[java.lang.String, str]) -> java.lang.String: ...
        def bitString$default$2(self) -> java.lang.String: ...
        def bits(self, num: int) -> scala.collection.immutable.IndexedSeq[typing.Any]: ...
        def complement(self, i: int) -> int: ...
        def hasMatch(self, key: int, prefix: int, m: int) -> bool: ...
        def highestOneBit(self, j: int) -> int: ...
        def mask(self, i: int, mask: int) -> int: ...
        def shorter(self, m1: int, m2: int) -> bool: ...
        def unsignedCompare(self, i: int, j: int) -> bool: ...
        def zero(self, i: int, mask: int) -> bool: ...
    class Long$(scala.collection.generic.BitOperations.Long):
        MODULE$: typing.ClassVar['BitOperations.Long.'] = ...
        def __init__(self): ...
        def bitString(self, num: int, sep: typing.Union[java.lang.String, str]) -> java.lang.String: ...
        def bitString$default$2(self) -> java.lang.String: ...
        def bits(self, num: int) -> scala.collection.immutable.IndexedSeq[typing.Any]: ...
        def complement(self, i: int) -> int: ...
        def hasMatch(self, key: int, prefix: int, m: int) -> bool: ...
        def highestOneBit(self, j: int) -> int: ...
        def mask(self, i: int, mask: int) -> int: ...
        def shorter(self, m1: int, m2: int) -> bool: ...
        def unsignedCompare(self, i: int, j: int) -> bool: ...
        def zero(self, i: int, mask: int) -> bool: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("scala.collection.generic")``.

    AtomicIndexFlag: typing.Type[AtomicIndexFlag]
    BitOperations: typing.Type[BitOperations]
    BitSetFactory: typing.Type[BitSetFactory]
    CanBuildFrom: typing.Type[CanBuildFrom]
    CanCombineFrom: typing.Type[CanCombineFrom]
    ClassTagTraversableFactory: typing.Type[ClassTagTraversableFactory]
    Clearable: typing.Type[Clearable]
    DefaultSignalling: typing.Type[DefaultSignalling]
    DelegatedContext: typing.Type[DelegatedContext]
    DelegatedSignalling: typing.Type[DelegatedSignalling]
    FilterMonadic: typing.Type[FilterMonadic]
    GenMapFactory: typing.Type[GenMapFactory]
    GenSeqFactory: typing.Type[GenSeqFactory]
    GenSetFactory: typing.Type[GenSetFactory]
    GenTraversableFactory: typing.Type[GenTraversableFactory]
    GenericClassTagCompanion: typing.Type[GenericClassTagCompanion]
    GenericClassTagTraversableTemplate: typing.Type[GenericClassTagTraversableTemplate]
    GenericCompanion: typing.Type[GenericCompanion]
    GenericOrderedCompanion: typing.Type[GenericOrderedCompanion]
    GenericOrderedTraversableTemplate: typing.Type[GenericOrderedTraversableTemplate]
    GenericParCompanion: typing.Type[GenericParCompanion]
    GenericParMapCompanion: typing.Type[GenericParMapCompanion]
    GenericParMapTemplate: typing.Type[GenericParMapTemplate]
    GenericParTemplate: typing.Type[GenericParTemplate]
    GenericSeqCompanion: typing.Type[GenericSeqCompanion]
    GenericSetTemplate: typing.Type[GenericSetTemplate]
    GenericTraversableTemplate: typing.Type[GenericTraversableTemplate]
    Growable: typing.Type[Growable]
    HasNewBuilder: typing.Type[HasNewBuilder]
    HasNewCombiner: typing.Type[HasNewCombiner]
    IdleSignalling: typing.Type[IdleSignalling]
    ImmutableMapFactory: typing.Type[ImmutableMapFactory]
    ImmutableSetFactory: typing.Type[ImmutableSetFactory]
    ImmutableSortedMapFactory: typing.Type[ImmutableSortedMapFactory]
    ImmutableSortedSetFactory: typing.Type[ImmutableSortedSetFactory]
    IndexedSeqFactory: typing.Type[IndexedSeqFactory]
    IsSeqLike: typing.Type[IsSeqLike]
    IsTraversableLike: typing.Type[IsTraversableLike]
    IsTraversableOnce: typing.Type[IsTraversableOnce]
    IterableForwarder: typing.Type[IterableForwarder]
    MapFactory: typing.Type[MapFactory]
    MutableMapFactory: typing.Type[MutableMapFactory]
    MutableSetFactory: typing.Type[MutableSetFactory]
    MutableSortedMapFactory: typing.Type[MutableSortedMapFactory]
    MutableSortedSetFactory: typing.Type[MutableSortedSetFactory]
    OrderedTraversableFactory: typing.Type[OrderedTraversableFactory]
    ParFactory: typing.Type[ParFactory]
    ParMapFactory: typing.Type[ParMapFactory]
    ParSetFactory: typing.Type[ParSetFactory]
    SeqFactory: typing.Type[SeqFactory]
    SeqForwarder: typing.Type[SeqForwarder]
    SetFactory: typing.Type[SetFactory]
    Shrinkable: typing.Type[Shrinkable]
    Signalling: typing.Type[Signalling]
    Sizing: typing.Type[Sizing]
    SliceInterval: typing.Type[SliceInterval]
    Sorted: typing.Type[Sorted]
    SortedMapFactory: typing.Type[SortedMapFactory]
    SortedSetFactory: typing.Type[SortedSetFactory]
    Subtractable: typing.Type[Subtractable]
    TaggedDelegatedContext: typing.Type[TaggedDelegatedContext]
    TraversableFactory: typing.Type[TraversableFactory]
    TraversableForwarder: typing.Type[TraversableForwarder]
    VolatileAbort: typing.Type[VolatileAbort]
    package: typing.Type[package]
