import java.lang
import java.math
import org.bouncycastle.math.ec.custom.sec
import org.ergoplatform.validation
import scala
import scala.collection
import scala.collection.immutable
import scala.collection.mutable
import scala.runtime
import scala.util
import scalan
import sigmastate
import sigmastate.interpreter
import sigmastate.lang
import sigmastate.serialization
import sigmastate.serialization.transformers
import sigmastate.utils
import special.collection
import special.sigma
import typing



class AvlTreeConstant$:
    MODULE$: typing.ClassVar[sigmastate.Values.AvlTreeConstant.] = ...
    def __init__(self): ...
    def apply(self, value: special.sigma.AvlTree) -> sigmastate.Values.Constant[sigmastate.SAvlTree.]: ...

class BigIntArrayConstant$:
    MODULE$: typing.ClassVar[sigmastate.Values.BigIntArrayConstant.] = ...
    def __init__(self): ...
    @typing.overload
    def apply(self, value: special.collection.Coll[special.sigma.BigInt]) -> sigmastate.Values.Constant[sigmastate.SCollection[sigmastate.SBigInt.]]: ...
    @typing.overload
    def apply(self, value: typing.List[special.sigma.BigInt]) -> sigmastate.Values.Constant[sigmastate.SCollection[sigmastate.SBigInt.]]: ...
    def unapply(self, node: sigmastate.Values.Value[sigmastate.SType]) -> scala.Option[special.collection.Coll[special.sigma.BigInt]]: ...

class BigIntConstant$:
    MODULE$: typing.ClassVar[sigmastate.Values.BigIntConstant.] = ...
    def __init__(self): ...
    @typing.overload
    def apply(self, value: java.math.BigInteger) -> sigmastate.Values.Constant[sigmastate.SBigInt.]: ...
    @typing.overload
    def apply(self, value: int) -> sigmastate.Values.Constant[sigmastate.SBigInt.]: ...
    @typing.overload
    def apply(self, value: special.sigma.BigInt) -> sigmastate.Values.Constant[sigmastate.SBigInt.]: ...

class BlockItem(sigmastate.Values.NotReadyValue[sigmastate.SType]):
    def id(self) -> int: ...
    def isValDef(self) -> bool: ...
    def rhs(self) -> sigmastate.Values.Value[sigmastate.SType]: ...

class BlockItem$:
    MODULE$: typing.ClassVar[sigmastate.Values.BlockItem.] = ...
    def __init__(self): ...
    def EmptyArray(self) -> typing.List[sigmastate.Values.BlockItem]: ...
    def EmptySeq(self) -> scala.collection.IndexedSeq[sigmastate.Values.BlockItem]: ...

class BlockValue(sigmastate.Values.Value[sigmastate.SType], sigmastate.Values.NotReadyValue[sigmastate.SType], scala.Serializable):
    def __init__(self, items: scala.collection.IndexedSeq[sigmastate.Values.BlockItem], result: sigmastate.Values.Value[sigmastate.SType]): ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def companion(self) -> sigmastate.Values.BlockValue.: ...
    def copy(self, items: scala.collection.IndexedSeq[sigmastate.Values.BlockItem], result: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.BlockValue: ...
    def copy$default$1(self) -> scala.collection.IndexedSeq[sigmastate.Values.BlockItem]: ...
    def copy$default$2(self) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def eval(self, env: scala.collection.immutable.Map[typing.Any, typing.Any], E: sigmastate.interpreter.ErgoTreeEvaluator) -> typing.Any: ...
    def hashCode(self) -> int: ...
    def items(self) -> scala.collection.IndexedSeq[sigmastate.Values.BlockItem]: ...
    def opType(self) -> sigmastate.SFunc: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def result(self) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def toString(self) -> java.lang.String: ...
    def tpe(self) -> sigmastate.SType: ...
    class : ...

class BlockValue$(sigmastate.Values.ValueCompanion, scala.Serializable):
    MODULE$: typing.ClassVar[sigmastate.Values.BlockValue.] = ...
    def __init__(self): ...
    def apply(self, items: scala.collection.IndexedSeq[sigmastate.Values.BlockItem], result: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.BlockValue: ...
    def costKind(self) -> sigmastate.PerItemCost: ...
    def init(self) -> None: ...
    def opCode(self) -> int: ...
    def opDesc(self) -> sigmastate.interpreter.CompanionDesc: ...
    def sigmastate$Values$ValueCompanion$_setter_$opDesc_$eq(self, x$1: sigmastate.interpreter.CompanionDesc) -> None: ...
    def toString(self) -> java.lang.String: ...
    def typeName(self) -> java.lang.String: ...
    def unapply(self, x$0: sigmastate.Values.BlockValue) -> scala.Option[scala.Tuple2[scala.collection.IndexedSeq[sigmastate.Values.BlockItem], sigmastate.Values.Value[sigmastate.SType]]]: ...

class BoolArrayConstant$:
    MODULE$: typing.ClassVar[sigmastate.Values.BoolArrayConstant.] = ...
    def __init__(self): ...
    @typing.overload
    def apply(self, value: typing.List[bool]) -> sigmastate.Values.Constant[sigmastate.SCollection[sigmastate.SBoolean.]]: ...
    @typing.overload
    def apply(self, value: special.collection.Coll[typing.Any]) -> sigmastate.Values.Constant[sigmastate.SCollection[sigmastate.SBoolean.]]: ...
    def unapply(self, node: sigmastate.Values.Value[sigmastate.SType]) -> scala.Option[special.collection.Coll[typing.Any]]: ...

class BoolValueOps:
    def __init__(self, b: sigmastate.Values.Value[sigmastate.SBoolean.]): ...
    def b(self) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toSigmaProp(self) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...

class BoolValueOps$:
    MODULE$: typing.ClassVar[sigmastate.Values.BoolValueOps.] = ...
    def __init__(self): ...
    def equals$extension(self, $this: sigmastate.Values.Value, x$1: typing.Any) -> bool: ...
    def hashCode$extension(self, $this: sigmastate.Values.Value) -> int: ...
    def toSigmaProp$extension(self, $this: sigmastate.Values.Value[sigmastate.SBoolean.]) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...

class BooleanConstant$:
    MODULE$: typing.ClassVar[sigmastate.Values.BooleanConstant.] = ...
    def __init__(self): ...
    def apply(self, value: bool) -> sigmastate.Values.Constant[sigmastate.SBoolean.]: ...
    def fromBoolean(self, v: bool) -> sigmastate.Values.Constant[sigmastate.SBoolean.]: ...
    def unapply(self, v: sigmastate.Values.Value[sigmastate.SType]) -> scala.Option[typing.Any]: ...

class BoxConstant$:
    MODULE$: typing.ClassVar[sigmastate.Values.BoxConstant.] = ...
    def __init__(self): ...
    def apply(self, value: special.sigma.Box) -> sigmastate.Values.Constant[sigmastate.SBox.]: ...

class ByteArrayConstant$:
    MODULE$: typing.ClassVar[sigmastate.Values.ByteArrayConstant.] = ...
    def __init__(self): ...
    @typing.overload
    def apply(self, value: typing.List[int]) -> sigmastate.Values.Constant[sigmastate.SCollection[sigmastate.SByte.]]: ...
    @typing.overload
    def apply(self, value: special.collection.Coll[typing.Any]) -> sigmastate.Values.Constant[sigmastate.SCollection[sigmastate.SByte.]]: ...
    def unapply(self, node: sigmastate.Values.Value[sigmastate.SType]) -> scala.Option[special.collection.Coll[typing.Any]]: ...

class ByteConstant$:
    MODULE$: typing.ClassVar[sigmastate.Values.ByteConstant.] = ...
    def __init__(self): ...
    def apply(self, value: int) -> sigmastate.Values.Constant[sigmastate.SByte.]: ...

class CollectionConstant$:
    MODULE$: typing.ClassVar[sigmastate.Values.CollectionConstant.] = ...
    def __init__(self): ...
    _apply__T = typing.TypeVar('_apply__T', bound=sigmastate.SType)  # <T>
    def apply(self, value: special.collection.Coll[typing.Any], elementType: _apply__T) -> sigmastate.Values.Constant[sigmastate.SCollection[_apply__T]]: ...
    _unapply__T = typing.TypeVar('_unapply__T', bound=sigmastate.SType)  # <T>
    def unapply(self, node: sigmastate.Values.Value[sigmastate.SCollection[_unapply__T]]) -> scala.Option[scala.Tuple2[special.collection.Coll[typing.Any], _unapply__T]]: ...

_sigmastate_Values__CollectionOps__T = typing.TypeVar('_sigmastate_Values__CollectionOps__T', bound=sigmastate.SType)  # <T>
class CollectionOps(typing.Generic[_sigmastate_Values__CollectionOps__T]):
    def __init__(self, coll: sigmastate.Values.Value[sigmastate.SCollection[_sigmastate_Values__CollectionOps__T]]): ...
    def coll(self) -> sigmastate.Values.Value[sigmastate.SCollection[_sigmastate_Values__CollectionOps__T]]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def items(self) -> scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]]: ...
    def length(self) -> int: ...
    _matchCase__R = typing.TypeVar('_matchCase__R')  # <R>
    def matchCase(self, whenConcrete: scala.Function1[sigmastate.Values.ConcreteCollection[_sigmastate_Values__CollectionOps__T], _matchCase__R], whenConstant: scala.Function1[sigmastate.Values.Constant[sigmastate.SCollection[_sigmastate_Values__CollectionOps__T]], _matchCase__R], whenTuple: scala.Function1[sigmastate.Values.Tuple, _matchCase__R]) -> _matchCase__R: ...

class CollectionOps$:
    MODULE$: typing.ClassVar[sigmastate.Values.CollectionOps.] = ...
    def __init__(self): ...
    _equals$extension__T = typing.TypeVar('_equals$extension__T', bound=sigmastate.SType)  # <T>
    def equals$extension(self, $this: sigmastate.Values.Value[sigmastate.SCollection[_equals.extension__T]], x$1: typing.Any) -> bool: ...
    _hashCode$extension__T = typing.TypeVar('_hashCode$extension__T', bound=sigmastate.SType)  # <T>
    def hashCode$extension(self, $this: sigmastate.Values.Value[sigmastate.SCollection[_hashCode.extension__T]]) -> int: ...
    _items$extension__T = typing.TypeVar('_items$extension__T', bound=sigmastate.SType)  # <T>
    def items$extension(self, $this: sigmastate.Values.Value[sigmastate.SCollection[_items.extension__T]]) -> scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]]: ...
    _length$extension__T = typing.TypeVar('_length$extension__T', bound=sigmastate.SType)  # <T>
    def length$extension(self, $this: sigmastate.Values.Value[sigmastate.SCollection[_length.extension__T]]) -> int: ...
    _matchCase$extension__R = typing.TypeVar('_matchCase$extension__R')  # <R>
    _matchCase$extension__T = typing.TypeVar('_matchCase$extension__T', bound=sigmastate.SType)  # <T>
    def matchCase$extension(self, $this: sigmastate.Values.Value[sigmastate.SCollection[_matchCase.extension__T]], whenConcrete: scala.Function1[sigmastate.Values.ConcreteCollection[_matchCase.extension__T], _matchCase.extension__R], whenConstant: scala.Function1[sigmastate.Values.Constant[sigmastate.SCollection[_matchCase.extension__T]], _matchCase.extension__R], whenTuple: scala.Function1[sigmastate.Values.Tuple, _matchCase.extension__R]) -> _matchCase.extension__R: ...

_sigmastate_Values__ConcreteCollection__V = typing.TypeVar('_sigmastate_Values__ConcreteCollection__V', bound=sigmastate.SType)  # <V>
class ConcreteCollection(sigmastate.Values.EvaluatedValue[sigmastate.SCollection[_sigmastate_Values__ConcreteCollection__V]], sigmastate.Values.EvaluatedCollection[_sigmastate_Values__ConcreteCollection__V, sigmastate.SCollection[_sigmastate_Values__ConcreteCollection__V]], scala.Serializable, typing.Generic[_sigmastate_Values__ConcreteCollection__V]):
    def __init__(self, items: scala.collection.Seq[sigmastate.Values.Value[_sigmastate_Values__ConcreteCollection__V]], elementType: _sigmastate_Values__ConcreteCollection__V): ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def companion(self) -> sigmastate.Values.ValueCompanion: ...
    _copy__V = typing.TypeVar('_copy__V', bound=sigmastate.SType)  # <V>
    def copy(self, items: scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]], elementType: sigmastate.SType) -> sigmastate.Values.ConcreteCollection[sigmastate.SType]: ...
    _copy$default$1__V = typing.TypeVar('_copy$default$1__V', bound=sigmastate.SType)  # <V>
    def copy$default$1(self) -> scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]]: ...
    _copy$default$2__V = typing.TypeVar('_copy$default$2__V', bound=sigmastate.SType)  # <V>
    def copy$default$2(self) -> sigmastate.SType: ...
    def elementType(self) -> _sigmastate_Values__ConcreteCollection__V: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def eval(self, env: scala.collection.immutable.Map[typing.Any, typing.Any], E: sigmastate.interpreter.ErgoTreeEvaluator) -> typing.Any: ...
    def hashCode(self) -> int: ...
    def items(self) -> scala.collection.Seq[sigmastate.Values.Value[_sigmastate_Values__ConcreteCollection__V]]: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def tElement(self) -> scalan.RType[typing.Any]: ...
    def toString(self) -> java.lang.String: ...
    def tpe(self) -> sigmastate.SCollection[_sigmastate_Values__ConcreteCollection__V]: ...
    def value(self) -> special.collection.Coll[typing.Any]: ...

class ConcreteCollection$(sigmastate.Values.ValueCompanion, scala.Serializable):
    MODULE$: typing.ClassVar[sigmastate.Values.ConcreteCollection.] = ...
    def __init__(self): ...
    _apply__V = typing.TypeVar('_apply__V', bound=sigmastate.SType)  # <V>
    def apply(self, items: scala.collection.Seq[sigmastate.Values.Value[_apply__V]], elementType: _apply__V) -> sigmastate.Values.ConcreteCollection[_apply__V]: ...
    def costKind(self) -> sigmastate.FixedCost: ...
    _fromItems__V = typing.TypeVar('_fromItems__V', bound=sigmastate.SType)  # <V>
    def fromItems(self, items: scala.collection.Seq[sigmastate.Values.Value[_fromItems__V]], tV: _fromItems__V) -> sigmastate.Values.ConcreteCollection[_fromItems__V]: ...
    _fromSeq__V = typing.TypeVar('_fromSeq__V', bound=sigmastate.SType)  # <V>
    def fromSeq(self, items: scala.collection.Seq[sigmastate.Values.Value[_fromSeq__V]], tV: _fromSeq__V) -> sigmastate.Values.ConcreteCollection[_fromSeq__V]: ...
    def init(self) -> None: ...
    def opCode(self) -> int: ...
    def opDesc(self) -> sigmastate.interpreter.CompanionDesc: ...
    def sigmastate$Values$ValueCompanion$_setter_$opDesc_$eq(self, x$1: sigmastate.interpreter.CompanionDesc) -> None: ...
    def toString(self) -> java.lang.String: ...
    def typeName(self) -> java.lang.String: ...
    _unapply__V = typing.TypeVar('_unapply__V', bound=sigmastate.SType)  # <V>
    def unapply(self, x$0: sigmastate.Values.ConcreteCollection[_unapply__V]) -> scala.Option[scala.Tuple2[scala.collection.Seq[sigmastate.Values.Value[_unapply__V]], _unapply__V]]: ...

class ConcreteCollectionBooleanConstant$(sigmastate.Values.ValueCompanion):
    MODULE$: typing.ClassVar[sigmastate.Values.ConcreteCollectionBooleanConstant.] = ...
    def __init__(self): ...
    def costKind(self) -> sigmastate.FixedCost: ...
    def init(self) -> None: ...
    def opCode(self) -> int: ...
    def opDesc(self) -> sigmastate.interpreter.CompanionDesc: ...
    def sigmastate$Values$ValueCompanion$_setter_$opDesc_$eq(self, x$1: sigmastate.interpreter.CompanionDesc) -> None: ...
    def toString(self) -> java.lang.String: ...
    def typeName(self) -> java.lang.String: ...

_sigmastate_Values__Constant__S = typing.TypeVar('_sigmastate_Values__Constant__S', bound=sigmastate.SType)  # <S>
class Constant(sigmastate.Values.EvaluatedValue[_sigmastate_Values__Constant__S], typing.Generic[_sigmastate_Values__Constant__S]):
    def __init__(self): ...

class Constant$(sigmastate.Values.FixedCostValueCompanion):
    MODULE$: typing.ClassVar[sigmastate.Values.Constant.] = ...
    def __init__(self): ...
    def EmptyArray(self) -> typing.List[sigmastate.Values.Constant[sigmastate.SType]]: ...
    def EmptySeq(self) -> scala.collection.IndexedSeq[sigmastate.Values.Constant[sigmastate.SType]]: ...
    _apply__S = typing.TypeVar('_apply__S', bound=sigmastate.SType)  # <S>
    def apply(self, value: typing.Any, tpe: _apply__S) -> sigmastate.Values.Constant[_apply__S]: ...
    def costKind(self) -> sigmastate.FixedCost: ...
    def init(self) -> None: ...
    _isCorrectType__T = typing.TypeVar('_isCorrectType__T', bound=sigmastate.SType)  # <T>
    def isCorrectType(self, value: typing.Any, tpe: _isCorrectType__T) -> bool: ...
    def opCode(self) -> int: ...
    def opDesc(self) -> sigmastate.interpreter.CompanionDesc: ...
    def sigmastate$Values$ValueCompanion$_setter_$opDesc_$eq(self, x$1: sigmastate.interpreter.CompanionDesc) -> None: ...
    def toString(self) -> java.lang.String: ...
    def typeName(self) -> java.lang.String: ...
    _unapply__S = typing.TypeVar('_unapply__S', bound=sigmastate.SType)  # <S>
    def unapply(self, v: sigmastate.Values.EvaluatedValue[_unapply__S]) -> scala.Option[scala.Tuple2[typing.Any, _unapply__S]]: ...

_sigmastate_Values__ConstantNode__S = typing.TypeVar('_sigmastate_Values__ConstantNode__S', bound=sigmastate.SType)  # <S>
class ConstantNode(sigmastate.Values.Constant[_sigmastate_Values__ConstantNode__S], scala.Serializable, typing.Generic[_sigmastate_Values__ConstantNode__S]):
    def __init__(self, value: typing.Any, tpe: _sigmastate_Values__ConstantNode__S): ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def companion(self) -> sigmastate.Values.ValueCompanion: ...
    _copy__S = typing.TypeVar('_copy__S', bound=sigmastate.SType)  # <S>
    def copy(self, value: typing.Any, tpe: sigmastate.SType) -> sigmastate.Values.ConstantNode[sigmastate.SType]: ...
    _copy$default$1__S = typing.TypeVar('_copy$default$1__S', bound=sigmastate.SType)  # <S>
    def copy$default$1(self) -> typing.Any: ...
    _copy$default$2__S = typing.TypeVar('_copy$default$2__S', bound=sigmastate.SType)  # <S>
    def copy$default$2(self) -> sigmastate.SType: ...
    def equals(self, obj: typing.Any) -> bool: ...
    def eval(self, env: scala.collection.immutable.Map[typing.Any, typing.Any], E: sigmastate.interpreter.ErgoTreeEvaluator) -> typing.Any: ...
    def hashCode(self) -> int: ...
    def opCode(self) -> int: ...
    def opName(self) -> java.lang.String: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...
    def tpe(self) -> _sigmastate_Values__ConstantNode__S: ...
    def value(self) -> typing.Any: ...

class ConstantNode$(scala.Serializable):
    MODULE$: typing.ClassVar[sigmastate.Values.ConstantNode.] = ...
    def __init__(self): ...
    _apply__S = typing.TypeVar('_apply__S', bound=sigmastate.SType)  # <S>
    def apply(self, value: typing.Any, tpe: _apply__S) -> sigmastate.Values.ConstantNode[_apply__S]: ...
    def toString(self) -> java.lang.String: ...
    _unapply__S = typing.TypeVar('_unapply__S', bound=sigmastate.SType)  # <S>
    def unapply(self, x$0: sigmastate.Values.ConstantNode[_unapply__S]) -> scala.Option[scala.Tuple2[typing.Any, _unapply__S]]: ...

_sigmastate_Values__ConstantPlaceholder__S = typing.TypeVar('_sigmastate_Values__ConstantPlaceholder__S', bound=sigmastate.SType)  # <S>
class ConstantPlaceholder(sigmastate.Values.Value[_sigmastate_Values__ConstantPlaceholder__S], scala.Serializable, typing.Generic[_sigmastate_Values__ConstantPlaceholder__S]):
    def __init__(self, id: int, tpe: _sigmastate_Values__ConstantPlaceholder__S): ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def companion(self) -> sigmastate.Values.ValueCompanion: ...
    _copy__S = typing.TypeVar('_copy__S', bound=sigmastate.SType)  # <S>
    def copy(self, id: int, tpe: sigmastate.SType) -> sigmastate.Values.ConstantPlaceholder[sigmastate.SType]: ...
    _copy$default$1__S = typing.TypeVar('_copy$default$1__S', bound=sigmastate.SType)  # <S>
    def copy$default$1(self) -> int: ...
    _copy$default$2__S = typing.TypeVar('_copy$default$2__S', bound=sigmastate.SType)  # <S>
    def copy$default$2(self) -> sigmastate.SType: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def eval(self, env: scala.collection.immutable.Map[typing.Any, typing.Any], E: sigmastate.interpreter.ErgoTreeEvaluator) -> typing.Any: ...
    def hashCode(self) -> int: ...
    def id(self) -> int: ...
    def opType(self) -> sigmastate.SFunc: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...
    def tpe(self) -> _sigmastate_Values__ConstantPlaceholder__S: ...

class ConstantPlaceholder$(sigmastate.Values.ValueCompanion, scala.Serializable):
    MODULE$: typing.ClassVar[sigmastate.Values.ConstantPlaceholder.] = ...
    def __init__(self): ...
    _apply__S = typing.TypeVar('_apply__S', bound=sigmastate.SType)  # <S>
    def apply(self, id: int, tpe: _apply__S) -> sigmastate.Values.ConstantPlaceholder[_apply__S]: ...
    def costKind(self) -> sigmastate.FixedCost: ...
    def init(self) -> None: ...
    def opCode(self) -> int: ...
    def opDesc(self) -> sigmastate.interpreter.CompanionDesc: ...
    def sigmastate$Values$ValueCompanion$_setter_$opDesc_$eq(self, x$1: sigmastate.interpreter.CompanionDesc) -> None: ...
    def toString(self) -> java.lang.String: ...
    def typeName(self) -> java.lang.String: ...
    _unapply__S = typing.TypeVar('_unapply__S', bound=sigmastate.SType)  # <S>
    def unapply(self, x$0: sigmastate.Values.ConstantPlaceholder[_unapply__S]) -> scala.Option[scala.Tuple2[typing.Any, _unapply__S]]: ...

_sigmastate_Values__ContextVariable__S = typing.TypeVar('_sigmastate_Values__ContextVariable__S', bound=sigmastate.SType)  # <S>
class ContextVariable(sigmastate.Values.NotReadyValue[_sigmastate_Values__ContextVariable__S], typing.Generic[_sigmastate_Values__ContextVariable__S]): ...

class ErgoTree(scala.Product, scala.Serializable):
    @typing.overload
    def __init__(self, header: int, constants: scala.collection.IndexedSeq[sigmastate.Values.Constant[sigmastate.SType]], root: scala.util.Either[sigmastate.Values.UnparsedErgoTree, sigmastate.Values.Value[sigmastate.SSigmaProp.]]): ...
    @typing.overload
    def __init__(self, header: int, constants: scala.collection.IndexedSeq[sigmastate.Values.Constant[sigmastate.SType]], root: scala.util.Either[sigmastate.Values.UnparsedErgoTree, sigmastate.Values.Value[sigmastate.SSigmaProp.]], givenComplexity: int, propositionBytes: typing.List[int], givenDeserialize: scala.Option[typing.Any]): ...
    def _bytes(self) -> typing.List[int]: ...
    def _bytes_$eq(self, x$1: typing.List[int]) -> None: ...
    def _hasDeserialize(self) -> scala.Option[typing.Any]: ...
    def _hasDeserialize_$eq(self, x$1: scala.Option[typing.Any]) -> None: ...
    def bytes(self) -> typing.List[int]: ...
    def bytesHex(self) -> java.lang.String: ...
    def canEqual(self, that: typing.Any) -> bool: ...
    def complexity(self) -> int: ...
    def constants(self) -> scala.collection.IndexedSeq[sigmastate.Values.Constant[sigmastate.SType]]: ...
    def copy(self, header: int, constants: scala.collection.IndexedSeq[sigmastate.Values.Constant[sigmastate.SType]], root: scala.util.Either[sigmastate.Values.UnparsedErgoTree, sigmastate.Values.Value[sigmastate.SSigmaProp.]], givenComplexity: int, propositionBytes: typing.List[int], givenDeserialize: scala.Option[typing.Any]) -> sigmastate.Values.ErgoTree: ...
    def copy$default$1(self) -> int: ...
    def copy$default$2(self) -> scala.collection.IndexedSeq[sigmastate.Values.Constant[sigmastate.SType]]: ...
    def copy$default$3(self) -> scala.util.Either[sigmastate.Values.UnparsedErgoTree, sigmastate.Values.Value[sigmastate.SSigmaProp.]]: ...
    def copy$default$4(self) -> int: ...
    def copy$default$5(self) -> typing.List[int]: ...
    def copy$default$6(self) -> scala.Option[typing.Any]: ...
    def equals(self, obj: typing.Any) -> bool: ...
    def givenComplexity$access$3(self) -> int: ...
    def givenDeserialize$access$5(self) -> scala.Option[typing.Any]: ...
    def hasDeserialize(self) -> bool: ...
    def hasSize(self) -> bool: ...
    def hashCode(self) -> int: ...
    def header(self) -> int: ...
    def isConstantSegregation(self) -> bool: ...
    def isRightParsed(self) -> bool: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def proposition(self) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...
    def propositionBytes$access$4(self) -> typing.List[int]: ...
    def root(self) -> scala.util.Either[sigmastate.Values.UnparsedErgoTree, sigmastate.Values.Value[sigmastate.SSigmaProp.]]: ...
    def sigmastate$Values$ErgoTree$$givenComplexity(self) -> int: ...
    def sigmastate$Values$ErgoTree$$givenDeserialize(self) -> scala.Option[typing.Any]: ...
    def sigmastate$Values$ErgoTree$$propositionBytes(self) -> typing.List[int]: ...
    def template(self) -> typing.List[int]: ...
    def toProposition(self, replaceConstants: bool) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...
    def toString(self) -> java.lang.String: ...
    def version(self) -> int: ...

class ErgoTree$(scala.Serializable):
    MODULE$: typing.ClassVar[sigmastate.Values.ErgoTree.] = ...
    def __init__(self): ...
    def ConstantSegregationFlag(self) -> int: ...
    def ConstantSegregationHeader(self) -> int: ...
    def DefaultHeader(self) -> int: ...
    def EmptyConstants(self) -> scala.collection.IndexedSeq[sigmastate.Values.Constant[sigmastate.SType]]: ...
    def SizeFlag(self) -> int: ...
    def VersionFlag(self) -> int: ...
    def VersionMask(self) -> int: ...
    @typing.overload
    def apply(self, header: int, constants: scala.collection.IndexedSeq[sigmastate.Values.Constant[sigmastate.SType]], root: scala.util.Either[sigmastate.Values.UnparsedErgoTree, sigmastate.Values.Value[sigmastate.SSigmaProp.]], givenComplexity: int, propositionBytes: typing.List[int], givenDeserialize: scala.Option[typing.Any]) -> sigmastate.Values.ErgoTree: ...
    @typing.overload
    def apply(self, header: int, constants: scala.collection.IndexedSeq[sigmastate.Values.Constant[sigmastate.SType]], root: sigmastate.Values.Value[sigmastate.SSigmaProp.]) -> sigmastate.Values.ErgoTree: ...
    @typing.overload
    def fromProposition(self, headerFlags: int, prop: sigmastate.Values.Value[sigmastate.SSigmaProp.]) -> sigmastate.Values.ErgoTree: ...
    @typing.overload
    def fromProposition(self, prop: sigmastate.Values.Value[sigmastate.SSigmaProp.]) -> sigmastate.Values.ErgoTree: ...
    @typing.overload
    def fromSigmaBoolean(self, headerFlags: int, pk: sigmastate.Values.SigmaBoolean) -> sigmastate.Values.ErgoTree: ...
    @typing.overload
    def fromSigmaBoolean(self, pk: sigmastate.Values.SigmaBoolean) -> sigmastate.Values.ErgoTree: ...
    def getVersion(self, header: int) -> int: ...
    def hasSize(self, header: int) -> bool: ...
    def headerWithVersion(self, version: int) -> int: ...
    def isConstantSegregation(self, header: int) -> bool: ...
    def substConstants(self, root: sigmastate.Values.Value[sigmastate.SType], constants: scala.collection.IndexedSeq[sigmastate.Values.Constant[sigmastate.SType]]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def unapply(self, x$0: sigmastate.Values.ErgoTree) -> scala.Option[scala.Tuple6[typing.Any, scala.collection.IndexedSeq[sigmastate.Values.Constant[sigmastate.SType]], scala.util.Either[sigmastate.Values.UnparsedErgoTree, sigmastate.Values.Value[sigmastate.SSigmaProp.]], typing.Any, typing.List[int], scala.Option[typing.Any]]]: ...
    def updateVersionBits(self, header: int, version: int) -> int: ...
    @typing.overload
    def withSegregation(self, headerFlags: int, prop: sigmastate.Values.Value[sigmastate.SSigmaProp.]) -> sigmastate.Values.ErgoTree: ...
    @typing.overload
    def withSegregation(self, prop: sigmastate.Values.Value[sigmastate.SSigmaProp.]) -> sigmastate.Values.ErgoTree: ...
    @typing.overload
    def withoutSegregation(self, headerFlags: int, root: sigmastate.Values.Value[sigmastate.SSigmaProp.]) -> sigmastate.Values.ErgoTree: ...
    @typing.overload
    def withoutSegregation(self, root: sigmastate.Values.Value[sigmastate.SSigmaProp.]) -> sigmastate.Values.ErgoTree: ...

_sigmastate_Values__EvaluatedCollection__T = typing.TypeVar('_sigmastate_Values__EvaluatedCollection__T', bound=sigmastate.SType)  # <T>
_sigmastate_Values__EvaluatedCollection__C = typing.TypeVar('_sigmastate_Values__EvaluatedCollection__C', bound=sigmastate.SCollection)  # <C>
class EvaluatedCollection(typing.Generic[_sigmastate_Values__EvaluatedCollection__T, _sigmastate_Values__EvaluatedCollection__C]):
    def elementType(self) -> _sigmastate_Values__EvaluatedCollection__T: ...

_sigmastate_Values__EvaluatedValue__S = typing.TypeVar('_sigmastate_Values__EvaluatedValue__S', bound=sigmastate.SType)  # <S>
class EvaluatedValue(sigmastate.Values.Value[_sigmastate_Values__EvaluatedValue__S], typing.Generic[_sigmastate_Values__EvaluatedValue__S]):
    def __init__(self): ...
    def opType(self) -> sigmastate.SFunc: ...
    def value(self) -> typing.Any: ...

class FalseLeaf$(sigmastate.Values.ConstantNode[sigmastate.SBoolean.], sigmastate.Values.ValueCompanion):
    MODULE$: typing.ClassVar[sigmastate.Values.FalseLeaf.] = ...
    def __init__(self): ...
    def companion(self) -> sigmastate.Values.FalseLeaf.: ...
    def costKind(self) -> sigmastate.FixedCost: ...
    def init(self) -> None: ...
    def opCode(self) -> int: ...
    def opDesc(self) -> sigmastate.interpreter.CompanionDesc: ...
    def sigmastate$Values$ValueCompanion$_setter_$opDesc_$eq(self, x$1: sigmastate.interpreter.CompanionDesc) -> None: ...
    def toString(self) -> java.lang.String: ...
    def typeName(self) -> java.lang.String: ...

class FixedCostValueCompanion(sigmastate.Values.ValueCompanion):
    @typing.overload
    def costKind(self) -> sigmastate.CostKind: ...
    @typing.overload
    def costKind(self) -> sigmastate.FixedCost: ...
    def toString(self) -> java.lang.String: ...

class FunDef$(sigmastate.Values.ValueCompanion):
    MODULE$: typing.ClassVar[sigmastate.Values.FunDef.] = ...
    def __init__(self): ...
    def costKind(self) -> scala.runtime.Nothing.: ...
    def init(self) -> None: ...
    def opCode(self) -> int: ...
    def opDesc(self) -> sigmastate.interpreter.CompanionDesc: ...
    def sigmastate$Values$ValueCompanion$_setter_$opDesc_$eq(self, x$1: sigmastate.interpreter.CompanionDesc) -> None: ...
    def toString(self) -> java.lang.String: ...
    def typeName(self) -> java.lang.String: ...
    def unapply(self, d: sigmastate.Values.BlockItem) -> scala.Option[scala.Tuple3[typing.Any, scala.collection.Seq[sigmastate.STypeVar], sigmastate.Values.Value[sigmastate.SType]]]: ...

class FuncValue(sigmastate.Values.Value[sigmastate.SFunc], sigmastate.Values.NotReadyValue[sigmastate.SFunc], scala.Serializable):
    def __init__(self, args: scala.collection.IndexedSeq[scala.Tuple2[typing.Any, sigmastate.SType]], body: sigmastate.Values.Value[sigmastate.SType]): ...
    def args(self) -> scala.collection.IndexedSeq[scala.Tuple2[typing.Any, sigmastate.SType]]: ...
    def body(self) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def companion(self) -> sigmastate.Values.FuncValue.: ...
    def copy(self, args: scala.collection.IndexedSeq[scala.Tuple2[typing.Any, sigmastate.SType]], body: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.FuncValue: ...
    def copy$default$1(self) -> scala.collection.IndexedSeq[scala.Tuple2[typing.Any, sigmastate.SType]]: ...
    def copy$default$2(self) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def eval(self, env: scala.collection.immutable.Map[typing.Any, typing.Any], E: sigmastate.interpreter.ErgoTreeEvaluator) -> typing.Any: ...
    def hashCode(self) -> int: ...
    def opType(self) -> sigmastate.SFunc: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...
    def tpe(self) -> sigmastate.SFunc: ...
    class : ...

class FuncValue$(sigmastate.Values.FixedCostValueCompanion, scala.Serializable):
    MODULE$: typing.ClassVar[sigmastate.Values.FuncValue.] = ...
    def __init__(self): ...
    def AddToEnvironmentDesc(self) -> sigmastate.interpreter.NamedDesc: ...
    def AddToEnvironmentDesc_CostKind(self) -> sigmastate.FixedCost: ...
    @typing.overload
    def apply(self, argId: int, tArg: sigmastate.SType, body: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.FuncValue: ...
    @typing.overload
    def apply(self, args: scala.collection.IndexedSeq[scala.Tuple2[typing.Any, sigmastate.SType]], body: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.FuncValue: ...
    def costKind(self) -> sigmastate.FixedCost: ...
    def init(self) -> None: ...
    def opCode(self) -> int: ...
    def opDesc(self) -> sigmastate.interpreter.CompanionDesc: ...
    def sigmastate$Values$ValueCompanion$_setter_$opDesc_$eq(self, x$1: sigmastate.interpreter.CompanionDesc) -> None: ...
    def toString(self) -> java.lang.String: ...
    def typeName(self) -> java.lang.String: ...
    def unapply(self, x$0: sigmastate.Values.FuncValue) -> scala.Option[scala.Tuple2[scala.collection.IndexedSeq[scala.Tuple2[typing.Any, sigmastate.SType]], sigmastate.Values.Value[sigmastate.SType]]]: ...

class GroupElementConstant$:
    MODULE$: typing.ClassVar[sigmastate.Values.GroupElementConstant.] = ...
    def __init__(self): ...
    @typing.overload
    def apply(self, value: org.bouncycastle.math.ec.custom.sec.SecP256K1Point) -> sigmastate.Values.Constant[sigmastate.SGroupElement.]: ...
    @typing.overload
    def apply(self, value: special.sigma.GroupElement) -> sigmastate.Values.Constant[sigmastate.SGroupElement.]: ...
    def unapply(self, v: sigmastate.Values.Value[sigmastate.SType]) -> scala.Option[special.sigma.GroupElement]: ...

class GroupGenerator$(sigmastate.Values.EvaluatedValue[sigmastate.SGroupElement.], sigmastate.Values.ValueCompanion, scala.Serializable):
    MODULE$: typing.ClassVar[sigmastate.Values.GroupGenerator.] = ...
    def __init__(self): ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def companion(self) -> sigmastate.Values.GroupGenerator.: ...
    def costKind(self) -> sigmastate.FixedCost: ...
    def eval(self, env: scala.collection.immutable.Map[typing.Any, typing.Any], E: sigmastate.interpreter.ErgoTreeEvaluator) -> typing.Any: ...
    def hashCode(self) -> int: ...
    def init(self) -> None: ...
    def opCode(self) -> int: ...
    def opDesc(self) -> sigmastate.interpreter.CompanionDesc: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def sigmastate$Values$ValueCompanion$_setter_$opDesc_$eq(self, x$1: sigmastate.interpreter.CompanionDesc) -> None: ...
    def toString(self) -> java.lang.String: ...
    def tpe(self) -> sigmastate.SGroupElement.: ...
    def typeName(self) -> java.lang.String: ...
    def value(self) -> special.sigma.GroupElement: ...

class HeaderConstant$:
    MODULE$: typing.ClassVar[sigmastate.Values.HeaderConstant.] = ...
    def __init__(self): ...
    def apply(self, value: special.sigma.Header) -> sigmastate.Values.Constant[sigmastate.SHeader.]: ...
    def unapply(self, v: sigmastate.Values.Value[sigmastate.SType]) -> scala.Option[special.sigma.Header]: ...

class IntArrayConstant$:
    MODULE$: typing.ClassVar[sigmastate.Values.IntArrayConstant.] = ...
    def __init__(self): ...
    @typing.overload
    def apply(self, value: typing.List[int]) -> sigmastate.Values.Constant[sigmastate.SCollection[sigmastate.SInt.]]: ...
    @typing.overload
    def apply(self, value: special.collection.Coll[typing.Any]) -> sigmastate.Values.Constant[sigmastate.SCollection[sigmastate.SInt.]]: ...
    def unapply(self, node: sigmastate.Values.Value[sigmastate.SType]) -> scala.Option[special.collection.Coll[typing.Any]]: ...

class IntConstant$:
    MODULE$: typing.ClassVar[sigmastate.Values.IntConstant.] = ...
    def __init__(self): ...
    def Zero(self) -> sigmastate.Values.Constant[sigmastate.SInt.]: ...
    def apply(self, value: int) -> sigmastate.Values.Constant[sigmastate.SInt.]: ...
    def unapply(self, v: sigmastate.Values.Value[sigmastate.SType]) -> scala.Option[typing.Any]: ...

_sigmastate_Values__LazyCollection__V = typing.TypeVar('_sigmastate_Values__LazyCollection__V', bound=sigmastate.SType)  # <V>
class LazyCollection(sigmastate.Values.NotReadyValue[sigmastate.SCollection[_sigmastate_Values__LazyCollection__V]], typing.Generic[_sigmastate_Values__LazyCollection__V]): ...

class LongArrayConstant$:
    MODULE$: typing.ClassVar[sigmastate.Values.LongArrayConstant.] = ...
    def __init__(self): ...
    @typing.overload
    def apply(self, value: typing.List[int]) -> sigmastate.Values.Constant[sigmastate.SCollection[sigmastate.SLong.]]: ...
    @typing.overload
    def apply(self, value: special.collection.Coll[typing.Any]) -> sigmastate.Values.Constant[sigmastate.SCollection[sigmastate.SLong.]]: ...
    def unapply(self, node: sigmastate.Values.Value[sigmastate.SType]) -> scala.Option[special.collection.Coll[typing.Any]]: ...

class LongConstant$:
    MODULE$: typing.ClassVar[sigmastate.Values.LongConstant.] = ...
    def __init__(self): ...
    def apply(self, value: int) -> sigmastate.Values.Constant[sigmastate.SLong.]: ...
    def unapply(self, v: sigmastate.Values.Value[sigmastate.SType]) -> scala.Option[typing.Any]: ...

_sigmastate_Values__NoneValue__T = typing.TypeVar('_sigmastate_Values__NoneValue__T', bound=sigmastate.SType)  # <T>
class NoneValue(sigmastate.Values.Value[sigmastate.SOption[_sigmastate_Values__NoneValue__T]], sigmastate.Values.OptionValue[_sigmastate_Values__NoneValue__T], scala.Serializable, typing.Generic[_sigmastate_Values__NoneValue__T]):
    def __init__(self, elemType: _sigmastate_Values__NoneValue__T): ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def companion(self) -> sigmastate.Values.NoneValue.: ...
    _copy__T = typing.TypeVar('_copy__T', bound=sigmastate.SType)  # <T>
    def copy(self, elemType: sigmastate.SType) -> sigmastate.Values.NoneValue[sigmastate.SType]: ...
    _copy$default$1__T = typing.TypeVar('_copy$default$1__T', bound=sigmastate.SType)  # <T>
    def copy$default$1(self) -> sigmastate.SType: ...
    def elemType(self) -> _sigmastate_Values__NoneValue__T: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def opType(self) -> sigmastate.SFunc: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...
    def tpe(self) -> sigmastate.SOption[_sigmastate_Values__NoneValue__T]: ...
    class : ...

class NoneValue$(sigmastate.Values.ValueCompanion, scala.Serializable):
    MODULE$: typing.ClassVar[sigmastate.Values.NoneValue.] = ...
    def __init__(self): ...
    _apply__T = typing.TypeVar('_apply__T', bound=sigmastate.SType)  # <T>
    def apply(self, elemType: _apply__T) -> sigmastate.Values.NoneValue[_apply__T]: ...
    def costKind(self) -> sigmastate.CostKind: ...
    def init(self) -> None: ...
    def opCode(self) -> int: ...
    def opDesc(self) -> sigmastate.interpreter.CompanionDesc: ...
    def sigmastate$Values$ValueCompanion$_setter_$opDesc_$eq(self, x$1: sigmastate.interpreter.CompanionDesc) -> None: ...
    def toString(self) -> java.lang.String: ...
    def typeName(self) -> java.lang.String: ...
    _unapply__T = typing.TypeVar('_unapply__T', bound=sigmastate.SType)  # <T>
    def unapply(self, x$0: sigmastate.Values.NoneValue[_unapply__T]) -> scala.Option[_unapply__T]: ...

_sigmastate_Values__NotReadyValue__S = typing.TypeVar('_sigmastate_Values__NotReadyValue__S', bound=sigmastate.SType)  # <S>
class NotReadyValue(typing.Generic[_sigmastate_Values__NotReadyValue__S]): ...

class NotReadyValueAvlTree(sigmastate.Values.NotReadyValue[sigmastate.SAvlTree.]):
    @staticmethod
    def $init$($this: sigmastate.Values.NotReadyValueAvlTree) -> None: ...
    def tpe(self) -> sigmastate.SAvlTree.: ...

class NotReadyValueBigInt(sigmastate.Values.NotReadyValue[sigmastate.SBigInt.]):
    @staticmethod
    def $init$($this: sigmastate.Values.NotReadyValueBigInt) -> None: ...
    def tpe(self) -> sigmastate.SBigInt.: ...

class NotReadyValueBoolean(sigmastate.Values.NotReadyValue[sigmastate.SBoolean.]):
    @staticmethod
    def $init$($this: sigmastate.Values.NotReadyValueBoolean) -> None: ...
    def tpe(self) -> sigmastate.SBoolean.: ...

class NotReadyValueBox(sigmastate.Values.NotReadyValue[sigmastate.SBox.]):
    @staticmethod
    def $init$($this: sigmastate.Values.NotReadyValueBox) -> None: ...
    def tpe(self) -> sigmastate.SBox.: ...

class NotReadyValueByteArray(sigmastate.Values.NotReadyValue[sigmastate.SCollection[sigmastate.SByte.]]):
    @staticmethod
    def $init$($this: sigmastate.Values.NotReadyValueByteArray) -> None: ...
    def tpe(self) -> sigmastate.SCollection[sigmastate.SByte.]: ...

class NotReadyValueGroupElement(sigmastate.Values.NotReadyValue[sigmastate.SGroupElement.]):
    @staticmethod
    def $init$($this: sigmastate.Values.NotReadyValueGroupElement) -> None: ...
    def tpe(self) -> sigmastate.SGroupElement.: ...

class NotReadyValueInt(sigmastate.Values.NotReadyValue[sigmastate.SInt.]):
    @staticmethod
    def $init$($this: sigmastate.Values.NotReadyValueInt) -> None: ...
    def tpe(self) -> sigmastate.SInt.: ...

class NotReadyValueLong(sigmastate.Values.NotReadyValue[sigmastate.SLong.]):
    @staticmethod
    def $init$($this: sigmastate.Values.NotReadyValueLong) -> None: ...
    def tpe(self) -> sigmastate.SLong.: ...

_sigmastate_Values__OptionValue__T = typing.TypeVar('_sigmastate_Values__OptionValue__T', bound=sigmastate.SType)  # <T>
class OptionValue(typing.Generic[_sigmastate_Values__OptionValue__T]): ...

_sigmastate_Values__OptionValueOps__T = typing.TypeVar('_sigmastate_Values__OptionValueOps__T', bound=sigmastate.SType)  # <T>
class OptionValueOps(typing.Generic[_sigmastate_Values__OptionValueOps__T]):
    def __init__(self, p: sigmastate.Values.Value[sigmastate.SOption[_sigmastate_Values__OptionValueOps__T]]): ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def get(self) -> sigmastate.Values.Value[_sigmastate_Values__OptionValueOps__T]: ...
    def getOrElse(self, default: sigmastate.Values.Value[_sigmastate_Values__OptionValueOps__T]) -> sigmastate.Values.Value[_sigmastate_Values__OptionValueOps__T]: ...
    def hashCode(self) -> int: ...
    def isDefined(self) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    def p(self) -> sigmastate.Values.Value[sigmastate.SOption[_sigmastate_Values__OptionValueOps__T]]: ...

class OptionValueOps$:
    MODULE$: typing.ClassVar[sigmastate.Values.OptionValueOps.] = ...
    def __init__(self): ...
    _equals$extension__T = typing.TypeVar('_equals$extension__T', bound=sigmastate.SType)  # <T>
    def equals$extension(self, $this: sigmastate.Values.Value[sigmastate.SOption[_equals.extension__T]], x$1: typing.Any) -> bool: ...
    _get$extension__T = typing.TypeVar('_get$extension__T', bound=sigmastate.SType)  # <T>
    def get$extension(self, $this: sigmastate.Values.Value[sigmastate.SOption[_get.extension__T]]) -> sigmastate.Values.Value[_get.extension__T]: ...
    _getOrElse$extension__T = typing.TypeVar('_getOrElse$extension__T', bound=sigmastate.SType)  # <T>
    def getOrElse$extension(self, $this: sigmastate.Values.Value[sigmastate.SOption[_getOrElse.extension__T]], default: sigmastate.Values.Value[_getOrElse.extension__T]) -> sigmastate.Values.Value[_getOrElse.extension__T]: ...
    _hashCode$extension__T = typing.TypeVar('_hashCode$extension__T', bound=sigmastate.SType)  # <T>
    def hashCode$extension(self, $this: sigmastate.Values.Value[sigmastate.SOption[_hashCode.extension__T]]) -> int: ...
    _isDefined$extension__T = typing.TypeVar('_isDefined$extension__T', bound=sigmastate.SType)  # <T>
    def isDefined$extension(self, $this: sigmastate.Values.Value[sigmastate.SOption[_isDefined.extension__T]]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...

class PerItemCostValueCompanion(sigmastate.Values.ValueCompanion):
    @typing.overload
    def costKind(self) -> sigmastate.CostKind: ...
    @typing.overload
    def costKind(self) -> sigmastate.PerItemCost: ...
    def toString(self) -> java.lang.String: ...

class PreHeaderConstant$:
    MODULE$: typing.ClassVar[sigmastate.Values.PreHeaderConstant.] = ...
    def __init__(self): ...
    def apply(self, value: special.sigma.PreHeader) -> sigmastate.Values.Constant[sigmastate.SPreHeader.]: ...
    def unapply(self, v: sigmastate.Values.Value[sigmastate.SType]) -> scala.Option[special.sigma.PreHeader]: ...

class ShortArrayConstant$:
    MODULE$: typing.ClassVar[sigmastate.Values.ShortArrayConstant.] = ...
    def __init__(self): ...
    @typing.overload
    def apply(self, value: typing.List[int]) -> sigmastate.Values.Constant[sigmastate.SCollection[sigmastate.SShort.]]: ...
    @typing.overload
    def apply(self, value: special.collection.Coll[typing.Any]) -> sigmastate.Values.Constant[sigmastate.SCollection[sigmastate.SShort.]]: ...
    def unapply(self, node: sigmastate.Values.Value[sigmastate.SType]) -> scala.Option[special.collection.Coll[typing.Any]]: ...

class ShortConstant$:
    MODULE$: typing.ClassVar[sigmastate.Values.ShortConstant.] = ...
    def __init__(self): ...
    def apply(self, value: int) -> sigmastate.Values.Constant[sigmastate.SShort.]: ...

class SigmaBoolean:
    def opCode(self) -> int: ...
    def size(self) -> int: ...

class SigmaBoolean$:
    MODULE$: typing.ClassVar[sigmastate.Values.SigmaBoolean.] = ...
    def __init__(self): ...
    def estimateCost(self, sb: sigmastate.Values.SigmaBoolean) -> int: ...
    def totalSize(self, children: scala.collection.Seq[sigmastate.Values.SigmaBoolean]) -> int: ...
    class serializer$(sigmastate.serialization.SigmaSerializer[sigmastate.Values.SigmaBoolean, sigmastate.Values.SigmaBoolean]):
        MODULE$: typing.ClassVar[sigmastate.Values.SigmaBoolean.serializer.] = ...
        def __init__(self): ...
        def dhtSerializer(self) -> sigmastate.serialization.transformers.ProveDHTupleSerializer: ...
        def dlogSerializer(self) -> sigmastate.serialization.ProveDlogSerializer: ...
        def parse(self, r: sigmastate.utils.SigmaByteReader) -> sigmastate.Values.SigmaBoolean: ...
        def serialize(self, data: sigmastate.Values.SigmaBoolean, w: sigmastate.utils.SigmaByteWriter) -> None: ...

class SigmaBooleanOps:
    def __init__(self, sb: sigmastate.Values.SigmaBoolean): ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def isProven(self) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    def sb(self) -> sigmastate.Values.SigmaBoolean: ...
    def showToString(self) -> java.lang.String: ...
    def toSigmaProp(self) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...

class SigmaBooleanOps$:
    MODULE$: typing.ClassVar[sigmastate.Values.SigmaBooleanOps.] = ...
    def __init__(self): ...
    def equals$extension(self, $this: sigmastate.Values.SigmaBoolean, x$1: typing.Any) -> bool: ...
    def hashCode$extension(self, $this: sigmastate.Values.SigmaBoolean) -> int: ...
    def isProven$extension(self, $this: sigmastate.Values.SigmaBoolean) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    def showToString$extension(self, $this: sigmastate.Values.SigmaBoolean) -> java.lang.String: ...
    def toSigmaProp$extension(self, $this: sigmastate.Values.SigmaBoolean) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...

class SigmaPropConstant$:
    MODULE$: typing.ClassVar[sigmastate.Values.SigmaPropConstant.] = ...
    def __init__(self): ...
    @typing.overload
    def apply(self, value: sigmastate.Values.SigmaBoolean) -> sigmastate.Values.Constant[sigmastate.SSigmaProp.]: ...
    @typing.overload
    def apply(self, value: special.sigma.SigmaProp) -> sigmastate.Values.Constant[sigmastate.SSigmaProp.]: ...
    def unapply(self, v: sigmastate.Values.Value[sigmastate.SType]) -> scala.Option[special.sigma.SigmaProp]: ...

class SigmaPropValueOps:
    def __init__(self, p: sigmastate.Values.Value[sigmastate.SSigmaProp.]): ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def isProven(self) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    def p(self) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...
    def propBytes(self) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    @typing.overload
    def treeWithSegregation(self) -> sigmastate.Values.ErgoTree: ...
    @typing.overload
    def treeWithSegregation(self, headerFlags: int) -> sigmastate.Values.ErgoTree: ...

class SigmaPropValueOps$:
    MODULE$: typing.ClassVar[sigmastate.Values.SigmaPropValueOps.] = ...
    def __init__(self): ...
    def equals$extension(self, $this: sigmastate.Values.Value, x$1: typing.Any) -> bool: ...
    def hashCode$extension(self, $this: sigmastate.Values.Value) -> int: ...
    def isProven$extension(self, $this: sigmastate.Values.Value[sigmastate.SSigmaProp.]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    def propBytes$extension(self, $this: sigmastate.Values.Value[sigmastate.SSigmaProp.]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    def treeWithSegregation$extension0(self, $this: sigmastate.Values.Value) -> sigmastate.Values.ErgoTree: ...
    def treeWithSegregation$extension1(self, $this: sigmastate.Values.Value, headerFlags: int) -> sigmastate.Values.ErgoTree: ...

_sigmastate_Values__SomeValue__T = typing.TypeVar('_sigmastate_Values__SomeValue__T', bound=sigmastate.SType)  # <T>
class SomeValue(sigmastate.Values.Value[sigmastate.SOption[_sigmastate_Values__SomeValue__T]], sigmastate.Values.OptionValue[_sigmastate_Values__SomeValue__T], scala.Serializable, typing.Generic[_sigmastate_Values__SomeValue__T]):
    def __init__(self, x: sigmastate.Values.Value[_sigmastate_Values__SomeValue__T]): ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def companion(self) -> sigmastate.Values.SomeValue.: ...
    _copy__T = typing.TypeVar('_copy__T', bound=sigmastate.SType)  # <T>
    def copy(self, x: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.SomeValue[sigmastate.SType]: ...
    _copy$default$1__T = typing.TypeVar('_copy$default$1__T', bound=sigmastate.SType)  # <T>
    def copy$default$1(self) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def opType(self) -> sigmastate.SFunc: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...
    def tpe(self) -> sigmastate.SOption[_sigmastate_Values__SomeValue__T]: ...
    def x(self) -> sigmastate.Values.Value[_sigmastate_Values__SomeValue__T]: ...
    class : ...

class SomeValue$(sigmastate.Values.ValueCompanion, scala.Serializable):
    MODULE$: typing.ClassVar[sigmastate.Values.SomeValue.] = ...
    def __init__(self): ...
    _apply__T = typing.TypeVar('_apply__T', bound=sigmastate.SType)  # <T>
    def apply(self, x: sigmastate.Values.Value[_apply__T]) -> sigmastate.Values.SomeValue[_apply__T]: ...
    def costKind(self) -> sigmastate.CostKind: ...
    def init(self) -> None: ...
    def opCode(self) -> int: ...
    def opDesc(self) -> sigmastate.interpreter.CompanionDesc: ...
    def sigmastate$Values$ValueCompanion$_setter_$opDesc_$eq(self, x$1: sigmastate.interpreter.CompanionDesc) -> None: ...
    def toString(self) -> java.lang.String: ...
    def typeName(self) -> java.lang.String: ...
    _unapply__T = typing.TypeVar('_unapply__T', bound=sigmastate.SType)  # <T>
    def unapply(self, x$0: sigmastate.Values.SomeValue[_unapply__T]) -> scala.Option[sigmastate.Values.Value[_unapply__T]]: ...

class StringConstant$:
    MODULE$: typing.ClassVar[sigmastate.Values.StringConstant.] = ...
    def __init__(self): ...
    def apply(self, value: typing.Union[java.lang.String, str]) -> sigmastate.Values.Constant[sigmastate.SString.]: ...
    def unapply(self, v: sigmastate.Values.Value[sigmastate.SType]) -> scala.Option[java.lang.String]: ...

_sigmastate_Values__TaggedVariable__T = typing.TypeVar('_sigmastate_Values__TaggedVariable__T', bound=sigmastate.SType)  # <T>
class TaggedVariable(sigmastate.Values.ContextVariable[_sigmastate_Values__TaggedVariable__T], typing.Generic[_sigmastate_Values__TaggedVariable__T]):
    def varId(self) -> int: ...

class TaggedVariable$(sigmastate.Values.ValueCompanion):
    MODULE$: typing.ClassVar[sigmastate.Values.TaggedVariable.] = ...
    def __init__(self): ...
    _apply__T = typing.TypeVar('_apply__T', bound=sigmastate.SType)  # <T>
    def apply(self, varId: int, tpe: _apply__T) -> sigmastate.Values.TaggedVariable[_apply__T]: ...
    def costKind(self) -> sigmastate.CostKind: ...
    def init(self) -> None: ...
    def opCode(self) -> int: ...
    def opDesc(self) -> sigmastate.interpreter.CompanionDesc: ...
    def sigmastate$Values$ValueCompanion$_setter_$opDesc_$eq(self, x$1: sigmastate.interpreter.CompanionDesc) -> None: ...
    def toString(self) -> java.lang.String: ...
    def typeName(self) -> java.lang.String: ...

_sigmastate_Values__TaggedVariableNode__T = typing.TypeVar('_sigmastate_Values__TaggedVariableNode__T', bound=sigmastate.SType)  # <T>
class TaggedVariableNode(sigmastate.Values.Value[_sigmastate_Values__TaggedVariableNode__T], sigmastate.Values.TaggedVariable[_sigmastate_Values__TaggedVariableNode__T], scala.Serializable, typing.Generic[_sigmastate_Values__TaggedVariableNode__T]):
    def __init__(self, varId: int, tpe: _sigmastate_Values__TaggedVariableNode__T): ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def companion(self) -> sigmastate.Values.TaggedVariable.: ...
    _copy__T = typing.TypeVar('_copy__T', bound=sigmastate.SType)  # <T>
    def copy(self, varId: int, tpe: sigmastate.SType) -> sigmastate.Values.TaggedVariableNode[sigmastate.SType]: ...
    _copy$default$1__T = typing.TypeVar('_copy$default$1__T', bound=sigmastate.SType)  # <T>
    def copy$default$1(self) -> int: ...
    _copy$default$2__T = typing.TypeVar('_copy$default$2__T', bound=sigmastate.SType)  # <T>
    def copy$default$2(self) -> sigmastate.SType: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def opType(self) -> sigmastate.SFunc: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...
    def tpe(self) -> _sigmastate_Values__TaggedVariableNode__T: ...
    def varId(self) -> int: ...

class TaggedVariableNode$(scala.Serializable):
    MODULE$: typing.ClassVar[sigmastate.Values.TaggedVariableNode.] = ...
    def __init__(self): ...
    _apply__T = typing.TypeVar('_apply__T', bound=sigmastate.SType)  # <T>
    def apply(self, varId: int, tpe: _apply__T) -> sigmastate.Values.TaggedVariableNode[_apply__T]: ...
    def toString(self) -> java.lang.String: ...
    _unapply__T = typing.TypeVar('_unapply__T', bound=sigmastate.SType)  # <T>
    def unapply(self, x$0: sigmastate.Values.TaggedVariableNode[_unapply__T]) -> scala.Option[scala.Tuple2[typing.Any, _unapply__T]]: ...

class TrueLeaf$(sigmastate.Values.ConstantNode[sigmastate.SBoolean.], sigmastate.Values.ValueCompanion):
    MODULE$: typing.ClassVar[sigmastate.Values.TrueLeaf.] = ...
    def __init__(self): ...
    def companion(self) -> sigmastate.Values.TrueLeaf.: ...
    def costKind(self) -> sigmastate.FixedCost: ...
    def init(self) -> None: ...
    def opCode(self) -> int: ...
    def opDesc(self) -> sigmastate.interpreter.CompanionDesc: ...
    def sigmastate$Values$ValueCompanion$_setter_$opDesc_$eq(self, x$1: sigmastate.interpreter.CompanionDesc) -> None: ...
    def toString(self) -> java.lang.String: ...
    def typeName(self) -> java.lang.String: ...

class Tuple(sigmastate.Values.EvaluatedValue[sigmastate.STuple], sigmastate.Values.EvaluatedCollection[sigmastate.SAny., sigmastate.STuple], scala.Serializable):
    def __init__(self, items: scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]]): ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def companion(self) -> sigmastate.Values.Tuple.: ...
    def copy(self, items: scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]]) -> sigmastate.Values.Tuple: ...
    def copy$default$1(self) -> scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]]: ...
    def elementType(self) -> sigmastate.SAny.: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def eval(self, env: scala.collection.immutable.Map[typing.Any, typing.Any], E: sigmastate.interpreter.ErgoTreeEvaluator) -> typing.Any: ...
    def hashCode(self) -> int: ...
    def items(self) -> scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]]: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...
    def tpe(self) -> sigmastate.STuple: ...
    def value(self) -> special.collection.Coll[typing.Any]: ...
    class : ...

class Tuple$(sigmastate.Values.FixedCostValueCompanion, scala.Serializable):
    MODULE$: typing.ClassVar[sigmastate.Values.Tuple.] = ...
    def __init__(self): ...
    @typing.overload
    def apply(self, items: scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]]) -> sigmastate.Values.Tuple: ...
    @typing.overload
    def apply(self, items: scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]]) -> sigmastate.Values.Tuple: ...
    def costKind(self) -> sigmastate.FixedCost: ...
    def init(self) -> None: ...
    def opCode(self) -> int: ...
    def opDesc(self) -> sigmastate.interpreter.CompanionDesc: ...
    def sigmastate$Values$ValueCompanion$_setter_$opDesc_$eq(self, x$1: sigmastate.interpreter.CompanionDesc) -> None: ...
    def toString(self) -> java.lang.String: ...
    def typeName(self) -> java.lang.String: ...
    def unapply(self, x$0: sigmastate.Values.Tuple) -> scala.Option[scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]]]: ...

class UnitConstant(sigmastate.Values.EvaluatedValue[sigmastate.SUnit.], scala.Serializable):
    def __init__(self): ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def companion(self) -> sigmastate.Values.ValueCompanion: ...
    def copy(self) -> sigmastate.Values.UnitConstant: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...
    def tpe(self) -> sigmastate.SUnit.: ...
    def value(self) -> None: ...

class UnitConstant$(sigmastate.Values.ValueCompanion, scala.Serializable):
    MODULE$: typing.ClassVar[sigmastate.Values.UnitConstant.] = ...
    def __init__(self): ...
    def apply(self) -> sigmastate.Values.UnitConstant: ...
    def costKind(self) -> sigmastate.FixedCost: ...
    def init(self) -> None: ...
    def opCode(self) -> int: ...
    def opDesc(self) -> sigmastate.interpreter.CompanionDesc: ...
    def sigmastate$Values$ValueCompanion$_setter_$opDesc_$eq(self, x$1: sigmastate.interpreter.CompanionDesc) -> None: ...
    def toString(self) -> java.lang.String: ...
    def typeName(self) -> java.lang.String: ...
    def unapply(self, x$0: sigmastate.Values.UnitConstant) -> bool: ...

class UnparsedErgoTree(scala.Product, scala.Serializable):
    def __init__(self, bytes: scala.collection.mutable.WrappedArray[typing.Any], error: org.ergoplatform.validation.ValidationException): ...
    def bytes(self) -> scala.collection.mutable.WrappedArray[typing.Any]: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def copy(self, bytes: scala.collection.mutable.WrappedArray[typing.Any], error: org.ergoplatform.validation.ValidationException) -> sigmastate.Values.UnparsedErgoTree: ...
    def copy$default$1(self) -> scala.collection.mutable.WrappedArray[typing.Any]: ...
    def copy$default$2(self) -> org.ergoplatform.validation.ValidationException: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def error(self) -> org.ergoplatform.validation.ValidationException: ...
    def hashCode(self) -> int: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...

class UnparsedErgoTree$(scala.runtime.AbstractFunction2[scala.collection.mutable.WrappedArray[typing.Any], org.ergoplatform.validation.ValidationException, sigmastate.Values.UnparsedErgoTree], scala.Serializable):
    MODULE$: typing.ClassVar[sigmastate.Values.UnparsedErgoTree.] = ...
    def __init__(self): ...
    def apply(self, bytes: scala.collection.mutable.WrappedArray[typing.Any], error: org.ergoplatform.validation.ValidationException) -> sigmastate.Values.UnparsedErgoTree: ...
    def toString(self) -> java.lang.String: ...
    def unapply(self, x$0: sigmastate.Values.UnparsedErgoTree) -> scala.Option[scala.Tuple2[scala.collection.mutable.WrappedArray[typing.Any], org.ergoplatform.validation.ValidationException]]: ...

class ValDef(sigmastate.Values.Value[sigmastate.SType], sigmastate.Values.BlockItem, scala.Serializable):
    def __init__(self, id: int, tpeArgs: scala.collection.Seq[sigmastate.STypeVar], rhs: sigmastate.Values.Value[sigmastate.SType]): ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def companion(self) -> sigmastate.Values.ValueCompanion: ...
    def copy(self, id: int, tpeArgs: scala.collection.Seq[sigmastate.STypeVar], rhs: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.ValDef: ...
    def copy$default$1(self) -> int: ...
    def copy$default$2(self) -> scala.collection.Seq[sigmastate.STypeVar]: ...
    def copy$default$3(self) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def id(self) -> int: ...
    def isValDef(self) -> bool: ...
    def opType(self) -> sigmastate.SFunc: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def rhs(self) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def toString(self) -> java.lang.String: ...
    def tpe(self) -> sigmastate.SType: ...
    def tpeArgs(self) -> scala.collection.Seq[sigmastate.STypeVar]: ...

class ValDef$(sigmastate.Values.ValueCompanion, scala.Serializable):
    MODULE$: typing.ClassVar[sigmastate.Values.ValDef.] = ...
    def __init__(self): ...
    @typing.overload
    def apply(self, id: int, tpeArgs: scala.collection.Seq[sigmastate.STypeVar], rhs: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.ValDef: ...
    @typing.overload
    def apply(self, id: int, rhs: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.ValDef: ...
    def costKind(self) -> scala.runtime.Nothing.: ...
    def init(self) -> None: ...
    def opCode(self) -> int: ...
    def opDesc(self) -> sigmastate.interpreter.CompanionDesc: ...
    def sigmastate$Values$ValueCompanion$_setter_$opDesc_$eq(self, x$1: sigmastate.interpreter.CompanionDesc) -> None: ...
    def toString(self) -> java.lang.String: ...
    def typeName(self) -> java.lang.String: ...
    def unapply(self, x$0: sigmastate.Values.ValDef) -> scala.Option[scala.Tuple3[typing.Any, scala.collection.Seq[sigmastate.STypeVar], sigmastate.Values.Value[sigmastate.SType]]]: ...

_sigmastate_Values__ValUse__T = typing.TypeVar('_sigmastate_Values__ValUse__T', bound=sigmastate.SType)  # <T>
class ValUse(sigmastate.Values.Value[_sigmastate_Values__ValUse__T], sigmastate.Values.NotReadyValue[_sigmastate_Values__ValUse__T], scala.Serializable, typing.Generic[_sigmastate_Values__ValUse__T]):
    def __init__(self, valId: int, tpe: _sigmastate_Values__ValUse__T): ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def companion(self) -> sigmastate.Values.ValUse.: ...
    _copy__T = typing.TypeVar('_copy__T', bound=sigmastate.SType)  # <T>
    def copy(self, valId: int, tpe: sigmastate.SType) -> sigmastate.Values.ValUse[sigmastate.SType]: ...
    _copy$default$1__T = typing.TypeVar('_copy$default$1__T', bound=sigmastate.SType)  # <T>
    def copy$default$1(self) -> int: ...
    _copy$default$2__T = typing.TypeVar('_copy$default$2__T', bound=sigmastate.SType)  # <T>
    def copy$default$2(self) -> sigmastate.SType: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def eval(self, env: scala.collection.immutable.Map[typing.Any, typing.Any], E: sigmastate.interpreter.ErgoTreeEvaluator) -> typing.Any: ...
    def hashCode(self) -> int: ...
    def opType(self) -> sigmastate.SFunc: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...
    def tpe(self) -> _sigmastate_Values__ValUse__T: ...
    def valId(self) -> int: ...
    class : ...

class ValUse$(sigmastate.Values.FixedCostValueCompanion, scala.Serializable):
    MODULE$: typing.ClassVar[sigmastate.Values.ValUse.] = ...
    def __init__(self): ...
    _apply__T = typing.TypeVar('_apply__T', bound=sigmastate.SType)  # <T>
    def apply(self, valId: int, tpe: _apply__T) -> sigmastate.Values.ValUse[_apply__T]: ...
    def costKind(self) -> sigmastate.FixedCost: ...
    def init(self) -> None: ...
    def opCode(self) -> int: ...
    def opDesc(self) -> sigmastate.interpreter.CompanionDesc: ...
    def sigmastate$Values$ValueCompanion$_setter_$opDesc_$eq(self, x$1: sigmastate.interpreter.CompanionDesc) -> None: ...
    def toString(self) -> java.lang.String: ...
    def typeName(self) -> java.lang.String: ...
    _unapply__T = typing.TypeVar('_unapply__T', bound=sigmastate.SType)  # <T>
    def unapply(self, x$0: sigmastate.Values.ValUse[_unapply__T]) -> scala.Option[scala.Tuple2[typing.Any, _unapply__T]]: ...

_sigmastate_Values__Value__S = typing.TypeVar('_sigmastate_Values__Value__S', bound=sigmastate.SType)  # <S>
class Value(sigmastate.SigmaNode, typing.Generic[_sigmastate_Values__Value__S]):
    def __init__(self): ...
    def _sourceContext(self) -> sigmastate.lang.SourceContext: ...
    def _sourceContext_$eq(self, x$1: sigmastate.lang.SourceContext) -> None: ...
    _addCost_0__R = typing.TypeVar('_addCost_0__R')  # <R>
    @typing.overload
    def addCost(self, costKind: sigmastate.TypeBasedCost, tpe: sigmastate.SType, block: scala.Function0[_addCost_0__R], E: sigmastate.interpreter.ErgoTreeEvaluator) -> _addCost_0__R: ...
    @typing.overload
    def addCost(self, costKind: sigmastate.FixedCost, E: sigmastate.interpreter.ErgoTreeEvaluator) -> None: ...
    _addSeqCost__R = typing.TypeVar('_addSeqCost__R')  # <R>
    def addSeqCost(self, costKind: sigmastate.PerItemCost, nItems: int, block: scala.Function0[_addSeqCost__R], E: sigmastate.interpreter.ErgoTreeEvaluator) -> _addSeqCost__R: ...
    def addSeqCostNoOp(self, costKind: sigmastate.PerItemCost, nItems: int, E: sigmastate.interpreter.ErgoTreeEvaluator) -> None: ...
    def companion(self) -> sigmastate.Values.ValueCompanion: ...
    def eval(self, env: scala.collection.immutable.Map[typing.Any, typing.Any], E: sigmastate.interpreter.ErgoTreeEvaluator) -> typing.Any: ...
    _evalTo__T = typing.TypeVar('_evalTo__T')  # <T>
    def evalTo(self, env: scala.collection.immutable.Map[typing.Any, typing.Any], E: sigmastate.interpreter.ErgoTreeEvaluator) -> _evalTo__T: ...
    def opCode(self) -> int: ...
    def opName(self) -> java.lang.String: ...
    def opType(self) -> sigmastate.SFunc: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def sourceContext(self) -> sigmastate.lang.SourceContext: ...
    def sourceContext_$eq(self, srcCtx: sigmastate.lang.SourceContext) -> None: ...
    def tpe(self) -> _sigmastate_Values__Value__S: ...

class Value$:
    MODULE$: typing.ClassVar[sigmastate.Values.Value.] = ...
    def __init__(self): ...
    def EmptyArray(self) -> typing.List[sigmastate.Values.Value[sigmastate.SType]]: ...
    def EmptySeq(self) -> scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]]: ...
    @typing.overload
    def checkType(self, tpe: sigmastate.SType, evalResult: typing.Any) -> None: ...
    @typing.overload
    def checkType(self, node: sigmastate.Values.Value[sigmastate.SType], evalResult: typing.Any) -> None: ...
    def hasDeserialize(self, exp: sigmastate.Values.Value[sigmastate.SType]) -> bool: ...
    def liftBigInt(self, arr: special.sigma.BigInt) -> sigmastate.Values.Value[sigmastate.SBigInt.]: ...
    def liftByte(self, n: int) -> sigmastate.Values.Value[sigmastate.SByte.]: ...
    def liftByteArray(self, arr: typing.List[int]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    def liftECPoint(self, g: org.bouncycastle.math.ec.custom.sec.SecP256K1Point) -> sigmastate.Values.Value[sigmastate.SGroupElement.]: ...
    def liftGroupElement(self, g: special.sigma.GroupElement) -> sigmastate.Values.Value[sigmastate.SGroupElement.]: ...
    def liftInt(self, n: int) -> sigmastate.Values.Value[sigmastate.SInt.]: ...
    def liftLong(self, n: int) -> sigmastate.Values.Value[sigmastate.SLong.]: ...
    def liftShort(self, n: int) -> sigmastate.Values.Value[sigmastate.SShort.]: ...
    def liftSigmaBoolean(self, sb: sigmastate.Values.SigmaBoolean) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...
    def liftSigmaProp(self, g: special.sigma.SigmaProp) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...
    def notSupportedError(self, v: typing.Any, opName: typing.Union[java.lang.String, str]) -> scala.runtime.Nothing.: ...
    @typing.overload
    def typeError(self, tpe: sigmastate.SType, evalResult: typing.Any) -> scala.runtime.Nothing.: ...
    @typing.overload
    def typeError(self, node: sigmastate.Values.Value[sigmastate.SType], evalResult: typing.Any) -> scala.runtime.Nothing.: ...
    class Typed$:
        MODULE$: typing.ClassVar[sigmastate.Values.Value.Typed.] = ...
        def __init__(self): ...
        def unapply(self, v: sigmastate.Values.Value[sigmastate.SType]) -> scala.Option[scala.Tuple2[sigmastate.Values.Value[sigmastate.SType], sigmastate.SType]]: ...

class ValueCompanion(sigmastate.SigmaNodeCompanion):
    @staticmethod
    def $init$($this: sigmastate.Values.ValueCompanion) -> None: ...
    def costKind(self) -> sigmastate.CostKind: ...
    def init(self) -> None: ...
    def opCode(self) -> int: ...
    def opDesc(self) -> sigmastate.interpreter.CompanionDesc: ...
    def sigmastate$Values$ValueCompanion$_setter_$opDesc_$eq(self, x$1: sigmastate.interpreter.CompanionDesc) -> None: ...
    def toString(self) -> java.lang.String: ...
    def typeName(self) -> java.lang.String: ...

class ValueCompanion$:
    MODULE$: typing.ClassVar[sigmastate.Values.ValueCompanion.] = ...
    def __init__(self): ...
    def allOperations(self) -> scala.collection.immutable.Map[typing.Any, sigmastate.Values.ValueCompanion]: ...
    def sigmastate$Values$ValueCompanion$$_allOperations(self) -> scala.collection.mutable.HashMap[typing.Any, sigmastate.Values.ValueCompanion]: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("sigmastate.Values")``.

    pass
