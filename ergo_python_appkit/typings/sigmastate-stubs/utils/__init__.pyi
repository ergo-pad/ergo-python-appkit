import io.circe
import java.lang
import org.bouncycastle.math.ec.custom.sec
import scala
import scala.collection
import scala.reflect
import scala.runtime
import scala.util
import scorex.util.serialization
import sigmastate
import sigmastate.serialization
import special.collection
import special.sigma
import typing



_Helpers__DecoderResultOps__A = typing.TypeVar('_Helpers__DecoderResultOps__A')  # <A>
_Helpers__EitherOps__A = typing.TypeVar('_Helpers__EitherOps__A')  # <A>
_Helpers__EitherOps__B = typing.TypeVar('_Helpers__EitherOps__B')  # <B>
_Helpers__TryOps__A = typing.TypeVar('_Helpers__TryOps__A')  # <A>
class Helpers:
    @staticmethod
    def allOf(arr: typing.List[bool]) -> bool: ...
    @staticmethod
    def anyOf(arr: typing.List[bool]) -> bool: ...
    @staticmethod
    def castArray(array: typing.Any, evidence$3: scala.reflect.ClassTag) -> typing.Any: ...
    @typing.overload
    @staticmethod
    def concatArrays(arr1: typing.Any, arr2: typing.Any, evidence$1: scala.reflect.ClassTag) -> typing.Any: ...
    @typing.overload
    @staticmethod
    def concatArrays(seq: scala.collection.Traversable, evidence$2: scala.reflect.ClassTag) -> typing.Any: ...
    @staticmethod
    def concatBytes(seq: scala.collection.Traversable[typing.List[int]]) -> typing.List[int]: ...
    @staticmethod
    def decodeBytes(base16String: typing.Union[java.lang.String, str]) -> special.collection.Coll[typing.Any]: ...
    @staticmethod
    def decodeECPoint(hexString: typing.Union[java.lang.String, str]) -> org.bouncycastle.math.ec.custom.sec.SecP256K1Point: ...
    @staticmethod
    def decodeGroupElement(hexString: typing.Union[java.lang.String, str]) -> special.sigma.GroupElement: ...
    _deepHashCode__T = typing.TypeVar('_deepHashCode__T')  # <T>
    @staticmethod
    def deepHashCode(arr: typing.Any) -> int: ...
    _optionArrayEquals__A = typing.TypeVar('_optionArrayEquals__A')  # <A>
    @staticmethod
    def optionArrayEquals(maybeA1: scala.Option[typing.Any], maybeA2: scala.Option[typing.Any]) -> bool: ...
    @typing.overload
    @staticmethod
    def xor(ba1: typing.List[int], ba2: typing.List[int]) -> typing.List[int]: ...
    @typing.overload
    @staticmethod
    def xor(bas: scala.collection.Seq[typing.List[int]]) -> typing.List[int]: ...
    @typing.overload
    @staticmethod
    def xorU(ba1: typing.List[int], ba2: typing.List[int]) -> typing.List[int]: ...
    @typing.overload
    @staticmethod
    def xorU(target: typing.List[int], xss: scala.collection.Seq[typing.List[int]]) -> typing.List[int]: ...
    class DecoderResultOps(typing.Generic[_Helpers__DecoderResultOps__A]):
        def __init__(self, source: scala.util.Either[io.circe.DecodingFailure, _Helpers__DecoderResultOps__A]): ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def source(self) -> scala.util.Either[io.circe.DecodingFailure, _Helpers__DecoderResultOps__A]: ...
        def toTry(self) -> scala.util.Try[_Helpers__DecoderResultOps__A]: ...
    class DecoderResultOps$:
        MODULE$: typing.ClassVar['Helpers.DecoderResultOps.'] = ...
        def __init__(self): ...
        _equals$extension__A = typing.TypeVar('_equals$extension__A')  # <A>
        def equals$extension(self, $this: scala.util.Either[io.circe.DecodingFailure, _equals.extension__A], x$1: typing.Any) -> bool: ...
        _hashCode$extension__A = typing.TypeVar('_hashCode$extension__A')  # <A>
        def hashCode$extension(self, $this: scala.util.Either[io.circe.DecodingFailure, _hashCode.extension__A]) -> int: ...
        _toTry$extension__A = typing.TypeVar('_toTry$extension__A')  # <A>
        def toTry$extension(self, $this: scala.util.Either[io.circe.DecodingFailure, _toTry.extension__A]) -> scala.util.Try[_toTry.extension__A]: ...
    class EitherOps(typing.Generic[_Helpers__EitherOps__A, _Helpers__EitherOps__B]):
        def __init__(self, source: scala.util.Either[_Helpers__EitherOps__A, _Helpers__EitherOps__B]): ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        _mapRight__B1 = typing.TypeVar('_mapRight__B1')  # <B1>
        def mapRight(self, f: scala.Function1[_Helpers__EitherOps__B, _mapRight__B1]) -> scala.util.Either[_Helpers__EitherOps__A, _mapRight__B1]: ...
        def source(self) -> scala.util.Either[_Helpers__EitherOps__A, _Helpers__EitherOps__B]: ...
    class EitherOps$:
        MODULE$: typing.ClassVar['Helpers.EitherOps.'] = ...
        def __init__(self): ...
        _equals$extension__A = typing.TypeVar('_equals$extension__A')  # <A>
        _equals$extension__B = typing.TypeVar('_equals$extension__B')  # <B>
        def equals$extension(self, $this: scala.util.Either[_equals.extension__A, _equals.extension__B], x$1: typing.Any) -> bool: ...
        _hashCode$extension__A = typing.TypeVar('_hashCode$extension__A')  # <A>
        _hashCode$extension__B = typing.TypeVar('_hashCode$extension__B')  # <B>
        def hashCode$extension(self, $this: scala.util.Either[_hashCode.extension__A, _hashCode.extension__B]) -> int: ...
        _mapRight$extension__B1 = typing.TypeVar('_mapRight$extension__B1')  # <B1>
        _mapRight$extension__A = typing.TypeVar('_mapRight$extension__A')  # <A>
        _mapRight$extension__B = typing.TypeVar('_mapRight$extension__B')  # <B>
        def mapRight$extension(self, $this: scala.util.Either[_mapRight.extension__A, _mapRight.extension__B], f: scala.Function1[_mapRight.extension__B, _mapRight.extension__B1]) -> scala.util.Either[_mapRight.extension__A, _mapRight.extension__B1]: ...
    class TryOps(typing.Generic[_Helpers__TryOps__A]):
        def __init__(self, source: scala.util.Try[_Helpers__TryOps__A]): ...
        def equals(self, x$1: typing.Any) -> bool: ...
        _fold__B = typing.TypeVar('_fold__B')  # <B>
        def fold(self, onError: scala.Function1[java.lang.Throwable, _fold__B], onSuccess: scala.Function1[_Helpers__TryOps__A, _fold__B]) -> _fold__B: ...
        def getOrThrow(self) -> _Helpers__TryOps__A: ...
        def hashCode(self) -> int: ...
        _mapOrThrow__B = typing.TypeVar('_mapOrThrow__B')  # <B>
        def mapOrThrow(self, f: scala.Function1[_Helpers__TryOps__A, _mapOrThrow__B]) -> _mapOrThrow__B: ...
        def source(self) -> scala.util.Try[_Helpers__TryOps__A]: ...
        def toEither(self) -> scala.util.Either[java.lang.Throwable, _Helpers__TryOps__A]: ...
    class TryOps$:
        MODULE$: typing.ClassVar['Helpers.TryOps.'] = ...
        def __init__(self): ...
        _equals$extension__A = typing.TypeVar('_equals$extension__A')  # <A>
        def equals$extension(self, $this: scala.util.Try[_equals.extension__A], x$1: typing.Any) -> bool: ...
        _fold$extension__B = typing.TypeVar('_fold$extension__B')  # <B>
        _fold$extension__A = typing.TypeVar('_fold$extension__A')  # <A>
        def fold$extension(self, $this: scala.util.Try[_fold.extension__A], onError: scala.Function1[java.lang.Throwable, _fold.extension__B], onSuccess: scala.Function1[_fold.extension__A, _fold.extension__B]) -> _fold.extension__B: ...
        _getOrThrow$extension__A = typing.TypeVar('_getOrThrow$extension__A')  # <A>
        def getOrThrow$extension(self, $this: scala.util.Try[_getOrThrow.extension__A]) -> _getOrThrow.extension__A: ...
        _hashCode$extension__A = typing.TypeVar('_hashCode$extension__A')  # <A>
        def hashCode$extension(self, $this: scala.util.Try[_hashCode.extension__A]) -> int: ...
        _mapOrThrow$extension__B = typing.TypeVar('_mapOrThrow$extension__B')  # <B>
        _mapOrThrow$extension__A = typing.TypeVar('_mapOrThrow$extension__A')  # <A>
        def mapOrThrow$extension(self, $this: scala.util.Try[_mapOrThrow.extension__A], f: scala.Function1[_mapOrThrow.extension__A, _mapOrThrow.extension__B]) -> _mapOrThrow.extension__B: ...
        _toEither$extension__A = typing.TypeVar('_toEither$extension__A')  # <A>
        def toEither$extension(self, $this: scala.util.Try[_toEither.extension__A]) -> scala.util.Either[java.lang.Throwable, _toEither.extension__A]: ...

class Overloading:
    @staticmethod
    def overload1() -> 'Overloading.Overload1': ...
    @staticmethod
    def overload2() -> 'Overloading.Overload2': ...
    @staticmethod
    def overload3() -> 'Overloading.Overload3': ...
    class Overload1:
        def __init__(self): ...
    class Overload2:
        def __init__(self): ...
    class Overload3:
        def __init__(self): ...

class SigmaByteReader(scorex.util.serialization.Reader):
    def __init__(self, r: scorex.util.serialization.Reader, constantStore: sigmastate.serialization.ConstantStore, resolvePlaceholdersToConstants: bool, maxTreeDepth: int): ...
    @staticmethod
    def $lessinit$greater$default$4() -> int: ...
    def addComplexity(self, delta: int) -> None: ...
    def complexity(self) -> int: ...
    def complexity_$eq(self, v: int) -> None: ...
    def constantStore(self) -> sigmastate.serialization.ConstantStore: ...
    def constantStore_$eq(self, x$1: sigmastate.serialization.ConstantStore) -> None: ...
    def consumed(self) -> int: ...
    def getAllBufferBytes(self) -> typing.List[int]: ...
    def getBits(self, size: int) -> typing.List[bool]: ...
    def getByte(self) -> int: ...
    def getBytes(self, size: int) -> typing.List[int]: ...
    def getBytesUnsafe(self, numRequestedBytes: int) -> typing.List[int]: ...
    def getChunk(self, size: int) -> typing.Any: ...
    def getInt(self) -> int: ...
    def getLong(self) -> int: ...
    _getOption__T = typing.TypeVar('_getOption__T')  # <T>
    def getOption(self, getValue: scala.Function0[_getOption__T]) -> scala.Option[_getOption__T]: ...
    def getShort(self) -> int: ...
    def getShortString(self) -> java.lang.String: ...
    def getType(self) -> sigmastate.SType: ...
    def getUByte(self) -> int: ...
    def getUInt(self) -> int: ...
    def getULong(self) -> int: ...
    def getUShort(self) -> int: ...
    def getValue(self) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def getValues(self) -> scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]]: ...
    def level(self) -> int: ...
    def level_$eq(self, v: int) -> None: ...
    def mark(self) -> 'SigmaByteReader': ...
    def maxTreeDepth(self) -> int: ...
    def newReader(self, chunk: typing.Any) -> scorex.util.serialization.Reader: ...
    def peekByte(self) -> int: ...
    def position(self) -> int: ...
    def positionLimit(self) -> int: ...
    def positionLimit_$eq(self, v: int) -> None: ...
    def position_$eq(self, p: int) -> None: ...
    def r(self) -> scorex.util.serialization.Reader: ...
    def remaining(self) -> int: ...
    def resolvePlaceholdersToConstants(self) -> bool: ...
    def resolvePlaceholdersToConstants_$eq(self, x$1: bool) -> None: ...
    def sigmastate$utils$SigmaByteReader$$_complexity(self) -> int: ...
    def sigmastate$utils$SigmaByteReader$$_complexity_$eq(self, x$1: int) -> None: ...
    def sigmastate$utils$SigmaByteReader$$_wasDeserialize(self) -> bool: ...
    def sigmastate$utils$SigmaByteReader$$_wasDeserialize_$eq(self, x$1: bool) -> None: ...
    def sigmastate$utils$SigmaByteReader$$checkPositionLimit(self) -> None: ...
    def sigmastate$utils$SigmaByteReader$$lvl(self) -> int: ...
    def sigmastate$utils$SigmaByteReader$$lvl_$eq(self, x$1: int) -> None: ...
    def sigmastate$utils$SigmaByteReader$$positionLmt(self) -> int: ...
    def sigmastate$utils$SigmaByteReader$$positionLmt_$eq(self, x$1: int) -> None: ...
    def valDefTypeStore(self) -> sigmastate.serialization.ValDefTypeStore: ...
    def wasDeserialize(self) -> bool: ...
    def wasDeserialize_$eq(self, v: bool) -> None: ...

_SparseArrayContainer__T = typing.TypeVar('_SparseArrayContainer__T')  # <T>
class SparseArrayContainer(typing.Generic[_SparseArrayContainer__T]):
    def __init__(self, values: scala.collection.Seq[scala.Tuple2[typing.Any, _SparseArrayContainer__T]], evidence$1: scala.reflect.ClassTag[_SparseArrayContainer__T]): ...
    def add(self, code: int, value: _SparseArrayContainer__T) -> None: ...
    def apply(self, code: int) -> _SparseArrayContainer__T: ...
    @staticmethod
    def buildForSerializers(sers: scala.collection.Seq[sigmastate.serialization.ValueSerializer[sigmastate.Values.Value[sigmastate.SType]]]) -> 'SparseArrayContainer'[sigmastate.serialization.ValueSerializer[sigmastate.Values.Value[sigmastate.SType]]]: ...
    def get(self, code: int) -> scala.Option[_SparseArrayContainer__T]: ...
    def remove(self, code: int) -> None: ...
    def sigmastate$utils$SparseArrayContainer$$codeToIndex(self, code: int) -> int: ...
    def sigmastate$utils$SparseArrayContainer$$sparseArray(self) -> typing.Any: ...

_SigmaByteWriter__DataInfo__T = typing.TypeVar('_SigmaByteWriter__DataInfo__T')  # <T>
_SigmaByteWriter__FormatDescriptor__T = typing.TypeVar('_SigmaByteWriter__FormatDescriptor__T')  # <T>
_SigmaByteWriter__SeqFmt__T = typing.TypeVar('_SigmaByteWriter__SeqFmt__T')  # <T>
_SigmaByteWriter__U__T = typing.TypeVar('_SigmaByteWriter__U__T')  # <T>
_SigmaByteWriter__UVlqFmt__T = typing.TypeVar('_SigmaByteWriter__UVlqFmt__T')  # <T>
_SigmaByteWriter__Vlq__T = typing.TypeVar('_SigmaByteWriter__Vlq__T')  # <T>
_SigmaByteWriter__ZigZag__T = typing.TypeVar('_SigmaByteWriter__ZigZag__T')  # <T>
_SigmaByteWriter__ZigZagFmt__T = typing.TypeVar('_SigmaByteWriter__ZigZagFmt__T')  # <T>
_SigmaByteWriter__ZigZagVlqFmt__T = typing.TypeVar('_SigmaByteWriter__ZigZagVlqFmt__T')  # <T>
class SigmaByteWriter(scorex.util.serialization.Writer):
    def __init__(self, w: scorex.util.serialization.Writer, constantExtractionStore: scala.Option[sigmastate.serialization.ConstantStore]): ...
    _argInfoToDataInfo__T = typing.TypeVar('_argInfoToDataInfo__T')  # <T>
    @staticmethod
    def argInfoToDataInfo(arg: sigmastate.ArgInfo, fmt: 'SigmaByteWriter.FormatDescriptor'[_argInfoToDataInfo__T]) -> 'SigmaByteWriter.DataInfo'[_argInfoToDataInfo__T]: ...
    @staticmethod
    def bitsInfo(name: typing.Union[java.lang.String, str], desc: typing.Union[java.lang.String, str]) -> 'SigmaByteWriter.DataInfo'['SigmaByteWriter.Bits']: ...
    @staticmethod
    def bitsInfo$default$2() -> java.lang.String: ...
    def constantExtractionStore(self) -> scala.Option[sigmastate.serialization.ConstantStore]: ...
    def length(self) -> int: ...
    @staticmethod
    def maxBitsInfo(name: typing.Union[java.lang.String, str], maxBits: int, desc: typing.Union[java.lang.String, str]) -> 'SigmaByteWriter.DataInfo'['SigmaByteWriter.Bits']: ...
    @staticmethod
    def maxBitsInfo$default$3() -> java.lang.String: ...
    _nameToDataInfo__T = typing.TypeVar('_nameToDataInfo__T')  # <T>
    @staticmethod
    def nameToDataInfo(name: typing.Union[java.lang.String, str], fmt: 'SigmaByteWriter.FormatDescriptor'[_nameToDataInfo__T]) -> 'SigmaByteWriter.DataInfo'[_nameToDataInfo__T]: ...
    def newWriter(self) -> scorex.util.serialization.Writer: ...
    @typing.overload
    def put(self, x: int) -> 'SigmaByteWriter': ...
    @typing.overload
    def put(self, x: int, info: 'SigmaByteWriter.DataInfo'[typing.Any]) -> 'SigmaByteWriter': ...
    @typing.overload
    def putBits(self, xs: typing.List[bool]) -> 'SigmaByteWriter': ...
    @typing.overload
    def putBits(self, xs: typing.List[bool], info: 'SigmaByteWriter.DataInfo'['SigmaByteWriter.Bits']) -> 'SigmaByteWriter': ...
    @typing.overload
    def putBoolean(self, x: bool) -> 'SigmaByteWriter': ...
    @typing.overload
    def putBoolean(self, x: bool, info: 'SigmaByteWriter.DataInfo'[typing.Any]) -> 'SigmaByteWriter': ...
    @typing.overload
    def putBytes(self, xs: typing.List[int]) -> 'SigmaByteWriter': ...
    @typing.overload
    def putBytes(self, xs: typing.List[int], offset: int, length: int) -> 'SigmaByteWriter': ...
    @typing.overload
    def putBytes(self, xs: typing.List[int], info: 'SigmaByteWriter.DataInfo'[typing.List[int]]) -> 'SigmaByteWriter': ...
    def putChunk(self, chunk: typing.Any) -> 'SigmaByteWriter': ...
    @typing.overload
    def putInt(self, x: int) -> 'SigmaByteWriter': ...
    @typing.overload
    def putInt(self, x: int, info: 'SigmaByteWriter.DataInfo'[typing.Any]) -> 'SigmaByteWriter': ...
    @typing.overload
    def putLong(self, x: int) -> 'SigmaByteWriter': ...
    @typing.overload
    def putLong(self, x: int, info: 'SigmaByteWriter.DataInfo'['SigmaByteWriter.Vlq'['SigmaByteWriter.ZigZag'[typing.Any]]]) -> 'SigmaByteWriter': ...
    _putOption__T = typing.TypeVar('_putOption__T')  # <T>
    def putOption(self, x: scala.Option[_putOption__T], putValueC: scala.Function2['SigmaByteWriter', _putOption__T, scala.runtime.BoxedUnit]) -> 'SigmaByteWriter': ...
    @typing.overload
    def putShort(self, x: int) -> 'SigmaByteWriter': ...
    @typing.overload
    def putShort(self, x: int, info: 'SigmaByteWriter.DataInfo'[typing.Any]) -> 'SigmaByteWriter': ...
    def putShortBytes(self, value: int) -> 'SigmaByteWriter': ...
    def putShortString(self, s: typing.Union[java.lang.String, str]) -> 'SigmaByteWriter': ...
    _putType_0__T = typing.TypeVar('_putType_0__T', bound=sigmastate.SType)  # <T>
    _putType_1__T = typing.TypeVar('_putType_1__T', bound=sigmastate.SType)  # <T>
    @typing.overload
    def putType(self, x: _putType_0__T) -> 'SigmaByteWriter': ...
    @typing.overload
    def putType(self, x: _putType_1__T, info: 'SigmaByteWriter.DataInfo'[sigmastate.SType]) -> 'SigmaByteWriter': ...
    @typing.overload
    def putUByte(self, x: int) -> 'SigmaByteWriter': ...
    @typing.overload
    def putUByte(self, x: int, info: 'SigmaByteWriter.DataInfo'['SigmaByteWriter.U'[typing.Any]]) -> 'SigmaByteWriter': ...
    @typing.overload
    def putUInt(self, x: int) -> 'SigmaByteWriter': ...
    @typing.overload
    def putUInt(self, x: int, info: 'SigmaByteWriter.DataInfo'['SigmaByteWriter.Vlq'['SigmaByteWriter.U'[typing.Any]]]) -> 'SigmaByteWriter': ...
    @typing.overload
    def putULong(self, x: int) -> 'SigmaByteWriter': ...
    @typing.overload
    def putULong(self, x: int, info: 'SigmaByteWriter.DataInfo'['SigmaByteWriter.Vlq'['SigmaByteWriter.U'[typing.Any]]]) -> 'SigmaByteWriter': ...
    @typing.overload
    def putUShort(self, x: int) -> 'SigmaByteWriter': ...
    @typing.overload
    def putUShort(self, x: int, info: 'SigmaByteWriter.DataInfo'['SigmaByteWriter.Vlq'['SigmaByteWriter.U'[typing.Any]]]) -> 'SigmaByteWriter': ...
    _putValue_0__T = typing.TypeVar('_putValue_0__T', bound=sigmastate.SType)  # <T>
    _putValue_1__T = typing.TypeVar('_putValue_1__T', bound=sigmastate.SType)  # <T>
    @typing.overload
    def putValue(self, x: sigmastate.Values.Value[_putValue_0__T]) -> 'SigmaByteWriter': ...
    @typing.overload
    def putValue(self, x: sigmastate.Values.Value[_putValue_1__T], info: 'SigmaByteWriter.DataInfo'[sigmastate.Values.Value[sigmastate.SType]]) -> 'SigmaByteWriter': ...
    _putValues_0__T = typing.TypeVar('_putValues_0__T', bound=sigmastate.SType)  # <T>
    _putValues_1__T = typing.TypeVar('_putValues_1__T', bound=sigmastate.SType)  # <T>
    @typing.overload
    def putValues(self, xs: scala.collection.Seq[sigmastate.Values.Value[_putValues_0__T]]) -> 'SigmaByteWriter': ...
    @typing.overload
    def putValues(self, xs: scala.collection.Seq[sigmastate.Values.Value[_putValues_1__T]], info: 'SigmaByteWriter.DataInfo'[scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]]], itemInfo: 'SigmaByteWriter.DataInfo'[sigmastate.Values.Value[sigmastate.SType]]) -> 'SigmaByteWriter': ...
    def result(self) -> typing.Any: ...
    def toBytes(self) -> typing.List[int]: ...
    _toSeqFmt__T = typing.TypeVar('_toSeqFmt__T')  # <T>
    @staticmethod
    def toSeqFmt(fmt: 'SigmaByteWriter.FormatDescriptor'[_toSeqFmt__T]) -> 'SigmaByteWriter.FormatDescriptor'[scala.collection.Seq[_toSeqFmt__T]]: ...
    _toUVlqFmt__T = typing.TypeVar('_toUVlqFmt__T')  # <T>
    @staticmethod
    def toUVlqFmt(fmt: 'SigmaByteWriter.FormatDescriptor'['SigmaByteWriter.U'[_toUVlqFmt__T]]) -> 'SigmaByteWriter.FormatDescriptor'['SigmaByteWriter.Vlq'['SigmaByteWriter.U'[_toUVlqFmt__T]]]: ...
    _toZigZagFmt__T = typing.TypeVar('_toZigZagFmt__T')  # <T>
    @staticmethod
    def toZigZagFmt(fmt: 'SigmaByteWriter.FormatDescriptor'[_toZigZagFmt__T]) -> 'SigmaByteWriter.FormatDescriptor'['SigmaByteWriter.ZigZag'[_toZigZagFmt__T]]: ...
    _toZigZagVlqFmt__T = typing.TypeVar('_toZigZagVlqFmt__T')  # <T>
    @staticmethod
    def toZigZagVlqFmt(fmt: 'SigmaByteWriter.FormatDescriptor'['SigmaByteWriter.ZigZag'[_toZigZagVlqFmt__T]]) -> 'SigmaByteWriter.FormatDescriptor'['SigmaByteWriter.Vlq'['SigmaByteWriter.ZigZag'[_toZigZagVlqFmt__T]]]: ...
    @staticmethod
    def valuesItemInfo(info: 'SigmaByteWriter.DataInfo'[scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]]]) -> 'SigmaByteWriter.DataInfo'[sigmastate.Values.Value[sigmastate.SType]]: ...
    @staticmethod
    def valuesLengthInfo() -> 'SigmaByteWriter.DataInfo'['SigmaByteWriter.Vlq'['SigmaByteWriter.U'[typing.Any]]]: ...
    def w(self) -> scorex.util.serialization.Writer: ...
    class Bits: ...
    class BitsFmt$(sigmastate.utils.SigmaByteWriter.FormatDescriptor['SigmaByteWriter.Bits'], scala.Product, scala.Serializable):
        MODULE$: typing.ClassVar['SigmaByteWriter.BitsFmt.'] = ...
        def __init__(self): ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def size(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
    class BooleanFmt$(sigmastate.utils.SigmaByteWriter.FormatDescriptor[typing.Any]):
        MODULE$: typing.ClassVar['SigmaByteWriter.BooleanFmt.'] = ...
        def __init__(self): ...
        def size(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
    class ByteFmt$(sigmastate.utils.SigmaByteWriter.FormatDescriptor[typing.Any]):
        MODULE$: typing.ClassVar['SigmaByteWriter.ByteFmt.'] = ...
        def __init__(self): ...
        def size(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
    class DataInfo(scala.Product, scala.Serializable, typing.Generic[_SigmaByteWriter__DataInfo__T]):
        def __init__(self, info: sigmastate.ArgInfo, format: 'SigmaByteWriter.FormatDescriptor'[_SigmaByteWriter__DataInfo__T]): ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        _copy__T = typing.TypeVar('_copy__T')  # <T>
        def copy(self, info: sigmastate.ArgInfo, format: 'SigmaByteWriter.FormatDescriptor'[typing.Any]) -> 'SigmaByteWriter.DataInfo'[typing.Any]: ...
        _copy$default$1__T = typing.TypeVar('_copy$default$1__T')  # <T>
        def copy$default$1(self) -> sigmastate.ArgInfo: ...
        _copy$default$2__T = typing.TypeVar('_copy$default$2__T')  # <T>
        def copy$default$2(self) -> 'SigmaByteWriter.FormatDescriptor'[typing.Any]: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def format(self) -> 'SigmaByteWriter.FormatDescriptor'[_SigmaByteWriter__DataInfo__T]: ...
        def hashCode(self) -> int: ...
        def info(self) -> sigmastate.ArgInfo: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
    class DataInfo$(scala.Serializable):
        MODULE$: typing.ClassVar['SigmaByteWriter.DataInfo.'] = ...
        def __init__(self): ...
        _apply__T = typing.TypeVar('_apply__T')  # <T>
        def apply(self, info: sigmastate.ArgInfo, format: 'SigmaByteWriter.FormatDescriptor'[_apply__T]) -> 'SigmaByteWriter.DataInfo'[_apply__T]: ...
        def toString(self) -> java.lang.String: ...
        _unapply__T = typing.TypeVar('_unapply__T')  # <T>
        def unapply(self, x$0: 'SigmaByteWriter.DataInfo'[_unapply__T]) -> scala.Option[scala.Tuple2[sigmastate.ArgInfo, 'SigmaByteWriter.FormatDescriptor'[_unapply__T]]]: ...
    class FormatDescriptor(typing.Generic[_SigmaByteWriter__FormatDescriptor__T]):
        def size(self) -> java.lang.String: ...
    class IntFmt$(sigmastate.utils.SigmaByteWriter.FormatDescriptor[typing.Any]):
        MODULE$: typing.ClassVar['SigmaByteWriter.IntFmt.'] = ...
        def __init__(self): ...
        def size(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
    class LongFmt$(sigmastate.utils.SigmaByteWriter.FormatDescriptor[typing.Any]):
        MODULE$: typing.ClassVar['SigmaByteWriter.LongFmt.'] = ...
        def __init__(self): ...
        def size(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
    class MaxBitsFmt(sigmastate.utils.SigmaByteWriter.FormatDescriptor['SigmaByteWriter.Bits'], scala.Product, scala.Serializable):
        def __init__(self, maxBits: int): ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        def copy(self, maxBits: int) -> 'SigmaByteWriter.MaxBitsFmt': ...
        def copy$default$1(self) -> int: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def maxBits(self) -> int: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def size(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
    class MaxBitsFmt$(scala.runtime.AbstractFunction1[typing.Any, 'SigmaByteWriter.MaxBitsFmt'], scala.Serializable):
        MODULE$: typing.ClassVar['SigmaByteWriter.MaxBitsFmt.'] = ...
        def __init__(self): ...
        def apply(self, maxBits: int) -> 'SigmaByteWriter.MaxBitsFmt': ...
        def toString(self) -> java.lang.String: ...
        def unapply(self, x$0: 'SigmaByteWriter.MaxBitsFmt') -> scala.Option[typing.Any]: ...
    class SeqFmt(sigmastate.utils.SigmaByteWriter.FormatDescriptor[scala.collection.Seq[_SigmaByteWriter__SeqFmt__T]], scala.Product, scala.Serializable, typing.Generic[_SigmaByteWriter__SeqFmt__T]):
        def __init__(self, fmt: 'SigmaByteWriter.FormatDescriptor'[_SigmaByteWriter__SeqFmt__T]): ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        _copy__T = typing.TypeVar('_copy__T')  # <T>
        def copy(self, fmt: 'SigmaByteWriter.FormatDescriptor'[typing.Any]) -> 'SigmaByteWriter.SeqFmt'[typing.Any]: ...
        _copy$default$1__T = typing.TypeVar('_copy$default$1__T')  # <T>
        def copy$default$1(self) -> 'SigmaByteWriter.FormatDescriptor'[typing.Any]: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def fmt(self) -> 'SigmaByteWriter.FormatDescriptor'[_SigmaByteWriter__SeqFmt__T]: ...
        def hashCode(self) -> int: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def size(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
    class SeqFmt$(scala.Serializable):
        MODULE$: typing.ClassVar['SigmaByteWriter.SeqFmt.'] = ...
        def __init__(self): ...
        _apply__T = typing.TypeVar('_apply__T')  # <T>
        def apply(self, fmt: 'SigmaByteWriter.FormatDescriptor'[_apply__T]) -> 'SigmaByteWriter.SeqFmt'[_apply__T]: ...
        def toString(self) -> java.lang.String: ...
        _unapply__T = typing.TypeVar('_unapply__T')  # <T>
        def unapply(self, x$0: 'SigmaByteWriter.SeqFmt'[_unapply__T]) -> scala.Option['SigmaByteWriter.FormatDescriptor'[_unapply__T]]: ...
    class ShortFmt$(sigmastate.utils.SigmaByteWriter.FormatDescriptor[typing.Any]):
        MODULE$: typing.ClassVar['SigmaByteWriter.ShortFmt.'] = ...
        def __init__(self): ...
        def size(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
    class TypeFmt$(sigmastate.utils.SigmaByteWriter.FormatDescriptor[sigmastate.SType], scala.Product, scala.Serializable):
        MODULE$: typing.ClassVar['SigmaByteWriter.TypeFmt.'] = ...
        def __init__(self): ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def size(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
    class U(typing.Generic[_SigmaByteWriter__U__T]): ...
    class UByteFmt$(sigmastate.utils.SigmaByteWriter.FormatDescriptor['SigmaByteWriter.U'[typing.Any]]):
        MODULE$: typing.ClassVar['SigmaByteWriter.UByteFmt.'] = ...
        def __init__(self): ...
        def size(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
    class UIntFmt$(sigmastate.utils.SigmaByteWriter.FormatDescriptor['SigmaByteWriter.U'[typing.Any]]):
        MODULE$: typing.ClassVar['SigmaByteWriter.UIntFmt.'] = ...
        def __init__(self): ...
        def size(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
    class ULongFmt$(sigmastate.utils.SigmaByteWriter.FormatDescriptor['SigmaByteWriter.U'[typing.Any]]):
        MODULE$: typing.ClassVar['SigmaByteWriter.ULongFmt.'] = ...
        def __init__(self): ...
        def size(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
    class UShortFmt$(sigmastate.utils.SigmaByteWriter.FormatDescriptor['SigmaByteWriter.U'[typing.Any]]):
        MODULE$: typing.ClassVar['SigmaByteWriter.UShortFmt.'] = ...
        def __init__(self): ...
        def size(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
    class UVlqFmt(sigmastate.utils.SigmaByteWriter.FormatDescriptor['SigmaByteWriter.Vlq'['SigmaByteWriter.U'[_SigmaByteWriter__UVlqFmt__T]]], scala.Product, scala.Serializable, typing.Generic[_SigmaByteWriter__UVlqFmt__T]):
        def __init__(self, fmt: 'SigmaByteWriter.FormatDescriptor'['SigmaByteWriter.U'[_SigmaByteWriter__UVlqFmt__T]]): ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        _copy__T = typing.TypeVar('_copy__T')  # <T>
        def copy(self, fmt: 'SigmaByteWriter.FormatDescriptor'['SigmaByteWriter.U'[typing.Any]]) -> 'SigmaByteWriter.UVlqFmt'[typing.Any]: ...
        _copy$default$1__T = typing.TypeVar('_copy$default$1__T')  # <T>
        def copy$default$1(self) -> 'SigmaByteWriter.FormatDescriptor'['SigmaByteWriter.U'[typing.Any]]: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def fmt(self) -> 'SigmaByteWriter.FormatDescriptor'['SigmaByteWriter.U'[_SigmaByteWriter__UVlqFmt__T]]: ...
        def hashCode(self) -> int: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def size(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
    class UVlqFmt$(scala.Serializable):
        MODULE$: typing.ClassVar['SigmaByteWriter.UVlqFmt.'] = ...
        def __init__(self): ...
        _apply__T = typing.TypeVar('_apply__T')  # <T>
        def apply(self, fmt: 'SigmaByteWriter.FormatDescriptor'['SigmaByteWriter.U'[_apply__T]]) -> 'SigmaByteWriter.UVlqFmt'[_apply__T]: ...
        def toString(self) -> java.lang.String: ...
        _unapply__T = typing.TypeVar('_unapply__T')  # <T>
        def unapply(self, x$0: 'SigmaByteWriter.UVlqFmt'[_unapply__T]) -> scala.Option['SigmaByteWriter.FormatDescriptor'['SigmaByteWriter.U'[_unapply__T]]]: ...
    class ValueFmt$(sigmastate.utils.SigmaByteWriter.FormatDescriptor[sigmastate.Values.Value[sigmastate.SType]], scala.Product, scala.Serializable):
        MODULE$: typing.ClassVar['SigmaByteWriter.ValueFmt.'] = ...
        def __init__(self): ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def size(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
    class Vlq(typing.Generic[_SigmaByteWriter__Vlq__T]): ...
    class ZigZag(typing.Generic[_SigmaByteWriter__ZigZag__T]): ...
    class ZigZagFmt(sigmastate.utils.SigmaByteWriter.FormatDescriptor['SigmaByteWriter.ZigZag'[_SigmaByteWriter__ZigZagFmt__T]], scala.Product, scala.Serializable, typing.Generic[_SigmaByteWriter__ZigZagFmt__T]):
        def __init__(self, fmt: 'SigmaByteWriter.FormatDescriptor'[_SigmaByteWriter__ZigZagFmt__T]): ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        _copy__T = typing.TypeVar('_copy__T')  # <T>
        def copy(self, fmt: 'SigmaByteWriter.FormatDescriptor'[typing.Any]) -> 'SigmaByteWriter.ZigZagFmt'[typing.Any]: ...
        _copy$default$1__T = typing.TypeVar('_copy$default$1__T')  # <T>
        def copy$default$1(self) -> 'SigmaByteWriter.FormatDescriptor'[typing.Any]: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def fmt(self) -> 'SigmaByteWriter.FormatDescriptor'[_SigmaByteWriter__ZigZagFmt__T]: ...
        def hashCode(self) -> int: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def size(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
    class ZigZagFmt$(scala.Serializable):
        MODULE$: typing.ClassVar['SigmaByteWriter.ZigZagFmt.'] = ...
        def __init__(self): ...
        _apply__T = typing.TypeVar('_apply__T')  # <T>
        def apply(self, fmt: 'SigmaByteWriter.FormatDescriptor'[_apply__T]) -> 'SigmaByteWriter.ZigZagFmt'[_apply__T]: ...
        def toString(self) -> java.lang.String: ...
        _unapply__T = typing.TypeVar('_unapply__T')  # <T>
        def unapply(self, x$0: 'SigmaByteWriter.ZigZagFmt'[_unapply__T]) -> scala.Option['SigmaByteWriter.FormatDescriptor'[_unapply__T]]: ...
    class ZigZagVlqFmt(sigmastate.utils.SigmaByteWriter.FormatDescriptor['SigmaByteWriter.Vlq'['SigmaByteWriter.ZigZag'[_SigmaByteWriter__ZigZagVlqFmt__T]]], scala.Product, scala.Serializable, typing.Generic[_SigmaByteWriter__ZigZagVlqFmt__T]):
        def __init__(self, fmt: 'SigmaByteWriter.FormatDescriptor'['SigmaByteWriter.ZigZag'[_SigmaByteWriter__ZigZagVlqFmt__T]]): ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        _copy__T = typing.TypeVar('_copy__T')  # <T>
        def copy(self, fmt: 'SigmaByteWriter.FormatDescriptor'['SigmaByteWriter.ZigZag'[typing.Any]]) -> 'SigmaByteWriter.ZigZagVlqFmt'[typing.Any]: ...
        _copy$default$1__T = typing.TypeVar('_copy$default$1__T')  # <T>
        def copy$default$1(self) -> 'SigmaByteWriter.FormatDescriptor'['SigmaByteWriter.ZigZag'[typing.Any]]: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def fmt(self) -> 'SigmaByteWriter.FormatDescriptor'['SigmaByteWriter.ZigZag'[_SigmaByteWriter__ZigZagVlqFmt__T]]: ...
        def hashCode(self) -> int: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def size(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
    class ZigZagVlqFmt$(scala.Serializable):
        MODULE$: typing.ClassVar['SigmaByteWriter.ZigZagVlqFmt.'] = ...
        def __init__(self): ...
        _apply__T = typing.TypeVar('_apply__T')  # <T>
        def apply(self, fmt: 'SigmaByteWriter.FormatDescriptor'['SigmaByteWriter.ZigZag'[_apply__T]]) -> 'SigmaByteWriter.ZigZagVlqFmt'[_apply__T]: ...
        def toString(self) -> java.lang.String: ...
        _unapply__T = typing.TypeVar('_unapply__T')  # <T>
        def unapply(self, x$0: 'SigmaByteWriter.ZigZagVlqFmt'[_unapply__T]) -> scala.Option['SigmaByteWriter.FormatDescriptor'['SigmaByteWriter.ZigZag'[_unapply__T]]]: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("sigmastate.utils")``.

    Helpers: typing.Type[Helpers]
    Overloading: typing.Type[Overloading]
    SigmaByteReader: typing.Type[SigmaByteReader]
    SigmaByteWriter: typing.Type[SigmaByteWriter]
    SparseArrayContainer: typing.Type[SparseArrayContainer]
