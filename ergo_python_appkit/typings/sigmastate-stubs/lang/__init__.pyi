import fastparse.core
import java.lang
import org.bitbucket.inkytonik.kiama.output
import org.bitbucket.inkytonik.kiama.relation
import org.bitbucket.inkytonik.kiama.rewriting
import org.bitbucket.inkytonik.kiama.util
import org.ergoplatform
import scala
import scala.collection
import scala.collection.generic
import scala.collection.immutable
import scala.collection.mutable
import scala.runtime
import scala.util
import scalan
import sigmastate
import sigmastate.eval
import sigmastate.interpreter
import sigmastate.lang.exceptions
import sigmastate.lang.syntax
import sigmastate.utils
import sourcecode
import special.collection
import typing



class CompilerSettings(scala.Product, scala.Serializable):
    def __init__(self, networkPrefix: int, builder: 'SigmaBuilder', lowerMethodCalls: bool): ...
    @staticmethod
    def apply(networkPrefix: int, builder: 'SigmaBuilder', lowerMethodCalls: bool) -> 'CompilerSettings': ...
    def builder(self) -> 'SigmaBuilder': ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def copy(self, networkPrefix: int, builder: 'SigmaBuilder', lowerMethodCalls: bool) -> 'CompilerSettings': ...
    def copy$default$1(self) -> int: ...
    def copy$default$2(self) -> 'SigmaBuilder': ...
    def copy$default$3(self) -> bool: ...
    @staticmethod
    def curried() -> scala.Function1[typing.Any, scala.Function1['SigmaBuilder', scala.Function1[typing.Any, 'CompilerSettings']]]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def lowerMethodCalls(self) -> bool: ...
    def networkPrefix(self) -> int: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def tupled() -> scala.Function1[scala.Tuple3[typing.Any, 'SigmaBuilder', typing.Any], 'CompilerSettings']: ...
    @staticmethod
    def unapply(x$0: 'CompilerSettings') -> scala.Option[scala.Tuple3[typing.Any, 'SigmaBuilder', typing.Any]]: ...

class DeserializationSigmaBuilder:
    @staticmethod
    def canEqual(x$1: typing.Any) -> bool: ...
    _check2__T = typing.TypeVar('_check2__T', bound=sigmastate.SType)  # <T>
    @staticmethod
    def check2(left: sigmastate.Values.Value[_check2__T], right: sigmastate.Values.Value[_check2__T], constraints: scala.collection.Seq['Constraints.TypeConstraint2']) -> None: ...
    @staticmethod
    def currentSrcCtx() -> scala.util.DynamicVariable[scalan.Nullable['SourceContext']]: ...
    @staticmethod
    def hashCode() -> int: ...
    @staticmethod
    def liftAny(obj: typing.Any) -> sigmastate.Values.Value: ...
    @staticmethod
    def mkAND(input: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SBoolean.]]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    @staticmethod
    def mkAllOf(input: scala.collection.Seq[sigmastate.Values.Value[sigmastate.SBoolean.]]) -> sigmastate.Values.Value[scala.runtime.Nothing.]: ...
    @staticmethod
    def mkAnyOf(input: scala.collection.Seq[sigmastate.Values.Value[sigmastate.SBoolean.]]) -> sigmastate.Values.Value[scala.runtime.Nothing.]: ...
    _mkAppend__IV = typing.TypeVar('_mkAppend__IV', bound=sigmastate.SType)  # <IV>
    @staticmethod
    def mkAppend(input: sigmastate.Values.Value[sigmastate.SCollection[_mkAppend__IV]], col2: sigmastate.Values.Value[sigmastate.SCollection[_mkAppend__IV]]) -> sigmastate.Values.Value[sigmastate.SCollection[_mkAppend__IV]]: ...
    @staticmethod
    def mkApply(func: sigmastate.Values.Value[sigmastate.SType], args: scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    @staticmethod
    def mkApplyTypes(input: sigmastate.Values.Value[sigmastate.SType], tpeArgs: scala.collection.Seq[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    _mkArith__T = typing.TypeVar('_mkArith__T', bound=sigmastate.SNumericType)  # <T>
    @staticmethod
    def mkArith(left: sigmastate.Values.Value[_mkArith__T], right: sigmastate.Values.Value[_mkArith__T], opCode: int) -> sigmastate.Values.Value[_mkArith__T]: ...
    @staticmethod
    def mkAtLeast(bound: sigmastate.Values.Value[sigmastate.SInt.], input: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SSigmaProp.]]) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...
    @staticmethod
    def mkBinAnd(left: sigmastate.Values.Value[sigmastate.SBoolean.], right: sigmastate.Values.Value[sigmastate.SBoolean.]) -> sigmastate.Values.Value[scala.runtime.Nothing.]: ...
    @staticmethod
    def mkBinOr(left: sigmastate.Values.Value[sigmastate.SBoolean.], right: sigmastate.Values.Value[sigmastate.SBoolean.]) -> sigmastate.Values.Value[scala.runtime.Nothing.]: ...
    @staticmethod
    def mkBinXor(left: sigmastate.Values.Value[sigmastate.SBoolean.], right: sigmastate.Values.Value[sigmastate.SBoolean.]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    _mkBitAnd__T = typing.TypeVar('_mkBitAnd__T', bound=sigmastate.SNumericType)  # <T>
    @staticmethod
    def mkBitAnd(left: sigmastate.Values.Value[_mkBitAnd__T], right: sigmastate.Values.Value[_mkBitAnd__T]) -> sigmastate.Values.Value[_mkBitAnd__T]: ...
    _mkBitInversion__T = typing.TypeVar('_mkBitInversion__T', bound=sigmastate.SNumericType)  # <T>
    @staticmethod
    def mkBitInversion(input: sigmastate.Values.Value[_mkBitInversion__T]) -> sigmastate.Values.Value[_mkBitInversion__T]: ...
    _mkBitOr__T = typing.TypeVar('_mkBitOr__T', bound=sigmastate.SNumericType)  # <T>
    @staticmethod
    def mkBitOr(left: sigmastate.Values.Value[_mkBitOr__T], right: sigmastate.Values.Value[_mkBitOr__T]) -> sigmastate.Values.Value[_mkBitOr__T]: ...
    _mkBitShiftLeft__T = typing.TypeVar('_mkBitShiftLeft__T', bound=sigmastate.SNumericType)  # <T>
    @staticmethod
    def mkBitShiftLeft(bits: sigmastate.Values.Value[_mkBitShiftLeft__T], shift: sigmastate.Values.Value[_mkBitShiftLeft__T]) -> sigmastate.Values.Value[_mkBitShiftLeft__T]: ...
    _mkBitShiftRight__T = typing.TypeVar('_mkBitShiftRight__T', bound=sigmastate.SNumericType)  # <T>
    @staticmethod
    def mkBitShiftRight(bits: sigmastate.Values.Value[_mkBitShiftRight__T], shift: sigmastate.Values.Value[_mkBitShiftRight__T]) -> sigmastate.Values.Value[_mkBitShiftRight__T]: ...
    _mkBitShiftRightZeroed__T = typing.TypeVar('_mkBitShiftRightZeroed__T', bound=sigmastate.SNumericType)  # <T>
    @staticmethod
    def mkBitShiftRightZeroed(bits: sigmastate.Values.Value[_mkBitShiftRightZeroed__T], shift: sigmastate.Values.Value[_mkBitShiftRightZeroed__T]) -> sigmastate.Values.Value[_mkBitShiftRightZeroed__T]: ...
    _mkBitXor__T = typing.TypeVar('_mkBitXor__T', bound=sigmastate.SNumericType)  # <T>
    @staticmethod
    def mkBitXor(left: sigmastate.Values.Value[_mkBitXor__T], right: sigmastate.Values.Value[_mkBitXor__T]) -> sigmastate.Values.Value[_mkBitXor__T]: ...
    @staticmethod
    def mkBlock(bindings: scala.collection.Seq['Terms.Val'], result: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    @staticmethod
    def mkBlockValue(items: scala.collection.IndexedSeq[sigmastate.Values.BlockItem], result: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    @staticmethod
    def mkBoolToSigmaProp(value: sigmastate.Values.Value[sigmastate.SBoolean.]) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...
    _mkByIndex__IV = typing.TypeVar('_mkByIndex__IV', bound=sigmastate.SType)  # <IV>
    @staticmethod
    def mkByIndex(input: sigmastate.Values.Value[sigmastate.SCollection[_mkByIndex__IV]], index: sigmastate.Values.Value[sigmastate.SInt.], default: scala.Option[sigmastate.Values.Value[_mkByIndex__IV]]) -> sigmastate.Values.Value[_mkByIndex__IV]: ...
    _mkByIndex$default$3__IV = typing.TypeVar('_mkByIndex$default$3__IV', bound=sigmastate.SType)  # <IV>
    @staticmethod
    def mkByIndex$default$3() -> scala.None.: ...
    @staticmethod
    def mkByteArrayToBigInt(input: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]) -> sigmastate.Values.Value[sigmastate.SBigInt.]: ...
    @staticmethod
    def mkByteArrayToLong(input: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]) -> sigmastate.Values.Value[sigmastate.SLong.]: ...
    @staticmethod
    def mkCalcBlake2b256(input: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    @staticmethod
    def mkCalcSha256(input: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    _mkCollectionConstant_0__T = typing.TypeVar('_mkCollectionConstant_0__T', bound=sigmastate.SType)  # <T>
    _mkCollectionConstant_1__T = typing.TypeVar('_mkCollectionConstant_1__T', bound=sigmastate.SType)  # <T>
    @typing.overload
    @staticmethod
    def mkCollectionConstant(values: typing.Any, elementType: _mkCollectionConstant_0__T) -> sigmastate.Values.Constant[sigmastate.SCollection[_mkCollectionConstant_0__T]]: ...
    @typing.overload
    @staticmethod
    def mkCollectionConstant(values: special.collection.Coll[typing.Any], elementType: _mkCollectionConstant_1__T) -> sigmastate.Values.Constant[sigmastate.SCollection[_mkCollectionConstant_1__T]]: ...
    _mkConcreteCollection__T = typing.TypeVar('_mkConcreteCollection__T', bound=sigmastate.SType)  # <T>
    @staticmethod
    def mkConcreteCollection(items: scala.collection.Seq[sigmastate.Values.Value[_mkConcreteCollection__T]], elementType: _mkConcreteCollection__T) -> sigmastate.Values.Value[sigmastate.SCollection[_mkConcreteCollection__T]]: ...
    _mkConstant__T = typing.TypeVar('_mkConstant__T', bound=sigmastate.SType)  # <T>
    @staticmethod
    def mkConstant(value: typing.Any, tpe: _mkConstant__T) -> sigmastate.Values.Constant[_mkConstant__T]: ...
    _mkConstantPlaceholder__T = typing.TypeVar('_mkConstantPlaceholder__T', bound=sigmastate.SType)  # <T>
    @staticmethod
    def mkConstantPlaceholder(id: int, tpe: _mkConstantPlaceholder__T) -> sigmastate.Values.Value[sigmastate.SType]: ...
    @staticmethod
    def mkCreateAvlTree(operationFlags: sigmastate.Values.Value[sigmastate.SByte.], digest: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]], keyLength: sigmastate.Values.Value[sigmastate.SInt.], valueLengthOpt: sigmastate.Values.Value[sigmastate.SOption[sigmastate.SInt.]]) -> sigmastate.Values.Value[sigmastate.SAvlTree.]: ...
    @staticmethod
    def mkCreateProveDHTuple(gv: sigmastate.Values.Value[sigmastate.SGroupElement.], hv: sigmastate.Values.Value[sigmastate.SGroupElement.], uv: sigmastate.Values.Value[sigmastate.SGroupElement.], vv: sigmastate.Values.Value[sigmastate.SGroupElement.]) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...
    @staticmethod
    def mkCreateProveDlog(value: sigmastate.Values.Value[sigmastate.SGroupElement.]) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...
    @staticmethod
    def mkDecodePoint(input: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]) -> sigmastate.Values.Value[sigmastate.SGroupElement.]: ...
    _mkDeserializeContext__T = typing.TypeVar('_mkDeserializeContext__T', bound=sigmastate.SType)  # <T>
    @staticmethod
    def mkDeserializeContext(id: int, tpe: _mkDeserializeContext__T) -> sigmastate.Values.Value[_mkDeserializeContext__T]: ...
    _mkDeserializeRegister__T = typing.TypeVar('_mkDeserializeRegister__T', bound=sigmastate.SType)  # <T>
    @staticmethod
    def mkDeserializeRegister(reg: org.ergoplatform.ErgoBox.RegisterId, tpe: _mkDeserializeRegister__T, default: scala.Option[sigmastate.Values.Value[_mkDeserializeRegister__T]]) -> sigmastate.Values.Value[_mkDeserializeRegister__T]: ...
    _mkDeserializeRegister$default$3__T = typing.TypeVar('_mkDeserializeRegister$default$3__T', bound=sigmastate.SType)  # <T>
    @staticmethod
    def mkDeserializeRegister$default$3() -> scala.None.: ...
    _mkDivide__T = typing.TypeVar('_mkDivide__T', bound=sigmastate.SNumericType)  # <T>
    @staticmethod
    def mkDivide(left: sigmastate.Values.Value[_mkDivide__T], right: sigmastate.Values.Value[_mkDivide__T]) -> sigmastate.Values.Value[_mkDivide__T]: ...
    _mkDowncast__T = typing.TypeVar('_mkDowncast__T', bound=sigmastate.SNumericType)  # <T>
    _mkDowncast__R = typing.TypeVar('_mkDowncast__R', bound=sigmastate.SNumericType)  # <R>
    @staticmethod
    def mkDowncast(input: sigmastate.Values.Value[_mkDowncast__T], tpe: _mkDowncast__R) -> sigmastate.Values.Value[_mkDowncast__R]: ...
    _mkEQ__T = typing.TypeVar('_mkEQ__T', bound=sigmastate.SType)  # <T>
    @staticmethod
    def mkEQ(left: sigmastate.Values.Value[_mkEQ__T], right: sigmastate.Values.Value[_mkEQ__T]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    _mkExists__IV = typing.TypeVar('_mkExists__IV', bound=sigmastate.SType)  # <IV>
    @staticmethod
    def mkExists(input: sigmastate.Values.Value[sigmastate.SCollection[_mkExists__IV]], condition: sigmastate.Values.Value[sigmastate.SFunc]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    @staticmethod
    def mkExponentiate(left: sigmastate.Values.Value[sigmastate.SGroupElement.], right: sigmastate.Values.Value[sigmastate.SBigInt.]) -> sigmastate.Values.Value[sigmastate.SGroupElement.]: ...
    @staticmethod
    def mkExtractAmount(input: sigmastate.Values.Value[sigmastate.SBox.]) -> sigmastate.Values.Value[sigmastate.SLong.]: ...
    @staticmethod
    def mkExtractBytes(input: sigmastate.Values.Value[sigmastate.SBox.]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    @staticmethod
    def mkExtractBytesWithNoRef(input: sigmastate.Values.Value[sigmastate.SBox.]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    @staticmethod
    def mkExtractCreationInfo(input: sigmastate.Values.Value[sigmastate.SBox.]) -> sigmastate.Values.Value[sigmastate.STuple]: ...
    @staticmethod
    def mkExtractId(input: sigmastate.Values.Value[sigmastate.SBox.]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    _mkExtractRegisterAs__IV = typing.TypeVar('_mkExtractRegisterAs__IV', bound=sigmastate.SType)  # <IV>
    @staticmethod
    def mkExtractRegisterAs(input: sigmastate.Values.Value[sigmastate.SBox.], registerId: org.ergoplatform.ErgoBox.RegisterId, tpe: sigmastate.SOption[_mkExtractRegisterAs__IV]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    @staticmethod
    def mkExtractScriptBytes(input: sigmastate.Values.Value[sigmastate.SBox.]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    _mkFilter__IV = typing.TypeVar('_mkFilter__IV', bound=sigmastate.SType)  # <IV>
    @staticmethod
    def mkFilter(input: sigmastate.Values.Value[sigmastate.SCollection[_mkFilter__IV]], condition: sigmastate.Values.Value[sigmastate.SFunc]) -> sigmastate.Values.Value[sigmastate.SCollection[_mkFilter__IV]]: ...
    _mkFold__IV = typing.TypeVar('_mkFold__IV', bound=sigmastate.SType)  # <IV>
    _mkFold__OV = typing.TypeVar('_mkFold__OV', bound=sigmastate.SType)  # <OV>
    @staticmethod
    def mkFold(input: sigmastate.Values.Value[sigmastate.SCollection[_mkFold__IV]], zero: sigmastate.Values.Value[_mkFold__OV], foldOp: sigmastate.Values.Value[sigmastate.SFunc]) -> sigmastate.Values.Value[_mkFold__OV]: ...
    _mkForAll__IV = typing.TypeVar('_mkForAll__IV', bound=sigmastate.SType)  # <IV>
    @staticmethod
    def mkForAll(input: sigmastate.Values.Value[sigmastate.SCollection[_mkForAll__IV]], condition: sigmastate.Values.Value[sigmastate.SFunc]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    @staticmethod
    def mkFuncValue(args: scala.collection.IndexedSeq[scala.Tuple2[typing.Any, sigmastate.SType]], body: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SFunc]: ...
    _mkGE__T = typing.TypeVar('_mkGE__T', bound=sigmastate.SType)  # <T>
    @staticmethod
    def mkGE(left: sigmastate.Values.Value[_mkGE__T], right: sigmastate.Values.Value[_mkGE__T]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    _mkGT__T = typing.TypeVar('_mkGT__T', bound=sigmastate.SType)  # <T>
    @staticmethod
    def mkGT(left: sigmastate.Values.Value[_mkGT__T], right: sigmastate.Values.Value[_mkGT__T]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    @staticmethod
    def mkGenLambda(tpeParams: scala.collection.Seq['Terms.STypeParam'], args: scala.collection.IndexedSeq[scala.Tuple2[typing.Union[java.lang.String, str], sigmastate.SType]], givenResType: sigmastate.SType, body: scala.Option[sigmastate.Values.Value[sigmastate.SType]]) -> sigmastate.Values.Value[scala.runtime.Nothing.]: ...
    _mkGetVar__T = typing.TypeVar('_mkGetVar__T', bound=sigmastate.SType)  # <T>
    @staticmethod
    def mkGetVar(varId: int, tpe: _mkGetVar__T) -> sigmastate.Values.Value[sigmastate.SOption[_mkGetVar__T]]: ...
    @staticmethod
    def mkIdent(name: typing.Union[java.lang.String, str], tpe: sigmastate.SType) -> sigmastate.Values.Value[sigmastate.SType]: ...
    _mkIf__T = typing.TypeVar('_mkIf__T', bound=sigmastate.SType)  # <T>
    @staticmethod
    def mkIf(condition: sigmastate.Values.Value[sigmastate.SBoolean.], trueBranch: sigmastate.Values.Value[_mkIf__T], falseBranch: sigmastate.Values.Value[_mkIf__T]) -> sigmastate.Values.Value[_mkIf__T]: ...
    _mkLE__T = typing.TypeVar('_mkLE__T', bound=sigmastate.SType)  # <T>
    @staticmethod
    def mkLE(left: sigmastate.Values.Value[_mkLE__T], right: sigmastate.Values.Value[_mkLE__T]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    _mkLT__T = typing.TypeVar('_mkLT__T', bound=sigmastate.SType)  # <T>
    @staticmethod
    def mkLT(left: sigmastate.Values.Value[_mkLT__T], right: sigmastate.Values.Value[_mkLT__T]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    @staticmethod
    def mkLambda(args: scala.collection.IndexedSeq[scala.Tuple2[typing.Union[java.lang.String, str], sigmastate.SType]], givenResType: sigmastate.SType, body: scala.Option[sigmastate.Values.Value[sigmastate.SType]]) -> sigmastate.Values.Value[sigmastate.SFunc]: ...
    @staticmethod
    def mkLogicalNot(input: sigmastate.Values.Value[sigmastate.SBoolean.]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    @staticmethod
    def mkLongToByteArray(input: sigmastate.Values.Value[sigmastate.SLong.]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    _mkMapCollection__IV = typing.TypeVar('_mkMapCollection__IV', bound=sigmastate.SType)  # <IV>
    _mkMapCollection__OV = typing.TypeVar('_mkMapCollection__OV', bound=sigmastate.SType)  # <OV>
    @staticmethod
    def mkMapCollection(input: sigmastate.Values.Value[sigmastate.SCollection[_mkMapCollection__IV]], mapper: sigmastate.Values.Value[sigmastate.SFunc]) -> sigmastate.Values.Value[sigmastate.SCollection[_mkMapCollection__OV]]: ...
    _mkMax__T = typing.TypeVar('_mkMax__T', bound=sigmastate.SNumericType)  # <T>
    @staticmethod
    def mkMax(left: sigmastate.Values.Value[_mkMax__T], right: sigmastate.Values.Value[_mkMax__T]) -> sigmastate.Values.Value[_mkMax__T]: ...
    @staticmethod
    def mkMethodCall(obj: sigmastate.Values.Value[sigmastate.SType], method: sigmastate.SMethod, args: scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]], typeSubst: scala.collection.immutable.Map[sigmastate.STypeVar, sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    @staticmethod
    def mkMethodCall$default$4() -> scala.collection.immutable.Map[sigmastate.STypeVar, sigmastate.SType]: ...
    @staticmethod
    def mkMethodCallLike(obj: sigmastate.Values.Value[sigmastate.SType], name: typing.Union[java.lang.String, str], args: scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]], tpe: sigmastate.SType) -> sigmastate.Values.Value[sigmastate.SType]: ...
    @staticmethod
    def mkMethodCallLike$default$4() -> sigmastate.SType: ...
    _mkMin__T = typing.TypeVar('_mkMin__T', bound=sigmastate.SNumericType)  # <T>
    @staticmethod
    def mkMin(left: sigmastate.Values.Value[_mkMin__T], right: sigmastate.Values.Value[_mkMin__T]) -> sigmastate.Values.Value[_mkMin__T]: ...
    _mkMinus__T = typing.TypeVar('_mkMinus__T', bound=sigmastate.SNumericType)  # <T>
    @staticmethod
    def mkMinus(left: sigmastate.Values.Value[_mkMinus__T], right: sigmastate.Values.Value[_mkMinus__T]) -> sigmastate.Values.Value[_mkMinus__T]: ...
    @staticmethod
    def mkMinusModQ(left: sigmastate.Values.Value[sigmastate.SBigInt.], right: sigmastate.Values.Value[sigmastate.SBigInt.]) -> sigmastate.Values.Value[sigmastate.SBigInt.]: ...
    @staticmethod
    def mkModQ(input: sigmastate.Values.Value[sigmastate.SBigInt.]) -> sigmastate.Values.Value[sigmastate.SBigInt.]: ...
    _mkModulo__T = typing.TypeVar('_mkModulo__T', bound=sigmastate.SNumericType)  # <T>
    @staticmethod
    def mkModulo(left: sigmastate.Values.Value[_mkModulo__T], right: sigmastate.Values.Value[_mkModulo__T]) -> sigmastate.Values.Value[_mkModulo__T]: ...
    _mkMultiply__T = typing.TypeVar('_mkMultiply__T', bound=sigmastate.SNumericType)  # <T>
    @staticmethod
    def mkMultiply(left: sigmastate.Values.Value[_mkMultiply__T], right: sigmastate.Values.Value[_mkMultiply__T]) -> sigmastate.Values.Value[_mkMultiply__T]: ...
    @staticmethod
    def mkMultiplyGroup(left: sigmastate.Values.Value[sigmastate.SGroupElement.], right: sigmastate.Values.Value[sigmastate.SGroupElement.]) -> sigmastate.Values.Value[sigmastate.SGroupElement.]: ...
    _mkNEQ__T = typing.TypeVar('_mkNEQ__T', bound=sigmastate.SType)  # <T>
    @staticmethod
    def mkNEQ(left: sigmastate.Values.Value[_mkNEQ__T], right: sigmastate.Values.Value[_mkNEQ__T]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    _mkNegation__T = typing.TypeVar('_mkNegation__T', bound=sigmastate.SNumericType)  # <T>
    @staticmethod
    def mkNegation(input: sigmastate.Values.Value[_mkNegation__T]) -> sigmastate.Values.Value[_mkNegation__T]: ...
    _mkNoneValue__T = typing.TypeVar('_mkNoneValue__T', bound=sigmastate.SType)  # <T>
    @staticmethod
    def mkNoneValue(elemType: _mkNoneValue__T) -> sigmastate.Values.Value[sigmastate.SOption[_mkNoneValue__T]]: ...
    @staticmethod
    def mkOR(input: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SBoolean.]]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    _mkOptionGet__T = typing.TypeVar('_mkOptionGet__T', bound=sigmastate.SType)  # <T>
    @staticmethod
    def mkOptionGet(input: sigmastate.Values.Value[sigmastate.SOption[_mkOptionGet__T]]) -> sigmastate.Values.Value[_mkOptionGet__T]: ...
    _mkOptionGetOrElse__T = typing.TypeVar('_mkOptionGetOrElse__T', bound=sigmastate.SType)  # <T>
    @staticmethod
    def mkOptionGetOrElse(input: sigmastate.Values.Value[sigmastate.SOption[_mkOptionGetOrElse__T]], default: sigmastate.Values.Value[_mkOptionGetOrElse__T]) -> sigmastate.Values.Value[_mkOptionGetOrElse__T]: ...
    _mkOptionIsDefined__T = typing.TypeVar('_mkOptionIsDefined__T', bound=sigmastate.SType)  # <T>
    @staticmethod
    def mkOptionIsDefined(input: sigmastate.Values.Value[sigmastate.SOption[_mkOptionIsDefined__T]]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    _mkPlus__T = typing.TypeVar('_mkPlus__T', bound=sigmastate.SNumericType)  # <T>
    @staticmethod
    def mkPlus(left: sigmastate.Values.Value[_mkPlus__T], right: sigmastate.Values.Value[_mkPlus__T]) -> sigmastate.Values.Value[_mkPlus__T]: ...
    @staticmethod
    def mkPlusModQ(left: sigmastate.Values.Value[sigmastate.SBigInt.], right: sigmastate.Values.Value[sigmastate.SBigInt.]) -> sigmastate.Values.Value[sigmastate.SBigInt.]: ...
    @staticmethod
    def mkSelect(obj: sigmastate.Values.Value[sigmastate.SType], field: typing.Union[java.lang.String, str], resType: scala.Option[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    @staticmethod
    def mkSelect$default$3() -> scala.Option[sigmastate.SType]: ...
    @staticmethod
    def mkSelectField(input: sigmastate.Values.Value[sigmastate.STuple], fieldIndex: int) -> sigmastate.Values.Value[sigmastate.SType]: ...
    @staticmethod
    def mkSigmaAnd(items: scala.collection.Seq[sigmastate.Values.Value[sigmastate.SSigmaProp.]]) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...
    @staticmethod
    def mkSigmaOr(items: scala.collection.Seq[sigmastate.Values.Value[sigmastate.SSigmaProp.]]) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...
    @staticmethod
    def mkSigmaPropBytes(value: sigmastate.Values.Value[sigmastate.SSigmaProp.]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    @staticmethod
    def mkSigmaPropIsProven(value: sigmastate.Values.Value[sigmastate.SSigmaProp.]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    _mkSizeOf__V = typing.TypeVar('_mkSizeOf__V', bound=sigmastate.SType)  # <V>
    @staticmethod
    def mkSizeOf(input: sigmastate.Values.Value[sigmastate.SCollection[_mkSizeOf__V]]) -> sigmastate.Values.Value[sigmastate.SInt.]: ...
    _mkSlice__IV = typing.TypeVar('_mkSlice__IV', bound=sigmastate.SType)  # <IV>
    @staticmethod
    def mkSlice(input: sigmastate.Values.Value[sigmastate.SCollection[_mkSlice__IV]], from_: sigmastate.Values.Value[sigmastate.SInt.], until: sigmastate.Values.Value[sigmastate.SInt.]) -> sigmastate.Values.Value[sigmastate.SCollection[_mkSlice__IV]]: ...
    _mkSomeValue__T = typing.TypeVar('_mkSomeValue__T', bound=sigmastate.SType)  # <T>
    @staticmethod
    def mkSomeValue(x: sigmastate.Values.Value[_mkSomeValue__T]) -> sigmastate.Values.Value[sigmastate.SOption[_mkSomeValue__T]]: ...
    @staticmethod
    def mkStringConcat(left: sigmastate.Values.Constant[sigmastate.SString.], right: sigmastate.Values.Constant[sigmastate.SString.]) -> sigmastate.Values.Value[sigmastate.SString.]: ...
    _mkSubstConst__T = typing.TypeVar('_mkSubstConst__T', bound=sigmastate.SType)  # <T>
    @staticmethod
    def mkSubstConst(scriptBytes: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]], positions: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SInt.]], newValues: sigmastate.Values.Value[sigmastate.SCollection[_mkSubstConst__T]]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    _mkTaggedVariable__T = typing.TypeVar('_mkTaggedVariable__T', bound=sigmastate.SType)  # <T>
    @staticmethod
    def mkTaggedVariable(varId: int, tpe: _mkTaggedVariable__T) -> sigmastate.Values.TaggedVariable[_mkTaggedVariable__T]: ...
    @staticmethod
    def mkTreeLookup(tree: sigmastate.Values.Value[sigmastate.SAvlTree.], key: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]], proof: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]) -> sigmastate.Values.Value[sigmastate.SOption[sigmastate.SCollection[sigmastate.SByte.]]]: ...
    @staticmethod
    def mkTuple(items: scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    @staticmethod
    def mkUnitConstant() -> sigmastate.Values.Value[sigmastate.SUnit.]: ...
    _mkUpcast__T = typing.TypeVar('_mkUpcast__T', bound=sigmastate.SNumericType)  # <T>
    _mkUpcast__R = typing.TypeVar('_mkUpcast__R', bound=sigmastate.SNumericType)  # <R>
    @staticmethod
    def mkUpcast(input: sigmastate.Values.Value[_mkUpcast__T], tpe: _mkUpcast__R) -> sigmastate.Values.Value[_mkUpcast__R]: ...
    @staticmethod
    def mkVal(name: typing.Union[java.lang.String, str], givenType: sigmastate.SType, body: sigmastate.Values.Value[sigmastate.SType]) -> 'Terms.Val': ...
    @staticmethod
    def mkValUse(valId: int, tpe: sigmastate.SType) -> sigmastate.Values.Value[sigmastate.SType]: ...
    @staticmethod
    def mkXor(left: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]], right: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    @staticmethod
    def mkXorOf(input: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SBoolean.]]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    @staticmethod
    def mkZKProofBlock(body: sigmastate.Values.Value[sigmastate.SSigmaProp.]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    @staticmethod
    def productArity() -> int: ...
    @staticmethod
    def productElement(x$1: int) -> typing.Any: ...
    @staticmethod
    def productIterator() -> scala.collection.Iterator[typing.Any]: ...
    @staticmethod
    def productPrefix() -> java.lang.String: ...
    @staticmethod
    def toString() -> java.lang.String: ...

class SigmaBinder:
    sigmastate$lang$SigmaBinder$$builder: 'SigmaBuilder' = ...
    def __init__(self, env: scala.collection.immutable.Map[typing.Union[java.lang.String, str], typing.Any], builder: 'SigmaBuilder', networkPrefix: int, predefFuncRegistry: 'SigmaPredef.PredefinedFuncRegistry'): ...
    def bind(self, e: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    @staticmethod
    def error(msg: typing.Union[java.lang.String, str], srcCtx: 'SourceContext') -> scala.runtime.Nothing.: ...
    def sigmastate$lang$SigmaBinder$$PKFunc(self) -> 'SigmaPredef.PredefinedFunc': ...
    def sigmastate$lang$SigmaBinder$$eval(self, e: sigmastate.Values.Value[sigmastate.SType], env: scala.collection.immutable.Map[typing.Union[java.lang.String, str], typing.Any]) -> sigmastate.Values.Value[sigmastate.SType]: ...

class SigmaBuilder:
    def __init__(self): ...
    def currentSrcCtx(self) -> scala.util.DynamicVariable[scalan.Nullable['SourceContext']]: ...
    def liftAny(self, obj: typing.Any) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def mkAND(self, input: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SBoolean.]]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    def mkAllOf(self, input: scala.collection.Seq[sigmastate.Values.Value[sigmastate.SBoolean.]]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    def mkAnyOf(self, input: scala.collection.Seq[sigmastate.Values.Value[sigmastate.SBoolean.]]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    _mkAppend__IV = typing.TypeVar('_mkAppend__IV', bound=sigmastate.SType)  # <IV>
    def mkAppend(self, input: sigmastate.Values.Value[sigmastate.SCollection[_mkAppend__IV]], col2: sigmastate.Values.Value[sigmastate.SCollection[_mkAppend__IV]]) -> sigmastate.Values.Value[sigmastate.SCollection[_mkAppend__IV]]: ...
    def mkApply(self, func: sigmastate.Values.Value[sigmastate.SType], args: scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def mkApplyTypes(self, input: sigmastate.Values.Value[sigmastate.SType], tpeArgs: scala.collection.Seq[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    _mkArith__T = typing.TypeVar('_mkArith__T', bound=sigmastate.SNumericType)  # <T>
    def mkArith(self, left: sigmastate.Values.Value[_mkArith__T], right: sigmastate.Values.Value[_mkArith__T], opCode: int) -> sigmastate.Values.Value[_mkArith__T]: ...
    def mkAtLeast(self, bound: sigmastate.Values.Value[sigmastate.SInt.], input: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SSigmaProp.]]) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...
    def mkBinAnd(self, left: sigmastate.Values.Value[sigmastate.SBoolean.], right: sigmastate.Values.Value[sigmastate.SBoolean.]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    def mkBinOr(self, left: sigmastate.Values.Value[sigmastate.SBoolean.], right: sigmastate.Values.Value[sigmastate.SBoolean.]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    def mkBinXor(self, left: sigmastate.Values.Value[sigmastate.SBoolean.], right: sigmastate.Values.Value[sigmastate.SBoolean.]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    _mkBitAnd__T = typing.TypeVar('_mkBitAnd__T', bound=sigmastate.SNumericType)  # <T>
    def mkBitAnd(self, left: sigmastate.Values.Value[_mkBitAnd__T], right: sigmastate.Values.Value[_mkBitAnd__T]) -> sigmastate.Values.Value[_mkBitAnd__T]: ...
    _mkBitInversion__T = typing.TypeVar('_mkBitInversion__T', bound=sigmastate.SNumericType)  # <T>
    def mkBitInversion(self, input: sigmastate.Values.Value[_mkBitInversion__T]) -> sigmastate.Values.Value[_mkBitInversion__T]: ...
    _mkBitOr__T = typing.TypeVar('_mkBitOr__T', bound=sigmastate.SNumericType)  # <T>
    def mkBitOr(self, left: sigmastate.Values.Value[_mkBitOr__T], right: sigmastate.Values.Value[_mkBitOr__T]) -> sigmastate.Values.Value[_mkBitOr__T]: ...
    _mkBitShiftLeft__T = typing.TypeVar('_mkBitShiftLeft__T', bound=sigmastate.SNumericType)  # <T>
    def mkBitShiftLeft(self, bits: sigmastate.Values.Value[_mkBitShiftLeft__T], shift: sigmastate.Values.Value[_mkBitShiftLeft__T]) -> sigmastate.Values.Value[_mkBitShiftLeft__T]: ...
    _mkBitShiftRight__T = typing.TypeVar('_mkBitShiftRight__T', bound=sigmastate.SNumericType)  # <T>
    def mkBitShiftRight(self, bits: sigmastate.Values.Value[_mkBitShiftRight__T], shift: sigmastate.Values.Value[_mkBitShiftRight__T]) -> sigmastate.Values.Value[_mkBitShiftRight__T]: ...
    _mkBitShiftRightZeroed__T = typing.TypeVar('_mkBitShiftRightZeroed__T', bound=sigmastate.SNumericType)  # <T>
    def mkBitShiftRightZeroed(self, bits: sigmastate.Values.Value[_mkBitShiftRightZeroed__T], shift: sigmastate.Values.Value[_mkBitShiftRightZeroed__T]) -> sigmastate.Values.Value[_mkBitShiftRightZeroed__T]: ...
    _mkBitXor__T = typing.TypeVar('_mkBitXor__T', bound=sigmastate.SNumericType)  # <T>
    def mkBitXor(self, left: sigmastate.Values.Value[_mkBitXor__T], right: sigmastate.Values.Value[_mkBitXor__T]) -> sigmastate.Values.Value[_mkBitXor__T]: ...
    def mkBlock(self, bindings: scala.collection.Seq['Terms.Val'], result: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def mkBlockValue(self, items: scala.collection.IndexedSeq[sigmastate.Values.BlockItem], result: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def mkBoolToSigmaProp(self, value: sigmastate.Values.Value[sigmastate.SBoolean.]) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...
    _mkByIndex__IV = typing.TypeVar('_mkByIndex__IV', bound=sigmastate.SType)  # <IV>
    def mkByIndex(self, input: sigmastate.Values.Value[sigmastate.SCollection[_mkByIndex__IV]], index: sigmastate.Values.Value[sigmastate.SInt.], default: scala.Option[sigmastate.Values.Value[_mkByIndex__IV]]) -> sigmastate.Values.Value[_mkByIndex__IV]: ...
    _mkByIndex$default$3__IV = typing.TypeVar('_mkByIndex$default$3__IV', bound=sigmastate.SType)  # <IV>
    def mkByIndex$default$3(self) -> scala.None.: ...
    def mkByteArrayToBigInt(self, input: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]) -> sigmastate.Values.Value[sigmastate.SBigInt.]: ...
    def mkByteArrayToLong(self, input: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]) -> sigmastate.Values.Value[sigmastate.SLong.]: ...
    def mkCalcBlake2b256(self, input: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    def mkCalcSha256(self, input: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    _mkCollectionConstant_0__T = typing.TypeVar('_mkCollectionConstant_0__T', bound=sigmastate.SType)  # <T>
    _mkCollectionConstant_1__T = typing.TypeVar('_mkCollectionConstant_1__T', bound=sigmastate.SType)  # <T>
    @typing.overload
    def mkCollectionConstant(self, values: typing.Any, elementType: _mkCollectionConstant_0__T) -> sigmastate.Values.Constant[sigmastate.SCollection[_mkCollectionConstant_0__T]]: ...
    @typing.overload
    def mkCollectionConstant(self, values: special.collection.Coll[typing.Any], elementType: _mkCollectionConstant_1__T) -> sigmastate.Values.Constant[sigmastate.SCollection[_mkCollectionConstant_1__T]]: ...
    _mkConcreteCollection__T = typing.TypeVar('_mkConcreteCollection__T', bound=sigmastate.SType)  # <T>
    def mkConcreteCollection(self, items: scala.collection.Seq[sigmastate.Values.Value[_mkConcreteCollection__T]], elementType: _mkConcreteCollection__T) -> sigmastate.Values.Value[sigmastate.SCollection[_mkConcreteCollection__T]]: ...
    _mkConstant__T = typing.TypeVar('_mkConstant__T', bound=sigmastate.SType)  # <T>
    def mkConstant(self, value: typing.Any, tpe: _mkConstant__T) -> sigmastate.Values.Constant[_mkConstant__T]: ...
    _mkConstantPlaceholder__T = typing.TypeVar('_mkConstantPlaceholder__T', bound=sigmastate.SType)  # <T>
    def mkConstantPlaceholder(self, id: int, tpe: _mkConstantPlaceholder__T) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def mkCreateAvlTree(self, operationFlags: sigmastate.Values.Value[sigmastate.SByte.], digest: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]], keyLength: sigmastate.Values.Value[sigmastate.SInt.], valueLengthOpt: sigmastate.Values.Value[sigmastate.SOption[sigmastate.SInt.]]) -> sigmastate.Values.Value[sigmastate.SAvlTree.]: ...
    def mkCreateProveDHTuple(self, gv: sigmastate.Values.Value[sigmastate.SGroupElement.], hv: sigmastate.Values.Value[sigmastate.SGroupElement.], uv: sigmastate.Values.Value[sigmastate.SGroupElement.], vv: sigmastate.Values.Value[sigmastate.SGroupElement.]) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...
    def mkCreateProveDlog(self, value: sigmastate.Values.Value[sigmastate.SGroupElement.]) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...
    def mkDecodePoint(self, input: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]) -> sigmastate.Values.Value[sigmastate.SGroupElement.]: ...
    _mkDeserializeContext__T = typing.TypeVar('_mkDeserializeContext__T', bound=sigmastate.SType)  # <T>
    def mkDeserializeContext(self, id: int, tpe: _mkDeserializeContext__T) -> sigmastate.Values.Value[_mkDeserializeContext__T]: ...
    _mkDeserializeRegister__T = typing.TypeVar('_mkDeserializeRegister__T', bound=sigmastate.SType)  # <T>
    def mkDeserializeRegister(self, reg: org.ergoplatform.ErgoBox.RegisterId, tpe: _mkDeserializeRegister__T, default: scala.Option[sigmastate.Values.Value[_mkDeserializeRegister__T]]) -> sigmastate.Values.Value[_mkDeserializeRegister__T]: ...
    _mkDeserializeRegister$default$3__T = typing.TypeVar('_mkDeserializeRegister$default$3__T', bound=sigmastate.SType)  # <T>
    def mkDeserializeRegister$default$3(self) -> scala.None.: ...
    _mkDivide__T = typing.TypeVar('_mkDivide__T', bound=sigmastate.SNumericType)  # <T>
    def mkDivide(self, left: sigmastate.Values.Value[_mkDivide__T], right: sigmastate.Values.Value[_mkDivide__T]) -> sigmastate.Values.Value[_mkDivide__T]: ...
    _mkDowncast__T = typing.TypeVar('_mkDowncast__T', bound=sigmastate.SNumericType)  # <T>
    _mkDowncast__R = typing.TypeVar('_mkDowncast__R', bound=sigmastate.SNumericType)  # <R>
    def mkDowncast(self, input: sigmastate.Values.Value[_mkDowncast__T], tpe: _mkDowncast__R) -> sigmastate.Values.Value[_mkDowncast__R]: ...
    _mkEQ__T = typing.TypeVar('_mkEQ__T', bound=sigmastate.SType)  # <T>
    def mkEQ(self, left: sigmastate.Values.Value[_mkEQ__T], right: sigmastate.Values.Value[_mkEQ__T]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    _mkExists__IV = typing.TypeVar('_mkExists__IV', bound=sigmastate.SType)  # <IV>
    def mkExists(self, input: sigmastate.Values.Value[sigmastate.SCollection[_mkExists__IV]], condition: sigmastate.Values.Value[sigmastate.SFunc]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    def mkExponentiate(self, left: sigmastate.Values.Value[sigmastate.SGroupElement.], right: sigmastate.Values.Value[sigmastate.SBigInt.]) -> sigmastate.Values.Value[sigmastate.SGroupElement.]: ...
    def mkExtractAmount(self, input: sigmastate.Values.Value[sigmastate.SBox.]) -> sigmastate.Values.Value[sigmastate.SLong.]: ...
    def mkExtractBytes(self, input: sigmastate.Values.Value[sigmastate.SBox.]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    def mkExtractBytesWithNoRef(self, input: sigmastate.Values.Value[sigmastate.SBox.]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    def mkExtractCreationInfo(self, input: sigmastate.Values.Value[sigmastate.SBox.]) -> sigmastate.Values.Value[sigmastate.STuple]: ...
    def mkExtractId(self, input: sigmastate.Values.Value[sigmastate.SBox.]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    _mkExtractRegisterAs__IV = typing.TypeVar('_mkExtractRegisterAs__IV', bound=sigmastate.SType)  # <IV>
    def mkExtractRegisterAs(self, input: sigmastate.Values.Value[sigmastate.SBox.], registerId: org.ergoplatform.ErgoBox.RegisterId, tpe: sigmastate.SOption[_mkExtractRegisterAs__IV]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def mkExtractScriptBytes(self, input: sigmastate.Values.Value[sigmastate.SBox.]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    _mkFilter__IV = typing.TypeVar('_mkFilter__IV', bound=sigmastate.SType)  # <IV>
    def mkFilter(self, input: sigmastate.Values.Value[sigmastate.SCollection[_mkFilter__IV]], condition: sigmastate.Values.Value[sigmastate.SFunc]) -> sigmastate.Values.Value[sigmastate.SCollection[_mkFilter__IV]]: ...
    _mkFold__IV = typing.TypeVar('_mkFold__IV', bound=sigmastate.SType)  # <IV>
    _mkFold__OV = typing.TypeVar('_mkFold__OV', bound=sigmastate.SType)  # <OV>
    def mkFold(self, input: sigmastate.Values.Value[sigmastate.SCollection[_mkFold__IV]], zero: sigmastate.Values.Value[_mkFold__OV], foldOp: sigmastate.Values.Value[sigmastate.SFunc]) -> sigmastate.Values.Value[_mkFold__OV]: ...
    _mkForAll__IV = typing.TypeVar('_mkForAll__IV', bound=sigmastate.SType)  # <IV>
    def mkForAll(self, input: sigmastate.Values.Value[sigmastate.SCollection[_mkForAll__IV]], condition: sigmastate.Values.Value[sigmastate.SFunc]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    def mkFuncValue(self, args: scala.collection.IndexedSeq[scala.Tuple2[typing.Any, sigmastate.SType]], body: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SFunc]: ...
    _mkGE__T = typing.TypeVar('_mkGE__T', bound=sigmastate.SType)  # <T>
    def mkGE(self, left: sigmastate.Values.Value[_mkGE__T], right: sigmastate.Values.Value[_mkGE__T]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    _mkGT__T = typing.TypeVar('_mkGT__T', bound=sigmastate.SType)  # <T>
    def mkGT(self, left: sigmastate.Values.Value[_mkGT__T], right: sigmastate.Values.Value[_mkGT__T]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    def mkGenLambda(self, tpeParams: scala.collection.Seq['Terms.STypeParam'], args: scala.collection.IndexedSeq[scala.Tuple2[typing.Union[java.lang.String, str], sigmastate.SType]], givenResType: sigmastate.SType, body: scala.Option[sigmastate.Values.Value[sigmastate.SType]]) -> sigmastate.Values.Value[sigmastate.SFunc]: ...
    _mkGetVar__T = typing.TypeVar('_mkGetVar__T', bound=sigmastate.SType)  # <T>
    def mkGetVar(self, varId: int, tpe: _mkGetVar__T) -> sigmastate.Values.Value[sigmastate.SOption[_mkGetVar__T]]: ...
    def mkIdent(self, name: typing.Union[java.lang.String, str], tpe: sigmastate.SType) -> sigmastate.Values.Value[sigmastate.SType]: ...
    _mkIf__T = typing.TypeVar('_mkIf__T', bound=sigmastate.SType)  # <T>
    def mkIf(self, condition: sigmastate.Values.Value[sigmastate.SBoolean.], trueBranch: sigmastate.Values.Value[_mkIf__T], falseBranch: sigmastate.Values.Value[_mkIf__T]) -> sigmastate.Values.Value[_mkIf__T]: ...
    _mkLE__T = typing.TypeVar('_mkLE__T', bound=sigmastate.SType)  # <T>
    def mkLE(self, left: sigmastate.Values.Value[_mkLE__T], right: sigmastate.Values.Value[_mkLE__T]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    _mkLT__T = typing.TypeVar('_mkLT__T', bound=sigmastate.SType)  # <T>
    def mkLT(self, left: sigmastate.Values.Value[_mkLT__T], right: sigmastate.Values.Value[_mkLT__T]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    def mkLambda(self, args: scala.collection.IndexedSeq[scala.Tuple2[typing.Union[java.lang.String, str], sigmastate.SType]], givenResType: sigmastate.SType, body: scala.Option[sigmastate.Values.Value[sigmastate.SType]]) -> sigmastate.Values.Value[sigmastate.SFunc]: ...
    def mkLogicalNot(self, input: sigmastate.Values.Value[sigmastate.SBoolean.]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    def mkLongToByteArray(self, input: sigmastate.Values.Value[sigmastate.SLong.]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    _mkMapCollection__IV = typing.TypeVar('_mkMapCollection__IV', bound=sigmastate.SType)  # <IV>
    _mkMapCollection__OV = typing.TypeVar('_mkMapCollection__OV', bound=sigmastate.SType)  # <OV>
    def mkMapCollection(self, input: sigmastate.Values.Value[sigmastate.SCollection[_mkMapCollection__IV]], mapper: sigmastate.Values.Value[sigmastate.SFunc]) -> sigmastate.Values.Value[sigmastate.SCollection[_mkMapCollection__OV]]: ...
    _mkMax__T = typing.TypeVar('_mkMax__T', bound=sigmastate.SNumericType)  # <T>
    def mkMax(self, left: sigmastate.Values.Value[_mkMax__T], right: sigmastate.Values.Value[_mkMax__T]) -> sigmastate.Values.Value[_mkMax__T]: ...
    def mkMethodCall(self, obj: sigmastate.Values.Value[sigmastate.SType], method: sigmastate.SMethod, args: scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]], typeSubst: scala.collection.immutable.Map[sigmastate.STypeVar, sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def mkMethodCallLike(self, obj: sigmastate.Values.Value[sigmastate.SType], name: typing.Union[java.lang.String, str], args: scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]], tpe: sigmastate.SType) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def mkMethodCallLike$default$4(self) -> sigmastate.SType: ...
    _mkMin__T = typing.TypeVar('_mkMin__T', bound=sigmastate.SNumericType)  # <T>
    def mkMin(self, left: sigmastate.Values.Value[_mkMin__T], right: sigmastate.Values.Value[_mkMin__T]) -> sigmastate.Values.Value[_mkMin__T]: ...
    _mkMinus__T = typing.TypeVar('_mkMinus__T', bound=sigmastate.SNumericType)  # <T>
    def mkMinus(self, left: sigmastate.Values.Value[_mkMinus__T], right: sigmastate.Values.Value[_mkMinus__T]) -> sigmastate.Values.Value[_mkMinus__T]: ...
    def mkMinusModQ(self, left: sigmastate.Values.Value[sigmastate.SBigInt.], right: sigmastate.Values.Value[sigmastate.SBigInt.]) -> sigmastate.Values.Value[sigmastate.SBigInt.]: ...
    def mkModQ(self, input: sigmastate.Values.Value[sigmastate.SBigInt.]) -> sigmastate.Values.Value[sigmastate.SBigInt.]: ...
    _mkModulo__T = typing.TypeVar('_mkModulo__T', bound=sigmastate.SNumericType)  # <T>
    def mkModulo(self, left: sigmastate.Values.Value[_mkModulo__T], right: sigmastate.Values.Value[_mkModulo__T]) -> sigmastate.Values.Value[_mkModulo__T]: ...
    _mkMultiply__T = typing.TypeVar('_mkMultiply__T', bound=sigmastate.SNumericType)  # <T>
    def mkMultiply(self, left: sigmastate.Values.Value[_mkMultiply__T], right: sigmastate.Values.Value[_mkMultiply__T]) -> sigmastate.Values.Value[_mkMultiply__T]: ...
    def mkMultiplyGroup(self, left: sigmastate.Values.Value[sigmastate.SGroupElement.], right: sigmastate.Values.Value[sigmastate.SGroupElement.]) -> sigmastate.Values.Value[sigmastate.SGroupElement.]: ...
    _mkNEQ__T = typing.TypeVar('_mkNEQ__T', bound=sigmastate.SType)  # <T>
    def mkNEQ(self, left: sigmastate.Values.Value[_mkNEQ__T], right: sigmastate.Values.Value[_mkNEQ__T]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    _mkNegation__T = typing.TypeVar('_mkNegation__T', bound=sigmastate.SNumericType)  # <T>
    def mkNegation(self, input: sigmastate.Values.Value[_mkNegation__T]) -> sigmastate.Values.Value[_mkNegation__T]: ...
    _mkNoneValue__T = typing.TypeVar('_mkNoneValue__T', bound=sigmastate.SType)  # <T>
    def mkNoneValue(self, elemType: _mkNoneValue__T) -> sigmastate.Values.Value[sigmastate.SOption[_mkNoneValue__T]]: ...
    def mkOR(self, input: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SBoolean.]]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    _mkOptionGet__T = typing.TypeVar('_mkOptionGet__T', bound=sigmastate.SType)  # <T>
    def mkOptionGet(self, input: sigmastate.Values.Value[sigmastate.SOption[_mkOptionGet__T]]) -> sigmastate.Values.Value[_mkOptionGet__T]: ...
    _mkOptionGetOrElse__T = typing.TypeVar('_mkOptionGetOrElse__T', bound=sigmastate.SType)  # <T>
    def mkOptionGetOrElse(self, input: sigmastate.Values.Value[sigmastate.SOption[_mkOptionGetOrElse__T]], default: sigmastate.Values.Value[_mkOptionGetOrElse__T]) -> sigmastate.Values.Value[_mkOptionGetOrElse__T]: ...
    _mkOptionIsDefined__T = typing.TypeVar('_mkOptionIsDefined__T', bound=sigmastate.SType)  # <T>
    def mkOptionIsDefined(self, input: sigmastate.Values.Value[sigmastate.SOption[_mkOptionIsDefined__T]]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    _mkPlus__T = typing.TypeVar('_mkPlus__T', bound=sigmastate.SNumericType)  # <T>
    def mkPlus(self, left: sigmastate.Values.Value[_mkPlus__T], right: sigmastate.Values.Value[_mkPlus__T]) -> sigmastate.Values.Value[_mkPlus__T]: ...
    def mkPlusModQ(self, left: sigmastate.Values.Value[sigmastate.SBigInt.], right: sigmastate.Values.Value[sigmastate.SBigInt.]) -> sigmastate.Values.Value[sigmastate.SBigInt.]: ...
    def mkSelect(self, obj: sigmastate.Values.Value[sigmastate.SType], field: typing.Union[java.lang.String, str], resType: scala.Option[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def mkSelect$default$3(self) -> scala.Option[sigmastate.SType]: ...
    def mkSelectField(self, input: sigmastate.Values.Value[sigmastate.STuple], fieldIndex: int) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def mkSigmaAnd(self, items: scala.collection.Seq[sigmastate.Values.Value[sigmastate.SSigmaProp.]]) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...
    def mkSigmaOr(self, items: scala.collection.Seq[sigmastate.Values.Value[sigmastate.SSigmaProp.]]) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...
    def mkSigmaPropBytes(self, value: sigmastate.Values.Value[sigmastate.SSigmaProp.]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    def mkSigmaPropIsProven(self, value: sigmastate.Values.Value[sigmastate.SSigmaProp.]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    _mkSizeOf__IV = typing.TypeVar('_mkSizeOf__IV', bound=sigmastate.SType)  # <IV>
    def mkSizeOf(self, input: sigmastate.Values.Value[sigmastate.SCollection[_mkSizeOf__IV]]) -> sigmastate.Values.Value[sigmastate.SInt.]: ...
    _mkSlice__IV = typing.TypeVar('_mkSlice__IV', bound=sigmastate.SType)  # <IV>
    def mkSlice(self, input: sigmastate.Values.Value[sigmastate.SCollection[_mkSlice__IV]], from_: sigmastate.Values.Value[sigmastate.SInt.], until: sigmastate.Values.Value[sigmastate.SInt.]) -> sigmastate.Values.Value[sigmastate.SCollection[_mkSlice__IV]]: ...
    _mkSomeValue__T = typing.TypeVar('_mkSomeValue__T', bound=sigmastate.SType)  # <T>
    def mkSomeValue(self, x: sigmastate.Values.Value[_mkSomeValue__T]) -> sigmastate.Values.Value[sigmastate.SOption[_mkSomeValue__T]]: ...
    def mkStringConcat(self, left: sigmastate.Values.Constant[sigmastate.SString.], right: sigmastate.Values.Constant[sigmastate.SString.]) -> sigmastate.Values.Value[sigmastate.SString.]: ...
    _mkSubstConst__T = typing.TypeVar('_mkSubstConst__T', bound=sigmastate.SType)  # <T>
    def mkSubstConst(self, scriptBytes: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]], positions: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SInt.]], newValues: sigmastate.Values.Value[sigmastate.SCollection[_mkSubstConst__T]]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    _mkTaggedVariable__T = typing.TypeVar('_mkTaggedVariable__T', bound=sigmastate.SType)  # <T>
    def mkTaggedVariable(self, varId: int, tpe: _mkTaggedVariable__T) -> sigmastate.Values.TaggedVariable[_mkTaggedVariable__T]: ...
    def mkTreeLookup(self, tree: sigmastate.Values.Value[sigmastate.SAvlTree.], key: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]], proof: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]) -> sigmastate.Values.Value[sigmastate.SOption[sigmastate.SCollection[sigmastate.SByte.]]]: ...
    def mkTuple(self, items: scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def mkUnitConstant(self) -> sigmastate.Values.Value[sigmastate.SUnit.]: ...
    _mkUpcast__T = typing.TypeVar('_mkUpcast__T', bound=sigmastate.SNumericType)  # <T>
    _mkUpcast__R = typing.TypeVar('_mkUpcast__R', bound=sigmastate.SNumericType)  # <R>
    def mkUpcast(self, input: sigmastate.Values.Value[_mkUpcast__T], tpe: _mkUpcast__R) -> sigmastate.Values.Value[_mkUpcast__R]: ...
    def mkVal(self, name: typing.Union[java.lang.String, str], givenType: sigmastate.SType, body: sigmastate.Values.Value[sigmastate.SType]) -> 'Terms.Val': ...
    def mkValUse(self, valId: int, tpe: sigmastate.SType) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def mkXor(self, left: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]], right: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    def mkXorOf(self, input: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SBoolean.]]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    def mkZKProofBlock(self, body: sigmastate.Values.Value[sigmastate.SSigmaProp.]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...

class SigmaCompiler:
    sigmastate$lang$SigmaCompiler$$settings: CompilerSettings = ...
    def __init__(self, settings: CompilerSettings): ...
    @staticmethod
    def apply(settings: CompilerSettings) -> 'SigmaCompiler': ...
    def builder(self) -> SigmaBuilder: ...
    def compile(self, env: scala.collection.immutable.Map[typing.Union[java.lang.String, str], typing.Any], code: typing.Union[java.lang.String, str], IR: sigmastate.eval.IRContext) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def compileWithoutCosting(self, env: scala.collection.immutable.Map[typing.Union[java.lang.String, str], typing.Any], code: typing.Union[java.lang.String, str]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def networkPrefix(self) -> int: ...
    def parse(self, x: typing.Union[java.lang.String, str]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    @typing.overload
    def typecheck(self, env: scala.collection.immutable.Map[typing.Union[java.lang.String, str], typing.Any], code: typing.Union[java.lang.String, str]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    @typing.overload
    def typecheck(self, env: scala.collection.immutable.Map[typing.Union[java.lang.String, str], typing.Any], parsed: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SType]: ...

class SigmaParser:
    @staticmethod
    def $at() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def $colon() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def $eq() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def $eq$greater() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def $greater$colon() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def $hash() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def $less$colon() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def $times() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def $u007B() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def $u007D() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def Annot() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def AnnotType() -> fastparse.core.Parser[sigmastate.SType, typing.Any, java.lang.String]: ...
    @staticmethod
    def AnonTmpl() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def ArgList() -> fastparse.core.Parser[sigmastate.Values.Value[sigmastate.SType], typing.Any, java.lang.String]: ...
    @staticmethod
    def BacktickId() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def BaseBlock(end: fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, typing.Union[java.lang.String, str]], name: sourcecode.Name) -> fastparse.core.Parser[sigmastate.Values.Value[sigmastate.SType], typing.Any, java.lang.String]: ...
    @staticmethod
    def BindPattern() -> fastparse.core.Parser[typing.Any, typing.Any, java.lang.String]: ...
    @staticmethod
    def Block() -> fastparse.core.Parser[sigmastate.Values.Value[sigmastate.SType], typing.Any, java.lang.String]: ...
    @staticmethod
    def BlockChunk() -> fastparse.core.Parser[scala.Tuple2[scala.collection.Seq[scala.collection.Seq[scala.Tuple2[java.lang.String, sigmastate.SType]]], scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]]], typing.Any, java.lang.String]: ...
    @staticmethod
    def BlockDef() -> fastparse.core.Parser[sigmastate.Values.Value[sigmastate.SType], typing.Any, java.lang.String]: ...
    @staticmethod
    def BlockExpr() -> fastparse.core.Parser[sigmastate.Values.Value[sigmastate.SType], typing.Any, java.lang.String]: ...
    @staticmethod
    def BlockLambda() -> fastparse.core.Parser[scala.collection.Seq[scala.Tuple2[java.lang.String, sigmastate.SType]], typing.Any, java.lang.String]: ...
    @staticmethod
    def BlockLambdaHead() -> fastparse.core.Parser[scala.collection.Seq[scala.Tuple2[java.lang.String, sigmastate.SType]], typing.Any, java.lang.String]: ...
    @staticmethod
    def CaseBlock() -> fastparse.core.Parser[sigmastate.Values.Value[sigmastate.SType], typing.Any, java.lang.String]: ...
    @staticmethod
    def CaseClauses() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def CompoundType() -> fastparse.core.Parser[sigmastate.SType, typing.Any, java.lang.String]: ...
    @staticmethod
    def Constr() -> fastparse.core.Parser[scala.Tuple2[sigmastate.SType, scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]]], typing.Any, java.lang.String]: ...
    @staticmethod
    def Constrs() -> fastparse.core.Parser[scala.collection.Seq[scala.Tuple2[sigmastate.SType, scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]]]], typing.Any, java.lang.String]: ...
    @staticmethod
    def Dcl() -> fastparse.core.Parser[sigmastate.Values.Value[sigmastate.SType], typing.Any, java.lang.String]: ...
    @staticmethod
    def DefTmpl() -> fastparse.core.Parser[typing.Any, typing.Any, java.lang.String]: ...
    @staticmethod
    def DottyExtMethodSubj() -> fastparse.core.Parser[scala.Tuple2[java.lang.String, sigmastate.SType], typing.Any, java.lang.String]: ...
    @staticmethod
    def EarlyDefTmpl() -> fastparse.core.Parser[scala.Tuple4[scala.Option[scala.collection.Seq[scala.Tuple2[java.lang.String, sigmastate.SType]]], scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]], scala.collection.Seq[scala.Tuple2[sigmastate.SType, scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]]]], scala.Option[scala.Tuple2[scala.Option[scala.collection.Seq[scala.Tuple2[java.lang.String, sigmastate.SType]]], scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]]]]], typing.Any, java.lang.String]: ...
    @staticmethod
    def ExprCtx() -> sigmastate.lang.syntax.Exprs.ExprCtx.: ...
    @staticmethod
    def ExprLiteral() -> fastparse.core.Parser[sigmastate.Values.Constant[sigmastate.SMonoType], typing.Any, java.lang.String]: ...
    @staticmethod
    def Exprs() -> fastparse.core.Parser[scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]], typing.Any, java.lang.String]: ...
    @staticmethod
    def FreeCtx() -> sigmastate.lang.syntax.Exprs.FreeCtx.: ...
    @staticmethod
    def FunDef() -> fastparse.core.Parser['Terms.Val', typing.Any, java.lang.String]: ...
    @staticmethod
    def FunSig() -> fastparse.core.Parser[scala.collection.Seq[scala.collection.Seq[scala.Tuple2[java.lang.String, sigmastate.SType]]], typing.Any, java.lang.String]: ...
    @staticmethod
    def Id() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def Ids() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def InfixType() -> fastparse.core.Parser[sigmastate.SType, typing.Any, java.lang.String]: ...
    @staticmethod
    def Literals() -> sigmastate.lang.syntax.Literals.Literals.: ...
    @staticmethod
    def NLAnnot() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def NamedTmpl() -> fastparse.core.Parser[scala.Tuple2[scala.collection.Seq[scala.Tuple2[sigmastate.SType, scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]]]], scala.Option[scala.Tuple2[scala.Option[scala.collection.Seq[scala.Tuple2[java.lang.String, sigmastate.SType]]], scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]]]]], typing.Any, java.lang.String]: ...
    @staticmethod
    def Newline() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def NotNewline() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def OneNLMax() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def ParenArgList() -> fastparse.core.Parser[sigmastate.Values.Value[sigmastate.SType], typing.Any, java.lang.String]: ...
    _ParserOps__T = typing.TypeVar('_ParserOps__T')  # <T>
    @staticmethod
    def ParserOps(p: fastparse.core.Parser[_ParserOps__T, typing.Any, typing.Union[java.lang.String, str]]) -> sigmastate.lang.syntax.Literals.ParserOps[_ParserOps__T]: ...
    @staticmethod
    def PatLiteral() -> fastparse.core.Parser[sigmastate.Values.Constant[sigmastate.SMonoType], typing.Any, java.lang.String]: ...
    @staticmethod
    def Pattern() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def Patterns() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def PostDotCheck() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def PostfixType() -> fastparse.core.Parser[sigmastate.SType, typing.Any, java.lang.String]: ...
    @staticmethod
    def QualId() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def Semi() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def Semis() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def SimplePattern() -> fastparse.core.Parser[typing.Any, typing.Any, java.lang.String]: ...
    @staticmethod
    def SimpleType() -> fastparse.core.Parser[sigmastate.SType, typing.Any, java.lang.String]: ...
    @staticmethod
    def StableId() -> fastparse.core.Parser[sigmastate.Values.Value[sigmastate.SType], typing.Any, java.lang.String]: ...
    @staticmethod
    def StatCtx() -> sigmastate.lang.syntax.Exprs.StatCtx.: ...
    @staticmethod
    def TmplBody() -> fastparse.core.Parser[scala.Tuple2[scala.Option[scala.collection.Seq[scala.Tuple2[java.lang.String, sigmastate.SType]]], scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]]], typing.Any, java.lang.String]: ...
    @staticmethod
    def TrailingComma() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def Type() -> fastparse.core.Parser[sigmastate.SType, typing.Any, java.lang.String]: ...
    @staticmethod
    def TypeArg() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def TypeArgList() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def TypeArgs() -> fastparse.core.Parser[scala.collection.Seq[sigmastate.SType], typing.Any, java.lang.String]: ...
    @staticmethod
    def TypeBounds() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def TypeExpr() -> fastparse.core.Parser[sigmastate.Values.Value[sigmastate.SType], typing.Any, java.lang.String]: ...
    @staticmethod
    def TypeId() -> fastparse.core.Parser[sigmastate.SType, typing.Any, java.lang.String]: ...
    @staticmethod
    def TypeOrBindPattern() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def TypePat() -> fastparse.core.Parser[sigmastate.SType, typing.Any, java.lang.String]: ...
    @staticmethod
    def TypePattern() -> fastparse.core.Parser[sigmastate.SType, typing.Any, java.lang.String]: ...
    @staticmethod
    def ValVarDef() -> fastparse.core.Parser[sigmastate.Values.Value[sigmastate.SType], typing.Any, java.lang.String]: ...
    @staticmethod
    def VarId() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def WL() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def WL0() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def WS() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def WhitespaceApi() -> sigmastate.lang.syntax.Core.Wrapper2: ...
    @staticmethod
    def _() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def _$times() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def apply(script: typing.Union[java.lang.String, str], sigmaBuilder: SigmaBuilder) -> fastparse.core.Parsed[sigmastate.Values.Value[sigmastate.SType], typing.Any, java.lang.String]: ...
    _atSrcPos__A = typing.TypeVar('_atSrcPos__A')  # <A>
    @staticmethod
    def atSrcPos(parserIndex: int, thunk: scala.Function0[_atSrcPos__A]) -> _atSrcPos__A: ...
    @staticmethod
    def builder() -> SigmaBuilder: ...
    @staticmethod
    def case() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def currentInput() -> scala.util.DynamicVariable[java.lang.String]: ...
    @staticmethod
    def extends() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def extractBlockStats(stats: scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]]) -> scala.Tuple2[scala.collection.Seq['Terms.Val'], sigmastate.Values.Value[sigmastate.SType]]: ...
    @staticmethod
    def implicit() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def lazy() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def logged() -> scala.collection.mutable.Buffer[java.lang.String]: ...
    @staticmethod
    def logger() -> fastparse.core.Logger: ...
    @staticmethod
    def match() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def mkBinaryOp(l: sigmastate.Values.Value[sigmastate.SType], opName: typing.Union[java.lang.String, str], r: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    @staticmethod
    def mkUnaryOp(opName: typing.Union[java.lang.String, str], arg: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    @staticmethod
    def new() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def parseAsMethods() -> scala.collection.immutable.Set[java.lang.String]: ...
    @staticmethod
    def parseType(str: typing.Union[java.lang.String, str]) -> sigmastate.SType: ...
    @staticmethod
    def parsedType(str: typing.Union[java.lang.String, str]) -> fastparse.core.Parsed[sigmastate.SType, typing.Any, java.lang.String]: ...
    @typing.overload
    @staticmethod
    def precedenceOf(ch: str) -> int: ...
    @typing.overload
    @staticmethod
    def precedenceOf(op: typing.Union[java.lang.String, str]) -> int: ...
    @staticmethod
    def predefTypes() -> scala.collection.immutable.Map[java.lang.String, sigmastate.SType]: ...
    @staticmethod
    def priorityList() -> scala.collection.Seq[scala.collection.Seq[typing.Any]]: ...
    @staticmethod
    def priorityMap() -> scala.collection.immutable.Map[typing.Any, typing.Any]: ...
    @staticmethod
    def srcCtx(parserIndex: int) -> 'SourceContext': ...
    @staticmethod
    def super() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def then() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def this() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def type() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    @staticmethod
    def typeFromName(tn: typing.Union[java.lang.String, str]) -> scala.Option[sigmastate.SType]: ...
    @staticmethod
    def val() -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...

class SigmaPredef:
    class PredefFuncInfo(scala.Product, scala.Serializable):
        def __init__(self, irBuilder: scala.PartialFunction[scala.Tuple2[sigmastate.Values.Value[sigmastate.SType], scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]]], sigmastate.Values.Value[sigmastate.SType]]): ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        def copy(self, irBuilder: scala.PartialFunction[scala.Tuple2[sigmastate.Values.Value[sigmastate.SType], scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]]], sigmastate.Values.Value[sigmastate.SType]]) -> 'SigmaPredef.PredefFuncInfo': ...
        def copy$default$1(self) -> scala.PartialFunction[scala.Tuple2[sigmastate.Values.Value[sigmastate.SType], scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]]], sigmastate.Values.Value[sigmastate.SType]]: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def irBuilder(self) -> scala.PartialFunction[scala.Tuple2[sigmastate.Values.Value[sigmastate.SType], scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]]], sigmastate.Values.Value[sigmastate.SType]]: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
    class PredefFuncInfo$(scala.runtime.AbstractFunction1[scala.PartialFunction[scala.Tuple2[sigmastate.Values.Value[sigmastate.SType], scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]]], sigmastate.Values.Value[sigmastate.SType]], 'SigmaPredef.PredefFuncInfo'], scala.Serializable):
        MODULE$: typing.ClassVar['SigmaPredef.PredefFuncInfo.'] = ...
        def __init__(self): ...
        def apply(self, irBuilder: scala.PartialFunction[scala.Tuple2[sigmastate.Values.Value[sigmastate.SType], scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]]], sigmastate.Values.Value[sigmastate.SType]]) -> 'SigmaPredef.PredefFuncInfo': ...
        def toString(self) -> java.lang.String: ...
        def unapply(self, x$0: 'SigmaPredef.PredefFuncInfo') -> scala.Option[scala.PartialFunction[scala.Tuple2[sigmastate.Values.Value[sigmastate.SType], scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]]], sigmastate.Values.Value[sigmastate.SType]]]: ...
    class PredefinedFunc(scala.Product, scala.Serializable):
        def __init__(self, name: typing.Union[java.lang.String, str], declaration: 'Terms.Lambda', irInfo: 'SigmaPredef.PredefFuncInfo', docInfo: sigmastate.OperationInfo): ...
        def argInfo(self, argName: typing.Union[java.lang.String, str]) -> sigmastate.ArgInfo: ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        def copy(self, name: typing.Union[java.lang.String, str], declaration: 'Terms.Lambda', irInfo: 'SigmaPredef.PredefFuncInfo', docInfo: sigmastate.OperationInfo) -> 'SigmaPredef.PredefinedFunc': ...
        def copy$default$1(self) -> java.lang.String: ...
        def copy$default$2(self) -> 'Terms.Lambda': ...
        def copy$default$3(self) -> 'SigmaPredef.PredefFuncInfo': ...
        def copy$default$4(self) -> sigmastate.OperationInfo: ...
        def declaration(self) -> 'Terms.Lambda': ...
        def docInfo(self) -> sigmastate.OperationInfo: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def irInfo(self) -> 'SigmaPredef.PredefFuncInfo': ...
        def name(self) -> java.lang.String: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def sym(self) -> 'Terms.Ident': ...
        def symNoType(self) -> 'Terms.Ident': ...
        def toString(self) -> java.lang.String: ...
    class PredefinedFunc$(scala.runtime.AbstractFunction4[java.lang.String, 'Terms.Lambda', 'SigmaPredef.PredefFuncInfo', sigmastate.OperationInfo, 'SigmaPredef.PredefinedFunc'], scala.Serializable):
        MODULE$: typing.ClassVar['SigmaPredef.PredefinedFunc.'] = ...
        def __init__(self): ...
        def apply(self, name: typing.Union[java.lang.String, str], declaration: 'Terms.Lambda', irInfo: 'SigmaPredef.PredefFuncInfo', docInfo: sigmastate.OperationInfo) -> 'SigmaPredef.PredefinedFunc': ...
        def toString(self) -> java.lang.String: ...
        def unapply(self, x$0: 'SigmaPredef.PredefinedFunc') -> scala.Option[scala.Tuple4[java.lang.String, 'Terms.Lambda', 'SigmaPredef.PredefFuncInfo', sigmastate.OperationInfo]]: ...
    class PredefinedFuncApply$:
        MODULE$: typing.ClassVar['SigmaPredef.PredefinedFuncApply.'] = ...
        def __init__(self): ...
        def unapply(self, apply: 'Terms.Apply', registry: 'SigmaPredef.PredefinedFuncRegistry') -> sigmastate.Values.Value[sigmastate.SType]: ...
    class PredefinedFuncRegistry:
        sigmastate$lang$SigmaPredef$PredefinedFuncRegistry$$builder: SigmaBuilder = ...
        def __init__(self, builder: SigmaBuilder): ...
        def AllOfFunc(self) -> 'SigmaPredef.PredefinedFunc': ...
        def AllZKFunc(self) -> 'SigmaPredef.PredefinedFunc': ...
        def AnyOfFunc(self) -> 'SigmaPredef.PredefinedFunc': ...
        def AnyZKFunc(self) -> 'SigmaPredef.PredefinedFunc': ...
        def AtLeastFunc(self) -> 'SigmaPredef.PredefinedFunc': ...
        def AvlTreeFunc(self) -> 'SigmaPredef.PredefinedFunc': ...
        def Blake2b256Func(self) -> 'SigmaPredef.PredefinedFunc': ...
        def ByteArrayToBigIntFunc(self) -> 'SigmaPredef.PredefinedFunc': ...
        def ByteArrayToLongFunc(self) -> 'SigmaPredef.PredefinedFunc': ...
        def DecodePointFunc(self) -> 'SigmaPredef.PredefinedFunc': ...
        def DeserializeFunc(self) -> 'SigmaPredef.PredefinedFunc': ...
        def ExecuteFromSelfRegFunc(self) -> 'SigmaPredef.PredefinedFunc': ...
        def ExecuteFromVarFunc(self) -> 'SigmaPredef.PredefinedFunc': ...
        def FromBase58Func(self) -> 'SigmaPredef.PredefinedFunc': ...
        def FromBase64Func(self) -> 'SigmaPredef.PredefinedFunc': ...
        def GetVarFunc(self) -> 'SigmaPredef.PredefinedFunc': ...
        def LongToByteArrayFunc(self) -> 'SigmaPredef.PredefinedFunc': ...
        def OuterJoinFunc(self) -> 'SigmaPredef.PredefinedFunc': ...
        def PKFunc(self, networkPrefix: int) -> 'SigmaPredef.PredefinedFunc': ...
        def ProveDHTupleFunc(self) -> 'SigmaPredef.PredefinedFunc': ...
        def ProveDlogFunc(self) -> 'SigmaPredef.PredefinedFunc': ...
        def Sha256Func(self) -> 'SigmaPredef.PredefinedFunc': ...
        def SigmaPropFunc(self) -> 'SigmaPredef.PredefinedFunc': ...
        def SubstConstantsFunc(self) -> 'SigmaPredef.PredefinedFunc': ...
        def XorOfFunc(self) -> 'SigmaPredef.PredefinedFunc': ...
        def ZKProofFunc(self) -> 'SigmaPredef.PredefinedFunc': ...
        def binaryOp(self, symbolName: typing.Union[java.lang.String, str], opDesc: sigmastate.Values.ValueCompanion, desc: typing.Union[java.lang.String, str], args: scala.collection.Seq[sigmastate.ArgInfo]) -> 'SigmaPredef.PredefinedFunc': ...
        def comparisonOp(self, symbolName: typing.Union[java.lang.String, str], opDesc: sigmastate.Values.ValueCompanion, desc: typing.Union[java.lang.String, str], args: scala.collection.Seq[sigmastate.ArgInfo]) -> 'SigmaPredef.PredefinedFunc': ...
        def funcs(self) -> scala.collection.immutable.Map[java.lang.String, 'SigmaPredef.PredefinedFunc']: ...
        def globalFuncs(self) -> scala.collection.immutable.Map[java.lang.String, 'SigmaPredef.PredefinedFunc']: ...
        def infixFuncs(self) -> scala.collection.immutable.Map[java.lang.String, 'SigmaPredef.PredefinedFunc']: ...
        def irBuilderForFunc(self, name: typing.Union[java.lang.String, str]) -> scala.Option[scala.PartialFunction[scala.Tuple2[sigmastate.Values.Value[sigmastate.SType], scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]]], sigmastate.Values.Value[sigmastate.SType]]]: ...
        def logicalOp(self, symbolName: typing.Union[java.lang.String, str], opDesc: sigmastate.Values.ValueCompanion, desc: typing.Union[java.lang.String, str], args: scala.collection.Seq[sigmastate.ArgInfo]) -> 'SigmaPredef.PredefinedFunc': ...
        def specialFuncs(self) -> scala.collection.immutable.Map[java.lang.String, 'SigmaPredef.PredefinedFunc']: ...
        def unaryFuncs(self) -> scala.collection.immutable.Map[java.lang.String, 'SigmaPredef.PredefinedFunc']: ...

class SigmaPrinter(org.bitbucket.inkytonik.kiama.output.PrettyPrinter):
    def __init__(self): ...
    def Finish(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Finish.: ...
    def Start(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Start.: ...
    def Text(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Text.: ...
    def align(self, d: org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def ampersand(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def angles(self, d: org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def any(self, a: typing.Any) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    _arguments__T = typing.TypeVar('_arguments__T')  # <T>
    def arguments(self, l: scala.collection.immutable.Seq[_arguments__T], elemToDoc: scala.Function1[_arguments__T, org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps], sep: org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps, sepfn: scala.Function2[scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps], org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps, org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps]) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    _arguments$default$2__T = typing.TypeVar('_arguments$default$2__T')  # <T>
    def arguments$default$2(self) -> scala.Function1[_arguments.default.2__T, org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps]: ...
    _arguments$default$3__T = typing.TypeVar('_arguments$default$3__T')  # <T>
    def arguments$default$3(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    _arguments$default$4__T = typing.TypeVar('_arguments$default$4__T')  # <T>
    def arguments$default$4(self) -> scala.Function2[scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps], org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps, org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps]: ...
    def asterisk(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def atsign(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def backquote(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def backslash(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def binToDoc(self, l: sigmastate.Values.Value[sigmastate.SType], op: typing.Union[java.lang.String, str], r: sigmastate.Values.Value[sigmastate.SType]) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Doc: ...
    def braces(self, d: org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def brackets(self, d: org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def caret(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def cat(self, ds: scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps]) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def char(self, c: str) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def colon(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def column(self, f: scala.Function1[typing.Any, org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Doc]) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Doc: ...
    def comma(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def defaultIndent(self) -> int: ...
    def defaultWidth(self) -> int: ...
    def dollar(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def dot(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def dquote(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def dquotes(self, d: org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def emptyDoc(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Doc: ...
    def enclose(self, l: org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps, d: org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps, r: org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def equal(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def exclamation(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def fillcat(self, ds: scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps]) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    @typing.overload
    def fillsep(self, ds: scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps]) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    @typing.overload
    def fillsep(self, ds: scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps], sep: org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def folddoc(self, ds: scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps], f: scala.Function2[org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps, org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps, org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps]) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    @typing.overload
    def format(self, t: sigmastate.SType) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterTypes.Document: ...
    @typing.overload
    def format(self, t: sigmastate.Values.Value[sigmastate.SType]) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterTypes.Document: ...
    @typing.overload
    def formattedLayout(self, t: sigmastate.SType) -> java.lang.String: ...
    @typing.overload
    def formattedLayout(self, t: sigmastate.Values.Value[sigmastate.SType]) -> java.lang.String: ...
    def forwslash(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def group(self, d: org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Doc) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Doc: ...
    def hang(self, d: org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps, i: int) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def hang$default$2(self) -> int: ...
    def hash(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def hcat(self, ds: scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps]) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    @typing.overload
    def hsep(self, ds: scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps]) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    @typing.overload
    def hsep(self, ds: scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps], sep: org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def indent(self, d: org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps, i: int) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def indent$default$2(self) -> int: ...
    def insert(self, len: int, entry: org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Entry) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Doc: ...
    def langle(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def layout(self, d: org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps, w: int) -> java.lang.String: ...
    def layout$default$2(self) -> int: ...
    def lbrace(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def lbracket(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def leave(self, c: scala.Function2[typing.Any, scala.collection.immutable.Queue[scala.Tuple2[typing.Any, scala.Function1[typing.Any, scala.Function1[scala.Function1[typing.Any, org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Entry]]], org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.Function1[typing.Any, org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Entry]]]]]]]], org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.Function1[typing.Any, org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Entry]]]]]) -> scala.Function2[typing.Any, scala.collection.immutable.Queue[scala.Tuple2[typing.Any, scala.Function1[typing.Any, scala.Function1[scala.Function1[typing.Any, org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Entry]]], org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.Function1[typing.Any, org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Entry]]]]]]]], org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.Function1[typing.Any, org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Entry]]]]]: ...
    @typing.overload
    def line(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Doc: ...
    @typing.overload
    def line(self, repl: typing.Union[java.lang.String, str]) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Doc: ...
    def linebreak(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Doc: ...
    def link(self, n: typing.Any, d: org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Doc) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Doc: ...
    def links(self, d: org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps, w: int) -> scala.collection.immutable.List[org.bitbucket.inkytonik.kiama.output.PrettyPrinterTypes.Link]: ...
    def links$default$2(self) -> int: ...
    _list__T = typing.TypeVar('_list__T')  # <T>
    def list(self, l: scala.collection.immutable.List[_list__T], prefix: typing.Union[java.lang.String, str], elemToDoc: scala.Function1[_list__T, org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps], sep: org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps, sepfn: scala.Function2[scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps], org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps, org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps]) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    _list$default$2__T = typing.TypeVar('_list$default$2__T')  # <T>
    def list$default$2(self) -> java.lang.String: ...
    _list$default$3__T = typing.TypeVar('_list$default$3__T')  # <T>
    def list$default$3(self) -> scala.Function1[_list.default.3__T, org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps]: ...
    _list$default$4__T = typing.TypeVar('_list$default$4__T')  # <T>
    def list$default$4(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    _list$default$5__T = typing.TypeVar('_list$default$5__T')  # <T>
    def list$default$5(self) -> scala.Function2[scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps], org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps, org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps]: ...
    def lparen(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def lsep(self, ds: scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps], sep: org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def lsep2(self, ds: scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps], sep: org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def lterm(self, ds: scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps], term: org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def minus(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def nest(self, d: org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Doc, j: int) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Doc: ...
    def nest$default$2(self) -> int: ...
    def nesting(self, f: scala.Function1[typing.Any, org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Doc]) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Doc: ...
    def org$bitbucket$inkytonik$kiama$output$PrettyPrinterBase$_setter_$defaultIndent_$eq(self, x$1: int) -> None: ...
    def org$bitbucket$inkytonik$kiama$output$PrettyPrinterBase$_setter_$defaultWidth_$eq(self, x$1: int) -> None: ...
    def output(self, o: scala.Function1[typing.Any, org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Entry]]], r: int, entry: org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Entry) -> org.bitbucket.inkytonik.kiama.util.Trampolines.More[scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Entry]]: ...
    def padto(self, p: int, d: org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def padtobreak(self, p: int, d: org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def parens(self, d: org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def percent(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def plus(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def pretty(self, d: org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Doc, w: int) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterTypes.Document: ...
    def pretty$default$2(self) -> int: ...
    def prune(self, c1: scala.Function2[typing.Any, scala.collection.immutable.Queue[scala.Tuple2[typing.Any, scala.Function1[typing.Any, scala.Function1[scala.Function1[typing.Any, org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Entry]]], org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.Function1[typing.Any, org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Entry]]]]]]]], org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.Function1[typing.Any, org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Entry]]]]]) -> scala.Function2[typing.Any, scala.collection.immutable.Queue[scala.Tuple2[typing.Any, scala.Function1[typing.Any, scala.Function1[scala.Function1[typing.Any, org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Entry]]], org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.Function1[typing.Any, org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Entry]]]]]]]], org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.Function1[typing.Any, org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Entry]]]]]: ...
    def question(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def rangle(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def rbrace(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def rbracket(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def rparen(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def scan(self, l: int, out: scala.Function1[typing.Any, scala.Function1[scala.Function1[typing.Any, org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Entry]]], org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.Function1[typing.Any, org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Entry]]]]]], c: scala.Function2[typing.Any, scala.collection.immutable.Queue[scala.Tuple2[typing.Any, scala.Function1[typing.Any, scala.Function1[scala.Function1[typing.Any, org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Entry]]], org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.Function1[typing.Any, org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Entry]]]]]]]], org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.Function1[typing.Any, org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Entry]]]]]) -> org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.Function2[typing.Any, scala.collection.immutable.Queue[scala.Tuple2[typing.Any, scala.Function1[typing.Any, scala.Function1[scala.Function1[typing.Any, org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Entry]]], org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.Function1[typing.Any, org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Entry]]]]]]]], org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.Function1[typing.Any, org.bitbucket.inkytonik.kiama.util.Trampolines.Trampoline[scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Entry]]]]]]: ...
    def semi(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def sep(self, ds: scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps]) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    _seq__T = typing.TypeVar('_seq__T')  # <T>
    def seq(self, l: scala.collection.immutable.Seq[_seq__T], prefix: typing.Union[java.lang.String, str], elemToDoc: scala.Function1[_seq__T, org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps], sep: org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps, sepfn: scala.Function2[scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps], org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps, org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps]) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    _seq$default$2__T = typing.TypeVar('_seq$default$2__T')  # <T>
    def seq$default$2(self) -> java.lang.String: ...
    _seq$default$3__T = typing.TypeVar('_seq$default$3__T')  # <T>
    def seq$default$3(self) -> scala.Function1[_seq.default.3__T, org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps]: ...
    _seq$default$4__T = typing.TypeVar('_seq$default$4__T')  # <T>
    def seq$default$4(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    _seq$default$5__T = typing.TypeVar('_seq$default$5__T')  # <T>
    def seq$default$5(self) -> scala.Function2[scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps], org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps, org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps]: ...
    def softbreak(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def softline(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def space(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def spaces(self, n: int) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def squote(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def squotes(self, d: org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def ssep(self, ds: scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps], sep: org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def sterm(self, ds: scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps], term: org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def string(self, s: typing.Union[java.lang.String, str]) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def surround(self, d: org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps, b: org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def text(self, t: typing.Union[java.lang.String, str]) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Doc: ...
    def tilde(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def toDoc(self, t: sigmastate.Values.Value[sigmastate.SType]) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Doc: ...
    def typeToDoc(self, t: sigmastate.SType) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Doc: ...
    def typedeclToDoc(self, t: sigmastate.SType) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinter.Doc: ...
    def underscore(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def value(self, v: typing.Any) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def vcat(self, ds: scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps]) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def verticalbar(self) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    @typing.overload
    def vsep(self, ds: scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps]) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    @typing.overload
    def vsep(self, ds: scala.collection.immutable.Seq[org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps], sep: org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...
    def width(self, d: org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps, f: scala.Function1[typing.Any, org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps]) -> org.bitbucket.inkytonik.kiama.output.PrettyPrinterBase.DocOps: ...

class SigmaSpecializer:
    def __init__(self, builder: SigmaBuilder): ...
    def builder(self) -> SigmaBuilder: ...
    @typing.overload
    @staticmethod
    def error(msg: typing.Union[java.lang.String, str]) -> scala.runtime.Nothing.: ...
    @typing.overload
    @staticmethod
    def error(msg: typing.Union[java.lang.String, str], srcCtx: 'SourceContext') -> scala.runtime.Nothing.: ...
    def mkTagged(self, name: typing.Union[java.lang.String, str], tpe: sigmastate.SType, tag: int) -> sigmastate.Values.TaggedVariable[sigmastate.SType]: ...
    def sigmastate$lang$SigmaSpecializer$$eval(self, env: scala.collection.immutable.Map[typing.Union[java.lang.String, str], sigmastate.Values.Value[sigmastate.SType]], e: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def sigmastate$lang$SigmaSpecializer$$predefFuncRegistry(self) -> SigmaPredef.PredefinedFuncRegistry: ...
    @typing.overload
    def specialize(self, env: scala.collection.immutable.Map[typing.Union[java.lang.String, str], sigmastate.Values.Value[sigmastate.SType]], typed: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    @typing.overload
    def specialize(self, typed: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SType]: ...

class SigmaTyper:
    def __init__(self, builder: SigmaBuilder, predefFuncRegistry: SigmaPredef.PredefinedFuncRegistry, lowerMethodCalls: bool): ...
    @staticmethod
    def EmptySubst() -> scala.collection.immutable.Map[sigmastate.STypeVar, sigmastate.SType]: ...
    def adaptSigmaPropToBoolean(self, items: scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]], expectedTypes: scala.collection.Seq[sigmastate.SType]) -> scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]]: ...
    @staticmethod
    def applySubst(tpe: sigmastate.SType, subst: scala.collection.immutable.Map[sigmastate.STypeVar, sigmastate.SType]) -> sigmastate.SType: ...
    def assignConcreteCollection(self, cc: sigmastate.Values.ConcreteCollection[sigmastate.SType], newItems: scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]]: ...
    def assignType(self, env: scala.collection.immutable.Map[typing.Union[java.lang.String, str], sigmastate.SType], bound: sigmastate.Values.Value[sigmastate.SType], expected: scala.Option[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def assignType$default$3(self) -> scala.Option[sigmastate.SType]: ...
    _bimap__T = typing.TypeVar('_bimap__T', bound=sigmastate.SType)  # <T>
    def bimap(self, env: scala.collection.immutable.Map[typing.Union[java.lang.String, str], sigmastate.SType], op: typing.Union[java.lang.String, str], l: sigmastate.Values.Value[_bimap__T], r: sigmastate.Values.Value[_bimap__T], mkNode: scala.Function2[sigmastate.Values.Value[_bimap__T], sigmastate.Values.Value[_bimap__T], sigmastate.Values.Value[sigmastate.SType]], tArg: sigmastate.SType, tRes: sigmastate.SType) -> sigmastate.Values.Value[sigmastate.SType]: ...
    _bimap2__T = typing.TypeVar('_bimap2__T', bound=sigmastate.SType)  # <T>
    def bimap2(self, env: scala.collection.immutable.Map[typing.Union[java.lang.String, str], sigmastate.SType], op: typing.Union[java.lang.String, str], l: sigmastate.Values.Value[_bimap2__T], r: sigmastate.Values.Value[_bimap2__T], newNode: scala.Function2[sigmastate.Values.Value[_bimap2__T], sigmastate.Values.Value[_bimap2__T], sigmastate.Values.Value[sigmastate.SType]]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def builder(self) -> SigmaBuilder: ...
    @staticmethod
    def error(msg: typing.Union[java.lang.String, str], srcCtx: 'SourceContext') -> scala.runtime.Nothing.: ...
    @staticmethod
    def msgType(t1: sigmastate.SType, t2: sigmastate.SType) -> scala.Option[sigmastate.SType]: ...
    @staticmethod
    def msgTypeOf(ts: scala.collection.Seq[sigmastate.SType]) -> scala.Option[sigmastate.SType]: ...
    def typecheck(self, bound: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    @staticmethod
    def unifyTypeLists(items1: scala.collection.Seq[sigmastate.SType], items2: scala.collection.Seq[sigmastate.SType]) -> scala.Option[scala.collection.immutable.Map[sigmastate.STypeVar, sigmastate.SType]]: ...
    @staticmethod
    def unifyTypes(t1: sigmastate.SType, t2: sigmastate.SType) -> scala.Option[scala.collection.immutable.Map[sigmastate.STypeVar, sigmastate.SType]]: ...
    _unmap__T = typing.TypeVar('_unmap__T', bound=sigmastate.SType)  # <T>
    def unmap(self, env: scala.collection.immutable.Map[typing.Union[java.lang.String, str], sigmastate.SType], op: typing.Union[java.lang.String, str], i: sigmastate.Values.Value[_unmap__T], newNode: scala.Function1[sigmastate.Values.Value[_unmap__T], sigmastate.Values.Value[sigmastate.SType]], tArg: sigmastate.SType) -> sigmastate.Values.Value[sigmastate.SType]: ...

class SourceContext(scala.Product, scala.Serializable):
    def __init__(self, line: int, column: int, sourceLine: typing.Union[java.lang.String, str]): ...
    @staticmethod
    def apply(line: int, column: int, sourceLine: typing.Union[java.lang.String, str]) -> 'SourceContext': ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def column(self) -> int: ...
    def copy(self, line: int, column: int, sourceLine: typing.Union[java.lang.String, str]) -> 'SourceContext': ...
    def copy$default$1(self) -> int: ...
    def copy$default$2(self) -> int: ...
    def copy$default$3(self) -> java.lang.String: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    @staticmethod
    def fromParserFailure(e: fastparse.core.Parsed.Failure[typing.Any, typing.Union[java.lang.String, str]]) -> 'SourceContext': ...
    @staticmethod
    def fromParserIndex(index: int, input: typing.Union[java.lang.String, str]) -> 'SourceContext': ...
    def hashCode(self) -> int: ...
    def line(self) -> int: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def sourceLine(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def unapply(x$0: 'SourceContext') -> scala.Option[scala.Tuple3[typing.Any, typing.Any, java.lang.String]]: ...

class SrcCtxCallbackRewriter:
    @staticmethod
    def Duplicator() -> org.bitbucket.inkytonik.kiama.rewriting.RewriterCore.Duplicator.: ...
    @staticmethod
    def Term() -> org.bitbucket.inkytonik.kiama.rewriting.RewriterCore.Term.: ...
    @staticmethod
    def all(name: typing.Union[java.lang.String, str], s: scala.Function0[org.bitbucket.inkytonik.kiama.rewriting.Strategy]) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    _allMap__CC = typing.TypeVar('_allMap__CC', bound=scala.collection.immutable.Map)  # <CC>
    @staticmethod
    def allMap(s: org.bitbucket.inkytonik.kiama.rewriting.Strategy, t: _allMap__CC, cbf: scala.collection.generic.CanBuildFrom[_allMap__CC, scala.Tuple2[typing.Any, typing.Any], _allMap__CC]) -> scala.Option[_allMap__CC]: ...
    @staticmethod
    def allProduct(s: org.bitbucket.inkytonik.kiama.rewriting.Strategy, p: scala.Product) -> scala.Option[typing.Any]: ...
    @staticmethod
    def allRewritable(s: org.bitbucket.inkytonik.kiama.rewriting.Strategy, r: org.bitbucket.inkytonik.kiama.rewriting.Rewritable) -> scala.Option[typing.Any]: ...
    _allTraversable__CC = typing.TypeVar('_allTraversable__CC', bound=scala.collection.Traversable)  # <CC>
    @staticmethod
    def allTraversable(s: org.bitbucket.inkytonik.kiama.rewriting.Strategy, t: _allTraversable__CC, cbf: scala.collection.generic.CanBuildFrom[_allTraversable__CC, typing.Any, _allTraversable__CC]) -> scala.Option[_allTraversable__CC]: ...
    @staticmethod
    def allbu(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def alldownup2(name: typing.Union[java.lang.String, str], s1: org.bitbucket.inkytonik.kiama.rewriting.Strategy, s2: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def alltd(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def alltdfold(name: typing.Union[java.lang.String, str], s1: org.bitbucket.inkytonik.kiama.rewriting.Strategy, s2: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def attempt(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def bottomup(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def bottomupS(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy, stop: scala.Function1[scala.Function0[org.bitbucket.inkytonik.kiama.rewriting.Strategy], org.bitbucket.inkytonik.kiama.rewriting.Strategy]) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def breadthfirst(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def build(name: typing.Union[java.lang.String, str], t: scala.Function0[typing.Any]) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def child(name: typing.Union[java.lang.String, str], i: int, s: scala.Function0[org.bitbucket.inkytonik.kiama.rewriting.Strategy]) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def childProduct(s: org.bitbucket.inkytonik.kiama.rewriting.Strategy, i: int, p: scala.Product) -> scala.Option[typing.Any]: ...
    _childSeq__CC = typing.TypeVar('_childSeq__CC', bound=scala.collection.immutable.Seq)  # <CC>
    @staticmethod
    def childSeq(s: org.bitbucket.inkytonik.kiama.rewriting.Strategy, i: int, t: _childSeq__CC, cbf: scala.collection.generic.CanBuildFrom[_childSeq__CC, typing.Any, _childSeq__CC]) -> scala.Option[_childSeq__CC]: ...
    _collectWithName__CC = typing.TypeVar('_collectWithName__CC', bound=scala.collection.Traversable)  # <CC>
    _collectWithName__U = typing.TypeVar('_collectWithName__U')  # <U>
    @staticmethod
    def collectWithName(name: typing.Union[java.lang.String, str], f: scala.PartialFunction[typing.Any, _collectWithName__U], cbf: scala.collection.generic.CanBuildFrom[_collectWithName__CC, _collectWithName__U, _collectWithName__CC]) -> scala.Function1[typing.Any, _collectWithName__CC]: ...
    _collectallWithName__CC = typing.TypeVar('_collectallWithName__CC', bound=scala.collection.Traversable)  # <CC>
    _collectallWithName__U = typing.TypeVar('_collectallWithName__U')  # <U>
    @staticmethod
    def collectallWithName(name: typing.Union[java.lang.String, str], f: scala.PartialFunction[typing.Any, _collectallWithName__CC], cbf: scala.collection.generic.CanBuildFrom[_collectallWithName__CC, _collectallWithName__U, _collectallWithName__CC]) -> scala.Function1[typing.Any, _collectallWithName__CC]: ...
    _collectl__U = typing.TypeVar('_collectl__U')  # <U>
    @staticmethod
    def collectl(f: scala.PartialFunction[typing.Any, _collectl__U]) -> scala.Function1[typing.Any, scala.collection.immutable.List[_collectl__U]]: ...
    _collects__U = typing.TypeVar('_collects__U')  # <U>
    @staticmethod
    def collects(f: scala.PartialFunction[typing.Any, _collects__U]) -> scala.Function1[typing.Any, scala.collection.immutable.Set[_collects__U]]: ...
    @staticmethod
    def congruence(name: typing.Union[java.lang.String, str], ss: scala.collection.Seq[org.bitbucket.inkytonik.kiama.rewriting.Strategy]) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def congruenceProduct(p: scala.Product, ss: scala.collection.Seq[org.bitbucket.inkytonik.kiama.rewriting.Strategy]) -> scala.Option[typing.Any]: ...
    _copy__T = typing.TypeVar('_copy__T', bound=scala.Product)  # <T>
    @staticmethod
    def copy(t: _copy__T) -> _copy__T: ...
    @staticmethod
    def count(name: typing.Union[java.lang.String, str], f: scala.PartialFunction[typing.Any, typing.Any]) -> scala.Function1[typing.Any, typing.Any]: ...
    @staticmethod
    def debug(name: typing.Union[java.lang.String, str], msg: typing.Union[java.lang.String, str], emitter: org.bitbucket.inkytonik.kiama.util.Emitter) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def debug$default$2() -> org.bitbucket.inkytonik.kiama.util.Emitter: ...
    @staticmethod
    def dispatch(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def doloop(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy, r: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def dontstop(s: scala.Function0[org.bitbucket.inkytonik.kiama.rewriting.Strategy]) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @typing.overload
    @staticmethod
    def downup(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @typing.overload
    @staticmethod
    def downup(name: typing.Union[java.lang.String, str], s1: org.bitbucket.inkytonik.kiama.rewriting.Strategy, s2: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @typing.overload
    @staticmethod
    def downupS(name: typing.Union[java.lang.String, str], s1: org.bitbucket.inkytonik.kiama.rewriting.Strategy, s2: org.bitbucket.inkytonik.kiama.rewriting.Strategy, stop: scala.Function1[scala.Function0[org.bitbucket.inkytonik.kiama.rewriting.Strategy], org.bitbucket.inkytonik.kiama.rewriting.Strategy]) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @typing.overload
    @staticmethod
    def downupS(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy, stop: scala.Function1[scala.Function0[org.bitbucket.inkytonik.kiama.rewriting.Strategy], org.bitbucket.inkytonik.kiama.rewriting.Strategy]) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    _dup__T = typing.TypeVar('_dup__T', bound=scala.Product)  # <T>
    @staticmethod
    def dup(t: _dup__T, children: typing.List[typing.Any]) -> _dup__T: ...
    @staticmethod
    def eq() -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def equal() -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    _everything__T = typing.TypeVar('_everything__T')  # <T>
    @staticmethod
    def everything(name: typing.Union[java.lang.String, str], v: _everything__T, f: scala.Function2[_everything__T, _everything__T, _everything__T], g: scala.PartialFunction[typing.Any, _everything__T], t: typing.Any) -> _everything__T: ...
    @staticmethod
    def everywhere(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def everywherebu(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def everywheretd(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def fail() -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def id() -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def innermost(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def innermost2(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def ior(name: typing.Union[java.lang.String, str], s1: org.bitbucket.inkytonik.kiama.rewriting.Strategy, s2: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def isinnernode() -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def isleaf() -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def ispropersubterm() -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def ispropersuperterm() -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def issubterm() -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def issuperterm() -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def lastly(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy, f: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @typing.overload
    @staticmethod
    def leaves(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy, isleaf: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @typing.overload
    @staticmethod
    def leaves(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy, isleaf: org.bitbucket.inkytonik.kiama.rewriting.Strategy, skip: scala.Function1[org.bitbucket.inkytonik.kiama.rewriting.Strategy, org.bitbucket.inkytonik.kiama.rewriting.Strategy]) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def log(name: typing.Union[java.lang.String, str], s: scala.Function0[org.bitbucket.inkytonik.kiama.rewriting.Strategy], msg: typing.Union[java.lang.String, str], emitter: org.bitbucket.inkytonik.kiama.util.Emitter) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def log$default$3() -> org.bitbucket.inkytonik.kiama.util.Emitter: ...
    _logfail__T = typing.TypeVar('_logfail__T')  # <T>
    @staticmethod
    def logfail(name: typing.Union[java.lang.String, str], s: scala.Function0[org.bitbucket.inkytonik.kiama.rewriting.Strategy], msg: typing.Union[java.lang.String, str], emitter: org.bitbucket.inkytonik.kiama.util.Emitter) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    _logfail$default$3__T = typing.TypeVar('_logfail$default$3__T')  # <T>
    @staticmethod
    def logfail$default$3() -> org.bitbucket.inkytonik.kiama.util.Emitter: ...
    @staticmethod
    def loop(name: typing.Union[java.lang.String, str], c: org.bitbucket.inkytonik.kiama.rewriting.Strategy, s: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @typing.overload
    @staticmethod
    def loopiter(name: typing.Union[java.lang.String, str], i: org.bitbucket.inkytonik.kiama.rewriting.Strategy, r: org.bitbucket.inkytonik.kiama.rewriting.Strategy, s: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @typing.overload
    @staticmethod
    def loopiter(name: typing.Union[java.lang.String, str], s: scala.Function1[typing.Any, org.bitbucket.inkytonik.kiama.rewriting.Strategy], low: int, high: int) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def loopnot(name: typing.Union[java.lang.String, str], r: org.bitbucket.inkytonik.kiama.rewriting.Strategy, s: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def manybu(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def manytd(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def map(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def memo(name: typing.Union[java.lang.String, str], s: scala.Function0[org.bitbucket.inkytonik.kiama.rewriting.Strategy]) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def mkStrategy(name: typing.Union[java.lang.String, str], f: scala.Function1[typing.Any, scala.Option[typing.Any]]) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def oncebu(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def oncetd(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def one(name: typing.Union[java.lang.String, str], s: scala.Function0[org.bitbucket.inkytonik.kiama.rewriting.Strategy]) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    _oneMap__CC = typing.TypeVar('_oneMap__CC', bound=scala.collection.immutable.Map)  # <CC>
    @staticmethod
    def oneMap(s: org.bitbucket.inkytonik.kiama.rewriting.Strategy, t: _oneMap__CC, cbf: scala.collection.generic.CanBuildFrom[_oneMap__CC, scala.Tuple2[typing.Any, typing.Any], _oneMap__CC]) -> scala.Option[_oneMap__CC]: ...
    @staticmethod
    def oneProduct(s: org.bitbucket.inkytonik.kiama.rewriting.Strategy, p: scala.Product) -> scala.Option[typing.Any]: ...
    @staticmethod
    def oneRewritable(s: org.bitbucket.inkytonik.kiama.rewriting.Strategy, r: org.bitbucket.inkytonik.kiama.rewriting.Rewritable) -> scala.Option[typing.Any]: ...
    _oneTraversable__CC = typing.TypeVar('_oneTraversable__CC', bound=scala.collection.Traversable)  # <CC>
    @staticmethod
    def oneTraversable(s: org.bitbucket.inkytonik.kiama.rewriting.Strategy, t: _oneTraversable__CC, cbf: scala.collection.generic.CanBuildFrom[_oneTraversable__CC, typing.Any, _oneTraversable__CC]) -> scala.Option[_oneTraversable__CC]: ...
    @staticmethod
    def option(name: typing.Union[java.lang.String, str], o: scala.Function0[scala.Option[typing.Any]]) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def outermost(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    _para__T = typing.TypeVar('_para__T')  # <T>
    @staticmethod
    def para(f: scala.Function2[typing.Any, scala.collection.immutable.Seq[_para__T], _para__T]) -> scala.Function1[typing.Any, _para__T]: ...
    _queryWithName__T = typing.TypeVar('_queryWithName__T')  # <T>
    @staticmethod
    def queryWithName(name: typing.Union[java.lang.String, str], f: scala.PartialFunction[_queryWithName__T, scala.runtime.BoxedUnit]) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def queryf(name: typing.Union[java.lang.String, str], f: scala.Function1[typing.Any, scala.runtime.BoxedUnit]) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def reduce(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @typing.overload
    @staticmethod
    def repeat(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @typing.overload
    @staticmethod
    def repeat(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy, n: int) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @typing.overload
    @staticmethod
    def repeat(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy, r: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @typing.overload
    @staticmethod
    def repeat1(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @typing.overload
    @staticmethod
    def repeat1(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy, r: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def repeatuntil(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy, r: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def restore(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy, rest: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def restorealways(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy, rest: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    _rewrite__T = typing.TypeVar('_rewrite__T')  # <T>
    @staticmethod
    def rewrite(s: org.bitbucket.inkytonik.kiama.rewriting.Strategy, t: _rewrite__T) -> _rewrite__T: ...
    _rewriteTree__T = typing.TypeVar('_rewriteTree__T', bound=scala.Product)  # <T>
    _rewriteTree__U = typing.TypeVar('_rewriteTree__U', bound=scala.Product)  # <U>
    @staticmethod
    def rewriteTree(s: org.bitbucket.inkytonik.kiama.rewriting.Strategy, t: org.bitbucket.inkytonik.kiama.relation.Tree[_rewriteTree__T, _rewriteTree__U], shape: org.bitbucket.inkytonik.kiama.relation.TreeShape) -> org.bitbucket.inkytonik.kiama.relation.Tree[_rewriteTree__T, _rewriteTree__U]: ...
    _rewriteTree$default$3__T = typing.TypeVar('_rewriteTree$default$3__T', bound=scala.Product)  # <T>
    _rewriteTree$default$3__U = typing.TypeVar('_rewriteTree$default$3__U', bound=scala.Product)  # <U>
    @staticmethod
    def rewriteTree$default$3(s: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.relation.TreeShape: ...
    _rewriting__T = typing.TypeVar('_rewriting__T')  # <T>
    @staticmethod
    def rewriting(oldTerm: _rewriting__T, newTerm: _rewriting__T) -> _rewriting__T: ...
    _ruleWithName__T = typing.TypeVar('_ruleWithName__T')  # <T>
    @staticmethod
    def ruleWithName(n: typing.Union[java.lang.String, str], f: scala.PartialFunction[_ruleWithName__T, _ruleWithName__T]) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def rulef(n: typing.Union[java.lang.String, str], f: scala.Function1[typing.Any, typing.Any]) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    _rulefsWithName__T = typing.TypeVar('_rulefsWithName__T')  # <T>
    @staticmethod
    def rulefsWithName(n: typing.Union[java.lang.String, str], f: scala.PartialFunction[_rulefsWithName__T, org.bitbucket.inkytonik.kiama.rewriting.Strategy]) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def some(name: typing.Union[java.lang.String, str], s: scala.Function0[org.bitbucket.inkytonik.kiama.rewriting.Strategy]) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    _someMap__CC = typing.TypeVar('_someMap__CC', bound=scala.collection.immutable.Map)  # <CC>
    @staticmethod
    def someMap(s: org.bitbucket.inkytonik.kiama.rewriting.Strategy, t: _someMap__CC, cbf: scala.collection.generic.CanBuildFrom[_someMap__CC, scala.Tuple2[typing.Any, typing.Any], _someMap__CC]) -> scala.Option[_someMap__CC]: ...
    @staticmethod
    def someProduct(s: org.bitbucket.inkytonik.kiama.rewriting.Strategy, p: scala.Product) -> scala.Option[typing.Any]: ...
    @staticmethod
    def someRewritable(s: org.bitbucket.inkytonik.kiama.rewriting.Strategy, r: org.bitbucket.inkytonik.kiama.rewriting.Rewritable) -> scala.Option[typing.Any]: ...
    _someTraversable__CC = typing.TypeVar('_someTraversable__CC', bound=scala.collection.Traversable)  # <CC>
    @staticmethod
    def someTraversable(s: org.bitbucket.inkytonik.kiama.rewriting.Strategy, t: _someTraversable__CC, cbf: scala.collection.generic.CanBuildFrom[_someTraversable__CC, typing.Any, _someTraversable__CC]) -> scala.Option[_someTraversable__CC]: ...
    @staticmethod
    def somebu(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def somedownup(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def sometd(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    _strategyWithName__T = typing.TypeVar('_strategyWithName__T')  # <T>
    @staticmethod
    def strategyWithName(n: typing.Union[java.lang.String, str], f: scala.PartialFunction[_strategyWithName__T, scala.Option[_strategyWithName__T]]) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def strategyf(n: typing.Union[java.lang.String, str], f: scala.Function1[typing.Any, scala.Option[typing.Any]]) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    _termWithName__T = typing.TypeVar('_termWithName__T')  # <T>
    @staticmethod
    def termWithName(name: typing.Union[java.lang.String, str], t: _termWithName__T) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def test(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def topdown(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def topdownS(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy, stop: scala.Function1[scala.Function0[org.bitbucket.inkytonik.kiama.rewriting.Strategy], org.bitbucket.inkytonik.kiama.rewriting.Strategy]) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...
    @staticmethod
    def where(name: typing.Union[java.lang.String, str], s: org.bitbucket.inkytonik.kiama.rewriting.Strategy) -> org.bitbucket.inkytonik.kiama.rewriting.Strategy: ...

class Types(sigmastate.lang.syntax.Core):
    @staticmethod
    def $init$($this: 'Types') -> None: ...
    def Annot(self) -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    def AnnotType(self) -> fastparse.core.Parser[sigmastate.SType, typing.Any, java.lang.String]: ...
    def CompoundType(self) -> fastparse.core.Parser[sigmastate.SType, typing.Any, java.lang.String]: ...
    def Dcl(self) -> fastparse.core.Parser[sigmastate.Values.Value[sigmastate.SType], typing.Any, java.lang.String]: ...
    def DottyExtMethodSubj(self) -> fastparse.core.Parser[scala.Tuple2[java.lang.String, sigmastate.SType], typing.Any, java.lang.String]: ...
    def Exprs(self) -> fastparse.core.Parser[scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]], typing.Any, java.lang.String]: ...
    def FunSig(self) -> fastparse.core.Parser[scala.collection.Seq[scala.collection.Seq[scala.Tuple2[java.lang.String, sigmastate.SType]]], typing.Any, java.lang.String]: ...
    def InfixType(self) -> fastparse.core.Parser[sigmastate.SType, typing.Any, java.lang.String]: ...
    def NLAnnot(self) -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    def PostfixType(self) -> fastparse.core.Parser[sigmastate.SType, typing.Any, java.lang.String]: ...
    def SimpleType(self) -> fastparse.core.Parser[sigmastate.SType, typing.Any, java.lang.String]: ...
    def Type(self) -> fastparse.core.Parser[sigmastate.SType, typing.Any, java.lang.String]: ...
    def TypeArg(self) -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    def TypeArgList(self) -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    def TypeArgs(self) -> fastparse.core.Parser[scala.collection.Seq[sigmastate.SType], typing.Any, java.lang.String]: ...
    def TypeBounds(self) -> fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, java.lang.String]: ...
    def TypeExpr(self) -> fastparse.core.Parser[sigmastate.Values.Value[sigmastate.SType], typing.Any, java.lang.String]: ...
    def TypeId(self) -> fastparse.core.Parser[sigmastate.SType, typing.Any, java.lang.String]: ...
    def ValVarDef(self) -> fastparse.core.Parser[sigmastate.Values.Value[sigmastate.SType], typing.Any, java.lang.String]: ...
    def predefTypes(self) -> scala.collection.immutable.Map[java.lang.String, sigmastate.SType]: ...
    def sigmastate$lang$Types$_setter_$AnnotType_$eq(self, x$1: fastparse.core.Parser[sigmastate.SType, typing.Any, typing.Union[java.lang.String, str]]) -> None: ...
    def sigmastate$lang$Types$_setter_$Annot_$eq(self, x$1: fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, typing.Union[java.lang.String, str]]) -> None: ...
    def sigmastate$lang$Types$_setter_$CompoundType_$eq(self, x$1: fastparse.core.Parser[sigmastate.SType, typing.Any, typing.Union[java.lang.String, str]]) -> None: ...
    def sigmastate$lang$Types$_setter_$Dcl_$eq(self, x$1: fastparse.core.Parser[sigmastate.Values.Value[sigmastate.SType], typing.Any, typing.Union[java.lang.String, str]]) -> None: ...
    def sigmastate$lang$Types$_setter_$DottyExtMethodSubj_$eq(self, x$1: fastparse.core.Parser[scala.Tuple2[typing.Union[java.lang.String, str], sigmastate.SType], typing.Any, typing.Union[java.lang.String, str]]) -> None: ...
    def sigmastate$lang$Types$_setter_$Exprs_$eq(self, x$1: fastparse.core.Parser[scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]], typing.Any, typing.Union[java.lang.String, str]]) -> None: ...
    def sigmastate$lang$Types$_setter_$FunSig_$eq(self, x$1: fastparse.core.Parser[scala.collection.Seq[scala.collection.Seq[scala.Tuple2[typing.Union[java.lang.String, str], sigmastate.SType]]], typing.Any, typing.Union[java.lang.String, str]]) -> None: ...
    def sigmastate$lang$Types$_setter_$InfixType_$eq(self, x$1: fastparse.core.Parser[sigmastate.SType, typing.Any, typing.Union[java.lang.String, str]]) -> None: ...
    def sigmastate$lang$Types$_setter_$NLAnnot_$eq(self, x$1: fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, typing.Union[java.lang.String, str]]) -> None: ...
    def sigmastate$lang$Types$_setter_$PostfixType_$eq(self, x$1: fastparse.core.Parser[sigmastate.SType, typing.Any, typing.Union[java.lang.String, str]]) -> None: ...
    def sigmastate$lang$Types$_setter_$SimpleType_$eq(self, x$1: fastparse.core.Parser[sigmastate.SType, typing.Any, typing.Union[java.lang.String, str]]) -> None: ...
    def sigmastate$lang$Types$_setter_$TypeArgList_$eq(self, x$1: fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, typing.Union[java.lang.String, str]]) -> None: ...
    def sigmastate$lang$Types$_setter_$TypeArg_$eq(self, x$1: fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, typing.Union[java.lang.String, str]]) -> None: ...
    def sigmastate$lang$Types$_setter_$TypeArgs_$eq(self, x$1: fastparse.core.Parser[scala.collection.Seq[sigmastate.SType], typing.Any, typing.Union[java.lang.String, str]]) -> None: ...
    def sigmastate$lang$Types$_setter_$TypeBounds_$eq(self, x$1: fastparse.core.Parser[scala.runtime.BoxedUnit, typing.Any, typing.Union[java.lang.String, str]]) -> None: ...
    def sigmastate$lang$Types$_setter_$TypeId_$eq(self, x$1: fastparse.core.Parser[sigmastate.SType, typing.Any, typing.Union[java.lang.String, str]]) -> None: ...
    def sigmastate$lang$Types$_setter_$Type_$eq(self, x$1: fastparse.core.Parser[sigmastate.SType, typing.Any, typing.Union[java.lang.String, str]]) -> None: ...
    def sigmastate$lang$Types$_setter_$predefTypes_$eq(self, x$1: scala.collection.immutable.Map[typing.Union[java.lang.String, str], sigmastate.SType]) -> None: ...
    def typeFromName(self, tn: typing.Union[java.lang.String, str]) -> scala.Option[sigmastate.SType]: ...

class StdSigmaBuilder(SigmaBuilder):
    def __init__(self): ...
    _arithOp__T = typing.TypeVar('_arithOp__T', bound=sigmastate.SNumericType)  # <T>
    _arithOp__R = typing.TypeVar('_arithOp__R')  # <R>
    def arithOp(self, left: sigmastate.Values.Value[_arithOp__T], right: sigmastate.Values.Value[_arithOp__T], cons: scala.Function2[sigmastate.Values.Value[_arithOp__T], sigmastate.Values.Value[_arithOp__T], _arithOp__R]) -> _arithOp__R: ...
    @staticmethod
    def canEqual(x$1: typing.Any) -> bool: ...
    _check2__T = typing.TypeVar('_check2__T', bound=sigmastate.SType)  # <T>
    def check2(self, left: sigmastate.Values.Value[_check2__T], right: sigmastate.Values.Value[_check2__T], constraints: scala.collection.Seq['Constraints.TypeConstraint2']) -> None: ...
    _comparisonOp__T = typing.TypeVar('_comparisonOp__T', bound=sigmastate.SType)  # <T>
    _comparisonOp__R = typing.TypeVar('_comparisonOp__R')  # <R>
    def comparisonOp(self, left: sigmastate.Values.Value[_comparisonOp__T], right: sigmastate.Values.Value[_comparisonOp__T], cons: scala.Function2[sigmastate.Values.Value[_comparisonOp__T], sigmastate.Values.Value[_comparisonOp__T], _comparisonOp__R]) -> _comparisonOp__R: ...
    _equalityOp__T = typing.TypeVar('_equalityOp__T', bound=sigmastate.SType)  # <T>
    _equalityOp__R = typing.TypeVar('_equalityOp__R')  # <R>
    def equalityOp(self, left: sigmastate.Values.Value[_equalityOp__T], right: sigmastate.Values.Value[_equalityOp__T], cons: scala.Function2[sigmastate.Values.Value[_equalityOp__T], sigmastate.Values.Value[_equalityOp__T], _equalityOp__R]) -> _equalityOp__R: ...
    def mkAND(self, input: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SBoolean.]]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    def mkAllOf(self, input: scala.collection.Seq[sigmastate.Values.Value[sigmastate.SBoolean.]]) -> sigmastate.Values.Value[scala.runtime.Nothing.]: ...
    def mkAnyOf(self, input: scala.collection.Seq[sigmastate.Values.Value[sigmastate.SBoolean.]]) -> sigmastate.Values.Value[scala.runtime.Nothing.]: ...
    _mkAppend__IV = typing.TypeVar('_mkAppend__IV', bound=sigmastate.SType)  # <IV>
    def mkAppend(self, input: sigmastate.Values.Value[sigmastate.SCollection[_mkAppend__IV]], col2: sigmastate.Values.Value[sigmastate.SCollection[_mkAppend__IV]]) -> sigmastate.Values.Value[sigmastate.SCollection[_mkAppend__IV]]: ...
    def mkApply(self, func: sigmastate.Values.Value[sigmastate.SType], args: scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def mkApplyTypes(self, input: sigmastate.Values.Value[sigmastate.SType], tpeArgs: scala.collection.Seq[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    _mkArith__T = typing.TypeVar('_mkArith__T', bound=sigmastate.SNumericType)  # <T>
    def mkArith(self, left: sigmastate.Values.Value[_mkArith__T], right: sigmastate.Values.Value[_mkArith__T], opCode: int) -> sigmastate.Values.Value[_mkArith__T]: ...
    def mkAtLeast(self, bound: sigmastate.Values.Value[sigmastate.SInt.], input: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SSigmaProp.]]) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...
    def mkBinAnd(self, left: sigmastate.Values.Value[sigmastate.SBoolean.], right: sigmastate.Values.Value[sigmastate.SBoolean.]) -> sigmastate.Values.Value[scala.runtime.Nothing.]: ...
    def mkBinOr(self, left: sigmastate.Values.Value[sigmastate.SBoolean.], right: sigmastate.Values.Value[sigmastate.SBoolean.]) -> sigmastate.Values.Value[scala.runtime.Nothing.]: ...
    def mkBinXor(self, left: sigmastate.Values.Value[sigmastate.SBoolean.], right: sigmastate.Values.Value[sigmastate.SBoolean.]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    _mkBitAnd__T = typing.TypeVar('_mkBitAnd__T', bound=sigmastate.SNumericType)  # <T>
    def mkBitAnd(self, left: sigmastate.Values.Value[_mkBitAnd__T], right: sigmastate.Values.Value[_mkBitAnd__T]) -> sigmastate.Values.Value[_mkBitAnd__T]: ...
    _mkBitInversion__T = typing.TypeVar('_mkBitInversion__T', bound=sigmastate.SNumericType)  # <T>
    def mkBitInversion(self, input: sigmastate.Values.Value[_mkBitInversion__T]) -> sigmastate.Values.Value[_mkBitInversion__T]: ...
    _mkBitOr__T = typing.TypeVar('_mkBitOr__T', bound=sigmastate.SNumericType)  # <T>
    def mkBitOr(self, left: sigmastate.Values.Value[_mkBitOr__T], right: sigmastate.Values.Value[_mkBitOr__T]) -> sigmastate.Values.Value[_mkBitOr__T]: ...
    _mkBitShiftLeft__T = typing.TypeVar('_mkBitShiftLeft__T', bound=sigmastate.SNumericType)  # <T>
    def mkBitShiftLeft(self, bits: sigmastate.Values.Value[_mkBitShiftLeft__T], shift: sigmastate.Values.Value[_mkBitShiftLeft__T]) -> sigmastate.Values.Value[_mkBitShiftLeft__T]: ...
    _mkBitShiftRight__T = typing.TypeVar('_mkBitShiftRight__T', bound=sigmastate.SNumericType)  # <T>
    def mkBitShiftRight(self, bits: sigmastate.Values.Value[_mkBitShiftRight__T], shift: sigmastate.Values.Value[_mkBitShiftRight__T]) -> sigmastate.Values.Value[_mkBitShiftRight__T]: ...
    _mkBitShiftRightZeroed__T = typing.TypeVar('_mkBitShiftRightZeroed__T', bound=sigmastate.SNumericType)  # <T>
    def mkBitShiftRightZeroed(self, bits: sigmastate.Values.Value[_mkBitShiftRightZeroed__T], shift: sigmastate.Values.Value[_mkBitShiftRightZeroed__T]) -> sigmastate.Values.Value[_mkBitShiftRightZeroed__T]: ...
    _mkBitXor__T = typing.TypeVar('_mkBitXor__T', bound=sigmastate.SNumericType)  # <T>
    def mkBitXor(self, left: sigmastate.Values.Value[_mkBitXor__T], right: sigmastate.Values.Value[_mkBitXor__T]) -> sigmastate.Values.Value[_mkBitXor__T]: ...
    def mkBlock(self, bindings: scala.collection.Seq['Terms.Val'], result: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def mkBlockValue(self, items: scala.collection.IndexedSeq[sigmastate.Values.BlockItem], result: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def mkBoolToSigmaProp(self, value: sigmastate.Values.Value[sigmastate.SBoolean.]) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...
    _mkByIndex__IV = typing.TypeVar('_mkByIndex__IV', bound=sigmastate.SType)  # <IV>
    def mkByIndex(self, input: sigmastate.Values.Value[sigmastate.SCollection[_mkByIndex__IV]], index: sigmastate.Values.Value[sigmastate.SInt.], default: scala.Option[sigmastate.Values.Value[_mkByIndex__IV]]) -> sigmastate.Values.Value[_mkByIndex__IV]: ...
    _mkByIndex$default$3__IV = typing.TypeVar('_mkByIndex$default$3__IV', bound=sigmastate.SType)  # <IV>
    def mkByIndex$default$3(self) -> scala.None.: ...
    def mkByteArrayToBigInt(self, input: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]) -> sigmastate.Values.Value[sigmastate.SBigInt.]: ...
    def mkByteArrayToLong(self, input: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]) -> sigmastate.Values.Value[sigmastate.SLong.]: ...
    def mkCalcBlake2b256(self, input: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    def mkCalcSha256(self, input: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    _mkCollectionConstant_0__T = typing.TypeVar('_mkCollectionConstant_0__T', bound=sigmastate.SType)  # <T>
    _mkCollectionConstant_1__T = typing.TypeVar('_mkCollectionConstant_1__T', bound=sigmastate.SType)  # <T>
    @typing.overload
    def mkCollectionConstant(self, values: typing.Any, elementType: _mkCollectionConstant_0__T) -> sigmastate.Values.Constant[sigmastate.SCollection[_mkCollectionConstant_0__T]]: ...
    @typing.overload
    def mkCollectionConstant(self, values: special.collection.Coll[typing.Any], elementType: _mkCollectionConstant_1__T) -> sigmastate.Values.Constant[sigmastate.SCollection[_mkCollectionConstant_1__T]]: ...
    _mkConcreteCollection__T = typing.TypeVar('_mkConcreteCollection__T', bound=sigmastate.SType)  # <T>
    def mkConcreteCollection(self, items: scala.collection.Seq[sigmastate.Values.Value[_mkConcreteCollection__T]], elementType: _mkConcreteCollection__T) -> sigmastate.Values.Value[sigmastate.SCollection[_mkConcreteCollection__T]]: ...
    _mkConstant__T = typing.TypeVar('_mkConstant__T', bound=sigmastate.SType)  # <T>
    def mkConstant(self, value: typing.Any, tpe: _mkConstant__T) -> sigmastate.Values.Constant[_mkConstant__T]: ...
    _mkConstantPlaceholder__T = typing.TypeVar('_mkConstantPlaceholder__T', bound=sigmastate.SType)  # <T>
    def mkConstantPlaceholder(self, id: int, tpe: _mkConstantPlaceholder__T) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def mkCreateAvlTree(self, operationFlags: sigmastate.Values.Value[sigmastate.SByte.], digest: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]], keyLength: sigmastate.Values.Value[sigmastate.SInt.], valueLengthOpt: sigmastate.Values.Value[sigmastate.SOption[sigmastate.SInt.]]) -> sigmastate.Values.Value[sigmastate.SAvlTree.]: ...
    def mkCreateProveDHTuple(self, gv: sigmastate.Values.Value[sigmastate.SGroupElement.], hv: sigmastate.Values.Value[sigmastate.SGroupElement.], uv: sigmastate.Values.Value[sigmastate.SGroupElement.], vv: sigmastate.Values.Value[sigmastate.SGroupElement.]) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...
    def mkCreateProveDlog(self, value: sigmastate.Values.Value[sigmastate.SGroupElement.]) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...
    def mkDecodePoint(self, input: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]) -> sigmastate.Values.Value[sigmastate.SGroupElement.]: ...
    _mkDeserializeContext__T = typing.TypeVar('_mkDeserializeContext__T', bound=sigmastate.SType)  # <T>
    def mkDeserializeContext(self, id: int, tpe: _mkDeserializeContext__T) -> sigmastate.Values.Value[_mkDeserializeContext__T]: ...
    _mkDeserializeRegister__T = typing.TypeVar('_mkDeserializeRegister__T', bound=sigmastate.SType)  # <T>
    def mkDeserializeRegister(self, reg: org.ergoplatform.ErgoBox.RegisterId, tpe: _mkDeserializeRegister__T, default: scala.Option[sigmastate.Values.Value[_mkDeserializeRegister__T]]) -> sigmastate.Values.Value[_mkDeserializeRegister__T]: ...
    _mkDeserializeRegister$default$3__T = typing.TypeVar('_mkDeserializeRegister$default$3__T', bound=sigmastate.SType)  # <T>
    def mkDeserializeRegister$default$3(self) -> scala.None.: ...
    _mkDivide__T = typing.TypeVar('_mkDivide__T', bound=sigmastate.SNumericType)  # <T>
    def mkDivide(self, left: sigmastate.Values.Value[_mkDivide__T], right: sigmastate.Values.Value[_mkDivide__T]) -> sigmastate.Values.Value[_mkDivide__T]: ...
    _mkDowncast__T = typing.TypeVar('_mkDowncast__T', bound=sigmastate.SNumericType)  # <T>
    _mkDowncast__R = typing.TypeVar('_mkDowncast__R', bound=sigmastate.SNumericType)  # <R>
    def mkDowncast(self, input: sigmastate.Values.Value[_mkDowncast__T], tpe: _mkDowncast__R) -> sigmastate.Values.Value[_mkDowncast__R]: ...
    _mkEQ__T = typing.TypeVar('_mkEQ__T', bound=sigmastate.SType)  # <T>
    def mkEQ(self, left: sigmastate.Values.Value[_mkEQ__T], right: sigmastate.Values.Value[_mkEQ__T]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    _mkExists__IV = typing.TypeVar('_mkExists__IV', bound=sigmastate.SType)  # <IV>
    def mkExists(self, input: sigmastate.Values.Value[sigmastate.SCollection[_mkExists__IV]], condition: sigmastate.Values.Value[sigmastate.SFunc]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    def mkExponentiate(self, left: sigmastate.Values.Value[sigmastate.SGroupElement.], right: sigmastate.Values.Value[sigmastate.SBigInt.]) -> sigmastate.Values.Value[sigmastate.SGroupElement.]: ...
    def mkExtractAmount(self, input: sigmastate.Values.Value[sigmastate.SBox.]) -> sigmastate.Values.Value[sigmastate.SLong.]: ...
    def mkExtractBytes(self, input: sigmastate.Values.Value[sigmastate.SBox.]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    def mkExtractBytesWithNoRef(self, input: sigmastate.Values.Value[sigmastate.SBox.]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    def mkExtractCreationInfo(self, input: sigmastate.Values.Value[sigmastate.SBox.]) -> sigmastate.Values.Value[sigmastate.STuple]: ...
    def mkExtractId(self, input: sigmastate.Values.Value[sigmastate.SBox.]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    _mkExtractRegisterAs__IV = typing.TypeVar('_mkExtractRegisterAs__IV', bound=sigmastate.SType)  # <IV>
    def mkExtractRegisterAs(self, input: sigmastate.Values.Value[sigmastate.SBox.], registerId: org.ergoplatform.ErgoBox.RegisterId, tpe: sigmastate.SOption[_mkExtractRegisterAs__IV]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def mkExtractScriptBytes(self, input: sigmastate.Values.Value[sigmastate.SBox.]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    _mkFilter__IV = typing.TypeVar('_mkFilter__IV', bound=sigmastate.SType)  # <IV>
    def mkFilter(self, input: sigmastate.Values.Value[sigmastate.SCollection[_mkFilter__IV]], condition: sigmastate.Values.Value[sigmastate.SFunc]) -> sigmastate.Values.Value[sigmastate.SCollection[_mkFilter__IV]]: ...
    _mkFold__IV = typing.TypeVar('_mkFold__IV', bound=sigmastate.SType)  # <IV>
    _mkFold__OV = typing.TypeVar('_mkFold__OV', bound=sigmastate.SType)  # <OV>
    def mkFold(self, input: sigmastate.Values.Value[sigmastate.SCollection[_mkFold__IV]], zero: sigmastate.Values.Value[_mkFold__OV], foldOp: sigmastate.Values.Value[sigmastate.SFunc]) -> sigmastate.Values.Value[_mkFold__OV]: ...
    _mkForAll__IV = typing.TypeVar('_mkForAll__IV', bound=sigmastate.SType)  # <IV>
    def mkForAll(self, input: sigmastate.Values.Value[sigmastate.SCollection[_mkForAll__IV]], condition: sigmastate.Values.Value[sigmastate.SFunc]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    def mkFuncValue(self, args: scala.collection.IndexedSeq[scala.Tuple2[typing.Any, sigmastate.SType]], body: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SFunc]: ...
    _mkGE__T = typing.TypeVar('_mkGE__T', bound=sigmastate.SType)  # <T>
    def mkGE(self, left: sigmastate.Values.Value[_mkGE__T], right: sigmastate.Values.Value[_mkGE__T]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    _mkGT__T = typing.TypeVar('_mkGT__T', bound=sigmastate.SType)  # <T>
    def mkGT(self, left: sigmastate.Values.Value[_mkGT__T], right: sigmastate.Values.Value[_mkGT__T]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    def mkGenLambda(self, tpeParams: scala.collection.Seq['Terms.STypeParam'], args: scala.collection.IndexedSeq[scala.Tuple2[typing.Union[java.lang.String, str], sigmastate.SType]], givenResType: sigmastate.SType, body: scala.Option[sigmastate.Values.Value[sigmastate.SType]]) -> sigmastate.Values.Value[scala.runtime.Nothing.]: ...
    _mkGetVar__T = typing.TypeVar('_mkGetVar__T', bound=sigmastate.SType)  # <T>
    def mkGetVar(self, varId: int, tpe: _mkGetVar__T) -> sigmastate.Values.Value[sigmastate.SOption[_mkGetVar__T]]: ...
    def mkIdent(self, name: typing.Union[java.lang.String, str], tpe: sigmastate.SType) -> sigmastate.Values.Value[sigmastate.SType]: ...
    _mkIf__T = typing.TypeVar('_mkIf__T', bound=sigmastate.SType)  # <T>
    def mkIf(self, condition: sigmastate.Values.Value[sigmastate.SBoolean.], trueBranch: sigmastate.Values.Value[_mkIf__T], falseBranch: sigmastate.Values.Value[_mkIf__T]) -> sigmastate.Values.Value[_mkIf__T]: ...
    _mkLE__T = typing.TypeVar('_mkLE__T', bound=sigmastate.SType)  # <T>
    def mkLE(self, left: sigmastate.Values.Value[_mkLE__T], right: sigmastate.Values.Value[_mkLE__T]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    _mkLT__T = typing.TypeVar('_mkLT__T', bound=sigmastate.SType)  # <T>
    def mkLT(self, left: sigmastate.Values.Value[_mkLT__T], right: sigmastate.Values.Value[_mkLT__T]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    def mkLambda(self, args: scala.collection.IndexedSeq[scala.Tuple2[typing.Union[java.lang.String, str], sigmastate.SType]], givenResType: sigmastate.SType, body: scala.Option[sigmastate.Values.Value[sigmastate.SType]]) -> sigmastate.Values.Value[sigmastate.SFunc]: ...
    def mkLogicalNot(self, input: sigmastate.Values.Value[sigmastate.SBoolean.]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    def mkLongToByteArray(self, input: sigmastate.Values.Value[sigmastate.SLong.]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    _mkMapCollection__IV = typing.TypeVar('_mkMapCollection__IV', bound=sigmastate.SType)  # <IV>
    _mkMapCollection__OV = typing.TypeVar('_mkMapCollection__OV', bound=sigmastate.SType)  # <OV>
    def mkMapCollection(self, input: sigmastate.Values.Value[sigmastate.SCollection[_mkMapCollection__IV]], mapper: sigmastate.Values.Value[sigmastate.SFunc]) -> sigmastate.Values.Value[sigmastate.SCollection[_mkMapCollection__OV]]: ...
    _mkMax__T = typing.TypeVar('_mkMax__T', bound=sigmastate.SNumericType)  # <T>
    def mkMax(self, left: sigmastate.Values.Value[_mkMax__T], right: sigmastate.Values.Value[_mkMax__T]) -> sigmastate.Values.Value[_mkMax__T]: ...
    def mkMethodCall(self, obj: sigmastate.Values.Value[sigmastate.SType], method: sigmastate.SMethod, args: scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]], typeSubst: scala.collection.immutable.Map[sigmastate.STypeVar, sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def mkMethodCall$default$4(self) -> scala.collection.immutable.Map[sigmastate.STypeVar, sigmastate.SType]: ...
    def mkMethodCallLike(self, obj: sigmastate.Values.Value[sigmastate.SType], name: typing.Union[java.lang.String, str], args: scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]], tpe: sigmastate.SType) -> sigmastate.Values.Value[sigmastate.SType]: ...
    _mkMin__T = typing.TypeVar('_mkMin__T', bound=sigmastate.SNumericType)  # <T>
    def mkMin(self, left: sigmastate.Values.Value[_mkMin__T], right: sigmastate.Values.Value[_mkMin__T]) -> sigmastate.Values.Value[_mkMin__T]: ...
    _mkMinus__T = typing.TypeVar('_mkMinus__T', bound=sigmastate.SNumericType)  # <T>
    def mkMinus(self, left: sigmastate.Values.Value[_mkMinus__T], right: sigmastate.Values.Value[_mkMinus__T]) -> sigmastate.Values.Value[_mkMinus__T]: ...
    def mkMinusModQ(self, left: sigmastate.Values.Value[sigmastate.SBigInt.], right: sigmastate.Values.Value[sigmastate.SBigInt.]) -> sigmastate.Values.Value[sigmastate.SBigInt.]: ...
    def mkModQ(self, input: sigmastate.Values.Value[sigmastate.SBigInt.]) -> sigmastate.Values.Value[sigmastate.SBigInt.]: ...
    _mkModulo__T = typing.TypeVar('_mkModulo__T', bound=sigmastate.SNumericType)  # <T>
    def mkModulo(self, left: sigmastate.Values.Value[_mkModulo__T], right: sigmastate.Values.Value[_mkModulo__T]) -> sigmastate.Values.Value[_mkModulo__T]: ...
    _mkMultiply__T = typing.TypeVar('_mkMultiply__T', bound=sigmastate.SNumericType)  # <T>
    def mkMultiply(self, left: sigmastate.Values.Value[_mkMultiply__T], right: sigmastate.Values.Value[_mkMultiply__T]) -> sigmastate.Values.Value[_mkMultiply__T]: ...
    def mkMultiplyGroup(self, left: sigmastate.Values.Value[sigmastate.SGroupElement.], right: sigmastate.Values.Value[sigmastate.SGroupElement.]) -> sigmastate.Values.Value[sigmastate.SGroupElement.]: ...
    _mkNEQ__T = typing.TypeVar('_mkNEQ__T', bound=sigmastate.SType)  # <T>
    def mkNEQ(self, left: sigmastate.Values.Value[_mkNEQ__T], right: sigmastate.Values.Value[_mkNEQ__T]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    _mkNegation__T = typing.TypeVar('_mkNegation__T', bound=sigmastate.SNumericType)  # <T>
    def mkNegation(self, input: sigmastate.Values.Value[_mkNegation__T]) -> sigmastate.Values.Value[_mkNegation__T]: ...
    _mkNoneValue__T = typing.TypeVar('_mkNoneValue__T', bound=sigmastate.SType)  # <T>
    def mkNoneValue(self, elemType: _mkNoneValue__T) -> sigmastate.Values.Value[sigmastate.SOption[_mkNoneValue__T]]: ...
    def mkOR(self, input: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SBoolean.]]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    _mkOptionGet__T = typing.TypeVar('_mkOptionGet__T', bound=sigmastate.SType)  # <T>
    def mkOptionGet(self, input: sigmastate.Values.Value[sigmastate.SOption[_mkOptionGet__T]]) -> sigmastate.Values.Value[_mkOptionGet__T]: ...
    _mkOptionGetOrElse__T = typing.TypeVar('_mkOptionGetOrElse__T', bound=sigmastate.SType)  # <T>
    def mkOptionGetOrElse(self, input: sigmastate.Values.Value[sigmastate.SOption[_mkOptionGetOrElse__T]], default: sigmastate.Values.Value[_mkOptionGetOrElse__T]) -> sigmastate.Values.Value[_mkOptionGetOrElse__T]: ...
    _mkOptionIsDefined__T = typing.TypeVar('_mkOptionIsDefined__T', bound=sigmastate.SType)  # <T>
    def mkOptionIsDefined(self, input: sigmastate.Values.Value[sigmastate.SOption[_mkOptionIsDefined__T]]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    _mkPlus__T = typing.TypeVar('_mkPlus__T', bound=sigmastate.SNumericType)  # <T>
    def mkPlus(self, left: sigmastate.Values.Value[_mkPlus__T], right: sigmastate.Values.Value[_mkPlus__T]) -> sigmastate.Values.Value[_mkPlus__T]: ...
    def mkPlusModQ(self, left: sigmastate.Values.Value[sigmastate.SBigInt.], right: sigmastate.Values.Value[sigmastate.SBigInt.]) -> sigmastate.Values.Value[sigmastate.SBigInt.]: ...
    def mkSelect(self, obj: sigmastate.Values.Value[sigmastate.SType], field: typing.Union[java.lang.String, str], resType: scala.Option[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def mkSelect$default$3(self) -> scala.Option[sigmastate.SType]: ...
    def mkSelectField(self, input: sigmastate.Values.Value[sigmastate.STuple], fieldIndex: int) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def mkSigmaAnd(self, items: scala.collection.Seq[sigmastate.Values.Value[sigmastate.SSigmaProp.]]) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...
    def mkSigmaOr(self, items: scala.collection.Seq[sigmastate.Values.Value[sigmastate.SSigmaProp.]]) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...
    def mkSigmaPropBytes(self, value: sigmastate.Values.Value[sigmastate.SSigmaProp.]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    def mkSigmaPropIsProven(self, value: sigmastate.Values.Value[sigmastate.SSigmaProp.]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    _mkSizeOf__V = typing.TypeVar('_mkSizeOf__V', bound=sigmastate.SType)  # <V>
    def mkSizeOf(self, input: sigmastate.Values.Value[sigmastate.SCollection[_mkSizeOf__V]]) -> sigmastate.Values.Value[sigmastate.SInt.]: ...
    _mkSlice__IV = typing.TypeVar('_mkSlice__IV', bound=sigmastate.SType)  # <IV>
    def mkSlice(self, input: sigmastate.Values.Value[sigmastate.SCollection[_mkSlice__IV]], from_: sigmastate.Values.Value[sigmastate.SInt.], until: sigmastate.Values.Value[sigmastate.SInt.]) -> sigmastate.Values.Value[sigmastate.SCollection[_mkSlice__IV]]: ...
    _mkSomeValue__T = typing.TypeVar('_mkSomeValue__T', bound=sigmastate.SType)  # <T>
    def mkSomeValue(self, x: sigmastate.Values.Value[_mkSomeValue__T]) -> sigmastate.Values.Value[sigmastate.SOption[_mkSomeValue__T]]: ...
    def mkStringConcat(self, left: sigmastate.Values.Constant[sigmastate.SString.], right: sigmastate.Values.Constant[sigmastate.SString.]) -> sigmastate.Values.Value[sigmastate.SString.]: ...
    _mkSubstConst__T = typing.TypeVar('_mkSubstConst__T', bound=sigmastate.SType)  # <T>
    def mkSubstConst(self, scriptBytes: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]], positions: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SInt.]], newValues: sigmastate.Values.Value[sigmastate.SCollection[_mkSubstConst__T]]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    _mkTaggedVariable__T = typing.TypeVar('_mkTaggedVariable__T', bound=sigmastate.SType)  # <T>
    def mkTaggedVariable(self, varId: int, tpe: _mkTaggedVariable__T) -> sigmastate.Values.TaggedVariable[_mkTaggedVariable__T]: ...
    def mkTreeLookup(self, tree: sigmastate.Values.Value[sigmastate.SAvlTree.], key: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]], proof: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]) -> sigmastate.Values.Value[sigmastate.SOption[sigmastate.SCollection[sigmastate.SByte.]]]: ...
    def mkTuple(self, items: scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]]) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def mkUnitConstant(self) -> sigmastate.Values.Value[sigmastate.SUnit.]: ...
    _mkUpcast__T = typing.TypeVar('_mkUpcast__T', bound=sigmastate.SNumericType)  # <T>
    _mkUpcast__R = typing.TypeVar('_mkUpcast__R', bound=sigmastate.SNumericType)  # <R>
    def mkUpcast(self, input: sigmastate.Values.Value[_mkUpcast__T], tpe: _mkUpcast__R) -> sigmastate.Values.Value[_mkUpcast__R]: ...
    def mkVal(self, name: typing.Union[java.lang.String, str], givenType: sigmastate.SType, body: sigmastate.Values.Value[sigmastate.SType]) -> 'Terms.Val': ...
    def mkValUse(self, valId: int, tpe: sigmastate.SType) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def mkXor(self, left: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]], right: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
    def mkXorOf(self, input: sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SBoolean.]]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    def mkZKProofBlock(self, body: sigmastate.Values.Value[sigmastate.SSigmaProp.]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    @staticmethod
    def productArity() -> int: ...
    @staticmethod
    def productElement(x$1: int) -> typing.Any: ...
    @staticmethod
    def productIterator() -> scala.collection.Iterator[typing.Any]: ...
    @staticmethod
    def productPrefix() -> java.lang.String: ...

class CheckingSigmaBuilder(StdSigmaBuilder):
    def __init__(self): ...
    _arithOp__T = typing.TypeVar('_arithOp__T', bound=sigmastate.SNumericType)  # <T>
    _arithOp__R = typing.TypeVar('_arithOp__R')  # <R>
    def arithOp(self, left: sigmastate.Values.Value[_arithOp__T], right: sigmastate.Values.Value[_arithOp__T], cons: scala.Function2[sigmastate.Values.Value[_arithOp__T], sigmastate.Values.Value[_arithOp__T], _arithOp__R]) -> _arithOp__R: ...
    @staticmethod
    def canEqual(x$1: typing.Any) -> bool: ...
    _comparisonOp__T = typing.TypeVar('_comparisonOp__T', bound=sigmastate.SType)  # <T>
    _comparisonOp__R = typing.TypeVar('_comparisonOp__R')  # <R>
    def comparisonOp(self, left: sigmastate.Values.Value[_comparisonOp__T], right: sigmastate.Values.Value[_comparisonOp__T], cons: scala.Function2[sigmastate.Values.Value[_comparisonOp__T], sigmastate.Values.Value[_comparisonOp__T], _comparisonOp__R]) -> _comparisonOp__R: ...
    _equalityOp__T = typing.TypeVar('_equalityOp__T', bound=sigmastate.SType)  # <T>
    _equalityOp__R = typing.TypeVar('_equalityOp__R')  # <R>
    def equalityOp(self, left: sigmastate.Values.Value[_equalityOp__T], right: sigmastate.Values.Value[_equalityOp__T], cons: scala.Function2[sigmastate.Values.Value[_equalityOp__T], sigmastate.Values.Value[_equalityOp__T], _equalityOp__R]) -> _equalityOp__R: ...
    @staticmethod
    def productArity() -> int: ...
    @staticmethod
    def productElement(x$1: int) -> typing.Any: ...
    @staticmethod
    def productIterator() -> scala.collection.Iterator[typing.Any]: ...
    @staticmethod
    def productPrefix() -> java.lang.String: ...

class TransformingSigmaBuilder(StdSigmaBuilder):
    def __init__(self): ...
    _arithOp__T = typing.TypeVar('_arithOp__T', bound=sigmastate.SNumericType)  # <T>
    _arithOp__R = typing.TypeVar('_arithOp__R')  # <R>
    def arithOp(self, left: sigmastate.Values.Value[_arithOp__T], right: sigmastate.Values.Value[_arithOp__T], cons: scala.Function2[sigmastate.Values.Value[_arithOp__T], sigmastate.Values.Value[_arithOp__T], _arithOp__R]) -> _arithOp__R: ...
    @staticmethod
    def canEqual(x$1: typing.Any) -> bool: ...
    _comparisonOp__T = typing.TypeVar('_comparisonOp__T', bound=sigmastate.SType)  # <T>
    _comparisonOp__R = typing.TypeVar('_comparisonOp__R')  # <R>
    def comparisonOp(self, left: sigmastate.Values.Value[_comparisonOp__T], right: sigmastate.Values.Value[_comparisonOp__T], cons: scala.Function2[sigmastate.Values.Value[_comparisonOp__T], sigmastate.Values.Value[_comparisonOp__T], _comparisonOp__R]) -> _comparisonOp__R: ...
    _equalityOp__T = typing.TypeVar('_equalityOp__T', bound=sigmastate.SType)  # <T>
    _equalityOp__R = typing.TypeVar('_equalityOp__R')  # <R>
    def equalityOp(self, left: sigmastate.Values.Value[_equalityOp__T], right: sigmastate.Values.Value[_equalityOp__T], cons: scala.Function2[sigmastate.Values.Value[_equalityOp__T], sigmastate.Values.Value[_equalityOp__T], _equalityOp__R]) -> _equalityOp__R: ...
    @staticmethod
    def productArity() -> int: ...
    @staticmethod
    def productElement(x$1: int) -> typing.Any: ...
    @staticmethod
    def productIterator() -> scala.collection.Iterator[typing.Any]: ...
    @staticmethod
    def productPrefix() -> java.lang.String: ...

class Constraints:
    @staticmethod
    def OnlyNumericAndSameTypeConstrain() -> scala.collection.Seq['Constraints.TypeConstraint2']: ...
    @staticmethod
    def OnlyNumericConstrain() -> scala.collection.Seq['Constraints.TypeConstraint2']: ...
    @staticmethod
    def SameTypeConstrain() -> scala.collection.Seq['Constraints.TypeConstraint2']: ...
    class OnlyNumeric2$(sigmastate.lang.Constraints.TypeConstraint2):
        MODULE$: typing.ClassVar['Constraints.OnlyNumeric2.'] = ...
        def __init__(self): ...
        def apply(self, t1: sigmastate.SType, t2: sigmastate.SType) -> bool: ...
    class SameType2$(sigmastate.lang.Constraints.TypeConstraint2):
        MODULE$: typing.ClassVar['Constraints.SameType2.'] = ...
        def __init__(self): ...
        def apply(self, t1: sigmastate.SType, t2: sigmastate.SType) -> bool: ...
    class TypeConstraint2:
        def __init__(self): ...
        def apply(self, t1: sigmastate.SType, t2: sigmastate.SType) -> bool: ...

class Terms:
    class Apply(sigmastate.Values.Value[sigmastate.SType], scala.Serializable):
        def __init__(self, func: sigmastate.Values.Value[sigmastate.SType], args: scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]]): ...
        def args(self) -> scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]]: ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        def companion(self) -> 'Terms.Apply.': ...
        def copy(self, func: sigmastate.Values.Value[sigmastate.SType], args: scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]]) -> 'Terms.Apply': ...
        def copy$default$1(self) -> sigmastate.Values.Value[sigmastate.SType]: ...
        def copy$default$2(self) -> scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]]: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def eval(self, env: scala.collection.immutable.Map[typing.Any, typing.Any], E: sigmastate.interpreter.ErgoTreeEvaluator) -> typing.Any: ...
        def func(self) -> sigmastate.Values.Value[sigmastate.SType]: ...
        def hashCode(self) -> int: ...
        def opType(self) -> sigmastate.SFunc: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
        def tpe(self) -> sigmastate.SType: ...
        class : ...
    class Apply$(sigmastate.Values.FixedCostValueCompanion, scala.Serializable):
        MODULE$: typing.ClassVar['Terms.Apply.'] = ...
        def __init__(self): ...
        def apply(self, func: sigmastate.Values.Value[sigmastate.SType], args: scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]]) -> 'Terms.Apply': ...
        def costKind(self) -> sigmastate.FixedCost: ...
        def init(self) -> None: ...
        def opCode(self) -> int: ...
        def opDesc(self) -> sigmastate.interpreter.CompanionDesc: ...
        def sigmastate$Values$ValueCompanion$_setter_$opDesc_$eq(self, x$1: sigmastate.interpreter.CompanionDesc) -> None: ...
        def toString(self) -> java.lang.String: ...
        def typeName(self) -> java.lang.String: ...
        def unapply(self, x$0: 'Terms.Apply') -> scala.Option[scala.Tuple2[sigmastate.Values.Value[sigmastate.SType], scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]]]]: ...
    class ApplyTypes(sigmastate.Values.Value[sigmastate.SType], scala.Serializable):
        def __init__(self, input: sigmastate.Values.Value[sigmastate.SType], tpeArgs: scala.collection.Seq[sigmastate.SType]): ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        def companion(self) -> 'Terms.ApplyTypes.': ...
        def copy(self, input: sigmastate.Values.Value[sigmastate.SType], tpeArgs: scala.collection.Seq[sigmastate.SType]) -> 'Terms.ApplyTypes': ...
        def copy$default$1(self) -> sigmastate.Values.Value[sigmastate.SType]: ...
        def copy$default$2(self) -> scala.collection.Seq[sigmastate.SType]: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def input(self) -> sigmastate.Values.Value[sigmastate.SType]: ...
        def opType(self) -> sigmastate.SFunc: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
        def tpe(self) -> sigmastate.SType: ...
        def tpeArgs(self) -> scala.collection.Seq[sigmastate.SType]: ...
        class : ...
    class ApplyTypes$(sigmastate.Values.ValueCompanion, scala.Serializable):
        MODULE$: typing.ClassVar['Terms.ApplyTypes.'] = ...
        def __init__(self): ...
        def apply(self, input: sigmastate.Values.Value[sigmastate.SType], tpeArgs: scala.collection.Seq[sigmastate.SType]) -> 'Terms.ApplyTypes': ...
        def costKind(self) -> sigmastate.CostKind: ...
        def init(self) -> None: ...
        def opCode(self) -> int: ...
        def opDesc(self) -> sigmastate.interpreter.CompanionDesc: ...
        def sigmastate$Values$ValueCompanion$_setter_$opDesc_$eq(self, x$1: sigmastate.interpreter.CompanionDesc) -> None: ...
        def toString(self) -> java.lang.String: ...
        def typeName(self) -> java.lang.String: ...
        def unapply(self, x$0: 'Terms.ApplyTypes') -> scala.Option[scala.Tuple2[sigmastate.Values.Value[sigmastate.SType], scala.collection.Seq[sigmastate.SType]]]: ...
    class Block(sigmastate.Values.Value[sigmastate.SType], scala.Serializable):
        def __init__(self, bindings: scala.collection.Seq['Terms.Val'], result: sigmastate.Values.Value[sigmastate.SType]): ...
        def bindings(self) -> scala.collection.Seq['Terms.Val']: ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        def companion(self) -> 'Terms.Block.': ...
        def copy(self, bindings: scala.collection.Seq['Terms.Val'], result: sigmastate.Values.Value[sigmastate.SType]) -> 'Terms.Block': ...
        def copy$default$1(self) -> scala.collection.Seq['Terms.Val']: ...
        def copy$default$2(self) -> sigmastate.Values.Value[sigmastate.SType]: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def opType(self) -> sigmastate.SFunc: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def result(self) -> sigmastate.Values.Value[sigmastate.SType]: ...
        def toString(self) -> java.lang.String: ...
        def tpe(self) -> sigmastate.SType: ...
        class : ...
    class Block$(sigmastate.Values.ValueCompanion, scala.Serializable):
        MODULE$: typing.ClassVar['Terms.Block.'] = ...
        def __init__(self): ...
        @typing.overload
        def apply(self, bindings: scala.collection.Seq['Terms.Val'], result: sigmastate.Values.Value[sigmastate.SType]) -> 'Terms.Block': ...
        @typing.overload
        def apply(self, let: 'Terms.Val', result: sigmastate.Values.Value[sigmastate.SType], o1: sigmastate.utils.Overloading.Overload1) -> 'Terms.Block': ...
        def costKind(self) -> sigmastate.CostKind: ...
        def init(self) -> None: ...
        def opCode(self) -> int: ...
        def opDesc(self) -> sigmastate.interpreter.CompanionDesc: ...
        def sigmastate$Values$ValueCompanion$_setter_$opDesc_$eq(self, x$1: sigmastate.interpreter.CompanionDesc) -> None: ...
        def toString(self) -> java.lang.String: ...
        def typeName(self) -> java.lang.String: ...
        def unapply(self, x$0: 'Terms.Block') -> scala.Option[scala.Tuple2[scala.collection.Seq['Terms.Val'], sigmastate.Values.Value[sigmastate.SType]]]: ...
    class Ident(sigmastate.Values.Value[sigmastate.SType], scala.Serializable):
        def __init__(self, name: typing.Union[java.lang.String, str], tpe: sigmastate.SType): ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        def companion(self) -> 'Terms.Ident.': ...
        def copy(self, name: typing.Union[java.lang.String, str], tpe: sigmastate.SType) -> 'Terms.Ident': ...
        def copy$default$1(self) -> java.lang.String: ...
        def copy$default$2(self) -> sigmastate.SType: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def name(self) -> java.lang.String: ...
        def opType(self) -> sigmastate.SFunc: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
        def tpe(self) -> sigmastate.SType: ...
        class : ...
    class Ident$(sigmastate.Values.ValueCompanion, scala.Serializable):
        MODULE$: typing.ClassVar['Terms.Ident.'] = ...
        def __init__(self): ...
        def $lessinit$greater$default$2(self) -> sigmastate.SType: ...
        @typing.overload
        def apply(self, name: typing.Union[java.lang.String, str]) -> 'Terms.Ident': ...
        @typing.overload
        def apply(self, name: typing.Union[java.lang.String, str], tpe: sigmastate.SType) -> 'Terms.Ident': ...
        def apply$default$2(self) -> sigmastate.SType: ...
        def costKind(self) -> sigmastate.CostKind: ...
        def init(self) -> None: ...
        def opCode(self) -> int: ...
        def opDesc(self) -> sigmastate.interpreter.CompanionDesc: ...
        def sigmastate$Values$ValueCompanion$_setter_$opDesc_$eq(self, x$1: sigmastate.interpreter.CompanionDesc) -> None: ...
        def toString(self) -> java.lang.String: ...
        def typeName(self) -> java.lang.String: ...
        def unapply(self, x$0: 'Terms.Ident') -> scala.Option[scala.Tuple2[java.lang.String, sigmastate.SType]]: ...
    class Lambda(sigmastate.Values.Value[sigmastate.SFunc], scala.Serializable):
        def __init__(self, tpeParams: scala.collection.Seq['Terms.STypeParam'], args: scala.collection.IndexedSeq[scala.Tuple2[typing.Union[java.lang.String, str], sigmastate.SType]], givenResType: sigmastate.SType, body: scala.Option[sigmastate.Values.Value[sigmastate.SType]]): ...
        def args(self) -> scala.collection.IndexedSeq[scala.Tuple2[java.lang.String, sigmastate.SType]]: ...
        def body(self) -> scala.Option[sigmastate.Values.Value[sigmastate.SType]]: ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        def companion(self) -> 'Terms.Lambda.': ...
        def copy(self, tpeParams: scala.collection.Seq['Terms.STypeParam'], args: scala.collection.IndexedSeq[scala.Tuple2[typing.Union[java.lang.String, str], sigmastate.SType]], givenResType: sigmastate.SType, body: scala.Option[sigmastate.Values.Value[sigmastate.SType]]) -> 'Terms.Lambda': ...
        def copy$default$1(self) -> scala.collection.Seq['Terms.STypeParam']: ...
        def copy$default$2(self) -> scala.collection.IndexedSeq[scala.Tuple2[java.lang.String, sigmastate.SType]]: ...
        def copy$default$3(self) -> sigmastate.SType: ...
        def copy$default$4(self) -> scala.Option[sigmastate.Values.Value[sigmastate.SType]]: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def givenResType(self) -> sigmastate.SType: ...
        def hashCode(self) -> int: ...
        def opType(self) -> sigmastate.SFunc: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
        def tpe(self) -> sigmastate.SFunc: ...
        def tpeParams(self) -> scala.collection.Seq['Terms.STypeParam']: ...
        class : ...
    class Lambda$(sigmastate.Values.ValueCompanion, scala.Serializable):
        MODULE$: typing.ClassVar['Terms.Lambda.'] = ...
        def __init__(self): ...
        @typing.overload
        def apply(self, args: scala.collection.IndexedSeq[scala.Tuple2[typing.Union[java.lang.String, str], sigmastate.SType]], resTpe: sigmastate.SType, body: scala.Option[sigmastate.Values.Value[sigmastate.SType]]) -> 'Terms.Lambda': ...
        @typing.overload
        def apply(self, args: scala.collection.IndexedSeq[scala.Tuple2[typing.Union[java.lang.String, str], sigmastate.SType]], resTpe: sigmastate.SType, body: sigmastate.Values.Value[sigmastate.SType]) -> 'Terms.Lambda': ...
        @typing.overload
        def apply(self, args: scala.collection.IndexedSeq[scala.Tuple2[typing.Union[java.lang.String, str], sigmastate.SType]], body: sigmastate.Values.Value[sigmastate.SType]) -> 'Terms.Lambda': ...
        @typing.overload
        def apply(self, tpeParams: scala.collection.Seq['Terms.STypeParam'], args: scala.collection.IndexedSeq[scala.Tuple2[typing.Union[java.lang.String, str], sigmastate.SType]], givenResType: sigmastate.SType, body: scala.Option[sigmastate.Values.Value[sigmastate.SType]]) -> 'Terms.Lambda': ...
        def costKind(self) -> sigmastate.CostKind: ...
        def init(self) -> None: ...
        def opCode(self) -> int: ...
        def opDesc(self) -> sigmastate.interpreter.CompanionDesc: ...
        def sigmastate$Values$ValueCompanion$_setter_$opDesc_$eq(self, x$1: sigmastate.interpreter.CompanionDesc) -> None: ...
        def toString(self) -> java.lang.String: ...
        def typeName(self) -> java.lang.String: ...
        def unapply(self, x$0: 'Terms.Lambda') -> scala.Option[scala.Tuple4[scala.collection.Seq['Terms.STypeParam'], scala.collection.IndexedSeq[scala.Tuple2[java.lang.String, sigmastate.SType]], sigmastate.SType, scala.Option[sigmastate.Values.Value[sigmastate.SType]]]]: ...
    class MethodCall(sigmastate.Values.Value[sigmastate.SType], scala.Serializable):
        def __init__(self, obj: sigmastate.Values.Value[sigmastate.SType], method: sigmastate.SMethod, args: scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]], typeSubst: scala.collection.immutable.Map[sigmastate.STypeVar, sigmastate.SType]): ...
        def args(self) -> scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]]: ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        def companion(self) -> sigmastate.Values.ValueCompanion: ...
        def copy(self, obj: sigmastate.Values.Value[sigmastate.SType], method: sigmastate.SMethod, args: scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]], typeSubst: scala.collection.immutable.Map[sigmastate.STypeVar, sigmastate.SType]) -> 'Terms.MethodCall': ...
        def copy$default$1(self) -> sigmastate.Values.Value[sigmastate.SType]: ...
        def copy$default$2(self) -> sigmastate.SMethod: ...
        def copy$default$3(self) -> scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]]: ...
        def copy$default$4(self) -> scala.collection.immutable.Map[sigmastate.STypeVar, sigmastate.SType]: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def eval(self, env: scala.collection.immutable.Map[typing.Any, typing.Any], E: sigmastate.interpreter.ErgoTreeEvaluator) -> typing.Any: ...
        def hashCode(self) -> int: ...
        def method(self) -> sigmastate.SMethod: ...
        def obj(self) -> sigmastate.Values.Value[sigmastate.SType]: ...
        def opType(self) -> sigmastate.SFunc: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
        def tpe(self) -> sigmastate.SType: ...
        def typeSubst(self) -> scala.collection.immutable.Map[sigmastate.STypeVar, sigmastate.SType]: ...
    class MethodCall$(sigmastate.Values.ValueCompanion, scala.Serializable):
        MODULE$: typing.ClassVar['Terms.MethodCall.'] = ...
        def __init__(self): ...
        def apply(self, obj: sigmastate.Values.Value[sigmastate.SType], method: sigmastate.SMethod, args: scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]], typeSubst: scala.collection.immutable.Map[sigmastate.STypeVar, sigmastate.SType]) -> 'Terms.MethodCall': ...
        def costKind(self) -> sigmastate.FixedCost: ...
        def init(self) -> None: ...
        def opCode(self) -> int: ...
        def opDesc(self) -> sigmastate.interpreter.CompanionDesc: ...
        def sigmastate$Values$ValueCompanion$_setter_$opDesc_$eq(self, x$1: sigmastate.interpreter.CompanionDesc) -> None: ...
        def toString(self) -> java.lang.String: ...
        def typeName(self) -> java.lang.String: ...
        _typed__T = typing.TypeVar('_typed__T', bound=sigmastate.Values.Value)  # <T>
        def typed(self, obj: sigmastate.Values.Value[sigmastate.SType], method: sigmastate.SMethod, args: scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]], typeSubst: scala.collection.immutable.Map[sigmastate.STypeVar, sigmastate.SType]) -> _typed__T: ...
        def unapply(self, x$0: 'Terms.MethodCall') -> scala.Option[scala.Tuple4[sigmastate.Values.Value[sigmastate.SType], sigmastate.SMethod, scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]], scala.collection.immutable.Map[sigmastate.STypeVar, sigmastate.SType]]]: ...
    class MethodCallLike(sigmastate.Values.Value[sigmastate.SType], scala.Serializable):
        def __init__(self, obj: sigmastate.Values.Value[sigmastate.SType], name: typing.Union[java.lang.String, str], args: scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]], tpe: sigmastate.SType): ...
        def args(self) -> scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]]: ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        def companion(self) -> 'Terms.MethodCallLike.': ...
        def copy(self, obj: sigmastate.Values.Value[sigmastate.SType], name: typing.Union[java.lang.String, str], args: scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]], tpe: sigmastate.SType) -> 'Terms.MethodCallLike': ...
        def copy$default$1(self) -> sigmastate.Values.Value[sigmastate.SType]: ...
        def copy$default$2(self) -> java.lang.String: ...
        def copy$default$3(self) -> scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]]: ...
        def copy$default$4(self) -> sigmastate.SType: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def name(self) -> java.lang.String: ...
        def obj(self) -> sigmastate.Values.Value[sigmastate.SType]: ...
        def opType(self) -> sigmastate.SFunc: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
        def tpe(self) -> sigmastate.SType: ...
        class : ...
    class MethodCallLike$(sigmastate.Values.ValueCompanion, scala.Serializable):
        MODULE$: typing.ClassVar['Terms.MethodCallLike.'] = ...
        def __init__(self): ...
        def $lessinit$greater$default$4(self) -> sigmastate.SType: ...
        def apply(self, obj: sigmastate.Values.Value[sigmastate.SType], name: typing.Union[java.lang.String, str], args: scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]], tpe: sigmastate.SType) -> 'Terms.MethodCallLike': ...
        def apply$default$4(self) -> sigmastate.SType: ...
        def costKind(self) -> sigmastate.CostKind: ...
        def init(self) -> None: ...
        def opCode(self) -> int: ...
        def opDesc(self) -> sigmastate.interpreter.CompanionDesc: ...
        def sigmastate$Values$ValueCompanion$_setter_$opDesc_$eq(self, x$1: sigmastate.interpreter.CompanionDesc) -> None: ...
        def toString(self) -> java.lang.String: ...
        def typeName(self) -> java.lang.String: ...
        def unapply(self, x$0: 'Terms.MethodCallLike') -> scala.Option[scala.Tuple4[sigmastate.Values.Value[sigmastate.SType], java.lang.String, scala.collection.IndexedSeq[sigmastate.Values.Value[sigmastate.SType]], sigmastate.SType]]: ...
    class OperationId(scala.Product, scala.Serializable):
        def __init__(self, name: typing.Union[java.lang.String, str], opType: sigmastate.SFunc): ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        def copy(self, name: typing.Union[java.lang.String, str], opType: sigmastate.SFunc) -> 'Terms.OperationId': ...
        def copy$default$1(self) -> java.lang.String: ...
        def copy$default$2(self) -> sigmastate.SFunc: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def name(self) -> java.lang.String: ...
        def opType(self) -> sigmastate.SFunc: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
    class OperationId$(scala.runtime.AbstractFunction2[java.lang.String, sigmastate.SFunc, 'Terms.OperationId'], scala.Serializable):
        MODULE$: typing.ClassVar['Terms.OperationId.'] = ...
        def __init__(self): ...
        def apply(self, name: typing.Union[java.lang.String, str], opType: sigmastate.SFunc) -> 'Terms.OperationId': ...
        def toString(self) -> java.lang.String: ...
        def unapply(self, x$0: 'Terms.OperationId') -> scala.Option[scala.Tuple2[java.lang.String, sigmastate.SFunc]]: ...
    class PropertyCall$(sigmastate.Values.FixedCostValueCompanion):
        MODULE$: typing.ClassVar['Terms.PropertyCall.'] = ...
        def __init__(self): ...
        def costKind(self) -> sigmastate.FixedCost: ...
        def init(self) -> None: ...
        def opCode(self) -> int: ...
        def opDesc(self) -> sigmastate.interpreter.CompanionDesc: ...
        def sigmastate$Values$ValueCompanion$_setter_$opDesc_$eq(self, x$1: sigmastate.interpreter.CompanionDesc) -> None: ...
        def toString(self) -> java.lang.String: ...
        def typeName(self) -> java.lang.String: ...
    class STypeParam(scala.Product, scala.Serializable):
        def __init__(self, ident: sigmastate.STypeVar, upperBound: scala.Option[sigmastate.SType], lowerBound: scala.Option[sigmastate.SType]): ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        def copy(self, ident: sigmastate.STypeVar, upperBound: scala.Option[sigmastate.SType], lowerBound: scala.Option[sigmastate.SType]) -> 'Terms.STypeParam': ...
        def copy$default$1(self) -> sigmastate.STypeVar: ...
        def copy$default$2(self) -> scala.Option[sigmastate.SType]: ...
        def copy$default$3(self) -> scala.Option[sigmastate.SType]: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def ident(self) -> sigmastate.STypeVar: ...
        def lowerBound(self) -> scala.Option[sigmastate.SType]: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
        def upperBound(self) -> scala.Option[sigmastate.SType]: ...
    class STypeParam$(scala.Serializable):
        MODULE$: typing.ClassVar['Terms.STypeParam.'] = ...
        def __init__(self): ...
        def $lessinit$greater$default$2(self) -> scala.Option[sigmastate.SType]: ...
        def $lessinit$greater$default$3(self) -> scala.Option[sigmastate.SType]: ...
        def apply(self, ident: sigmastate.STypeVar, upperBound: scala.Option[sigmastate.SType], lowerBound: scala.Option[sigmastate.SType]) -> 'Terms.STypeParam': ...
        def apply$default$2(self) -> scala.Option[sigmastate.SType]: ...
        def apply$default$3(self) -> scala.Option[sigmastate.SType]: ...
        def typeIdentToTypeParam(self, id: sigmastate.STypeVar) -> 'Terms.STypeParam': ...
        def unapply(self, x$0: 'Terms.STypeParam') -> scala.Option[scala.Tuple3[sigmastate.STypeVar, scala.Option[sigmastate.SType], scala.Option[sigmastate.SType]]]: ...
    class Select(sigmastate.Values.Value[sigmastate.SType], scala.Serializable):
        def __init__(self, obj: sigmastate.Values.Value[sigmastate.SType], field: typing.Union[java.lang.String, str], resType: scala.Option[sigmastate.SType]): ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        def companion(self) -> 'Terms.Select.': ...
        def copy(self, obj: sigmastate.Values.Value[sigmastate.SType], field: typing.Union[java.lang.String, str], resType: scala.Option[sigmastate.SType]) -> 'Terms.Select': ...
        def copy$default$1(self) -> sigmastate.Values.Value[sigmastate.SType]: ...
        def copy$default$2(self) -> java.lang.String: ...
        def copy$default$3(self) -> scala.Option[sigmastate.SType]: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def field(self) -> java.lang.String: ...
        def hashCode(self) -> int: ...
        def obj(self) -> sigmastate.Values.Value[sigmastate.SType]: ...
        def opType(self) -> sigmastate.SFunc: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def resType(self) -> scala.Option[sigmastate.SType]: ...
        def toString(self) -> java.lang.String: ...
        def tpe(self) -> sigmastate.SType: ...
        class : ...
    class Select$(sigmastate.Values.ValueCompanion, scala.Serializable):
        MODULE$: typing.ClassVar['Terms.Select.'] = ...
        def __init__(self): ...
        def $lessinit$greater$default$3(self) -> scala.Option[sigmastate.SType]: ...
        def apply(self, obj: sigmastate.Values.Value[sigmastate.SType], field: typing.Union[java.lang.String, str], resType: scala.Option[sigmastate.SType]) -> 'Terms.Select': ...
        def apply$default$3(self) -> scala.Option[sigmastate.SType]: ...
        def costKind(self) -> sigmastate.CostKind: ...
        def init(self) -> None: ...
        def opCode(self) -> int: ...
        def opDesc(self) -> sigmastate.interpreter.CompanionDesc: ...
        def sigmastate$Values$ValueCompanion$_setter_$opDesc_$eq(self, x$1: sigmastate.interpreter.CompanionDesc) -> None: ...
        def toString(self) -> java.lang.String: ...
        def typeName(self) -> java.lang.String: ...
        def unapply(self, x$0: 'Terms.Select') -> scala.Option[scala.Tuple3[sigmastate.Values.Value[sigmastate.SType], java.lang.String, scala.Option[sigmastate.SType]]]: ...
    class Val:
        def body(self) -> sigmastate.Values.Value[sigmastate.SType]: ...
        def givenType(self) -> sigmastate.SType: ...
        def name(self) -> java.lang.String: ...
    class Val$:
        MODULE$: typing.ClassVar['Terms.Val.'] = ...
        def __init__(self): ...
        @typing.overload
        def apply(self, name: typing.Union[java.lang.String, str], givenType: sigmastate.SType, body: sigmastate.Values.Value[sigmastate.SType]) -> 'Terms.Val': ...
        @typing.overload
        def apply(self, name: typing.Union[java.lang.String, str], body: sigmastate.Values.Value[sigmastate.SType]) -> 'Terms.Val': ...
        def unapply(self, v: sigmastate.Values.Value[sigmastate.SType]) -> scala.Option[scala.Tuple3[java.lang.String, sigmastate.SType, sigmastate.Values.Value[sigmastate.SType]]]: ...
    class ValNode(sigmastate.Values.Value[sigmastate.SType], sigmastate.lang.Terms.Val, scala.Serializable):
        def __init__(self, name: typing.Union[java.lang.String, str], givenType: sigmastate.SType, body: sigmastate.Values.Value[sigmastate.SType]): ...
        def body(self) -> sigmastate.Values.Value[sigmastate.SType]: ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        def companion(self) -> 'Terms.ValNode.': ...
        def copy(self, name: typing.Union[java.lang.String, str], givenType: sigmastate.SType, body: sigmastate.Values.Value[sigmastate.SType]) -> 'Terms.ValNode': ...
        def copy$default$1(self) -> java.lang.String: ...
        def copy$default$2(self) -> sigmastate.SType: ...
        def copy$default$3(self) -> sigmastate.Values.Value[sigmastate.SType]: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def givenType(self) -> sigmastate.SType: ...
        def hashCode(self) -> int: ...
        def name(self) -> java.lang.String: ...
        def opType(self) -> sigmastate.SFunc: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
        def tpe(self) -> sigmastate.SType: ...
        class : ...
    class ValNode$(sigmastate.Values.ValueCompanion, scala.Serializable):
        MODULE$: typing.ClassVar['Terms.ValNode.'] = ...
        def __init__(self): ...
        def apply(self, name: typing.Union[java.lang.String, str], givenType: sigmastate.SType, body: sigmastate.Values.Value[sigmastate.SType]) -> 'Terms.ValNode': ...
        def costKind(self) -> sigmastate.CostKind: ...
        def init(self) -> None: ...
        def opCode(self) -> int: ...
        def opDesc(self) -> sigmastate.interpreter.CompanionDesc: ...
        def sigmastate$Values$ValueCompanion$_setter_$opDesc_$eq(self, x$1: sigmastate.interpreter.CompanionDesc) -> None: ...
        def toString(self) -> java.lang.String: ...
        def typeName(self) -> java.lang.String: ...
        def unapply(self, x$0: 'Terms.ValNode') -> scala.Option[scala.Tuple3[java.lang.String, sigmastate.SType, sigmastate.Values.Value[sigmastate.SType]]]: ...
    class ValueOps:
        def __init__(self, v: sigmastate.Values.Value[sigmastate.SType]): ...
        def asBigInt(self) -> sigmastate.Values.Value[sigmastate.SBigInt.]: ...
        def asBoolValue(self) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
        def asBox(self) -> sigmastate.Values.Value[sigmastate.SBox.]: ...
        def asByteArray(self) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
        def asByteValue(self) -> sigmastate.Values.Value[sigmastate.SByte.]: ...
        _asCollection__T = typing.TypeVar('_asCollection__T', bound=sigmastate.SType)  # <T>
        def asCollection(self) -> sigmastate.Values.Value[sigmastate.SCollection[_asCollection__T]]: ...
        _asConcreteCollection__T = typing.TypeVar('_asConcreteCollection__T', bound=sigmastate.SType)  # <T>
        def asConcreteCollection(self) -> sigmastate.Values.ConcreteCollection[_asConcreteCollection__T]: ...
        def asFunc(self) -> sigmastate.Values.Value[sigmastate.SFunc]: ...
        def asGroupElement(self) -> sigmastate.Values.Value[sigmastate.SGroupElement.]: ...
        def asIntArray(self) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SInt.]]: ...
        def asIntValue(self) -> sigmastate.Values.Value[sigmastate.SInt.]: ...
        def asLongValue(self) -> sigmastate.Values.Value[sigmastate.SLong.]: ...
        def asNumValue(self) -> sigmastate.Values.Value[sigmastate.SNumericType]: ...
        _asOption__T = typing.TypeVar('_asOption__T', bound=sigmastate.SType)  # <T>
        def asOption(self) -> sigmastate.Values.Value[sigmastate.SOption[_asOption__T]]: ...
        def asShortValue(self) -> sigmastate.Values.Value[sigmastate.SShort.]: ...
        def asSigmaProp(self) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...
        def asStringValue(self) -> sigmastate.Values.Value[sigmastate.SString.]: ...
        def asTuple(self) -> sigmastate.Values.Value[sigmastate.STuple]: ...
        _asValue__T = typing.TypeVar('_asValue__T', bound=sigmastate.SType)  # <T>
        def asValue(self) -> sigmastate.Values.Value[_asValue__T]: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        _upcastTo__T = typing.TypeVar('_upcastTo__T', bound=sigmastate.SNumericType)  # <T>
        def upcastTo(self, targetType: _upcastTo__T) -> sigmastate.Values.Value[_upcastTo__T]: ...
        def v(self) -> sigmastate.Values.Value[sigmastate.SType]: ...
        _withEnsuredSrcCtx__T = typing.TypeVar('_withEnsuredSrcCtx__T', bound=sigmastate.SType)  # <T>
        def withEnsuredSrcCtx(self, sourceContext: SourceContext) -> sigmastate.Values.Value[_withEnsuredSrcCtx__T]: ...
        _withPropagatedSrcCtx__T = typing.TypeVar('_withPropagatedSrcCtx__T', bound=sigmastate.SType)  # <T>
        def withPropagatedSrcCtx(self, srcCtx: SourceContext) -> sigmastate.Values.Value[_withPropagatedSrcCtx__T]: ...
        _withSrcCtx__T = typing.TypeVar('_withSrcCtx__T', bound=sigmastate.SType)  # <T>
        def withSrcCtx(self, sourceContext: SourceContext) -> sigmastate.Values.Value[_withSrcCtx__T]: ...
    class ValueOps$:
        MODULE$: typing.ClassVar['Terms.ValueOps.'] = ...
        def __init__(self): ...
        def asBigInt$extension(self, $this: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SBigInt.]: ...
        def asBoolValue$extension(self, $this: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
        def asBox$extension(self, $this: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SBox.]: ...
        def asByteArray$extension(self, $this: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SByte.]]: ...
        def asByteValue$extension(self, $this: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SByte.]: ...
        _asCollection$extension__T = typing.TypeVar('_asCollection$extension__T', bound=sigmastate.SType)  # <T>
        def asCollection$extension(self, $this: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SCollection[_asCollection.extension__T]]: ...
        _asConcreteCollection$extension__T = typing.TypeVar('_asConcreteCollection$extension__T', bound=sigmastate.SType)  # <T>
        def asConcreteCollection$extension(self, $this: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.ConcreteCollection[_asConcreteCollection.extension__T]: ...
        def asFunc$extension(self, $this: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SFunc]: ...
        def asGroupElement$extension(self, $this: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SGroupElement.]: ...
        def asIntArray$extension(self, $this: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SInt.]]: ...
        def asIntValue$extension(self, $this: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SInt.]: ...
        def asLongValue$extension(self, $this: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SLong.]: ...
        def asNumValue$extension(self, $this: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SNumericType]: ...
        _asOption$extension__T = typing.TypeVar('_asOption$extension__T', bound=sigmastate.SType)  # <T>
        def asOption$extension(self, $this: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SOption[_asOption.extension__T]]: ...
        def asShortValue$extension(self, $this: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SShort.]: ...
        def asSigmaProp$extension(self, $this: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...
        def asStringValue$extension(self, $this: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.SString.]: ...
        def asTuple$extension(self, $this: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[sigmastate.STuple]: ...
        _asValue$extension__T = typing.TypeVar('_asValue$extension__T', bound=sigmastate.SType)  # <T>
        def asValue$extension(self, $this: sigmastate.Values.Value[sigmastate.SType]) -> sigmastate.Values.Value[_asValue.extension__T]: ...
        def equals$extension(self, $this: sigmastate.Values.Value, x$1: typing.Any) -> bool: ...
        def hashCode$extension(self, $this: sigmastate.Values.Value) -> int: ...
        _upcastTo$extension__T = typing.TypeVar('_upcastTo$extension__T', bound=sigmastate.SNumericType)  # <T>
        def upcastTo$extension(self, $this: sigmastate.Values.Value[sigmastate.SType], targetType: _upcastTo.extension__T) -> sigmastate.Values.Value[_upcastTo.extension__T]: ...
        _withEnsuredSrcCtx$extension__T = typing.TypeVar('_withEnsuredSrcCtx$extension__T', bound=sigmastate.SType)  # <T>
        def withEnsuredSrcCtx$extension(self, $this: sigmastate.Values.Value[sigmastate.SType], sourceContext: SourceContext) -> sigmastate.Values.Value[_withEnsuredSrcCtx.extension__T]: ...
        _withPropagatedSrcCtx$extension__T = typing.TypeVar('_withPropagatedSrcCtx$extension__T', bound=sigmastate.SType)  # <T>
        def withPropagatedSrcCtx$extension(self, $this: sigmastate.Values.Value[sigmastate.SType], srcCtx: SourceContext) -> sigmastate.Values.Value[_withPropagatedSrcCtx.extension__T]: ...
        _withSrcCtx$extension__T = typing.TypeVar('_withSrcCtx$extension__T', bound=sigmastate.SType)  # <T>
        def withSrcCtx$extension(self, $this: sigmastate.Values.Value[sigmastate.SType], sourceContext: SourceContext) -> sigmastate.Values.Value[_withSrcCtx.extension__T]: ...
    class ZKProofBlock(sigmastate.Values.Value[sigmastate.SBoolean.], scala.Serializable):
        def __init__(self, body: sigmastate.Values.Value[sigmastate.SSigmaProp.]): ...
        def body(self) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...
        def canEqual(self, x$1: typing.Any) -> bool: ...
        def companion(self) -> 'Terms.ZKProofBlock.': ...
        def copy(self, body: sigmastate.Values.Value[sigmastate.SSigmaProp.]) -> 'Terms.ZKProofBlock': ...
        def copy$default$1(self) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...
        def equals(self, x$1: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def opType(self) -> sigmastate.SFunc: ...
        def productArity(self) -> int: ...
        def productElement(self, x$1: int) -> typing.Any: ...
        def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
        def productPrefix(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
        def tpe(self) -> sigmastate.SBoolean.: ...
        class : ...
    class ZKProofBlock$(sigmastate.Values.ValueCompanion, scala.Serializable):
        MODULE$: typing.ClassVar['Terms.ZKProofBlock.'] = ...
        def __init__(self): ...
        def OpType(self) -> sigmastate.SFunc: ...
        def apply(self, body: sigmastate.Values.Value[sigmastate.SSigmaProp.]) -> 'Terms.ZKProofBlock': ...
        def costKind(self) -> sigmastate.CostKind: ...
        def init(self) -> None: ...
        def opCode(self) -> int: ...
        def opDesc(self) -> sigmastate.interpreter.CompanionDesc: ...
        def sigmastate$Values$ValueCompanion$_setter_$opDesc_$eq(self, x$1: sigmastate.interpreter.CompanionDesc) -> None: ...
        def toString(self) -> java.lang.String: ...
        def typeName(self) -> java.lang.String: ...
        def unapply(self, x$0: 'Terms.ZKProofBlock') -> scala.Option[sigmastate.Values.Value[sigmastate.SSigmaProp.]]: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("sigmastate.lang")``.

    CheckingSigmaBuilder: typing.Type[CheckingSigmaBuilder]
    CompilerSettings: typing.Type[CompilerSettings]
    Constraints: typing.Type[Constraints]
    DeserializationSigmaBuilder: typing.Type[DeserializationSigmaBuilder]
    SigmaBinder: typing.Type[SigmaBinder]
    SigmaBuilder: typing.Type[SigmaBuilder]
    SigmaCompiler: typing.Type[SigmaCompiler]
    SigmaParser: typing.Type[SigmaParser]
    SigmaPredef: typing.Type[SigmaPredef]
    SigmaPrinter: typing.Type[SigmaPrinter]
    SigmaSpecializer: typing.Type[SigmaSpecializer]
    SigmaTyper: typing.Type[SigmaTyper]
    SourceContext: typing.Type[SourceContext]
    SrcCtxCallbackRewriter: typing.Type[SrcCtxCallbackRewriter]
    StdSigmaBuilder: typing.Type[StdSigmaBuilder]
    Terms: typing.Type[Terms]
    TransformingSigmaBuilder: typing.Type[TransformingSigmaBuilder]
    Types: typing.Type[Types]
    exceptions: sigmastate.lang.exceptions.__module_protocol__
    syntax: sigmastate.lang.syntax.__module_protocol__
