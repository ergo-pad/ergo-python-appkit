import java.lang
import org.bouncycastle.math.ec.custom.sec
import org.ergoplatform
import scala
import scala.collection
import sigmastate
import sigmastate.basics
import sigmastate.serialization
import sigmastate.utils
import sigmastate.utxo
import typing



class AppendSerializer(sigmastate.serialization.ValueSerializer[sigmastate.utxo.Append[sigmastate.SType]], scala.Product, scala.Serializable):
    def __init__(self, cons: scala.Function2[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]]]): ...
    _andThen__A = typing.TypeVar('_andThen__A')  # <A>
    @staticmethod
    def andThen(g: scala.Function1['AppendSerializer', _andThen__A]) -> scala.Function1[scala.Function2[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]]], _andThen__A]: ...
    @staticmethod
    def apply(cons: scala.Function2[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]]]) -> 'AppendSerializer': ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    @staticmethod
    def compose(g: scala.Function1[_compose__A, scala.Function2[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]]]]) -> scala.Function1[_compose__A, 'AppendSerializer']: ...
    def cons(self) -> scala.Function2[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]]]: ...
    def copy(self, cons: scala.Function2[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]]]) -> 'AppendSerializer': ...
    def copy$default$1(self) -> scala.Function2[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]]]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def opDesc(self) -> sigmastate.utxo.Append.: ...
    def parse(self, r: sigmastate.utils.SigmaByteReader) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]]: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def serialize(self, obj: sigmastate.utxo.Append[sigmastate.SType], w: sigmastate.utils.SigmaByteWriter) -> None: ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def unapply(x$0: 'AppendSerializer') -> scala.Option[scala.Function2[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]]]]: ...

class AtLeastSerializer(sigmastate.serialization.ValueSerializer[sigmastate.AtLeast], scala.Product, scala.Serializable):
    def __init__(self, cons: scala.Function2[sigmastate.Values.Value[sigmastate.SInt.], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SSigmaProp.]], sigmastate.Values.Value[sigmastate.SSigmaProp.]]): ...
    _andThen__A = typing.TypeVar('_andThen__A')  # <A>
    @staticmethod
    def andThen(g: scala.Function1['AtLeastSerializer', _andThen__A]) -> scala.Function1[scala.Function2[sigmastate.Values.Value[sigmastate.SInt.], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SSigmaProp.]], sigmastate.Values.Value[sigmastate.SSigmaProp.]], _andThen__A]: ...
    @staticmethod
    def apply(cons: scala.Function2[sigmastate.Values.Value[sigmastate.SInt.], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SSigmaProp.]], sigmastate.Values.Value[sigmastate.SSigmaProp.]]) -> 'AtLeastSerializer': ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    @staticmethod
    def compose(g: scala.Function1[_compose__A, scala.Function2[sigmastate.Values.Value[sigmastate.SInt.], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SSigmaProp.]], sigmastate.Values.Value[sigmastate.SSigmaProp.]]]) -> scala.Function1[_compose__A, 'AtLeastSerializer']: ...
    def cons(self) -> scala.Function2[sigmastate.Values.Value[sigmastate.SInt.], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SSigmaProp.]], sigmastate.Values.Value[sigmastate.SSigmaProp.]]: ...
    def copy(self, cons: scala.Function2[sigmastate.Values.Value[sigmastate.SInt.], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SSigmaProp.]], sigmastate.Values.Value[sigmastate.SSigmaProp.]]) -> 'AtLeastSerializer': ...
    def copy$default$1(self) -> scala.Function2[sigmastate.Values.Value[sigmastate.SInt.], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SSigmaProp.]], sigmastate.Values.Value[sigmastate.SSigmaProp.]]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def opDesc(self) -> sigmastate.AtLeast.: ...
    def parse(self, r: sigmastate.utils.SigmaByteReader) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def serialize(self, obj: sigmastate.AtLeast, w: sigmastate.utils.SigmaByteWriter) -> None: ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def unapply(x$0: 'AtLeastSerializer') -> scala.Option[scala.Function2[sigmastate.Values.Value[sigmastate.SInt.], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SSigmaProp.]], sigmastate.Values.Value[sigmastate.SSigmaProp.]]]: ...

_BooleanTransformerSerializer__T = typing.TypeVar('_BooleanTransformerSerializer__T', bound=sigmastate.SType)  # <T>
class BooleanTransformerSerializer(sigmastate.serialization.ValueSerializer[sigmastate.utxo.BooleanTransformer[_BooleanTransformerSerializer__T]], scala.Product, scala.Serializable, typing.Generic[_BooleanTransformerSerializer__T]):
    def __init__(self, opDesc: sigmastate.utxo.BooleanTransformerCompanion, f: scala.Function2[sigmastate.Values.Value[sigmastate.SCollection[_BooleanTransformerSerializer__T]], sigmastate.Values.Value[sigmastate.SFunc], sigmastate.Values.Value[sigmastate.SBoolean.]]): ...
    _apply__T = typing.TypeVar('_apply__T', bound=sigmastate.SType)  # <T>
    @staticmethod
    def apply(opDesc: sigmastate.utxo.BooleanTransformerCompanion, f: scala.Function2[sigmastate.Values.Value[sigmastate.SCollection[_apply__T]], sigmastate.Values.Value[sigmastate.SFunc], sigmastate.Values.Value[sigmastate.SBoolean.]]) -> 'BooleanTransformerSerializer'[_apply__T]: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def conditionInfo(self) -> sigmastate.utils.SigmaByteWriter.DataInfo[sigmastate.Values.Value[sigmastate.SType]]: ...
    _copy__T = typing.TypeVar('_copy__T', bound=sigmastate.SType)  # <T>
    def copy(self, opDesc: sigmastate.utxo.BooleanTransformerCompanion, f: scala.Function2[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SFunc], sigmastate.Values.Value[sigmastate.SBoolean.]]) -> 'BooleanTransformerSerializer'[sigmastate.SType]: ...
    _copy$default$1__T = typing.TypeVar('_copy$default$1__T', bound=sigmastate.SType)  # <T>
    def copy$default$1(self) -> sigmastate.utxo.BooleanTransformerCompanion: ...
    _copy$default$2__T = typing.TypeVar('_copy$default$2__T', bound=sigmastate.SType)  # <T>
    def copy$default$2(self) -> scala.Function2[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SFunc], sigmastate.Values.Value[sigmastate.SBoolean.]]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def f(self) -> scala.Function2[sigmastate.Values.Value[sigmastate.SCollection[_BooleanTransformerSerializer__T]], sigmastate.Values.Value[sigmastate.SFunc], sigmastate.Values.Value[sigmastate.SBoolean.]]: ...
    def hashCode(self) -> int: ...
    def inputInfo(self) -> sigmastate.utils.SigmaByteWriter.DataInfo[sigmastate.Values.Value[sigmastate.SType]]: ...
    def opDesc(self) -> sigmastate.utxo.BooleanTransformerCompanion: ...
    def parse(self, r: sigmastate.utils.SigmaByteReader) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def serialize(self, obj: sigmastate.utxo.BooleanTransformer[_BooleanTransformerSerializer__T], w: sigmastate.utils.SigmaByteWriter) -> None: ...
    def toString(self) -> java.lang.String: ...
    _unapply__T = typing.TypeVar('_unapply__T', bound=sigmastate.SType)  # <T>
    @staticmethod
    def unapply(x$0: 'BooleanTransformerSerializer'[_unapply__T]) -> scala.Option[scala.Tuple2[sigmastate.utxo.BooleanTransformerCompanion, scala.Function2[sigmastate.Values.Value[sigmastate.SCollection[_unapply__T]], sigmastate.Values.Value[sigmastate.SFunc], sigmastate.Values.Value[sigmastate.SBoolean.]]]]: ...

class ByIndexSerializer(sigmastate.serialization.ValueSerializer[sigmastate.utxo.ByIndex[sigmastate.SType]], scala.Product, scala.Serializable):
    def __init__(self, cons: scala.Function3[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SInt.], scala.Option[sigmastate.Values.Value[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SType]]): ...
    _andThen__A = typing.TypeVar('_andThen__A')  # <A>
    @staticmethod
    def andThen(g: scala.Function1['ByIndexSerializer', _andThen__A]) -> scala.Function1[scala.Function3[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SInt.], scala.Option[sigmastate.Values.Value[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SType]], _andThen__A]: ...
    @staticmethod
    def apply(cons: scala.Function3[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SInt.], scala.Option[sigmastate.Values.Value[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SType]]) -> 'ByIndexSerializer': ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    @staticmethod
    def compose(g: scala.Function1[_compose__A, scala.Function3[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SInt.], scala.Option[sigmastate.Values.Value[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SType]]]) -> scala.Function1[_compose__A, 'ByIndexSerializer']: ...
    def cons(self) -> scala.Function3[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SInt.], scala.Option[sigmastate.Values.Value[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SType]]: ...
    def copy(self, cons: scala.Function3[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SInt.], scala.Option[sigmastate.Values.Value[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SType]]) -> 'ByIndexSerializer': ...
    def copy$default$1(self) -> scala.Function3[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SInt.], scala.Option[sigmastate.Values.Value[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SType]]: ...
    def defaultInfo(self) -> sigmastate.utils.SigmaByteWriter.DataInfo[sigmastate.Values.Value[sigmastate.SType]]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def indexInfo(self) -> sigmastate.utils.SigmaByteWriter.DataInfo[sigmastate.Values.Value[sigmastate.SType]]: ...
    def inputInfo(self) -> sigmastate.utils.SigmaByteWriter.DataInfo[sigmastate.Values.Value[sigmastate.SType]]: ...
    def opDesc(self) -> sigmastate.utxo.ByIndex.: ...
    def parse(self, r: sigmastate.utils.SigmaByteReader) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def serialize(self, obj: sigmastate.utxo.ByIndex[sigmastate.SType], w: sigmastate.utils.SigmaByteWriter) -> None: ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def unapply(x$0: 'ByIndexSerializer') -> scala.Option[scala.Function3[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SInt.], scala.Option[sigmastate.Values.Value[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SType]]]: ...

class CreateProveDHTupleSerializer(sigmastate.serialization.ValueSerializer[sigmastate.CreateProveDHTuple], scala.Product, scala.Serializable):
    def __init__(self, cons: scala.Function4[sigmastate.Values.Value[sigmastate.SGroupElement.], sigmastate.Values.Value[sigmastate.SGroupElement.], sigmastate.Values.Value[sigmastate.SGroupElement.], sigmastate.Values.Value[sigmastate.SGroupElement.], sigmastate.Values.Value[sigmastate.SSigmaProp.]]): ...
    _andThen__A = typing.TypeVar('_andThen__A')  # <A>
    @staticmethod
    def andThen(g: scala.Function1['CreateProveDHTupleSerializer', _andThen__A]) -> scala.Function1[scala.Function4[sigmastate.Values.Value[sigmastate.SGroupElement.], sigmastate.Values.Value[sigmastate.SGroupElement.], sigmastate.Values.Value[sigmastate.SGroupElement.], sigmastate.Values.Value[sigmastate.SGroupElement.], sigmastate.Values.Value[sigmastate.SSigmaProp.]], _andThen__A]: ...
    @staticmethod
    def apply(cons: scala.Function4[sigmastate.Values.Value[sigmastate.SGroupElement.], sigmastate.Values.Value[sigmastate.SGroupElement.], sigmastate.Values.Value[sigmastate.SGroupElement.], sigmastate.Values.Value[sigmastate.SGroupElement.], sigmastate.Values.Value[sigmastate.SSigmaProp.]]) -> 'CreateProveDHTupleSerializer': ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    @staticmethod
    def compose(g: scala.Function1[_compose__A, scala.Function4[sigmastate.Values.Value[sigmastate.SGroupElement.], sigmastate.Values.Value[sigmastate.SGroupElement.], sigmastate.Values.Value[sigmastate.SGroupElement.], sigmastate.Values.Value[sigmastate.SGroupElement.], sigmastate.Values.Value[sigmastate.SSigmaProp.]]]) -> scala.Function1[_compose__A, 'CreateProveDHTupleSerializer']: ...
    def cons(self) -> scala.Function4[sigmastate.Values.Value[sigmastate.SGroupElement.], sigmastate.Values.Value[sigmastate.SGroupElement.], sigmastate.Values.Value[sigmastate.SGroupElement.], sigmastate.Values.Value[sigmastate.SGroupElement.], sigmastate.Values.Value[sigmastate.SSigmaProp.]]: ...
    def copy(self, cons: scala.Function4[sigmastate.Values.Value[sigmastate.SGroupElement.], sigmastate.Values.Value[sigmastate.SGroupElement.], sigmastate.Values.Value[sigmastate.SGroupElement.], sigmastate.Values.Value[sigmastate.SGroupElement.], sigmastate.Values.Value[sigmastate.SSigmaProp.]]) -> 'CreateProveDHTupleSerializer': ...
    def copy$default$1(self) -> scala.Function4[sigmastate.Values.Value[sigmastate.SGroupElement.], sigmastate.Values.Value[sigmastate.SGroupElement.], sigmastate.Values.Value[sigmastate.SGroupElement.], sigmastate.Values.Value[sigmastate.SGroupElement.], sigmastate.Values.Value[sigmastate.SSigmaProp.]]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def opDesc(self) -> sigmastate.CreateProveDHTuple.: ...
    def parse(self, r: sigmastate.utils.SigmaByteReader) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def serialize(self, obj: sigmastate.CreateProveDHTuple, w: sigmastate.utils.SigmaByteWriter) -> None: ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def unapply(x$0: 'CreateProveDHTupleSerializer') -> scala.Option[scala.Function4[sigmastate.Values.Value[sigmastate.SGroupElement.], sigmastate.Values.Value[sigmastate.SGroupElement.], sigmastate.Values.Value[sigmastate.SGroupElement.], sigmastate.Values.Value[sigmastate.SGroupElement.], sigmastate.Values.Value[sigmastate.SSigmaProp.]]]: ...

class DeserializeContextSerializer(sigmastate.serialization.ValueSerializer[sigmastate.utxo.DeserializeContext[sigmastate.SType]], scala.Product, scala.Serializable):
    def __init__(self, cons: scala.Function2[typing.Any, sigmastate.SType, sigmastate.Values.Value[sigmastate.SType]]): ...
    _andThen__A = typing.TypeVar('_andThen__A')  # <A>
    @staticmethod
    def andThen(g: scala.Function1['DeserializeContextSerializer', _andThen__A]) -> scala.Function1[scala.Function2[typing.Any, sigmastate.SType, sigmastate.Values.Value[sigmastate.SType]], _andThen__A]: ...
    @staticmethod
    def apply(cons: scala.Function2[typing.Any, sigmastate.SType, sigmastate.Values.Value[sigmastate.SType]]) -> 'DeserializeContextSerializer': ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    @staticmethod
    def compose(g: scala.Function1[_compose__A, scala.Function2[typing.Any, sigmastate.SType, sigmastate.Values.Value[sigmastate.SType]]]) -> scala.Function1[_compose__A, 'DeserializeContextSerializer']: ...
    def cons(self) -> scala.Function2[typing.Any, sigmastate.SType, sigmastate.Values.Value[sigmastate.SType]]: ...
    def copy(self, cons: scala.Function2[typing.Any, sigmastate.SType, sigmastate.Values.Value[sigmastate.SType]]) -> 'DeserializeContextSerializer': ...
    def copy$default$1(self) -> scala.Function2[typing.Any, sigmastate.SType, sigmastate.Values.Value[sigmastate.SType]]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def idInfo(self) -> sigmastate.utils.SigmaByteWriter.DataInfo[typing.Any]: ...
    def opDesc(self) -> sigmastate.utxo.DeserializeContext.: ...
    def parse(self, r: sigmastate.utils.SigmaByteReader) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def serialize(self, obj: sigmastate.utxo.DeserializeContext[sigmastate.SType], w: sigmastate.utils.SigmaByteWriter) -> None: ...
    def toString(self) -> java.lang.String: ...
    def typeInfo(self) -> sigmastate.utils.SigmaByteWriter.DataInfo[sigmastate.SType]: ...
    @staticmethod
    def unapply(x$0: 'DeserializeContextSerializer') -> scala.Option[scala.Function2[typing.Any, sigmastate.SType, sigmastate.Values.Value[sigmastate.SType]]]: ...

class DeserializeRegisterSerializer(sigmastate.serialization.ValueSerializer[sigmastate.utxo.DeserializeRegister[sigmastate.SType]], scala.Product, scala.Serializable):
    def __init__(self, cons: scala.Function3[org.ergoplatform.ErgoBox.RegisterId, sigmastate.SType, scala.Option[sigmastate.Values.Value[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SType]]): ...
    _andThen__A = typing.TypeVar('_andThen__A')  # <A>
    @staticmethod
    def andThen(g: scala.Function1['DeserializeRegisterSerializer', _andThen__A]) -> scala.Function1[scala.Function3[org.ergoplatform.ErgoBox.RegisterId, sigmastate.SType, scala.Option[sigmastate.Values.Value[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SType]], _andThen__A]: ...
    @staticmethod
    def apply(cons: scala.Function3[org.ergoplatform.ErgoBox.RegisterId, sigmastate.SType, scala.Option[sigmastate.Values.Value[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SType]]) -> 'DeserializeRegisterSerializer': ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    @staticmethod
    def compose(g: scala.Function1[_compose__A, scala.Function3[org.ergoplatform.ErgoBox.RegisterId, sigmastate.SType, scala.Option[sigmastate.Values.Value[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SType]]]) -> scala.Function1[_compose__A, 'DeserializeRegisterSerializer']: ...
    def cons(self) -> scala.Function3[org.ergoplatform.ErgoBox.RegisterId, sigmastate.SType, scala.Option[sigmastate.Values.Value[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SType]]: ...
    def copy(self, cons: scala.Function3[org.ergoplatform.ErgoBox.RegisterId, sigmastate.SType, scala.Option[sigmastate.Values.Value[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SType]]) -> 'DeserializeRegisterSerializer': ...
    def copy$default$1(self) -> scala.Function3[org.ergoplatform.ErgoBox.RegisterId, sigmastate.SType, scala.Option[sigmastate.Values.Value[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SType]]: ...
    def defaultInfo(self) -> sigmastate.utils.SigmaByteWriter.DataInfo[sigmastate.Values.Value[sigmastate.SType]]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def idInfo(self) -> sigmastate.utils.SigmaByteWriter.DataInfo[typing.Any]: ...
    def opDesc(self) -> sigmastate.utxo.DeserializeRegister.: ...
    def parse(self, r: sigmastate.utils.SigmaByteReader) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def serialize(self, obj: sigmastate.utxo.DeserializeRegister[sigmastate.SType], w: sigmastate.utils.SigmaByteWriter) -> None: ...
    def toString(self) -> java.lang.String: ...
    def typeInfo(self) -> sigmastate.utils.SigmaByteWriter.DataInfo[sigmastate.SType]: ...
    @staticmethod
    def unapply(x$0: 'DeserializeRegisterSerializer') -> scala.Option[scala.Function3[org.ergoplatform.ErgoBox.RegisterId, sigmastate.SType, scala.Option[sigmastate.Values.Value[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SType]]]: ...

class ExtractRegisterAsSerializer(sigmastate.serialization.ValueSerializer[sigmastate.utxo.ExtractRegisterAs[sigmastate.SType]], scala.Product, scala.Serializable):
    def __init__(self, cons: scala.Function3[sigmastate.Values.Value[sigmastate.SBox.], org.ergoplatform.ErgoBox.RegisterId, sigmastate.SOption[sigmastate.SType], sigmastate.Values.Value[sigmastate.SType]]): ...
    _andThen__A = typing.TypeVar('_andThen__A')  # <A>
    @staticmethod
    def andThen(g: scala.Function1['ExtractRegisterAsSerializer', _andThen__A]) -> scala.Function1[scala.Function3[sigmastate.Values.Value[sigmastate.SBox.], org.ergoplatform.ErgoBox.RegisterId, sigmastate.SOption[sigmastate.SType], sigmastate.Values.Value[sigmastate.SType]], _andThen__A]: ...
    @staticmethod
    def apply(cons: scala.Function3[sigmastate.Values.Value[sigmastate.SBox.], org.ergoplatform.ErgoBox.RegisterId, sigmastate.SOption[sigmastate.SType], sigmastate.Values.Value[sigmastate.SType]]) -> 'ExtractRegisterAsSerializer': ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    @staticmethod
    def compose(g: scala.Function1[_compose__A, scala.Function3[sigmastate.Values.Value[sigmastate.SBox.], org.ergoplatform.ErgoBox.RegisterId, sigmastate.SOption[sigmastate.SType], sigmastate.Values.Value[sigmastate.SType]]]) -> scala.Function1[_compose__A, 'ExtractRegisterAsSerializer']: ...
    def cons(self) -> scala.Function3[sigmastate.Values.Value[sigmastate.SBox.], org.ergoplatform.ErgoBox.RegisterId, sigmastate.SOption[sigmastate.SType], sigmastate.Values.Value[sigmastate.SType]]: ...
    def copy(self, cons: scala.Function3[sigmastate.Values.Value[sigmastate.SBox.], org.ergoplatform.ErgoBox.RegisterId, sigmastate.SOption[sigmastate.SType], sigmastate.Values.Value[sigmastate.SType]]) -> 'ExtractRegisterAsSerializer': ...
    def copy$default$1(self) -> scala.Function3[sigmastate.Values.Value[sigmastate.SBox.], org.ergoplatform.ErgoBox.RegisterId, sigmastate.SOption[sigmastate.SType], sigmastate.Values.Value[sigmastate.SType]]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def opDesc(self) -> sigmastate.utxo.ExtractRegisterAs.: ...
    def parse(self, r: sigmastate.utils.SigmaByteReader) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def regIdInfo(self) -> sigmastate.utils.SigmaByteWriter.DataInfo[typing.Any]: ...
    def serialize(self, obj: sigmastate.utxo.ExtractRegisterAs[sigmastate.SType], w: sigmastate.utils.SigmaByteWriter) -> None: ...
    def thisInfo(self) -> sigmastate.utils.SigmaByteWriter.DataInfo[sigmastate.Values.Value[sigmastate.SType]]: ...
    def toString(self) -> java.lang.String: ...
    def typeInfo(self) -> sigmastate.utils.SigmaByteWriter.DataInfo[sigmastate.SType]: ...
    @staticmethod
    def unapply(x$0: 'ExtractRegisterAsSerializer') -> scala.Option[scala.Function3[sigmastate.Values.Value[sigmastate.SBox.], org.ergoplatform.ErgoBox.RegisterId, sigmastate.SOption[sigmastate.SType], sigmastate.Values.Value[sigmastate.SType]]]: ...

class FilterSerializer(sigmastate.serialization.ValueSerializer[sigmastate.utxo.Filter[sigmastate.SType]], scala.Product, scala.Serializable):
    def __init__(self, cons: scala.Function2[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SFunc], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]]]): ...
    _andThen__A = typing.TypeVar('_andThen__A')  # <A>
    @staticmethod
    def andThen(g: scala.Function1['FilterSerializer', _andThen__A]) -> scala.Function1[scala.Function2[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SFunc], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]]], _andThen__A]: ...
    @staticmethod
    def apply(cons: scala.Function2[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SFunc], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]]]) -> 'FilterSerializer': ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    @staticmethod
    def compose(g: scala.Function1[_compose__A, scala.Function2[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SFunc], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]]]]) -> scala.Function1[_compose__A, 'FilterSerializer']: ...
    def cons(self) -> scala.Function2[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SFunc], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]]]: ...
    def copy(self, cons: scala.Function2[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SFunc], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]]]) -> 'FilterSerializer': ...
    def copy$default$1(self) -> scala.Function2[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SFunc], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]]]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def opDesc(self) -> sigmastate.utxo.Filter.: ...
    def parse(self, r: sigmastate.utils.SigmaByteReader) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]]: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def serialize(self, obj: sigmastate.utxo.Filter[sigmastate.SType], w: sigmastate.utils.SigmaByteWriter) -> None: ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def unapply(x$0: 'FilterSerializer') -> scala.Option[scala.Function2[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SFunc], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]]]]: ...

class FoldSerializer(sigmastate.serialization.ValueSerializer[sigmastate.utxo.Fold[sigmastate.SType, sigmastate.SType]], scala.Product, scala.Serializable):
    def __init__(self, cons: scala.Function3[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SType], sigmastate.Values.Value[sigmastate.SFunc], sigmastate.Values.Value[sigmastate.SType]]): ...
    _andThen__A = typing.TypeVar('_andThen__A')  # <A>
    @staticmethod
    def andThen(g: scala.Function1['FoldSerializer', _andThen__A]) -> scala.Function1[scala.Function3[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SType], sigmastate.Values.Value[sigmastate.SFunc], sigmastate.Values.Value[sigmastate.SType]], _andThen__A]: ...
    @staticmethod
    def apply(cons: scala.Function3[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SType], sigmastate.Values.Value[sigmastate.SFunc], sigmastate.Values.Value[sigmastate.SType]]) -> 'FoldSerializer': ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    @staticmethod
    def compose(g: scala.Function1[_compose__A, scala.Function3[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SType], sigmastate.Values.Value[sigmastate.SFunc], sigmastate.Values.Value[sigmastate.SType]]]) -> scala.Function1[_compose__A, 'FoldSerializer']: ...
    def cons(self) -> scala.Function3[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SType], sigmastate.Values.Value[sigmastate.SFunc], sigmastate.Values.Value[sigmastate.SType]]: ...
    def copy(self, cons: scala.Function3[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SType], sigmastate.Values.Value[sigmastate.SFunc], sigmastate.Values.Value[sigmastate.SType]]) -> 'FoldSerializer': ...
    def copy$default$1(self) -> scala.Function3[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SType], sigmastate.Values.Value[sigmastate.SFunc], sigmastate.Values.Value[sigmastate.SType]]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def opDesc(self) -> sigmastate.utxo.Fold.: ...
    def opInfo(self) -> sigmastate.utils.SigmaByteWriter.DataInfo[sigmastate.Values.Value[sigmastate.SType]]: ...
    def parse(self, r: sigmastate.utils.SigmaByteReader) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def serialize(self, obj: sigmastate.utxo.Fold[sigmastate.SType, sigmastate.SType], w: sigmastate.utils.SigmaByteWriter) -> None: ...
    def thisInfo(self) -> sigmastate.utils.SigmaByteWriter.DataInfo[sigmastate.Values.Value[sigmastate.SType]]: ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def unapply(x$0: 'FoldSerializer') -> scala.Option[scala.Function3[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SType], sigmastate.Values.Value[sigmastate.SFunc], sigmastate.Values.Value[sigmastate.SType]]]: ...
    def zeroInfo(self) -> sigmastate.utils.SigmaByteWriter.DataInfo[sigmastate.Values.Value[sigmastate.SType]]: ...

_LogicalTransformerSerializer__I = typing.TypeVar('_LogicalTransformerSerializer__I', bound=sigmastate.SCollection)  # <I>
_LogicalTransformerSerializer__O = typing.TypeVar('_LogicalTransformerSerializer__O', bound=sigmastate.SBoolean.)  # <O>
class LogicalTransformerSerializer(sigmastate.serialization.ValueSerializer[sigmastate.utxo.Transformer[_LogicalTransformerSerializer__I, _LogicalTransformerSerializer__O]], scala.Product, scala.Serializable, typing.Generic[_LogicalTransformerSerializer__I, _LogicalTransformerSerializer__O]):
    def __init__(self, opDesc: sigmastate.LogicalTransformerCompanion, cons: scala.Function1[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SBoolean.]], sigmastate.Values.Value[sigmastate.SBoolean.]]): ...
    _apply__I = typing.TypeVar('_apply__I', bound=sigmastate.SCollection)  # <I>
    _apply__O = typing.TypeVar('_apply__O', bound=sigmastate.SBoolean.)  # <O>
    @staticmethod
    def apply(opDesc: sigmastate.LogicalTransformerCompanion, cons: scala.Function1[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SBoolean.]], sigmastate.Values.Value[sigmastate.SBoolean.]]) -> 'LogicalTransformerSerializer'[_apply__I, _apply__O]: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def cons(self) -> scala.Function1[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SBoolean.]], sigmastate.Values.Value[sigmastate.SBoolean.]]: ...
    _copy__I = typing.TypeVar('_copy__I', bound=sigmastate.SCollection)  # <I>
    _copy__O = typing.TypeVar('_copy__O', bound=sigmastate.SBoolean.)  # <O>
    def copy(self, opDesc: sigmastate.LogicalTransformerCompanion, cons: scala.Function1[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SBoolean.]], sigmastate.Values.Value[sigmastate.SBoolean.]]) -> 'LogicalTransformerSerializer'[sigmastate.SCollection, sigmastate.SBoolean.]: ...
    _copy$default$1__I = typing.TypeVar('_copy$default$1__I', bound=sigmastate.SCollection)  # <I>
    _copy$default$1__O = typing.TypeVar('_copy$default$1__O', bound=sigmastate.SBoolean.)  # <O>
    def copy$default$1(self) -> sigmastate.LogicalTransformerCompanion: ...
    _copy$default$2__I = typing.TypeVar('_copy$default$2__I', bound=sigmastate.SCollection)  # <I>
    _copy$default$2__O = typing.TypeVar('_copy$default$2__O', bound=sigmastate.SBoolean.)  # <O>
    def copy$default$2(self) -> scala.Function1[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SBoolean.]], sigmastate.Values.Value[sigmastate.SBoolean.]]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def inputInfo(self) -> sigmastate.utils.SigmaByteWriter.DataInfo[sigmastate.Values.Value[sigmastate.SType]]: ...
    def opDesc(self) -> sigmastate.LogicalTransformerCompanion: ...
    def parse(self, r: sigmastate.utils.SigmaByteReader) -> sigmastate.Values.Value[sigmastate.SBoolean.]: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def serialize(self, obj: sigmastate.utxo.Transformer[_LogicalTransformerSerializer__I, _LogicalTransformerSerializer__O], w: sigmastate.utils.SigmaByteWriter) -> None: ...
    def toString(self) -> java.lang.String: ...
    _unapply__I = typing.TypeVar('_unapply__I', bound=sigmastate.SCollection)  # <I>
    _unapply__O = typing.TypeVar('_unapply__O', bound=sigmastate.SBoolean.)  # <O>
    @staticmethod
    def unapply(x$0: 'LogicalTransformerSerializer'[_unapply__I, _unapply__O]) -> scala.Option[scala.Tuple2[sigmastate.LogicalTransformerCompanion, scala.Function1[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SBoolean.]], sigmastate.Values.Value[sigmastate.SBoolean.]]]]: ...

class MapCollectionSerializer(sigmastate.serialization.ValueSerializer[sigmastate.utxo.MapCollection[sigmastate.SType, sigmastate.SType]], scala.Product, scala.Serializable):
    def __init__(self, cons: scala.Function2[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SFunc], sigmastate.Values.Value[sigmastate.SType]]): ...
    _andThen__A = typing.TypeVar('_andThen__A')  # <A>
    @staticmethod
    def andThen(g: scala.Function1['MapCollectionSerializer', _andThen__A]) -> scala.Function1[scala.Function2[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SFunc], sigmastate.Values.Value[sigmastate.SType]], _andThen__A]: ...
    @staticmethod
    def apply(cons: scala.Function2[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SFunc], sigmastate.Values.Value[sigmastate.SType]]) -> 'MapCollectionSerializer': ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    @staticmethod
    def compose(g: scala.Function1[_compose__A, scala.Function2[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SFunc], sigmastate.Values.Value[sigmastate.SType]]]) -> scala.Function1[_compose__A, 'MapCollectionSerializer']: ...
    def cons(self) -> scala.Function2[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SFunc], sigmastate.Values.Value[sigmastate.SType]]: ...
    def copy(self, cons: scala.Function2[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SFunc], sigmastate.Values.Value[sigmastate.SType]]) -> 'MapCollectionSerializer': ...
    def copy$default$1(self) -> scala.Function2[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SFunc], sigmastate.Values.Value[sigmastate.SType]]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def fInfo(self) -> sigmastate.utils.SigmaByteWriter.DataInfo[sigmastate.Values.Value[sigmastate.SType]]: ...
    def hashCode(self) -> int: ...
    def opDesc(self) -> sigmastate.utxo.MapCollection.: ...
    def parse(self, r: sigmastate.utils.SigmaByteReader) -> sigmastate.Values.Value[sigmastate.SType]: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def serialize(self, obj: sigmastate.utxo.MapCollection[sigmastate.SType, sigmastate.SType], w: sigmastate.utils.SigmaByteWriter) -> None: ...
    def thisInfo(self) -> sigmastate.utils.SigmaByteWriter.DataInfo[sigmastate.Values.Value[sigmastate.SType]]: ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def unapply(x$0: 'MapCollectionSerializer') -> scala.Option[scala.Function2[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SFunc], sigmastate.Values.Value[sigmastate.SType]]]: ...

class NumericCastSerializer(sigmastate.serialization.ValueSerializer[sigmastate.utxo.Transformer[sigmastate.SNumericType, sigmastate.SNumericType]], scala.Product, scala.Serializable):
    def __init__(self, opDesc: sigmastate.NumericCastCompanion, cons: scala.Function2[sigmastate.Values.Value[sigmastate.SNumericType], sigmastate.SNumericType, sigmastate.Values.Value[sigmastate.SNumericType]]): ...
    @staticmethod
    def apply(opDesc: sigmastate.NumericCastCompanion, cons: scala.Function2[sigmastate.Values.Value[sigmastate.SNumericType], sigmastate.SNumericType, sigmastate.Values.Value[sigmastate.SNumericType]]) -> 'NumericCastSerializer': ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def cons(self) -> scala.Function2[sigmastate.Values.Value[sigmastate.SNumericType], sigmastate.SNumericType, sigmastate.Values.Value[sigmastate.SNumericType]]: ...
    def copy(self, opDesc: sigmastate.NumericCastCompanion, cons: scala.Function2[sigmastate.Values.Value[sigmastate.SNumericType], sigmastate.SNumericType, sigmastate.Values.Value[sigmastate.SNumericType]]) -> 'NumericCastSerializer': ...
    def copy$default$1(self) -> sigmastate.NumericCastCompanion: ...
    def copy$default$2(self) -> scala.Function2[sigmastate.Values.Value[sigmastate.SNumericType], sigmastate.SNumericType, sigmastate.Values.Value[sigmastate.SNumericType]]: ...
    @staticmethod
    def curried() -> scala.Function1[sigmastate.NumericCastCompanion, scala.Function1[scala.Function2[sigmastate.Values.Value[sigmastate.SNumericType], sigmastate.SNumericType, sigmastate.Values.Value[sigmastate.SNumericType]], 'NumericCastSerializer']]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def inputInfo(self) -> sigmastate.utils.SigmaByteWriter.DataInfo[sigmastate.Values.Value[sigmastate.SType]]: ...
    def opDesc(self) -> sigmastate.NumericCastCompanion: ...
    def parse(self, r: sigmastate.utils.SigmaByteReader) -> sigmastate.Values.Value[sigmastate.SNumericType]: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def serialize(self, obj: sigmastate.utxo.Transformer[sigmastate.SNumericType, sigmastate.SNumericType], w: sigmastate.utils.SigmaByteWriter) -> None: ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def tupled() -> scala.Function1[scala.Tuple2[sigmastate.NumericCastCompanion, scala.Function2[sigmastate.Values.Value[sigmastate.SNumericType], sigmastate.SNumericType, sigmastate.Values.Value[sigmastate.SNumericType]]], 'NumericCastSerializer']: ...
    def typeInfo(self) -> sigmastate.utils.SigmaByteWriter.DataInfo[sigmastate.SType]: ...
    @staticmethod
    def unapply(x$0: 'NumericCastSerializer') -> scala.Option[scala.Tuple2[sigmastate.NumericCastCompanion, scala.Function2[sigmastate.Values.Value[sigmastate.SNumericType], sigmastate.SNumericType, sigmastate.Values.Value[sigmastate.SNumericType]]]]: ...

class ProveDHTupleSerializer(sigmastate.serialization.SigmaSerializer[sigmastate.basics.ProveDHTuple, sigmastate.basics.ProveDHTuple], scala.Product, scala.Serializable):
    def __init__(self, cons: scala.Function4[org.bouncycastle.math.ec.custom.sec.SecP256K1Point, org.bouncycastle.math.ec.custom.sec.SecP256K1Point, org.bouncycastle.math.ec.custom.sec.SecP256K1Point, org.bouncycastle.math.ec.custom.sec.SecP256K1Point, sigmastate.basics.ProveDHTuple]): ...
    _andThen__A = typing.TypeVar('_andThen__A')  # <A>
    @staticmethod
    def andThen(g: scala.Function1['ProveDHTupleSerializer', _andThen__A]) -> scala.Function1[scala.Function4[org.bouncycastle.math.ec.custom.sec.SecP256K1Point, org.bouncycastle.math.ec.custom.sec.SecP256K1Point, org.bouncycastle.math.ec.custom.sec.SecP256K1Point, org.bouncycastle.math.ec.custom.sec.SecP256K1Point, sigmastate.basics.ProveDHTuple], _andThen__A]: ...
    @staticmethod
    def apply(cons: scala.Function4[org.bouncycastle.math.ec.custom.sec.SecP256K1Point, org.bouncycastle.math.ec.custom.sec.SecP256K1Point, org.bouncycastle.math.ec.custom.sec.SecP256K1Point, org.bouncycastle.math.ec.custom.sec.SecP256K1Point, sigmastate.basics.ProveDHTuple]) -> 'ProveDHTupleSerializer': ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    @staticmethod
    def compose(g: scala.Function1[_compose__A, scala.Function4[org.bouncycastle.math.ec.custom.sec.SecP256K1Point, org.bouncycastle.math.ec.custom.sec.SecP256K1Point, org.bouncycastle.math.ec.custom.sec.SecP256K1Point, org.bouncycastle.math.ec.custom.sec.SecP256K1Point, sigmastate.basics.ProveDHTuple]]) -> scala.Function1[_compose__A, 'ProveDHTupleSerializer']: ...
    def cons(self) -> scala.Function4[org.bouncycastle.math.ec.custom.sec.SecP256K1Point, org.bouncycastle.math.ec.custom.sec.SecP256K1Point, org.bouncycastle.math.ec.custom.sec.SecP256K1Point, org.bouncycastle.math.ec.custom.sec.SecP256K1Point, sigmastate.basics.ProveDHTuple]: ...
    def copy(self, cons: scala.Function4[org.bouncycastle.math.ec.custom.sec.SecP256K1Point, org.bouncycastle.math.ec.custom.sec.SecP256K1Point, org.bouncycastle.math.ec.custom.sec.SecP256K1Point, org.bouncycastle.math.ec.custom.sec.SecP256K1Point, sigmastate.basics.ProveDHTuple]) -> 'ProveDHTupleSerializer': ...
    def copy$default$1(self) -> scala.Function4[org.bouncycastle.math.ec.custom.sec.SecP256K1Point, org.bouncycastle.math.ec.custom.sec.SecP256K1Point, org.bouncycastle.math.ec.custom.sec.SecP256K1Point, org.bouncycastle.math.ec.custom.sec.SecP256K1Point, sigmastate.basics.ProveDHTuple]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def parse(self, r: sigmastate.utils.SigmaByteReader) -> sigmastate.basics.ProveDHTuple: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def serialize(self, obj: sigmastate.basics.ProveDHTuple, w: sigmastate.utils.SigmaByteWriter) -> None: ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def unapply(x$0: 'ProveDHTupleSerializer') -> scala.Option[scala.Function4[org.bouncycastle.math.ec.custom.sec.SecP256K1Point, org.bouncycastle.math.ec.custom.sec.SecP256K1Point, org.bouncycastle.math.ec.custom.sec.SecP256K1Point, org.bouncycastle.math.ec.custom.sec.SecP256K1Point, sigmastate.basics.ProveDHTuple]]: ...

_SigmaTransformerSerializer__I = typing.TypeVar('_SigmaTransformerSerializer__I', bound=sigmastate.Values.Value)  # <I>
_SigmaTransformerSerializer__O = typing.TypeVar('_SigmaTransformerSerializer__O', bound=sigmastate.Values.Value)  # <O>
class SigmaTransformerSerializer(sigmastate.serialization.ValueSerializer[sigmastate.SigmaTransformer[_SigmaTransformerSerializer__I, _SigmaTransformerSerializer__O]], scala.Product, scala.Serializable, typing.Generic[_SigmaTransformerSerializer__I, _SigmaTransformerSerializer__O]):
    def __init__(self, opDesc: sigmastate.SigmaTransformerCompanion, cons: scala.Function1[scala.collection.Seq[sigmastate.Values.Value[sigmastate.SSigmaProp.]], sigmastate.Values.Value[sigmastate.SSigmaProp.]]): ...
    _apply__I = typing.TypeVar('_apply__I', bound=sigmastate.Values.Value)  # <I>
    _apply__O = typing.TypeVar('_apply__O', bound=sigmastate.Values.Value)  # <O>
    @staticmethod
    def apply(opDesc: sigmastate.SigmaTransformerCompanion, cons: scala.Function1[scala.collection.Seq[sigmastate.Values.Value[sigmastate.SSigmaProp.]], sigmastate.Values.Value[sigmastate.SSigmaProp.]]) -> 'SigmaTransformerSerializer'[_apply__I, _apply__O]: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def cons(self) -> scala.Function1[scala.collection.Seq[sigmastate.Values.Value[sigmastate.SSigmaProp.]], sigmastate.Values.Value[sigmastate.SSigmaProp.]]: ...
    _copy__I = typing.TypeVar('_copy__I', bound=sigmastate.Values.Value)  # <I>
    _copy__O = typing.TypeVar('_copy__O', bound=sigmastate.Values.Value)  # <O>
    def copy(self, opDesc: sigmastate.SigmaTransformerCompanion, cons: scala.Function1[scala.collection.Seq[sigmastate.Values.Value[sigmastate.SSigmaProp.]], sigmastate.Values.Value[sigmastate.SSigmaProp.]]) -> 'SigmaTransformerSerializer'[sigmastate.Values.Value, sigmastate.Values.Value]: ...
    _copy$default$1__I = typing.TypeVar('_copy$default$1__I', bound=sigmastate.Values.Value)  # <I>
    _copy$default$1__O = typing.TypeVar('_copy$default$1__O', bound=sigmastate.Values.Value)  # <O>
    def copy$default$1(self) -> sigmastate.SigmaTransformerCompanion: ...
    _copy$default$2__I = typing.TypeVar('_copy$default$2__I', bound=sigmastate.Values.Value)  # <I>
    _copy$default$2__O = typing.TypeVar('_copy$default$2__O', bound=sigmastate.Values.Value)  # <O>
    def copy$default$2(self) -> scala.Function1[scala.collection.Seq[sigmastate.Values.Value[sigmastate.SSigmaProp.]], sigmastate.Values.Value[sigmastate.SSigmaProp.]]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def itemsInfo(self) -> sigmastate.utils.SigmaByteWriter.DataInfo[scala.collection.Seq[sigmastate.Values.Value[sigmastate.SType]]]: ...
    def itemsItemInfo(self) -> sigmastate.utils.SigmaByteWriter.DataInfo[sigmastate.Values.Value[sigmastate.SType]]: ...
    def opDesc(self) -> sigmastate.SigmaTransformerCompanion: ...
    def parse(self, r: sigmastate.utils.SigmaByteReader) -> sigmastate.Values.Value[sigmastate.SSigmaProp.]: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def serialize(self, obj: sigmastate.SigmaTransformer[_SigmaTransformerSerializer__I, _SigmaTransformerSerializer__O], w: sigmastate.utils.SigmaByteWriter) -> None: ...
    def toString(self) -> java.lang.String: ...
    _unapply__I = typing.TypeVar('_unapply__I', bound=sigmastate.Values.Value)  # <I>
    _unapply__O = typing.TypeVar('_unapply__O', bound=sigmastate.Values.Value)  # <O>
    @staticmethod
    def unapply(x$0: 'SigmaTransformerSerializer'[_unapply__I, _unapply__O]) -> scala.Option[scala.Tuple2[sigmastate.SigmaTransformerCompanion, scala.Function1[scala.collection.Seq[sigmastate.Values.Value[sigmastate.SSigmaProp.]], sigmastate.Values.Value[sigmastate.SSigmaProp.]]]]: ...

_SimpleTransformerSerializer__I = typing.TypeVar('_SimpleTransformerSerializer__I', bound=sigmastate.SType)  # <I>
_SimpleTransformerSerializer__O = typing.TypeVar('_SimpleTransformerSerializer__O', bound=sigmastate.SType)  # <O>
class SimpleTransformerSerializer(sigmastate.serialization.ValueSerializer[sigmastate.utxo.Transformer[_SimpleTransformerSerializer__I, _SimpleTransformerSerializer__O]], scala.Product, scala.Serializable, typing.Generic[_SimpleTransformerSerializer__I, _SimpleTransformerSerializer__O]):
    def __init__(self, opDesc: sigmastate.utxo.SimpleTransformerCompanion, cons: scala.Function1[sigmastate.Values.Value[_SimpleTransformerSerializer__I], sigmastate.Values.Value[_SimpleTransformerSerializer__O]]): ...
    _apply__I = typing.TypeVar('_apply__I', bound=sigmastate.SType)  # <I>
    _apply__O = typing.TypeVar('_apply__O', bound=sigmastate.SType)  # <O>
    @staticmethod
    def apply(opDesc: sigmastate.utxo.SimpleTransformerCompanion, cons: scala.Function1[sigmastate.Values.Value[_apply__I], sigmastate.Values.Value[_apply__O]]) -> 'SimpleTransformerSerializer'[_apply__I, _apply__O]: ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    def cons(self) -> scala.Function1[sigmastate.Values.Value[_SimpleTransformerSerializer__I], sigmastate.Values.Value[_SimpleTransformerSerializer__O]]: ...
    _copy__I = typing.TypeVar('_copy__I', bound=sigmastate.SType)  # <I>
    _copy__O = typing.TypeVar('_copy__O', bound=sigmastate.SType)  # <O>
    def copy(self, opDesc: sigmastate.utxo.SimpleTransformerCompanion, cons: scala.Function1[sigmastate.Values.Value[sigmastate.SType], sigmastate.Values.Value[sigmastate.SType]]) -> 'SimpleTransformerSerializer'[sigmastate.SType, sigmastate.SType]: ...
    _copy$default$1__I = typing.TypeVar('_copy$default$1__I', bound=sigmastate.SType)  # <I>
    _copy$default$1__O = typing.TypeVar('_copy$default$1__O', bound=sigmastate.SType)  # <O>
    def copy$default$1(self) -> sigmastate.utxo.SimpleTransformerCompanion: ...
    _copy$default$2__I = typing.TypeVar('_copy$default$2__I', bound=sigmastate.SType)  # <I>
    _copy$default$2__O = typing.TypeVar('_copy$default$2__O', bound=sigmastate.SType)  # <O>
    def copy$default$2(self) -> scala.Function1[sigmastate.Values.Value[sigmastate.SType], sigmastate.Values.Value[sigmastate.SType]]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def inputInfo(self) -> sigmastate.utils.SigmaByteWriter.DataInfo[sigmastate.Values.Value[sigmastate.SType]]: ...
    def opDesc(self) -> sigmastate.utxo.SimpleTransformerCompanion: ...
    def parse(self, r: sigmastate.utils.SigmaByteReader) -> sigmastate.Values.Value[_SimpleTransformerSerializer__O]: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def serialize(self, obj: sigmastate.utxo.Transformer[_SimpleTransformerSerializer__I, _SimpleTransformerSerializer__O], w: sigmastate.utils.SigmaByteWriter) -> None: ...
    def toString(self) -> java.lang.String: ...
    _unapply__I = typing.TypeVar('_unapply__I', bound=sigmastate.SType)  # <I>
    _unapply__O = typing.TypeVar('_unapply__O', bound=sigmastate.SType)  # <O>
    @staticmethod
    def unapply(x$0: 'SimpleTransformerSerializer'[_unapply__I, _unapply__O]) -> scala.Option[scala.Tuple2[sigmastate.utxo.SimpleTransformerCompanion, scala.Function1[sigmastate.Values.Value[_unapply__I], sigmastate.Values.Value[_unapply__O]]]]: ...

class SliceSerializer(sigmastate.serialization.ValueSerializer[sigmastate.utxo.Slice[sigmastate.SType]], scala.Product, scala.Serializable):
    def __init__(self, cons: scala.Function3[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SInt.], sigmastate.Values.Value[sigmastate.SInt.], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]]]): ...
    _andThen__A = typing.TypeVar('_andThen__A')  # <A>
    @staticmethod
    def andThen(g: scala.Function1['SliceSerializer', _andThen__A]) -> scala.Function1[scala.Function3[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SInt.], sigmastate.Values.Value[sigmastate.SInt.], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]]], _andThen__A]: ...
    @staticmethod
    def apply(cons: scala.Function3[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SInt.], sigmastate.Values.Value[sigmastate.SInt.], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]]]) -> 'SliceSerializer': ...
    def canEqual(self, x$1: typing.Any) -> bool: ...
    _compose__A = typing.TypeVar('_compose__A')  # <A>
    @staticmethod
    def compose(g: scala.Function1[_compose__A, scala.Function3[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SInt.], sigmastate.Values.Value[sigmastate.SInt.], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]]]]) -> scala.Function1[_compose__A, 'SliceSerializer']: ...
    def cons(self) -> scala.Function3[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SInt.], sigmastate.Values.Value[sigmastate.SInt.], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]]]: ...
    def copy(self, cons: scala.Function3[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SInt.], sigmastate.Values.Value[sigmastate.SInt.], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]]]) -> 'SliceSerializer': ...
    def copy$default$1(self) -> scala.Function3[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SInt.], sigmastate.Values.Value[sigmastate.SInt.], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]]]: ...
    def equals(self, x$1: typing.Any) -> bool: ...
    def fromInfo(self) -> sigmastate.utils.SigmaByteWriter.DataInfo[sigmastate.Values.Value[sigmastate.SType]]: ...
    def hashCode(self) -> int: ...
    def opDesc(self) -> sigmastate.utxo.Slice.: ...
    def parse(self, r: sigmastate.utils.SigmaByteReader) -> sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]]: ...
    def productArity(self) -> int: ...
    def productElement(self, x$1: int) -> typing.Any: ...
    def productIterator(self) -> scala.collection.Iterator[typing.Any]: ...
    def productPrefix(self) -> java.lang.String: ...
    def serialize(self, obj: sigmastate.utxo.Slice[sigmastate.SType], w: sigmastate.utils.SigmaByteWriter) -> None: ...
    def thisInfo(self) -> sigmastate.utils.SigmaByteWriter.DataInfo[sigmastate.Values.Value[sigmastate.SType]]: ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def unapply(x$0: 'SliceSerializer') -> scala.Option[scala.Function3[sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]], sigmastate.Values.Value[sigmastate.SInt.], sigmastate.Values.Value[sigmastate.SInt.], sigmastate.Values.Value[sigmastate.SCollection[sigmastate.SType]]]]: ...
    def untilInfo(self) -> sigmastate.utils.SigmaByteWriter.DataInfo[sigmastate.Values.Value[sigmastate.SType]]: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("sigmastate.serialization.transformers")``.

    AppendSerializer: typing.Type[AppendSerializer]
    AtLeastSerializer: typing.Type[AtLeastSerializer]
    BooleanTransformerSerializer: typing.Type[BooleanTransformerSerializer]
    ByIndexSerializer: typing.Type[ByIndexSerializer]
    CreateProveDHTupleSerializer: typing.Type[CreateProveDHTupleSerializer]
    DeserializeContextSerializer: typing.Type[DeserializeContextSerializer]
    DeserializeRegisterSerializer: typing.Type[DeserializeRegisterSerializer]
    ExtractRegisterAsSerializer: typing.Type[ExtractRegisterAsSerializer]
    FilterSerializer: typing.Type[FilterSerializer]
    FoldSerializer: typing.Type[FoldSerializer]
    LogicalTransformerSerializer: typing.Type[LogicalTransformerSerializer]
    MapCollectionSerializer: typing.Type[MapCollectionSerializer]
    NumericCastSerializer: typing.Type[NumericCastSerializer]
    ProveDHTupleSerializer: typing.Type[ProveDHTupleSerializer]
    SigmaTransformerSerializer: typing.Type[SigmaTransformerSerializer]
    SimpleTransformerSerializer: typing.Type[SimpleTransformerSerializer]
    SliceSerializer: typing.Type[SliceSerializer]
